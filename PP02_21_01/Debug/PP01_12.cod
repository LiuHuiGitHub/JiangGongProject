LX51 LINKER/LOCATER V4.66.1.0                                                           02/02/2016  20:46:19  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  .\Debug\PP01_12 (SYS_DELAY)


----- FUNCTION hwa_eepromInit (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   29: void hwa_eepromInit(void)
   30: {
   31: }
   32: 
000009 22                RET      
----- FUNCTION hwa_eepromInit (END) -------


----- FUNCTION sys_gpioInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   24: void sys_gpioInit(void)
   25: {
   26: }
   27: 
00000A 22                RET      
----- FUNCTION sys_gpioInit (END) -------


00000B 0217C8            LJMP     017C8H
----- FUNCTION sys_taskHandler10ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   67: void sys_taskHandler10ms(void)            //10ms interrupt task
   68: {
   69: }
   70: 
000022 22                RET      
----- FUNCTION sys_taskHandler10ms (END) -------


000023 021728            LJMP     01728H
----- FUNCTION _sys_delayus (BEGIN) -----
 FILE: 'System\sys_delay.c'
    5: void sys_delayus(UINT16 xus)
    6: {
;---- Variable 'xus' assigned to Register 'R6/R7' ----
    7:     while(xus--);
0004D0         ?C0001?SYS_DELAY:
    8: }
0004D0 EF                MOV      A,R7
0004D1 1F                DEC      R7
0004D2 AC06              MOV      R4,AR6
0004D4 7001              JNZ      ?C0012?SYS_DELAY
0004D6 1E                DEC      R6
0004D7         ?C0012?SYS_DELAY:
0004D7 4C                ORL      A,R4
0004D8 70F6              JNZ      ?C0001?SYS_DELAY
    9: 
0004DA 22                RET      
----- FUNCTION _sys_delayus (END) -------


----- FUNCTION Init_FM1702 (BEGIN) -----
 FILE: 'Driver\mifare.c'
  104: void Init_FM1702(void)
  105: {
  106: 	uchar temp;
  107: 	uint i;
  108: 	RC500SCK = 0;
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 2


0004DB C2A1              CLR      RC500SCK
  109: 	RC500SO = 1;
0004DD D2A2              SETB     RC500SO
  110: 	RC500SI = 1;
0004DF D2A4              SETB     RC500SI
  111: 	RC500RST = 1;	// FM1702复位 
0004E1 D2A5              SETB     RC500RST
  112: 	sys_delayms(2);
0004E3 7F02              MOV      R7,#02H
0004E5 7E00              MOV      R6,#00H
0004E7 12080A            LCALL    _sys_delayms
  113: 	RC500RST = 0;	
0004EA C2A5              CLR      RC500RST
  114: 	//进入复位阶段，需要512个FM1702SL的时钟周期，约38us
  115: 	sys_delayus(100); 
0004EC 7F64              MOV      R7,#064H
0004EE 7E00              MOV      R6,#00H
0004F0 91D0              ACALL    _sys_delayus
0004F2         ?C0024?MIFARE:
  116: 	//进入初始化阶段，需要128个时钟周期，约10us
  117: 	do{ 		// 等待Command = 0,FM1702复位成功
  118: 		temp = SPIReadOne(Command_Reg);	 //(Command_Reg<<1)|0x80 = 0x82
;---- Variable 'temp' assigned to Register 'R4' ----
0004F2 F1ED              ACALL    ?L?COM0037
0004F4 70FC              JNZ      ?C0024?MIFARE
  119: 	}while(temp!=0);
  120: ///////////////////////////////////////////////////////////////////////////////////
  121: 	SPIWriteOne(Page_Reg,0x80);	//初始化SPI接口
0004F6 7D80              MOV      R5,#080H
0004F8 FF                MOV      R7,A
0004F9 B135              ACALL    _SPIWriteOne
  122: 	for(i = 0; i < 0x1fff; i++) // 延时
;---- Variable 'i' assigned to Register 'R2/R3' ----
0004FB E4                CLR      A
0004FC FB                MOV      R3,A
0004FD FA                MOV      R2,A
0004FE         ?C0025?MIFARE:
  123: 	{
  124: 		temp = SPIReadOne(Command_Reg);
0004FE F1ED              ACALL    ?L?COM0037
000500 7006              JNZ      ?C0027?MIFARE
  125: 		if(temp == 0x00)	//SPI初始化成功
  126: 		{
  127: 			SPIWriteOne(Page_Reg,0);//可以使用SPI接口
000502 FD                MOV      R5,A
000503 FF                MOV      R7,A
000504 B135              ACALL    _SPIWriteOne
  128: 			break;
000506 800B              SJMP     ?C0026?MIFARE
  129: 		}
  130: 	}
000508         ?C0027?MIFARE:
000508 0B                INC      R3
000509 BB0001            CJNE     R3,#00H,?C0138?MIFARE
00050C 0A                INC      R2
00050D         ?C0138?MIFARE:
00050D BA1FEE            CJNE     R2,#01FH,?C0025?MIFARE
000510 BBFFEB            CJNE     R3,#0FFH,?C0025?MIFARE
000513         ?C0026?MIFARE:
  131: ////////////////////////////////////////////////////////////////////////////////////
  132: 	SPIWriteOne(InterruptEn_Reg,0x7F);	//  禁止所有中断请求（最高位置0）
000513 7D7F              MOV      R5,#07FH
000515 7F06              MOV      R7,#06H
000517 B135              ACALL    _SPIWriteOne
  133: 	SPIWriteOne(InterruptRq_Reg,0x7F);	// 禁止所有中断请求标识置0（最高位置0）
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 3


000519 7D7F              MOV      R5,#07FH
00051B 7F07              MOV      R7,#07H
00051D B135              ACALL    _SPIWriteOne
  134: 	
  135: 	//设置调制器的输入源为内部编码器, 并且设置TX1和TX2
  136: 	SPIWriteOne(TxControl_Reg,0x5B); 		// 发送控制寄存器 
00051F 7D5B              MOV      R5,#05BH
000521 7F11              MOV      R7,#011H
000523 B135              ACALL    _SPIWriteOne
  137: 	SPIWriteOne(RxControl2_Reg,0x01);
000525 7D01              MOV      R5,#01H
000527 7F1E              MOV      R7,#01EH
000529 B135              ACALL    _SPIWriteOne
  138: 	SPIWriteOne(RxWait_Reg,5);
00052B 7D05              MOV      R5,#05H
00052D 7F21              MOV      R7,#021H
00052F 8004              SJMP     _SPIWriteOne
----- FUNCTION Init_FM1702 (END) -------


----- FUNCTION ?L?COM0039 (BEGIN) -----
000531 F0                MOVX     @DPTR,A
000532 FD                MOV      R5,A
000533 7F01              MOV      R7,#01H
----- FUNCTION _SPIWriteOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   65: void SPIWriteOne(uchar SpiAddress,uchar wData)
   66: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
;---- Variable 'wData' assigned to Register 'R5' ----
   67: 	uchar i;
   68: 	SpiAddress = SpiAddress<<1;
000535 EF                MOV      A,R7
000536 25E0              ADD      A,ACC
   69: 	SpiAddress = SpiAddress & 0x7E;
000538 547E              ANL      A,#07EH
00053A FF                MOV      R7,A
   70: 
   71: 	//传输地址 从高位到低位传输
   72: 	RC500CS = 0;
00053B C2A3              CLR      RC500CS
   73: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
00053D E4                CLR      A
00053E FE                MOV      R6,A
00053F         ?C0011?MIFARE:
   74: 	{
   75: 		if(SpiAddress&0x80)
00053F EF                MOV      A,R7
000540 30E704            JNB      ACC.7,?C0014?MIFARE
   76: 			RC500SO = 1;
000543 D2A2              SETB     RC500SO
000545 8002              SJMP     ?C0015?MIFARE
000547         ?C0014?MIFARE:
   77: 		else
   78: 			RC500SO = 0;
000547 C2A2              CLR      RC500SO
000549         ?C0015?MIFARE:
   79: 		RC500SCK = 1;
000549 F1FB              ACALL    ?L?COM004A
00054B B408F1            CJNE     A,#08H,?C0011?MIFARE
00054E         ?C0012?MIFARE:
   80: 		SpiAddress = SpiAddress<<1;
   81: 		RC500SCK = 0;
   82: 	}
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 4


   83: 	//传输数据，从高位开始
   84: 	for (i=0;i<8;i++)
00054E E4                CLR      A
00054F FE                MOV      R6,A
000550         ?C0016?MIFARE:
   85: 	{
   86: 		if(wData & 0x80)
000550 ED                MOV      A,R5
000551 30E704            JNB      ACC.7,?C0019?MIFARE
   87: 			RC500SO = 1;
000554 D2A2              SETB     RC500SO
000556 8002              SJMP     ?C0020?MIFARE
000558         ?C0019?MIFARE:
   88: 		else
   89: 			RC500SO = 0;
000558 C2A2              CLR      RC500SO
00055A         ?C0020?MIFARE:
   90: 		RC500SCK = 1;
00055A D2A1              SETB     RC500SCK
   91: 		wData = wData<<1;
00055C ED                MOV      A,R5
00055D 25E0              ADD      A,ACC
00055F FD                MOV      R5,A
   92: 		RC500SCK = 0;
000560 C2A1              CLR      RC500SCK
   93: 	}
000562 0E                INC      R6
000563 EE                MOV      A,R6
000564 B408E9            CJNE     A,#08H,?C0016?MIFARE
000567         ?C0017?MIFARE:
   94: 	RC500CS = 1;
000567 D2A3              SETB     RC500CS
   95: }
000569 22                RET      
----- FUNCTION _SPIWriteOne (END) -------


----- FUNCTION _SPIReadOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   24: uchar SPIReadOne(uchar SpiAddress)
   25: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
   26: 	uchar i,rdata; 
   27: 	//地址字节最高位置1，表示为读数据，最低位固定为0，中间6位为地址
   28: 	SpiAddress = SpiAddress<<1;
00056A EF                MOV      A,R7
00056B 25E0              ADD      A,ACC
   29: 	SpiAddress = SpiAddress | 0x80;
00056D 4480              ORL      A,#080H
00056F FF                MOV      R7,A
   30: 	//传输地址 从高位到低位传输
   31: 	RC500CS = 0;
000570 C2A3              CLR      RC500CS
   32: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
000572 E4                CLR      A
000573 FE                MOV      R6,A
000574         ?C0001?MIFARE:
   33: 	{
   34: 		if(SpiAddress&0x80)
000574 EF                MOV      A,R7
000575 30E704            JNB      ACC.7,?C0004?MIFARE
   35: 			RC500SO = 1;
000578 D2A2              SETB     RC500SO
00057A 8002              SJMP     ?C0005?MIFARE
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 5


00057C         ?C0004?MIFARE:
   36: 		else
   37: 			RC500SO = 0;
00057C C2A2              CLR      RC500SO
00057E         ?C0005?MIFARE:
   38: 		RC500SCK = 1;
00057E F1FB              ACALL    ?L?COM004A
000580 B408F1            CJNE     A,#08H,?C0001?MIFARE
000583         ?C0002?MIFARE:
   39: 		SpiAddress = SpiAddress<<1;
   40: 		RC500SCK = 0;
   41: 	}
   42: 	
   43: 	//接收数据
   44: 	rdata = 0;
;---- Variable 'rdata' assigned to Register 'R7' ----
000583 E4                CLR      A
000584 FF                MOV      R7,A
   45: 	for (i=0;i<8;i++)
000585 FE                MOV      R6,A
000586         ?C0006?MIFARE:
   46: 	{
   47: 		RC500SCK = 1;
000586 D2A1              SETB     RC500SCK
   48: 		rdata = rdata<<1;
000588 EF                MOV      A,R7
000589 25E0              ADD      A,ACC
00058B FF                MOV      R7,A
   49: 		if (RC500SI)
00058C 30A401            JNB      RC500SI,?C0009?MIFARE
   50: 			rdata+= 1;
00058F 0F                INC      R7
000590         ?C0009?MIFARE:
   51: 		RC500SCK = 0;
000590 C2A1              CLR      RC500SCK
   52: 	}
000592 0E                INC      R6
000593 EE                MOV      A,R6
000594 B408EF            CJNE     A,#08H,?C0006?MIFARE
000597         ?C0007?MIFARE:
   53: 	RC500CS=1;
000597 D2A3              SETB     RC500CS
   54: 	return (rdata);
   55: }
000599 22                RET      
----- FUNCTION _SPIReadOne (END) -------


----- FUNCTION AntiColl (BEGIN) -----
 FILE: 'Driver\mifare.c'
  278: uchar AntiColl(void)
  279: {
  280: 	
  281: 	uchar	temp,i;
  282: 
  283: 	//选择TX1、TX2的发射天线阻抗
  284: 	SPIWriteOne(CwConductance_Reg,0x3f);
00059A F1A7              ACALL    ?L?COM0023
00059C 7493              MOV      A,#093H
00059E F0                MOVX     @DPTR,A
  285: 	//选择数据校验种类和模式
  286: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  287: 	
  288: 	gBuff[0] = RF_CMD_ANTICOL;
  289: 	gBuff[1] = 0x20;
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 6


00059F A3                INC      DPTR
0005A0 7420              MOV      A,#020H
0005A2 F108              ACALL    ?L?COM0013
0005A4 900070            MOV      DPTR,#?_Command_Send?BYTE+04H
0005A7 7402              MOV      A,#02H
0005A9 F0                MOVX     @DPTR,A
0005AA 7F1E              MOV      R7,#01EH
0005AC D107              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R5' ----
0005AE AD07              MOV      R5,AR7
  290: 	temp = Command_Send(Transceive,gBuff,2);
  291: 	if (temp==0)
0005B0 ED                MOV      A,R5
0005B1 7003              JNZ      ?C0062?MIFARE
  292: 	{
  293: 		return(FM1702_NOTAGERR);
0005B3 7F01              MOV      R7,#01H
0005B5 22                RET      
  294: 	}
0005B6         ?C0062?MIFARE:
  295: 
  296: 	temp = SPIReadOne(FIFOLength_Reg);
0005B6 1219BA            LCALL    ?L?COM0041
0005B9 7003              JNZ      ?C0064?MIFARE
  297: 	if (temp == 0)
  298: 	{
  299: 		return FM1702_BYTECOUNTERR;
0005BB 7F0C              MOV      R7,#0CH
0005BD 22                RET      
  300: 	}
0005BE         ?C0064?MIFARE:
  301: 
  302: 	for(i=0;i<temp;i++)
;---- Variable 'i' assigned to Register 'R4' ----
0005BE E4                CLR      A
0005BF FC                MOV      R4,A
0005C0         ?C0065?MIFARE:
0005C0 EC                MOV      A,R4
0005C1 C3                CLR      C
0005C2 9D                SUBB     A,R5
0005C3 500C              JNC      ?C0066?MIFARE
  303: 	{
  304: 		gBuff[i] = SPIReadOne(FIFO_Reg);
0005C5 7F02              MOV      R7,#02H
0005C7 B16A              ACALL    _SPIReadOne
0005C9 121ACE            LCALL    ?L?COM0035
0005CC EF                MOV      A,R7
0005CD F0                MOVX     @DPTR,A
  305: 	}
0005CE 0C                INC      R4
0005CF 80EF              SJMP     ?C0065?MIFARE
0005D1         ?C0066?MIFARE:
  306: 	temp = SPIReadOne(ErrorFlag_Reg);	// 判断接数据是否有冲突位
0005D1 7F0A              MOV      R7,#0AH
0005D3 1219BC            LCALL    ?L?COM0042
0005D6 5401              ANL      A,#01H
0005D8 FD                MOV      R5,A
  307: 	temp = temp & 0x01;
  308: 	if (temp == 0x00)
0005D9 7029              JNZ      ?C0068?MIFARE
  309: 	{
  310: 		for (i=0;i<5;i++)
0005DB FC                MOV      R4,A
0005DC         ?C0069?MIFARE:
  311: 			temp^=gBuff[i];
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 7


0005DC 121ACE            LCALL    ?L?COM0035
0005DF E0                MOVX     A,@DPTR
0005E0 6D                XRL      A,R5
0005E1 FD                MOV      R5,A
0005E2 0C                INC      R4
0005E3 EC                MOV      A,R4
0005E4 B405F5            CJNE     A,#05H,?C0069?MIFARE
0005E7         ?C0070?MIFARE:
  312: 		if (temp)
0005E7 ED                MOV      A,R5
0005E8 6003              JZ       ?C0072?MIFARE
  313: 			return(FM1702_SERNRERR);
0005EA 7F08              MOV      R7,#08H
0005EC 22                RET      
0005ED         ?C0072?MIFARE:
  314:         for (i=0;i<5;i++)
0005ED E4                CLR      A
0005EE FC                MOV      R4,A
0005EF         ?C0073?MIFARE:
  315:         {
  316:             gCard_UID[i]=gBuff[i];
0005EF 121ACE            LCALL    ?L?COM0035
0005F2 E0                MOVX     A,@DPTR
0005F3 FF                MOV      R7,A
0005F4 74D3              MOV      A,#LOW gCard_UID
0005F6 2C                ADD      A,R4
0005F7 1215D7            LCALL    ?L?COM0018
0005FA EF                MOV      A,R7
0005FB F0                MOVX     @DPTR,A
  317:         }
0005FC 0C                INC      R4
0005FD EC                MOV      A,R4
0005FE B405EE            CJNE     A,#05H,?C0073?MIFARE
000601         ?C0074?MIFARE:
  318: 		return(FM1702_OK);
000601 7F00              MOV      R7,#00H
000603 22                RET      
  319: 	}
000604         ?C0068?MIFARE:
  320: 	else //有冲突位
  321: 		return FM1702_SERNRERR;
000604 7F08              MOV      R7,#08H
  322: }
000606 22                RET      
----- FUNCTION AntiColl (END) -------


----- FUNCTION _Command_Send (BEGIN) -----
 FILE: 'Driver\mifare.c'
  251: uchar Command_Send(uchar Comm_Set,uchar *buff, uchar count)
  252: {
000607 90006C            MOV      DPTR,#Comm_Set
00060A EF                MOV      A,R7
00060B F0                MOVX     @DPTR,A
;---- Variable 'buff' assigned to Register 'R1/R2/R3' ----
  253:     uchar ucResult1,ucResult2,i;
  254:     SPIWriteOne(Command_Reg,0x00);
00060C E4                CLR      A
00060D FD                MOV      R5,A
00060E 7F01              MOV      R7,#01H
000610 B135              ACALL    _SPIWriteOne
  255:     if(Clear_FIFO()==FALSE)
000612 121964            LCALL    Clear_FIFO
000615 EF                MOV      A,R7
000616 7002              JNZ      ?C0055?MIFARE
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 8


  256:         return FALSE;
000618 FF                MOV      R7,A
000619 22                RET      
00061A         ?C0055?MIFARE:
  257:     Write_FIFO(buff,count);
00061A 900070            MOV      DPTR,#count
00061D E0                MOVX     A,@DPTR
00061E FD                MOV      R5,A
00061F 1216C5            LCALL    _Write_FIFO
  258: 	SPIWriteOne(Command_Reg,Comm_Set);
000622 90006C            MOV      DPTR,#Comm_Set
000625 E0                MOVX     A,@DPTR
000626 FD                MOV      R5,A
000627 7F01              MOV      R7,#01H
000629 B135              ACALL    _SPIWriteOne
  259: 	for (i=0;i<0xA0;i++)
;---- Variable 'i' assigned to Register 'R5' ----
00062B E4                CLR      A
00062C FD                MOV      R5,A
00062D         ?C0057?MIFARE:
  260: 	{
  261:         ucResult1 = SPIReadOne(Command_Reg);
00062D 7F01              MOV      R7,#01H
00062F B16A              ACALL    _SPIReadOne
;---- Variable 'ucResult1' assigned to Register 'R4' ----
000631 AC07              MOV      R4,AR7
  262:         ucResult2 = SPIReadOne(InterruptRq_Reg) & 0x80;
000633 7F07              MOV      R7,#07H
000635 B16A              ACALL    _SPIReadOne
000637 EF                MOV      A,R7
000638 5480              ANL      A,#080H
00063A FF                MOV      R7,A
;---- Variable 'ucResult2' assigned to Register 'R7' ----
  263:         if(ucResult1 == 0 || ucResult2 ==0x80)
00063B EC                MOV      A,R4
00063C 6004              JZ       ?C0061?MIFARE
00063E EF                MOV      A,R7
00063F B48003            CJNE     A,#080H,?C0059?MIFARE
000642         ?C0061?MIFARE:
  264:             return TRUE;
000642 7F01              MOV      R7,#01H
000644 22                RET      
  265: 	}
000645         ?C0059?MIFARE:
000645 0D                INC      R5
000646 ED                MOV      A,R5
000647 B4A0E3            CJNE     A,#0A0H,?C0057?MIFARE
00064A         ?C0058?MIFARE:
  266: 	return FALSE;
00064A 7F00              MOV      R7,#00H
  267: }
00064C 22                RET      
----- FUNCTION _Command_Send (END) -------


----- FUNCTION _Request (BEGIN) -----
 FILE: 'Driver\mifare.c'
  152: uchar Request(uchar mode)
  153: {
;---- Variable 'mode' assigned to Register 'R4' ----
00064D AC07              MOV      R4,AR7
  154: 	
  155: 	uchar temp;
  156: 	
  157: 	//选择TX1、TX2的发射天线阻抗
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 9


  158: 	SPIWriteOne(CwConductance_Reg,0x3f);
00064F F1E7              ACALL    ?L?COM0057
  159: 	//选择数据校验种类和模式
  160: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
000651 7D03              MOV      R5,#03H
000653 7F22              MOV      R7,#022H
000655 B135              ACALL    _SPIWriteOne
  161: 	//调整面向bit的格式
  162: 	SPIWriteOne(BitFraming_Reg,0x07);
000657 7D07              MOV      R5,#07H
000659 7F0F              MOV      R7,#0FH
00065B F1B1              ACALL    ?L?COM0025
00065D EC                MOV      A,R4
00065E F0                MOVX     @DPTR,A
  163: 	gBuff[0] = mode;		//Request模式选择 
  164: 	temp = SPIReadOne(Control_Reg);
00065F 7F09              MOV      R7,#09H
000661 B16A              ACALL    _SPIReadOne
;---- Variable 'temp' assigned to Register 'R7' ----
  165: 	temp = temp & (0xf7);	
000663 EF                MOV      A,R7
000664 54F7              ANL      A,#0F7H
  166: 	SPIWriteOne(Control_Reg,temp);			//Control reset value is 00
000666 FD                MOV      R5,A
000667 7F09              MOV      R7,#09H
000669 B135              ACALL    _SPIWriteOne
  167: 	temp = Command_Send(Transceive, gBuff,1 );   //发送接收命令 
00066B F109              ACALL    ?L?COM0014
00066D 900070            MOV      DPTR,#?_Command_Send?BYTE+04H
000670 7401              MOV      A,#01H
000672 121A11            LCALL    ?L?COM0028
000675 7003              JNZ      ?C0030?MIFARE
  168: 	if(temp==0 )
  169: 	{
  170: 		return FM1702_NOTAGERR;
000677 7F01              MOV      R7,#01H
000679 22                RET      
  171: 	}
00067A         ?C0030?MIFARE:
  172: 
  173: 	temp=Read_FIFO(gBuff);		//从FIFO中读取应答信息到gBuff中 
00067A F109              ACALL    ?L?COM0014
00067C 121986            LCALL    _Read_FIFO
  174: 	// 判断应答信号是否正确 
  175: 	// 2  	Mifare Pro 卡
  176: 	//4 		Mifare One 卡
  177: 	if((gBuff[0] == 0x04) & (gBuff[1] == 0x0) &(temp == 2))
00067F 9000D9            MOV      DPTR,#gBuff+01H
000682 E0                MOVX     A,@DPTR
000683 7E00              MOV      R6,#00H
000685 7002              JNZ      ?C0033?MIFARE
000687 7E01              MOV      R6,#01H
000689         ?C0033?MIFARE:
000689         ?C0034?MIFARE:
000689 9000D8            MOV      DPTR,#gBuff
00068C E0                MOVX     A,@DPTR
00068D 7D00              MOV      R5,#00H
00068F B40402            CJNE     A,#04H,?C0035?MIFARE
000692 7D01              MOV      R5,#01H
000694         ?C0035?MIFARE:
000694         ?C0036?MIFARE:
000694 ED                MOV      A,R5
000695 5E                ANL      A,R6
000696 FE                MOV      R6,A
000697 EF                MOV      A,R7
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 10


000698 7F00              MOV      R7,#00H
00069A B40202            CJNE     A,#02H,?C0037?MIFARE
00069D 7F01              MOV      R7,#01H
00069F         ?C0037?MIFARE:
00069F         ?C0038?MIFARE:
00069F EF                MOV      A,R7
0006A0 5E                ANL      A,R6
0006A1 7F15              MOV      R7,#015H
0006A3 6002              JZ       ?C0032?MIFARE
  178: 	{
  179: 			return FM1702_OK;
0006A5 7F00              MOV      R7,#00H
  180: 	}
0006A7         ?C0032?MIFARE:
  181: 	return FM1702_REQERR;
  182: }
0006A7 22                RET      
----- FUNCTION _Request (END) -------


----- FUNCTION SelectCard (BEGIN) -----
 FILE: 'Driver\mifare.c'
  335: uchar SelectCard(void)
  336: {
  337: 	
  338: 	uchar	temp, i;
  339: 	
  340: 	//选择TX1、TX2的发射天线阻抗
  341: 	SPIWriteOne(CwConductance_Reg,0x3f);
0006A8 F1E7              ACALL    ?L?COM0057
  342: 	//选择数据校验种类和模式
  343: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
0006AA 7D0F              MOV      R5,#0FH
0006AC F1AF              ACALL    ?L?COM0024
0006AE 7493              MOV      A,#093H
0006B0 F0                MOVX     @DPTR,A
  344: 
  345: 	gBuff[0] = RF_CMD_SELECT;
  346: 	gBuff[1] = 0x70;
0006B1 A3                INC      DPTR
0006B2 7470              MOV      A,#070H
0006B4 F0                MOVX     @DPTR,A
  347: 	for(i = 0; i < 5; i++)
;---- Variable 'i' assigned to Register 'R7' ----
0006B5 E4                CLR      A
0006B6 FF                MOV      R7,A
0006B7         ?C0077?MIFARE:
  348: 	{
  349: 		gBuff[i + 2] = gCard_UID[i];
0006B7 74D3              MOV      A,#LOW gCard_UID
0006B9 2F                ADD      A,R7
0006BA 1215D7            LCALL    ?L?COM0018
0006BD E0                MOVX     A,@DPTR
0006BE 120FF5            LCALL    ?L?COM0030
0006C1 B405F3            CJNE     A,#05H,?C0077?MIFARE
0006C4         ?C0078?MIFARE:
  350: 	}
  351: 	temp = Command_Send(Transceive, gBuff,7 );
0006C4 F109              ACALL    ?L?COM0014
0006C6 900070            MOV      DPTR,#?_Command_Send?BYTE+04H
0006C9 7407              MOV      A,#07H
;---- Variable 'temp' assigned to Register 'R7' ----
0006CB 121A11            LCALL    ?L?COM0028
0006CE 7003              JNZ      ?C0080?MIFARE
  352: 	if(temp==0 )
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 11


  353: 	{
  354: 		return(FM1702_NOTAGERR);
0006D0 7F01              MOV      R7,#01H
0006D2 22                RET      
  355: 	}
0006D3         ?C0080?MIFARE:
  356: 	else
  357: 	{
  358: 		temp = SPIReadOne(ErrorFlag_Reg);
0006D3 F1E1              ACALL    ?L?COM002F
0006D5 30E103            JNB      ACC.1,?C0083?MIFARE
0006D8 7F05              MOV      R7,#05H
0006DA 22                RET      
0006DB         ?C0083?MIFARE:
  359: 		if((temp & 0x02) == 0x02) return(FM1702_PARITYERR);
  360: 		if((temp & 0x04) == 0x04) return(FM1702_FRAMINGERR);
0006DB EF                MOV      A,R7
0006DC 30E203            JNB      ACC.2,?C0084?MIFARE
0006DF 7F14              MOV      R7,#014H
0006E1 22                RET      
0006E2         ?C0084?MIFARE:
  361: 		if((temp & 0x08) == 0x08) return(FM1702_CRCERR);
0006E2 EF                MOV      A,R7
0006E3 30E303            JNB      ACC.3,?C0085?MIFARE
0006E6 7F02              MOV      R7,#02H
0006E8 22                RET      
0006E9         ?C0085?MIFARE:
  362: 		temp = SPIReadOne(FIFOLength_Reg);
0006E9 7F04              MOV      R7,#04H
0006EB B16A              ACALL    _SPIReadOne
  363: 		if(temp != 1) return(FM1702_BYTECOUNTERR);
0006ED EF                MOV      A,R7
0006EE 6401              XRL      A,#01H
0006F0 6003              JZ       ?C0086?MIFARE
0006F2 7F0C              MOV      R7,#0CH
0006F4 22                RET      
0006F5         ?C0086?MIFARE:
  364: //		SPIRead(FIFO_Reg,gBuff,temp);	//从FIFO中读取应答信息
  365: 		gBuff[0] = SPIReadOne(FIFO_Reg);
0006F5 7F02              MOV      R7,#02H
0006F7 B16A              ACALL    _SPIReadOne
0006F9 9000D8            MOV      DPTR,#gBuff
0006FC EF                MOV      A,R7
0006FD F0                MOVX     @DPTR,A
  366: 		if(gBuff[0]==0x08) 	  	// 判断应答信号是否正确 
0006FE BF0803            CJNE     R7,#08H,?C0087?MIFARE
  367: 			return(FM1702_OK);
000701 7F00              MOV      R7,#00H
000703 22                RET      
000704         ?C0087?MIFARE:
  368: 		else
  369: 			return(FM1702_SELERR);
000704 7F16              MOV      R7,#016H
  370: 	}
  371: }
000706 22                RET      
----- FUNCTION SelectCard (END) -------


----- FUNCTION ?L?COM0012 (BEGIN) -----
000707 A3                INC      DPTR
000708         ?L?COM0013:
000708 F0                MOVX     @DPTR,A
000709         ?L?COM0014:
000709 7B01              MOV      R3,#01H
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 12


00070B 7A00              MOV      R2,#HIGH gBuff
00070D 79D8              MOV      R1,#LOW gBuff
00070F 22                RET      
----- FUNCTION ?L?COM0012 (END) -------


----- FUNCTION _Authentication (BEGIN) -----
 FILE: 'Driver\mifare.c'
  472: uchar Authentication(uchar *UID, uchar SecNR, uchar mode)
  473: {
000710 90004B            MOV      DPTR,#UID
000713 120DC9            LCALL    ?L?COM0004
;---- Variable 'SecNR' assigned to Register 'R4' ----
000716 AC05              MOV      R4,AR5
  474: 	uchar i;
  475: 	uchar temp, temp1;
  476: 
  477: 	if(SecNR >= 16)
000718 EC                MOV      A,R4
000719 C3                CLR      C
00071A 9410              SUBB     A,#010H
00071C 4004              JC       ?C0094?MIFARE
  478: 		SecNR = SecNR % 16;
00071E EC                MOV      A,R4
00071F 540F              ANL      A,#0FH
000721 FC                MOV      R4,A
000722         ?C0094?MIFARE:
  479: 	
  480: 	//选择数据校验种类和模式
  481: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
000722 F1F5              ACALL    ?L?COM0055
  482: 	gBuff[0] = mode;
000724 90004F            MOV      DPTR,#mode
000727 E0                MOVX     A,@DPTR
000728 9000D8            MOV      DPTR,#gBuff
00072B F0                MOVX     @DPTR,A
  483: 	gBuff[1] = SecNR * 4 + 3;
00072C EC                MOV      A,R4
00072D 25E0              ADD      A,ACC
00072F 25E0              ADD      A,ACC
000731 2403              ADD      A,#03H
000733 A3                INC      DPTR
000734 F0                MOVX     @DPTR,A
  484: 	for(i = 0; i < 4; i++)
;---- Variable 'i' assigned to Register 'R7' ----
000735 E4                CLR      A
000736 FF                MOV      R7,A
000737         ?C0095?MIFARE:
  485: 	{
  486: 		gBuff[2 + i] = UID[i];
000737 90004B            MOV      DPTR,#UID
00073A 120D64            LCALL    ?L?COM0008
00073D F9                MOV      R1,A
00073E 8F82              MOV      DPL,R7
000740 121088            LCALL    ?L?COM001F
000743 120FF5            LCALL    ?L?COM0030
000746 B404EE            CJNE     A,#04H,?C0095?MIFARE
000749         ?C0096?MIFARE:
  487: 	}
  488: 
  489: 	temp = Command_Send(Authent1, gBuff,6 );
000749 F109              ACALL    ?L?COM0014
00074B 900070            MOV      DPTR,#?_Command_Send?BYTE+04H
00074E 7406              MOV      A,#06H
000750 F0                MOVX     @DPTR,A
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 13


000751 7F0C              MOV      R7,#0CH
000753 D107              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  490: 	if(temp==0)
000755 EF                MOV      A,R7
000756 7003              JNZ      ?C0098?MIFARE
  491: 	{
  492: 		return 0x99;
000758 7F99              MOV      R7,#099H
00075A 22                RET      
  493: 	}
00075B         ?C0098?MIFARE:
  494: 
  495: 	temp = SPIReadOne(ErrorFlag_Reg);   
00075B F1E1              ACALL    ?L?COM002F
00075D 30E103            JNB      ACC.1,?C0100?MIFARE
000760 7F05              MOV      R7,#05H
000762 22                RET      
000763         ?C0100?MIFARE:
  496: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  497: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
000763 EF                MOV      A,R7
000764 30E203            JNB      ACC.2,?C0101?MIFARE
000767 7F14              MOV      R7,#014H
000769 22                RET      
00076A         ?C0101?MIFARE:
  498: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
00076A EF                MOV      A,R7
00076B 30E303            JNB      ACC.3,?C0102?MIFARE
00076E 7F02              MOV      R7,#02H
000770 22                RET      
000771         ?C0102?MIFARE:
  499: 	temp = Command_Send(Authent2, gBuff,0 );	
000771 F109              ACALL    ?L?COM0014
000773 E4                CLR      A
000774 900070            MOV      DPTR,#?_Command_Send?BYTE+04H
000777 F0                MOVX     @DPTR,A
000778 7F14              MOV      R7,#014H
00077A D107              ACALL    _Command_Send
  500: 	if(temp ==0)
00077C EF                MOV      A,R7
00077D 7003              JNZ      ?C0103?MIFARE
  501: 	{
  502: 		return 0x88;
00077F 7F88              MOV      R7,#088H
000781 22                RET      
  503: 	}
000782         ?C0103?MIFARE:
  504: 
  505: 	temp = SPIReadOne(ErrorFlag_Reg);
000782 F1E1              ACALL    ?L?COM002F
000784 30E103            JNB      ACC.1,?C0104?MIFARE
000787 7F05              MOV      R7,#05H
000789 22                RET      
00078A         ?C0104?MIFARE:
  506: //	Show(temp,0);
  507: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  508: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
00078A EF                MOV      A,R7
00078B 30E203            JNB      ACC.2,?C0105?MIFARE
00078E 7F14              MOV      R7,#014H
000790 22                RET      
000791         ?C0105?MIFARE:
  509: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
000791 EF                MOV      A,R7
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 14


000792 30E303            JNB      ACC.3,?C0106?MIFARE
000795 7F02              MOV      R7,#02H
000797 22                RET      
000798         ?C0106?MIFARE:
  510: 	temp1 = SPIReadOne(Control_Reg);
000798 7F09              MOV      R7,#09H
00079A B16A              ACALL    _SPIReadOne
;---- Variable 'temp1' assigned to Register 'R7' ----
  511: 	temp1 = temp1 & 0x08;	
00079C EF                MOV      A,R7
00079D 5408              ANL      A,#08H
  512: 	if(temp1 == 0x08)
00079F 7F04              MOV      R7,#04H
0007A1 B40802            CJNE     A,#08H,?C0107?MIFARE
  513: 	{
  514: 		return FM1702_OK;
0007A4 7F00              MOV      R7,#00H
  515: 	}
0007A6         ?C0107?MIFARE:
  516: 
  517: 	return FM1702_AUTHERR;
  518: }
0007A6 22                RET      
----- FUNCTION _Authentication (END) -------


----- FUNCTION ?L?COM0023 (BEGIN) -----
0007A7 7D3F              MOV      R5,#03FH
0007A9 7F12              MOV      R7,#012H
0007AB B135              ACALL    _SPIWriteOne
0007AD 7D03              MOV      R5,#03H
0007AF         ?L?COM0024:
0007AF 7F22              MOV      R7,#022H
0007B1         ?L?COM0025:
0007B1 B135              ACALL    _SPIWriteOne
0007B3 9000D8            MOV      DPTR,#gBuff
0007B6 22                RET      
----- FUNCTION ?L?COM0023 (END) -------


----- FUNCTION MIF_Halt (BEGIN) -----
 FILE: 'Driver\mifare.c'
  610: uchar MIF_Halt(void)
  611: {
  612: 	uchar	temp;
  613: 	//选择TX1、TX2的发射天线阻抗
  614: 	SPIWriteOne(CwConductance_Reg,0x3f);
0007B7 F1A7              ACALL    ?L?COM0023
0007B9 7450              MOV      A,#050H
0007BB F0                MOVX     @DPTR,A
  615: 	//选择数据校验种类和模式
  616: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  617: 	*gBuff = RF_CMD_HALT;
  618: 	*(gBuff + 1) = 0x00;
0007BC E4                CLR      A
0007BD F107              ACALL    ?L?COM0012
0007BF 900070            MOV      DPTR,#?_Command_Send?BYTE+04H
0007C2 7402              MOV      A,#02H
0007C4 F0                MOVX     @DPTR,A
0007C5 7F1A              MOV      R7,#01AH
0007C7 D107              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  619: 	temp = Command_Send(Transmit, gBuff, 2);//发送FIFO缓存地址
  620: 	if(temp == TRUE)
0007C9 EF                MOV      A,R7
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 15


0007CA B40103            CJNE     A,#01H,?C0133?MIFARE
  621: 		return FM1702_OK;
0007CD 7F00              MOV      R7,#00H
0007CF 22                RET      
0007D0         ?C0133?MIFARE:
  622: 	else
  623: 	{
  624: 		temp = SPIReadOne(ErrorFlag_Reg);
0007D0 F1E1              ACALL    ?L?COM002F
0007D2 30E103            JNB      ACC.1,?C0136?MIFARE
  625: 		if((temp & 0x02) == 0x02)
  626: 		{
  627: 			return(FM1702_PARITYERR);
0007D5 7F05              MOV      R7,#05H
0007D7 22                RET      
  628: 		}
0007D8         ?C0136?MIFARE:
  629: 
  630: 		if((temp & 0x04) == 0x04)
0007D8 EF                MOV      A,R7
0007D9 7F01              MOV      R7,#01H
0007DB 30E202            JNB      ACC.2,?C0137?MIFARE
  631: 		{
  632: 			return(FM1702_FRAMINGERR);
0007DE 7F14              MOV      R7,#014H
  633: 		}
0007E0         ?C0137?MIFARE:
  634: 		return(FM1702_NOTAGERR);
  635: 	}
  636: }
0007E0 22                RET      
----- FUNCTION MIF_Halt (END) -------


----- FUNCTION ?L?COM002F (BEGIN) -----
0007E1 7F0A              MOV      R7,#0AH
0007E3 B16A              ACALL    _SPIReadOne
0007E5 EF                MOV      A,R7
0007E6 22                RET      
----- FUNCTION ?L?COM002F (END) -------


----- FUNCTION ?L?COM0057 (BEGIN) -----
0007E7 7D3F              MOV      R5,#03FH
0007E9 7F12              MOV      R7,#012H
0007EB A135              AJMP     _SPIWriteOne
----- FUNCTION ?L?COM0057 (END) -------


----- FUNCTION ?L?COM0037 (BEGIN) -----
0007ED 7F01              MOV      R7,#01H
0007EF         ?L?COM0038:
0007EF B16A              ACALL    _SPIReadOne
0007F1 AC07              MOV      R4,AR7
0007F3 EC                MOV      A,R4
0007F4 22                RET      
----- FUNCTION ?L?COM0037 (END) -------


----- FUNCTION ?L?COM0055 (BEGIN) -----
0007F5 7D0F              MOV      R5,#0FH
0007F7 7F22              MOV      R7,#022H
0007F9 A135              AJMP     _SPIWriteOne
----- FUNCTION ?L?COM0055 (END) -------

LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 16



----- FUNCTION ?L?COM004A (BEGIN) -----
0007FB D2A1              SETB     RC500SCK
0007FD EF                MOV      A,R7
0007FE 25E0              ADD      A,ACC
000800 FF                MOV      R7,A
000801 C2A1              CLR      RC500SCK
000803 0E                INC      R6
000804 EE                MOV      A,R6
000805 22                RET      
----- FUNCTION ?L?COM004A (END) -------


----- FUNCTION ?L?COM0046 (BEGIN) -----
000806 7FE8              MOV      R7,#0E8H
000808 7E03              MOV      R6,#03H
----- FUNCTION _sys_delayms (BEGIN) -----
 FILE: 'System\sys_delay.c'
   10: void sys_delayms(UINT16 xms)
   11: {   
;---- Variable 'xms' assigned to Register 'R6/R7' ----
   12:     UINT8 i, j;
00080A         ?C0004?SYS_DELAY:
   13: 	while(xms--)
00080A EF                MOV      A,R7
00080B 1F                DEC      R7
00080C AC06              MOV      R4,AR6
00080E 7001              JNZ      ?C0013?SYS_DELAY
000810 1E                DEC      R6
000811         ?C0013?SYS_DELAY:
000811 4C                ORL      A,R4
000812 600D              JZ       ?C0011?SYS_DELAY
   14:     {
   15:     	WDT_CONTR |= 0x35;
000814 43C135            ORL      WDT_CONTR,#035H
   16:         i = 22;
;---- Variable 'i' assigned to Register 'R5' ----
000817 7D16              MOV      R5,#016H
   17:         j = 128;
;---- Variable 'j' assigned to Register 'R4' ----
000819 7C80              MOV      R4,#080H
   18:         do
   19:         {
00081B         ?C0009?SYS_DELAY:
   20:             while (--j);
00081B DCFE              DJNZ     R4,?C0009?SYS_DELAY
00081D         ?C0010?SYS_DELAY:
   21:         } while (--i);
00081D         ?C0006?SYS_DELAY:
00081D DDFC              DJNZ     R5,?C0009?SYS_DELAY
   22:     }
00081F 80E9              SJMP     ?C0004?SYS_DELAY
   22: }
000821         ?C0011?SYS_DELAY:
000821 22                RET      
----- FUNCTION _sys_delayms (END) -------


----- FUNCTION app_Show (BEGIN) -----
 FILE: 'App\app_brush.c'
   20: void app_Show(void)
   21: {
   22:     if(!b_FactorySystem)
   23:     {
000822 200C1D            JB       b_FactorySystem,?C0002?APP_BRUSH
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 17


   24:         sys_delayms(1000);
   25:         led_ShowNumber(MoneySum/100, MoneySum%100, 0);
000825 1106              ACALL    ?L?COM0046
   26:         sys_delayms(1000);
000827 1143              ACALL    ?L?COM002D
000829 C006              PUSH     AR6
00082B C007              PUSH     AR7
00082D 1143              ACALL    ?L?COM002D
00082F AF03              MOV      R7,AR3
000831 AD07              MOV      R5,AR7
000833 D007              POP      AR7
000835 D006              POP      AR6
000837 E4                CLR      A
000838 FB                MOV      R3,A
000839 115A              ACALL    _led_ShowNumber
   27:         gLedBuf[0] = 12;
00083B 1106              ACALL    ?L?COM0046
   28:         gLedBuf[1] = 15;
00083D 121A9C            LCALL    ?L?COM0026
   29:         gLedBuf[2] = 15;
   30:         gLedBuf[3] = 15;
   31:         gLedBuf[4] = 15;
   32:         gLedBuf[5] = 12;
   33:         gShowDot = 0;
   34:         sys_delayms(1000);
000840 1106              ACALL    ?L?COM0046
   35:     }
   36: }
000842         ?C0002?APP_BRUSH:
000842 22                RET      
----- FUNCTION app_Show (END) -------


----- FUNCTION ?L?COM002D (BEGIN) -----
000843 E4                CLR      A
000844 7B64              MOV      R3,#064H
000846 FA                MOV      R2,A
000847 F9                MOV      R1,A
000848 F8                MOV      R0,A
000849 9000BC            MOV      DPTR,#MoneySum
00084C E0                MOVX     A,@DPTR
00084D FC                MOV      R4,A
00084E A3                INC      DPTR
00084F E0                MOVX     A,@DPTR
000850 FD                MOV      R5,A
000851 A3                INC      DPTR
000852 E0                MOVX     A,@DPTR
000853 FE                MOV      R6,A
000854 A3                INC      DPTR
000855 E0                MOVX     A,@DPTR
000856 FF                MOV      R7,A
000857 0202D1            LJMP     ?C?ULDIV
----- FUNCTION ?L?COM002D (END) -------


----- FUNCTION _led_ShowNumber (BEGIN) -----
 FILE: 'Driver\LED.c'
   95: void led_ShowNumber(UINT16 L_num, UINT8 R_num, UINT8 DotPlace)
   96: {
00085A 900048            MOV      DPTR,#L_num
00085D EE                MOV      A,R6
00085E F0                MOVX     @DPTR,A
00085F A3                INC      DPTR
000860 EF                MOV      A,R7
000861 F0                MOVX     @DPTR,A
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 18


;---- Variable 'R_num' assigned to Register 'R2' ----
000862 AA05              MOV      R2,AR5
;---- Variable 'DotPlace' assigned to Register 'R3' ----
   97:     if(L_num>9999)
   98:     {
000864 D3                SETB     C
000865 E0                MOVX     A,@DPTR
000866 940F              SUBB     A,#0FH
000868 900048            MOV      DPTR,#L_num
00086B E0                MOVX     A,@DPTR
00086C 9427              SUBB     A,#027H
00086E 4007              JC       ?C0034?LED
   99:         L_num = 9999;
  100:     }
000870 7427              MOV      A,#027H
000872 F0                MOVX     @DPTR,A
000873 A3                INC      DPTR
000874 740F              MOV      A,#0FH
000876 F0                MOVX     @DPTR,A
  101:     if(R_num>99)
000877         ?C0034?LED:
  102:     {
000877 EA                MOV      A,R2
000878 D3                SETB     C
000879 9463              SUBB     A,#063H
00087B 4002              JC       ?C0035?LED
  103:         R_num = 99;
  104:     }
00087D 7A63              MOV      R2,#063H
  105:     gLedBuf[0] = L_num/1000;
00087F         ?C0035?LED:
  106:     gLedBuf[1] = L_num/100%10;
00087F 5101              ACALL    ?L?COM0050
000881 7C03              MOV      R4,#03H
000883 7DE8              MOV      R5,#0E8H
000885 1201A8            LCALL    ?C?UIDIV
000888 9000F1            MOV      DPTR,#gLedBuf
00088B EF                MOV      A,R7
00088C F0                MOVX     @DPTR,A
  107:     gLedBuf[2] = L_num/10%10;
00088D 900048            MOV      DPTR,#L_num
000890 315A              ACALL    ?L?COM002E
000892 11C5              ACALL    ?L?COM000C
000894 9000F2            MOV      DPTR,#gLedBuf+01H
000897 ED                MOV      A,R5
000898 F0                MOVX     @DPTR,A
  108:     gLedBuf[3] = L_num%10;
000899 900048            MOV      DPTR,#L_num
00089C 11BC              ACALL    ?L?COM000B
00089E 9000F3            MOV      DPTR,#gLedBuf+02H
0008A1 ED                MOV      A,R5
0008A2 F0                MOVX     @DPTR,A
  109:     gLedBuf[4] = R_num/10%10;
0008A3 5101              ACALL    ?L?COM0050
0008A5 11C8              ACALL    ?L?COM000D
0008A7 9000F4            MOV      DPTR,#gLedBuf+03H
0008AA ED                MOV      A,R5
0008AB F0                MOVX     @DPTR,A
  110:     gLedBuf[5] = R_num%10;
0008AC EA                MOV      A,R2
0008AD 75F00A            MOV      B,#0AH
0008B0 84                DIV      AB
0008B1 510A              ACALL    ?L?COM0051
  111:     gShowDot = DotPlace;
0008B3 EA                MOV      A,R2
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 19


0008B4 510A              ACALL    ?L?COM0051
  112: }
0008B6 9000F8            MOV      DPTR,#gShowDot
0008B9 EB                MOV      A,R3
0008BA F0                MOVX     @DPTR,A
  113: 
0008BB 22                RET      
----- FUNCTION _led_ShowNumber (END) -------


----- FUNCTION ?L?COM000B (BEGIN) -----
0008BC E0                MOVX     A,@DPTR
0008BD FE                MOV      R6,A
0008BE A3                INC      DPTR
0008BF E0                MOVX     A,@DPTR
0008C0 FF                MOV      R7,A
0008C1 7C00              MOV      R4,#00H
0008C3 7D0A              MOV      R5,#0AH
0008C5         ?L?COM000C:
0008C5 1201A8            LCALL    ?C?UIDIV
0008C8         ?L?COM000D:
0008C8 7C00              MOV      R4,#00H
0008CA 7D0A              MOV      R5,#0AH
0008CC 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM000B (END) -------


----- FUNCTION _led_ShowNumber1 (BEGIN) -----
 FILE: 'Driver\LED.c'
  114: void led_ShowNumber1(UINT16 L_num, UINT16 R_num, UINT8 DotPlace)
  115: {
0008CF 900049            MOV      DPTR,#R_num
0008D2 EC                MOV      A,R4
0008D3 F0                MOVX     @DPTR,A
0008D4 A3                INC      DPTR
0008D5 ED                MOV      A,R5
0008D6 F0                MOVX     @DPTR,A
0008D7 900047            MOV      DPTR,#L_num
0008DA EE                MOV      A,R6
0008DB F0                MOVX     @DPTR,A
0008DC A3                INC      DPTR
0008DD EF                MOV      A,R7
0008DE F0                MOVX     @DPTR,A
;---- Variable 'DotPlace' assigned to Register 'R3' ----
  116:     if(L_num>999)
  117:     {
0008DF D3                SETB     C
0008E0 94E7              SUBB     A,#0E7H
0008E2 EE                MOV      A,R6
0008E3 9403              SUBB     A,#03H
0008E5 4005              JC       ?C0037?LED
  118:         L_num = 999;
  119:     }
0008E7 900047            MOV      DPTR,#L_num
0008EA 31F9              ACALL    ?L?COM005B
  120:     if(R_num>999)
0008EC         ?C0037?LED:
  121:     {
0008EC D3                SETB     C
0008ED 90004A            MOV      DPTR,#R_num+01H
0008F0 E0                MOVX     A,@DPTR
0008F1 94E7              SUBB     A,#0E7H
0008F3 900049            MOV      DPTR,#R_num
0008F6 E0                MOVX     A,@DPTR
0008F7 9403              SUBB     A,#03H
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 20


0008F9 4002              JC       ?C0038?LED
  122:         R_num = 999;
  123:     }
0008FB 31F9              ACALL    ?L?COM005B
  124:     gLedBuf[0] = L_num/100%10;
0008FD         ?C0038?LED:
  125:     gLedBuf[1] = L_num/10%10;
0008FD 900047            MOV      DPTR,#L_num
000900 315A              ACALL    ?L?COM002E
000902 11C5              ACALL    ?L?COM000C
000904 9000F1            MOV      DPTR,#gLedBuf
000907 ED                MOV      A,R5
000908 F0                MOVX     @DPTR,A
  126:     gLedBuf[2] = L_num%10;
000909 900047            MOV      DPTR,#L_num
00090C 11BC              ACALL    ?L?COM000B
00090E 9000F2            MOV      DPTR,#gLedBuf+01H
000911 ED                MOV      A,R5
000912 F0                MOVX     @DPTR,A
  127:     gLedBuf[3] = R_num/100;
000913 900047            MOV      DPTR,#L_num
000916 E0                MOVX     A,@DPTR
000917 FE                MOV      R6,A
000918 A3                INC      DPTR
000919 E0                MOVX     A,@DPTR
00091A FF                MOV      R7,A
00091B 11C8              ACALL    ?L?COM000D
00091D 9000F3            MOV      DPTR,#gLedBuf+02H
000920 ED                MOV      A,R5
000921 F0                MOVX     @DPTR,A
  128:     if(gLedBuf[3] == 0)
000922 900049            MOV      DPTR,#R_num
000925 315A              ACALL    ?L?COM002E
000927 1201A8            LCALL    ?C?UIDIV
00092A 9000F4            MOV      DPTR,#gLedBuf+03H
00092D EF                MOV      A,R7
00092E F0                MOVX     @DPTR,A
  129:     {
00092F 7003              JNZ      ?C0039?LED
  130:         gLedBuf[3] = 12;
  131:     }
000931 740C              MOV      A,#0CH
000933 F0                MOVX     @DPTR,A
  132:     gLedBuf[4] = R_num/10%10;
000934         ?C0039?LED:
  133:     if(gLedBuf[4] == 0)
000934 900049            MOV      DPTR,#R_num
000937 11BC              ACALL    ?L?COM000B
000939 AF05              MOV      R7,AR5
00093B 9000F5            MOV      DPTR,#gLedBuf+04H
00093E EF                MOV      A,R7
00093F F0                MOVX     @DPTR,A
  134:     {
000940 7003              JNZ      ?C0040?LED
  135:         gLedBuf[4] = 12;
  136:     }
000942 740C              MOV      A,#0CH
000944 F0                MOVX     @DPTR,A
  137:     gLedBuf[5] = R_num%10;
000945         ?C0040?LED:
  138:     gShowDot = DotPlace;
000945 900049            MOV      DPTR,#R_num
000948 E0                MOVX     A,@DPTR
000949 FE                MOV      R6,A
00094A A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 21


00094B E0                MOVX     A,@DPTR
00094C FF                MOV      R7,A
00094D 11C8              ACALL    ?L?COM000D
00094F 9000F6            MOV      DPTR,#gLedBuf+05H
000952 ED                MOV      A,R5
000953 F0                MOVX     @DPTR,A
  139: }
000954 9000F8            MOV      DPTR,#gShowDot
000957 EB                MOV      A,R3
000958 F0                MOVX     @DPTR,A
  140: 
000959 22                RET      
----- FUNCTION _led_ShowNumber1 (END) -------


----- FUNCTION ?L?COM002E (BEGIN) -----
00095A E0                MOVX     A,@DPTR
00095B FE                MOV      R6,A
00095C A3                INC      DPTR
00095D E0                MOVX     A,@DPTR
00095E FF                MOV      R7,A
00095F 7C00              MOV      R4,#00H
000961 7D64              MOV      R5,#064H
000963 22                RET      
----- FUNCTION ?L?COM002E (END) -------


----- FUNCTION app_brushCycle1s (BEGIN) -----
 FILE: 'App\app_brush.c'
  104: void app_brushCycle1s(void)
  105: {
  106:     switch (app_brushCard())
  107:     {
000964 12151C            LCALL    app_brushCard
000967 EF                MOV      A,R7
000968 24FE              ADD      A,#0FEH
00096A 6047              JZ       ?C0031?APP_BRUSH
00096C 14                DEC      A
00096D 7063              JNZ      ?C0023?APP_BRUSH
  108:         case MEM_CARD:
  109:             break;
  110: //            if(hwa_mifareReadBlock(gBuff,4))
  111: //            {
  112: //                if(u8_FirstBrushCardDly)
  113: //                {
  114: //                    if(gBuff[0]==0x01 && gBuff[1]==0x0A)
  115: //                    {
  116: //                        s_System.Money += 1000;
  117: //						if (s_System.Money > 20000)
  118: //						{
  119: //							s_System.Money = 0;
  120: //						}
  121: //                        s_System.Money -= s_System.Money%1000;
  122: //                    }
  123: //                    else if(gBuff[0]==0xFA && gBuff[1]==0x01)
  124: //                    {
  125: //                        if(s_System.Money<20000)
  126: //                        {
  127: //                            s_System.Money += 100;
  128: //                            if (s_System.Money % 1000 == 0 && s_System.Money/1000>0)
  129: //                            {
  130: //                                s_System.Money -= 1000;
  131: //                            }
  132: //                        }
  133: //                    }
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 22


  134: //                }
  135: //                led_ShowNumber1(s_System.Money/100, u8_BrushNum, 0);
  136: //                u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
  137: //                buzzer_SoundNumber(1);
  138: //                b_SettingChange = TRUE;
  139: //            }
  140: //            break;
  141:             
  142:         case PWD_CARD:                                 //从初始卡中读取管理卡密码，并储存至E2
00096F         ?C0025?APP_BRUSH:
  143:             if(hwa_mifareReadBlock(gBuff,4))       //读取管理卡密码
00096F 120709            LCALL    ?L?COM0014
000972 7D04              MOV      R5,#04H
000974 B1D2              ACALL    _hwa_mifareReadBlock
000976 505A              JNC      ?C0023?APP_BRUSH
  144:             {
  145:                 memcpy(&s_System, gBuff, 16);
000978 78C0              MOV      R0,#LOW s_System
00097A 7C00              MOV      R4,#HIGH s_System
00097C 7D01              MOV      R5,#01H
00097E 120709            LCALL    ?L?COM0014
000981 121AE6            LCALL    ?L?COM0044
  146:                 s_System.Money = 0;
000984 E4                CLR      A
000985 9000D1            MOV      DPTR,#s_System+011H
000988 F0                MOVX     @DPTR,A
000989 120707            LCALL    ?L?COM0012
00098C 7D05              MOV      R5,#05H
00098E B1D2              ACALL    _hwa_mifareReadBlock
000990 5040              JNC      ?C0023?APP_BRUSH
  147: 
  148: 	            if (hwa_mifareReadBlock(gBuff, 5))			//读取管理卡和用户卡密码以及扇区
  149: 	            {
  150: 	                if(gBuff[0] == 0x01)
000992 9000D8            MOV      DPTR,#gBuff
000995 E0                MOVX     A,@DPTR
000996 B40108            CJNE     A,#01H,?C0028?APP_BRUSH
  151: 	                {
  152: 	                    s_System.RecoveryOldCard = 1;
000999 9000D0            MOV      DPTR,#s_System+010H
00099C 7401              MOV      A,#01H
00099E F0                MOVX     @DPTR,A
  153: 	                }
00099F 8005              SJMP     ?C0030?APP_BRUSH
0009A1         ?C0028?APP_BRUSH:
  154: 	                else
  155: 	                {
  156: 	                    s_System.RecoveryOldCard = 0;
0009A1 E4                CLR      A
0009A2 9000D0            MOV      DPTR,#s_System+010H
0009A5 F0                MOVX     @DPTR,A
  157: 	                }
  158: 	            }
  159: 	            else
  160: 	            {
  161: 	                break;
  162: 	            }
0009A6         ?C0030?APP_BRUSH:
  163:                 app_configWrite(SYSTEM_SETTING_SECTOR);
0009A6 E4                CLR      A
0009A7 FF                MOV      R7,A
0009A8 5113              ACALL    _app_configWrite
  164:                 buzzer_SoundNumber(1);
0009AA 7F01              MOV      R7,#01H
0009AC 12120A            LCALL    _buzzer_SoundNumber
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 23


  165:                 b_FactorySystem = FALSE;
0009AF C20C              CLR      b_FactorySystem
  166:             }
  167:             break;
0009B1 801F              SJMP     ?C0023?APP_BRUSH
  168:             
  169:         case USER_CARD:
0009B3         ?C0031?APP_BRUSH:
  170:             
  171:             if(hwa_mifareReadSector(gBuff, s_System.Sector))
0009B3 120709            LCALL    ?L?COM0014
0009B6 B1FE              ACALL    ?L?COM004E
0009B8 5018              JNC      ?C0023?APP_BRUSH
  172:             {
  173:                 led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
0009BA 121290            LCALL    ?L?COM0002
0009BD C006              PUSH     AR6
0009BF C007              PUSH     AR7
0009C1 1212A6            LCALL    ?L?COM0022
0009C4 D007              POP      AR7
0009C6 D006              POP      AR6
0009C8 7B08              MOV      R3,#08H
0009CA 115A              ACALL    _led_ShowNumber
  174:                 u8_FirstBrushCardDly = 3;
0009CC 9000F0            MOV      DPTR,#u8_FirstBrushCardDly
0009CF 7403              MOV      A,#03H
0009D1 F0                MOVX     @DPTR,A
  175:             }
  176:             break;
  177: //            pMoney->money = 1000;
  178: //            hwa_mifareWriteSector(gBuff, s_System.Sector);
  179: //            break;
  180: //            if(hwa_mifareReadSector(gBuff, s_System.Sector))
  181: //            {
  182: //                if(b_SettingChange == FALSE)
  183: //                {
  184: //                    led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
  185: //                    u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
  186: //                    buzzer_SoundNumber(1);
  187: //                }
  188: //                else
  189: //                {
  190: //                    if ((pMoney->money+s_System.Money <= 20000
  191: //                        && memcmp(LastCardId, gCard_UID, 5))
  192: //                        || s_System.Money == 0)
  193: //                    {
  194: //                        if(s_System.Money == 0)
  195: //                        {
  196: //                            pMoney->money = 0;
  197: //                            if(hwa_mifareWriteSector(gBuff, s_System.Sector))
  198: //                            {
  199: //                                buzzer_SoundNumber(1);
  200: //                                led_ShowNumber1(pMoney->money/100, u8_BrushNum, 0);
  201: //                                u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
  202: //                                break;
  203: //                            }
  204: //                            else
  205: //                            {
  206: //                                buzzer_SoundNumber(2);
  207: //                            }
  208: //                        }
  209: //                        else
  210: //                        {
  211: //                            pMoney->money += s_System.Money;
  212: //                            if(hwa_mifareWriteSector(gBuff, s_System.Sector))
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 24


  213: //                            {
  214: //                                MoneySum += s_System.Money/100;
  215: //                                u8_BrushNum++;
  216: //                                app_configWrite(MONEY_SECTOR);
  217: //                                led_ShowNumber1(pMoney->money/100, u8_BrushNum, 0);
  218: //                                u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
  219: //                                buzzer_SoundNumber(1);
  220: //                            }
  221: //                        }
  222: //                    }
  223: //                    else if(pMoney->money+s_System.Money > 20000)
  224: //                    {
  225: //                        buzzer_SoundNumber(2);
  226: //                    }
  227: //                }
  228: //                memcpy(LastCardId, gCard_UID, 5);
  229: //            }
  230:             break;
  231:             
  232:         default:
  233:             break;
  234:     }
0009D2         ?C0023?APP_BRUSH:
  235:     
  236:     if(u8_FirstBrushCardDly)
0009D2 9000F0            MOV      DPTR,#u8_FirstBrushCardDly
0009D5 E0                MOVX     A,@DPTR
0009D6 6003              JZ       ?C0034?APP_BRUSH
  237:     {
  238:         u8_FirstBrushCardDly--;
0009D8 14                DEC      A
0009D9 F0                MOVX     @DPTR,A
  239:     }
0009DA 22                RET      
0009DB         ?C0034?APP_BRUSH:
  240:     else if(!b_FactorySystem)
0009DB 200C1A            JB       b_FactorySystem,?C0039?APP_BRUSH
  241:     {
  242:         if(b_SettingChange)
0009DE 300B14            JNB      b_SettingChange,?C0037?APP_BRUSH
  243:         {
  244:             led_ShowNumber1(s_System.Money/100, u8_BrushNum, 0);
0009E1 9000D1            MOV      DPTR,#s_System+011H
0009E4 315A              ACALL    ?L?COM002E
0009E6 1201A8            LCALL    ?C?UIDIV
0009E9 9000EE            MOV      DPTR,#u8_BrushNum
0009EC E0                MOVX     A,@DPTR
0009ED FC                MOV      R4,A
0009EE A3                INC      DPTR
0009EF E0                MOVX     A,@DPTR
0009F0 FD                MOV      R5,A
0009F1 E4                CLR      A
0009F2 FB                MOV      R3,A
0009F3 01CF              AJMP     _led_ShowNumber1
  245:         }
0009F5         ?C0037?APP_BRUSH:
  246:         else
  247:         {
  248:             gLedBuf[0] = 12;
0009F5 121A9C            LCALL    ?L?COM0026
  249:             gLedBuf[1] = 15;
  250:             gLedBuf[2] = 15;
  251:             gLedBuf[3] = 15;
  252:             gLedBuf[4] = 15;
  253:             gLedBuf[5] = 12;
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 25


  254:             gShowDot = 0;
  255:         }
  256:     }
  257: }
0009F8         ?C0039?APP_BRUSH:
0009F8 22                RET      
----- FUNCTION app_brushCycle1s (END) -------


----- FUNCTION ?L?COM005B (BEGIN) -----
0009F9 7403              MOV      A,#03H
0009FB F0                MOVX     @DPTR,A
0009FC A3                INC      DPTR
0009FD 74E7              MOV      A,#0E7H
0009FF F0                MOVX     @DPTR,A
000A00 22                RET      
----- FUNCTION ?L?COM005B (END) -------


----- FUNCTION ?L?COM0050 (BEGIN) -----
000A01 900048            MOV      DPTR,#L_num
000A04 E0                MOVX     A,@DPTR
000A05 FE                MOV      R6,A
000A06 A3                INC      DPTR
000A07 E0                MOVX     A,@DPTR
000A08 FF                MOV      R7,A
000A09 22                RET      
----- FUNCTION ?L?COM0050 (END) -------


----- FUNCTION ?L?COM0051 (BEGIN) -----
000A0A 75F00A            MOV      B,#0AH
000A0D 84                DIV      AB
000A0E A3                INC      DPTR
000A0F E5F0              MOV      A,B
000A11 F0                MOVX     @DPTR,A
000A12 22                RET      
----- FUNCTION ?L?COM0051 (END) -------


----- FUNCTION _app_configWrite (BEGIN) -----
 FILE: 'App\app_config.c'
   99: void app_configWrite(UINT8 Sector)
  100: {
000A13 900047            MOV      DPTR,#Sector
000A16 EF                MOV      A,R7
000A17 F0                MOVX     @DPTR,A
  101:     led_Switch(OFF);
  102:     if(Sector == SYSTEM_SETTING_SECTOR)
000A18 C201              CLR      ?led_Switch?BIT
000A1A 5135              ACALL    led_Switch
  103:     {
000A1C 900047            MOV      DPTR,#Sector
000A1F E0                MOVX     A,@DPTR
000A20 7B01              MOV      R3,#01H
000A22 7007              JNZ      ?C0012?APP_CONFIG
  104:         hwa_eepromWriteSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
  105:     }
000A24 7A00              MOV      R2,#HIGH s_System
000A26 79C0              MOV      R1,#LOW s_System
000A28 FD                MOV      R5,A
  106:     else
000A29 8006              SJMP     ?C0017?APP_CONFIG
000A2B         ?C0012?APP_CONFIG:
  107:     {
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 26


  108:         hwa_eepromWriteSector((UINT8*)&MoneySum, MONEY_SECTOR);
000A2B 7A00              MOV      R2,#HIGH MoneySum
000A2D 79BC              MOV      R1,#LOW MoneySum
000A2F 7D01              MOV      R5,#01H
000A31         
000A31 9134              ACALL    _hwa_eepromWriteSector
  109:     }
000A33         ?C0013?APP_CONFIG:
  110:     led_Switch(ON);
000A33 D201              SETB     ?led_Switch?BIT
;----                  JMP      led_Switch
----- FUNCTION _app_configWrite (END) -------


----- FUNCTION led_Switch (BEGIN) -----
 FILE: 'Driver\LED.c'
  152: void led_Switch(bit sw)
  153: {
  154:     ledsw = sw;
  155:     if(ledsw==0)
000A35 A201              MOV      C,sw
000A37 920D              MOV      ledsw,C
  156:     {
000A39 200D03            JB       ledsw,?C0044?LED
  157:     	LED_CS0 = 1;
  158:     	LED_CS1 = 1;
000A3C 121957            LCALL    ?L?COM003D
  159:     	LED_CS2 = 1;
  160:     	LED_CS3 = 1;
  161:     	LED_CS4 = 1;
  162:     	LED_CS5 = 1;
  163:     }
  164: }
000A3F         ?C0044?LED:
000A3F 22                RET      
----- FUNCTION led_Switch (END) -------


----- FUNCTION app_configInit (BEGIN) -----
 FILE: 'App\app_config.c'
   47: void app_configInit(void)
   48: {
   49:     BOOL state = FALSE;
   50:     led_Switch(OFF);
000A40 C200              CLR      state
   51:     hwa_eepromInit();
000A42 C201              CLR      ?led_Switch?BIT
000A44 5135              ACALL    led_Switch
   52:     if(app_configRead(SYSTEM_SETTING_SECTOR) == FALSE)
000A46 120009            LCALL    hwa_eepromInit
   53:     {
000A49 E4                CLR      A
000A4A FF                MOV      R7,A
000A4B 51D3              ACALL    _app_configRead
000A4D 4021              JC       ?C0001?APP_CONFIG
   54:         memcpy(&s_System, &s_FactorySystem, sizeof(s_System));
   55:         b_FactorySystem = TRUE;
000A4F 78C0              MOV      R0,#LOW s_System
000A51 7C00              MOV      R4,#HIGH s_System
000A53 7D01              MOV      R5,#01H
000A55 7BFF              MOV      R3,#0FFH
000A57 7A04              MOV      R2,#HIGH s_FactorySystem
000A59 79B0              MOV      R1,#LOW s_FactorySystem
000A5B 7E00              MOV      R6,#00H
000A5D 7F13              MOV      R7,#013H
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 27


000A5F 1200F6            LCALL    ?C?COPY
   56:         led_ShowNumber(8888,88,0xFF);
000A62 D20C              SETB     b_FactorySystem
   57:     }
000A64 7BFF              MOV      R3,#0FFH
000A66 7D58              MOV      R5,#058H
000A68 7FB8              MOV      R7,#0B8H
000A6A 7E22              MOV      R6,#022H
000A6C 115A              ACALL    _led_ShowNumber
   58:     else
000A6E 8046              SJMP     ?C0002?APP_CONFIG
000A70         ?C0001?APP_CONFIG:
   59:     {
   60:         if(s_System.Sector > 16 || s_System.Sector < 1)                 //钱包分区不在1~16
000A70 9000C6            MOV      DPTR,#s_System+06H
000A73 E0                MOVX     A,@DPTR
000A74 FF                MOV      R7,A
000A75 D3                SETB     C
000A76 9410              SUBB     A,#010H
000A78 5006              JNC      ?C0004?APP_CONFIG
000A7A EF                MOV      A,R7
000A7B C3                CLR      C
000A7C 9401              SUBB     A,#01H
000A7E 500B              JNC      ?C0003?APP_CONFIG
000A80         ?C0004?APP_CONFIG:
   61:         {
   62:             s_System.Sector = s_FactorySystem.Sector;
000A80 9004B6            MOV      DPTR,#s_FactorySystem+06H
000A83 E4                CLR      A
000A84 93                MOVC     A,@A+DPTR
000A85 9000C6            MOV      DPTR,#s_System+06H
000A88 F0                MOVX     @DPTR,A
   63:             state = TRUE;
000A89 D200              SETB     state
   64:         }
000A8B         ?C0003?APP_CONFIG:
   65:         if(s_System.Money > 20000)                                        //金额大于200
000A8B D3                SETB     C
000A8C 9000D2            MOV      DPTR,#s_System+012H
000A8F E0                MOVX     A,@DPTR
000A90 9420              SUBB     A,#020H
000A92 9000D1            MOV      DPTR,#s_System+011H
000A95 E0                MOVX     A,@DPTR
000A96 944E              SUBB     A,#04EH
000A98 4013              JC       ?C0005?APP_CONFIG
   66:         {
   67:             s_System.Money = s_FactorySystem.Money;
000A9A 9004C1            MOV      DPTR,#s_FactorySystem+011H
000A9D E4                CLR      A
000A9E 93                MOVC     A,@A+DPTR
000A9F FF                MOV      R7,A
000AA0 7401              MOV      A,#01H
000AA2 93                MOVC     A,@A+DPTR
000AA3 9000D1            MOV      DPTR,#s_System+011H
000AA6 CF                XCH      A,R7
000AA7 F0                MOVX     @DPTR,A
000AA8 A3                INC      DPTR
000AA9 EF                MOV      A,R7
000AAA F0                MOVX     @DPTR,A
   68:             state = TRUE;
000AAB D200              SETB     state
   69:         }
000AAD         ?C0005?APP_CONFIG:
   70:         if(state)
000AAD 300006            JNB      state,?C0002?APP_CONFIG
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 28


   71:         {
   72: 			app_configWrite(SYSTEM_SETTING_SECTOR);
000AB0 E4                CLR      A
000AB1 FF                MOV      R7,A
000AB2 5113              ACALL    _app_configWrite
   73:             b_FactorySystem = TRUE;
000AB4 D20C              SETB     b_FactorySystem
   74:         }
   75:     }
000AB6         ?C0002?APP_CONFIG:
   76:     
   77:     if(app_configRead(MONEY_SECTOR) == FALSE)
000AB6 7F01              MOV      R7,#01H
000AB8 51D3              ACALL    _app_configRead
000ABA 4013              JC       ?C0007?APP_CONFIG
   78:     {
   79:         memset(&MoneySum, 0x00, sizeof(MoneySum));
000ABC 7E00              MOV      R6,#00H
000ABE 7F04              MOV      R7,#04H
000AC0 7D00              MOV      R5,#00H
000AC2 7B01              MOV      R3,#01H
000AC4 7A00              MOV      R2,#HIGH MoneySum
000AC6 79BC              MOV      R1,#LOW MoneySum
000AC8 120363            LCALL    ?C?MEMSET
   80: 		app_configWrite(MONEY_SECTOR);
000ACB 7F01              MOV      R7,#01H
000ACD 5113              ACALL    _app_configWrite
   81:     }
000ACF         ?C0007?APP_CONFIG:
   82:     led_Switch(ON);
000ACF D201              SETB     ?led_Switch?BIT
000AD1 4135              AJMP     led_Switch
----- FUNCTION app_configInit (END) -------


----- FUNCTION _app_configRead (BEGIN) -----
 FILE: 'App\app_config.c'
   85: BOOL app_configRead(UINT8 Sector)
   86: {
;---- Variable 'Sector' assigned to Register 'R7' ----
   87:     BOOL state;
   88:     if(Sector == SYSTEM_SETTING_SECTOR)
000AD3 EF                MOV      A,R7
000AD4 7B01              MOV      R3,#01H
000AD6 7007              JNZ      ?C0009?APP_CONFIG
   89:     {
   90:         state = hwa_eepromReadSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
000AD8 7A00              MOV      R2,#HIGH s_System
000ADA 79C0              MOV      R1,#LOW s_System
000ADC FD                MOV      R5,A
   91:     }
000ADD 8006              SJMP     ?C0016?APP_CONFIG
000ADF         ?C0009?APP_CONFIG:
   92:     else
   93:     {
   94:         state = hwa_eepromReadSector((UINT8*)&MoneySum, MONEY_SECTOR);
000ADF 7A00              MOV      R2,#HIGH MoneySum
000AE1 79BC              MOV      R1,#LOW MoneySum
000AE3 7D01              MOV      R5,#01H
000AE5         
000AE5 51EC              ACALL    _hwa_eepromReadSector
000AE7 9201              MOV      state,C
   95:     }
000AE9         ?C0010?APP_CONFIG:
   96:     return state;
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 29


000AE9 A201              MOV      C,state
   97: }
000AEB 22                RET      
----- FUNCTION _app_configRead (END) -------


----- FUNCTION _hwa_eepromReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   33: BOOL hwa_eepromReadSector(UINT8 *dat, UINT8 sector)
   34: {
000AEC 900056            MOV      DPTR,#dat
000AEF B1C9              ACALL    ?L?COM0004
000AF1 A3                INC      DPTR
000AF2 ED                MOV      A,R5
000AF3 F0                MOVX     @DPTR,A
   35:     BOOL e2_error = FALSE, e2_bak_error = FALSE;
   36:     UINT16 e2_addr, e2_bak_addr;
000AF4 C202              CLR      e2_error
000AF6 C203              CLR      e2_bak_error
   37:     UINT16 e2_check_sum, e2_bak_check_sum;
   38:     UINT16 Size, SectorSize;
   39: 
   40:     if(sector >= c_u8_eepromSectorNum)
000AF8 121B02            LCALL    ?L?COM004D
000AFB 4001              JC       ?C0010?HWA_EEPROM
   41:     {
   42:     	return FALSE;
000AFD 22                RET      
   43:     }
000AFE         ?C0010?HWA_EEPROM:
   44: 	Size = c_s_eepromConfig[sector].UseSize;
000AFE 900059            MOV      DPTR,#sector
000B01 121AB6            LCALL    ?L?COM002C
000B04 900062            MOV      DPTR,#Size
000B07 B131              ACALL    ?L?COM000E
000B09 3A                ADDC     A,R2
000B0A 90005A            MOV      DPTR,#e2_addr
000B0D 121B1D            LCALL    ?L?COM005F
000B10 B158              ACALL    ?L?COM000F
000B12 3A                ADDC     A,R2
000B13 90005C            MOV      DPTR,#e2_bak_addr
000B16 F0                MOVX     @DPTR,A
000B17 A3                INC      DPTR
000B18 CE                XCH      A,R6
000B19 F0                MOVX     @DPTR,A
   45:     SectorSize = Size+2;
   46:     
   47:     e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
   48:     e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
   49: 
   50:     sys_eepromRead(e2_addr, e2_data, SectorSize);
000B1A 9116              ACALL    ?L?COM0019
000B1C 900064            MOV      DPTR,#SectorSize
000B1F 91DD              ACALL    ?L?COM0011
000B21 B17B              ACALL    ?L?COM0015
000B23 6006              JZ       ?C0012?HWA_EEPROM
   51: 	if (c_s_eepromConfig[sector].Encrypt)
   52: 	{
   53: 		hwa_eepromDecrypt(e2_data, Size);
000B25 911E              ACALL    ?L?COM001A
000B27 912B              ACALL    ?L?COM0021
000B29 D1AD              ACALL    _hwa_eepromDecrypt
   54: 	}
000B2B         ?C0012?HWA_EEPROM:
   55:     e2_check_sum = e2_data[Size] << 8 | e2_data[Size + 1];
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 30


000B2B 912B              ACALL    ?L?COM0021
000B2D 2400              ADD      A,#LOW e2_data
000B2F F582              MOV      DPL,A
000B31 7400              MOV      A,#HIGH e2_data
000B33 3C                ADDC     A,R4
000B34 F583              MOV      DPH,A
000B36 E0                MOVX     A,@DPTR
000B37 FE                MOV      R6,A
000B38 7401              MOV      A,#LOW e2_data+01H
000B3A 2D                ADD      A,R5
000B3B F582              MOV      DPL,A
000B3D 7400              MOV      A,#HIGH e2_data+01H
000B3F 121B25            LCALL    ?L?COM0060
000B42 90005E            MOV      DPTR,#e2_check_sum
000B45 EE                MOV      A,R6
000B46 F0                MOVX     @DPTR,A
000B47 A3                INC      DPTR
000B48 EF                MOV      A,R7
000B49 F0                MOVX     @DPTR,A
   56: 
   57: 	sys_eepromRead(e2_bak_addr, e2_data_bak, SectorSize);
000B4A B16C              ACALL    ?L?COM0033
000B4C 900064            MOV      DPTR,#SectorSize
000B4F 91DD              ACALL    ?L?COM0011
000B51 B17B              ACALL    ?L?COM0015
000B53 6004              JZ       ?C0013?HWA_EEPROM
   58: 	if (c_s_eepromConfig[sector].Encrypt)
   59: 	{
   60: 		hwa_eepromDecrypt(e2_data_bak, Size);
000B55 9125              ACALL    ?L?COM0020
000B57 D1AD              ACALL    _hwa_eepromDecrypt
   61: 	}
000B59         ?C0013?HWA_EEPROM:
   62:     e2_bak_check_sum = e2_data_bak[Size] << 8 | e2_data_bak[Size + 1];
000B59 912B              ACALL    ?L?COM0021
000B5B 2420              ADD      A,#LOW e2_data_bak
000B5D F582              MOV      DPL,A
000B5F 7400              MOV      A,#HIGH e2_data_bak
000B61 3C                ADDC     A,R4
000B62 F583              MOV      DPH,A
000B64 E0                MOVX     A,@DPTR
000B65 FE                MOV      R6,A
000B66 7421              MOV      A,#LOW e2_data_bak+01H
000B68 2D                ADD      A,R5
000B69 F582              MOV      DPL,A
000B6B 7400              MOV      A,#HIGH e2_data_bak+01H
000B6D 121B25            LCALL    ?L?COM0060
000B70 900060            MOV      DPTR,#e2_bak_check_sum
000B73 EE                MOV      A,R6
000B74 F0                MOVX     @DPTR,A
000B75 A3                INC      DPTR
000B76 EF                MOV      A,R7
000B77 F0                MOVX     @DPTR,A
   63: 
   64:     if(e2_check_sum != hwa_eepromCheck(e2_data, Size))
000B78 911E              ACALL    ?L?COM001A
000B7A A3                INC      DPTR
000B7B A3                INC      DPTR
000B7C E0                MOVX     A,@DPTR
000B7D FD                MOV      R5,A
000B7E D1DE              ACALL    _hwa_eepromCheck
000B80 90005E            MOV      DPTR,#e2_check_sum
000B83 E0                MOVX     A,@DPTR
000B84 6E                XRL      A,R6
000B85 7003              JNZ      ?C0025?HWA_EEPROM
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 31


000B87 A3                INC      DPTR
000B88 E0                MOVX     A,@DPTR
000B89 6F                XRL      A,R7
000B8A         ?C0025?HWA_EEPROM:
000B8A 6002              JZ       ?C0014?HWA_EEPROM
   65:     {
   66:         e2_error = TRUE;
000B8C D202              SETB     e2_error
   67:     }
000B8E         ?C0014?HWA_EEPROM:
   68:     if(e2_bak_check_sum != hwa_eepromCheck(e2_data_bak, Size))
000B8E 9125              ACALL    ?L?COM0020
000B90 D1DE              ACALL    _hwa_eepromCheck
000B92 900060            MOV      DPTR,#e2_bak_check_sum
000B95 E0                MOVX     A,@DPTR
000B96 6E                XRL      A,R6
000B97 7003              JNZ      ?C0026?HWA_EEPROM
000B99 A3                INC      DPTR
000B9A E0                MOVX     A,@DPTR
000B9B 6F                XRL      A,R7
000B9C         ?C0026?HWA_EEPROM:
000B9C 6002              JZ       ?C0015?HWA_EEPROM
   69:     {
   70:         e2_bak_error = TRUE;
000B9E D203              SETB     e2_bak_error
   71:     }
000BA0         ?C0015?HWA_EEPROM:
   72: 
   73:     if(e2_error && e2_bak_error)    //~1~备份块和正常块都校验错误，返回错误
000BA0 300205            JNB      e2_error,?C0016?HWA_EEPROM
000BA3 300302            JNB      e2_bak_error,?C0016?HWA_EEPROM
   74:     {
   75:         return FALSE;
000BA6 C3                CLR      C
000BA7 22                RET      
   76:     }
000BA8         ?C0016?HWA_EEPROM:
   77:     else if(e2_error)                                 //~2~备份块校验错误，恢复正常块
000BA8 300214            JNB      e2_error,?C0018?HWA_EEPROM
   78:     {
   79:         memcpy(e2_data, e2_data_bak, SectorSize);
000BAB 900064            MOV      DPTR,#SectorSize
000BAE 121AED            LCALL    ?L?COM0045
000BB1 B174              ACALL    ?L?COM0034
000BB3 1200F6            LCALL    ?C?COPY
   80: 		sys_eepromEraseSector(e2_addr);
000BB6 90005A            MOV      DPTR,#e2_addr
000BB9 91EA              ACALL    ?L?COM0032
   81:         sys_eepromWrite(e2_addr, e2_data, SectorSize);
000BBB 9116              ACALL    ?L?COM0019
   82:     }
000BBD 8037              SJMP     ?C0028?HWA_EEPROM
000BBF         ?C0018?HWA_EEPROM:
   83:     else if(e2_bak_error ||                          //~3~正常块校验错误，恢复备份块
000BBF 20031A            JB       e2_bak_error,?C0021?HWA_EEPROM
000BC2 200238            JB       e2_error,?C0017?HWA_EEPROM
000BC5 200335            JB       e2_bak_error,?C0017?HWA_EEPROM
000BC8 900060            MOV      DPTR,#e2_bak_check_sum
000BCB E0                MOVX     A,@DPTR
000BCC FE                MOV      R6,A
000BCD A3                INC      DPTR
000BCE E0                MOVX     A,@DPTR
000BCF FF                MOV      R7,A
000BD0 90005E            MOV      DPTR,#e2_check_sum
000BD3 E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 32


000BD4 6E                XRL      A,R6
000BD5 7003              JNZ      ?C0027?HWA_EEPROM
000BD7 A3                INC      DPTR
000BD8 E0                MOVX     A,@DPTR
000BD9 6F                XRL      A,R7
000BDA         ?C0027?HWA_EEPROM:
000BDA 6021              JZ       ?C0017?HWA_EEPROM
000BDC         ?C0021?HWA_EEPROM:
   84:             (e2_error == FALSE                                //~4~正常块、备份块都检验正确，但数据不同，则以
   85:              && e2_bak_error == FALSE                         //   最新写入的正常块覆盖备份块
   86:              && e2_check_sum != e2_bak_check_sum)
   87:     )
   88:     {
   89:         memcpy(e2_data_bak, e2_data, SectorSize);
000BDC 900064            MOV      DPTR,#SectorSize
000BDF E0                MOVX     A,@DPTR
000BE0 FE                MOV      R6,A
000BE1 A3                INC      DPTR
000BE2 E0                MOVX     A,@DPTR
000BE3 FF                MOV      R7,A
000BE4 7820              MOV      R0,#LOW e2_data_bak
000BE6 7C00              MOV      R4,#HIGH e2_data_bak
000BE8 7D01              MOV      R5,#01H
000BEA 911E              ACALL    ?L?COM001A
000BEC 1200F6            LCALL    ?C?COPY
   90: 		sys_eepromEraseSector(e2_bak_addr);
000BEF 90005C            MOV      DPTR,#e2_bak_addr
000BF2 91EA              ACALL    ?L?COM0032
   91:         sys_eepromWrite(e2_bak_addr, e2_data_bak, SectorSize);
000BF4 B16C              ACALL    ?L?COM0033
000BF6         
000BF6 900064            MOV      DPTR,#SectorSize
000BF9 91DD              ACALL    ?L?COM0011
000BFB B109              ACALL    _sys_eepromWrite
   92:     }
000BFD         ?C0017?HWA_EEPROM:
   93:     memcpy(dat, e2_data, Size);
000BFD 900062            MOV      DPTR,#Size
000C00 E0                MOVX     A,@DPTR
000C01 FE                MOV      R6,A
000C02 A3                INC      DPTR
000C03 E0                MOVX     A,@DPTR
000C04 FF                MOV      R7,A
000C05 900056            MOV      DPTR,#dat
000C08 B164              ACALL    ?L?COM0008
000C0A F8                MOV      R0,A
000C0B AC02              MOV      R4,AR2
000C0D AD03              MOV      R5,AR3
000C0F 911E              ACALL    ?L?COM001A
000C11 1200F6            LCALL    ?C?COPY
   94:     return TRUE;
000C14 D3                SETB     C
   95: }
000C15 22                RET      
----- FUNCTION _hwa_eepromReadSector (END) -------


----- FUNCTION ?L?COM0019 (BEGIN) -----
000C16 90005A            MOV      DPTR,#e2_addr
000C19 E0                MOVX     A,@DPTR
000C1A FE                MOV      R6,A
000C1B A3                INC      DPTR
000C1C E0                MOVX     A,@DPTR
000C1D FF                MOV      R7,A
000C1E         ?L?COM001A:
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 33


000C1E 7B01              MOV      R3,#01H
000C20 7A00              MOV      R2,#HIGH e2_data
000C22 7900              MOV      R1,#LOW e2_data
000C24 22                RET      
----- FUNCTION ?L?COM0019 (END) -------


----- FUNCTION ?L?COM0020 (BEGIN) -----
000C25 7B01              MOV      R3,#01H
000C27 7A00              MOV      R2,#HIGH e2_data_bak
000C29 7920              MOV      R1,#LOW e2_data_bak
000C2B         ?L?COM0021:
000C2B 900062            MOV      DPTR,#Size
000C2E E0                MOVX     A,@DPTR
000C2F FC                MOV      R4,A
000C30 A3                INC      DPTR
000C31 E0                MOVX     A,@DPTR
000C32 FD                MOV      R5,A
000C33 22                RET      
----- FUNCTION ?L?COM0020 (END) -------


----- FUNCTION _hwa_eepromWriteSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   97: BOOL hwa_eepromWriteSector(UINT8 *dat, UINT8 sector)
   98: {
000C34 B1C6              ACALL    ?L?COM0003
000C36 A3                INC      DPTR
000C37 ED                MOV      A,R5
000C38 F0                MOVX     @DPTR,A
   99:     UINT16 e2_addr, e2_bak_addr;
  100:     UINT16 e2_check_sum;
  101:     
  102:     UINT16 Size, SectorSize;
  103:     
  104:     if(sector >= c_u8_eepromSectorNum)
000C39 121B02            LCALL    ?L?COM004D
000C3C 4001              JC       ?C0022?HWA_EEPROM
  105:     {
  106:     	return FALSE;
000C3E 22                RET      
  107:     }
000C3F         ?C0022?HWA_EEPROM:
  108: 	Size = c_s_eepromConfig[sector].UseSize;
000C3F 90004B            MOV      DPTR,#sector
000C42 121AB6            LCALL    ?L?COM002C
000C45 900052            MOV      DPTR,#Size
000C48 B131              ACALL    ?L?COM000E
000C4A 3A                ADDC     A,R2
000C4B 90004C            MOV      DPTR,#e2_addr
000C4E 121B1D            LCALL    ?L?COM005F
000C51 B158              ACALL    ?L?COM000F
000C53 3A                ADDC     A,R2
000C54 90004E            MOV      DPTR,#e2_bak_addr
000C57 F0                MOVX     @DPTR,A
000C58 A3                INC      DPTR
000C59 CE                XCH      A,R6
000C5A B160              ACALL    ?L?COM0006
000C5C F9                MOV      R1,A
000C5D 121B0C            LCALL    ?L?COM0054
000C60 D1DE              ACALL    _hwa_eepromCheck
000C62 900050            MOV      DPTR,#e2_check_sum
000C65 EE                MOV      A,R6
000C66 F0                MOVX     @DPTR,A
000C67 A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 34


000C68 EF                MOV      A,R7
000C69 F0                MOVX     @DPTR,A
  109:     SectorSize = Size+2;
  110: 
  111:     e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
  112:     e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
  113:     e2_check_sum = hwa_eepromCheck(dat, Size);
  114: 
  115:     hwa_eepromReadSector(e2_data, sector);                                  //  写入之前，如果有错误块，先恢复
000C6A 911E              ACALL    ?L?COM001A
000C6C 90004B            MOV      DPTR,#sector
000C6F E0                MOVX     A,@DPTR
000C70 FD                MOV      R5,A
000C71 51EC              ACALL    _hwa_eepromReadSector
  116: 
  117:     memcpy(e2_data, dat, Size);
000C73 900052            MOV      DPTR,#Size
000C76 121AED            LCALL    ?L?COM0045
000C79 B161              ACALL    ?L?COM0007
000C7B F9                MOV      R1,A
000C7C 1200F6            LCALL    ?C?COPY
  118: 
  119: 	if (c_s_eepromConfig[sector].Encrypt)
000C7F 90004B            MOV      DPTR,#sector
000C82 B180              ACALL    ?L?COM0016
000C84 6008              JZ       ?C0024?HWA_EEPROM
  120: 	{
  121: 		hwa_eepromEncrypt(e2_data, Size);
000C86 911E              ACALL    ?L?COM001A
000C88 121B0C            LCALL    ?L?COM0054
000C8B 12160D            LCALL    _hwa_eepromEncrypt
  122: 	}
000C8E         ?C0024?HWA_EEPROM:
  123:     e2_data[Size] = (UINT8)(e2_check_sum >> 8);
000C8E 900050            MOV      DPTR,#e2_check_sum
000C91 E0                MOVX     A,@DPTR
000C92 FC                MOV      R4,A
000C93 A3                INC      DPTR
000C94 E0                MOVX     A,@DPTR
000C95 FD                MOV      R5,A
000C96 EC                MOV      A,R4
000C97 FF                MOV      R7,A
000C98 A3                INC      DPTR
000C99 E0                MOVX     A,@DPTR
000C9A FA                MOV      R2,A
000C9B A3                INC      DPTR
000C9C E0                MOVX     A,@DPTR
000C9D FB                MOV      R3,A
000C9E 2400              ADD      A,#LOW e2_data
000CA0 F582              MOV      DPL,A
000CA2 7400              MOV      A,#HIGH e2_data
000CA4 3A                ADDC     A,R2
000CA5 F583              MOV      DPH,A
000CA7 EF                MOV      A,R7
000CA8 F0                MOVX     @DPTR,A
  124:     e2_data[Size + 1] = (UINT8)(e2_check_sum&0xFF);
000CA9 7401              MOV      A,#LOW e2_data+01H
000CAB 2B                ADD      A,R3
000CAC F582              MOV      DPL,A
000CAE 7400              MOV      A,#HIGH e2_data+01H
000CB0 3A                ADDC     A,R2
000CB1 F583              MOV      DPH,A
000CB3 ED                MOV      A,R5
000CB4 F0                MOVX     @DPTR,A
  125: 	sys_eepromEraseSector(e2_addr);
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 35


000CB5 90004C            MOV      DPTR,#e2_addr
000CB8 91EA              ACALL    ?L?COM0032
  126:     sys_eepromWrite(e2_addr, e2_data, SectorSize);
000CBA 90004C            MOV      DPTR,#e2_addr
000CBD 91CF              ACALL    ?L?COM0010
000CBF B109              ACALL    _sys_eepromWrite
  127: 	
  128: //    memcpy(e2_data_bak, e2_data, SectorSize);
  129: 	sys_eepromEraseSector(e2_bak_addr);
000CC1 90004E            MOV      DPTR,#e2_bak_addr
000CC4 91EA              ACALL    ?L?COM0032
  130: 	sys_eepromWrite(e2_bak_addr, e2_data, SectorSize);
000CC6 90004E            MOV      DPTR,#e2_bak_addr
000CC9 91CF              ACALL    ?L?COM0010
000CCB B109              ACALL    _sys_eepromWrite
  131:     return TRUE;
000CCD D3                SETB     C
  132: }
000CCE 22                RET      
----- FUNCTION _hwa_eepromWriteSector (END) -------


----- FUNCTION ?L?COM0010 (BEGIN) -----
000CCF E0                MOVX     A,@DPTR
000CD0 FE                MOV      R6,A
000CD1 A3                INC      DPTR
000CD2 E0                MOVX     A,@DPTR
000CD3 FF                MOV      R7,A
000CD4 7B01              MOV      R3,#01H
000CD6 7A00              MOV      R2,#HIGH e2_data
000CD8 7900              MOV      R1,#LOW e2_data
000CDA 900054            MOV      DPTR,#SectorSize
000CDD         ?L?COM0011:
000CDD E0                MOVX     A,@DPTR
000CDE FD                MOV      R5,A
000CDF A3                INC      DPTR
000CE0 E0                MOVX     A,@DPTR
000CE1 90006B            MOV      DPTR,#?_sys_eepromWrite?BYTE+05H
000CE4 CD                XCH      A,R5
000CE5 F0                MOVX     @DPTR,A
000CE6 A3                INC      DPTR
000CE7 ED                MOV      A,R5
000CE8 F0                MOVX     @DPTR,A
000CE9 22                RET      
----- FUNCTION ?L?COM0010 (END) -------


----- FUNCTION ?L?COM0032 (BEGIN) -----
000CEA E0                MOVX     A,@DPTR
000CEB FE                MOV      R6,A
000CEC A3                INC      DPTR
000CED E0                MOVX     A,@DPTR
000CEE FF                MOV      R7,A
----- FUNCTION _sys_eepromEraseSector (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   72: void sys_eepromEraseSector(UINT16 addr)
   73: {
;---- Variable 'addr' assigned to Register 'R6/R7' ----
   74:     IAP_CONTR = ENABLE_IAP;         //使能IAP
   75:     IAP_CMD = CMD_ERASE;            //设置IAP命令
000CEF 75C780            MOV      IAP_CONTR,#080H
   76:     IAP_ADDRL = addr;               //设置IAP低地址
000CF2 75C503            MOV      IAP_CMD,#03H
   77:     IAP_ADDRH = addr >> 8;          //设置IAP高地址
000CF5 8FC4              MOV      IAP_ADDRL,R7
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 36


   78:     IAP_TRIG = 0x5a;                //写触发命令(0x5a)
000CF7 EE                MOV      A,R6
000CF8 121AF9            LCALL    ?L?COM0047
   79:     IAP_TRIG = 0xa5;                //写触发命令(0xa5)
   80:     _nop_();                        //等待ISP/IAP/EEPROM操作完成
000CFB 00                NOP      
;----                  JMP      IapIdle
   81:     IapIdle();
----- FUNCTION _sys_eepromEraseSector (END) -------


----- FUNCTION IapIdle (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   24: void IapIdle(void)
   25: {
   26:     IAP_CONTR = 0;                  //关闭IAP功能
   27:     IAP_CMD = 0;                    //清除命令寄存器
000CFC E4                CLR      A
000CFD F5C7              MOV      IAP_CONTR,A
   28:     IAP_TRIG = 0;                   //清除触发寄存器
000CFF F5C5              MOV      IAP_CMD,A
   29:     IAP_ADDRH = 0x80;               //将地址设置到非IAP区域
000D01 F5C6              MOV      IAP_TRIG,A
   30:     IAP_ADDRL = 0;
000D03 75C380            MOV      IAP_ADDRH,#080H
   31: }
000D06 F5C4              MOV      IAP_ADDRL,A
   32: 
000D08 22                RET      
----- FUNCTION IapIdle (END) -------


----- FUNCTION _sys_eepromWrite (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
  100: void sys_eepromWrite(UINT16 addr, UINT8 *Data, UINT16 num)
  101: {
;---- Variable 'Data' assigned to Register 'R1/R2/R3' ----
;---- Variable 'addr' assigned to Register 'R4/R5' ----
000D09 121B2D            LCALL    ?L?COM0061
  102:     IAP_CONTR = ENABLE_IAP;
  103:     IAP_CMD = CMD_PROGRAM;
000D0C 75C502            MOV      IAP_CMD,#02H
000D0F         ?C0006?SYS_EEPROM:
  104:     while(num--)
000D0F 12165E            LCALL    ?L?COM002A
000D12 601B              JZ       ?C0007?SYS_EEPROM
  105:     {
  106:         IAP_ADDRL = addr;
000D14 8DC4              MOV      IAP_ADDRL,R5
  107:         IAP_ADDRH = addr >> 8;
000D16 EC                MOV      A,R4
000D17 F5C3              MOV      IAP_ADDRH,A
  108:         IAP_DATA = *Data;
000D19 12011C            LCALL    ?C?CLDPTR
000D1C F5C2              MOV      IAP_DATA,A
  109:         IAP_TRIG = 0x5a;
000D1E 121AFB            LCALL    ?L?COM0048
  110:         IAP_TRIG = 0xa5;
  111:         addr++;
000D21 0D                INC      R5
000D22 BD0001            CJNE     R5,#00H,?C0010?SYS_EEPROM
000D25 0C                INC      R4
000D26         ?C0010?SYS_EEPROM:
  112:         Data++;
000D26 7401              MOV      A,#01H
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 37


000D28 29                ADD      A,R1
000D29 F9                MOV      R1,A
000D2A E4                CLR      A
000D2B 3A                ADDC     A,R2
000D2C FA                MOV      R2,A
  113:     }
000D2D 80E0              SJMP     ?C0006?SYS_EEPROM
000D2F         ?C0007?SYS_EEPROM:
  114:     IapIdle();
000D2F 80CB              SJMP     IapIdle
----- FUNCTION _sys_eepromWrite (END) -------


----- FUNCTION ?L?COM000E (BEGIN) -----
000D31 EC                MOV      A,R4
000D32 F0                MOVX     @DPTR,A
000D33 A3                INC      DPTR
000D34 ED                MOV      A,R5
000D35 F0                MOVX     @DPTR,A
000D36 2402              ADD      A,#02H
000D38 FE                MOV      R6,A
000D39 E4                CLR      A
000D3A 3C                ADDC     A,R4
000D3B A3                INC      DPTR
000D3C F0                MOVX     @DPTR,A
000D3D A3                INC      DPTR
000D3E CE                XCH      A,R6
000D3F F0                MOVX     @DPTR,A
000D40 EB                MOV      A,R3
000D41 FF                MOV      R7,A
000D42 7E00              MOV      R6,#00H
000D44 9004CA            MOV      DPTR,#c_u16_eepromSectorSize
000D47 E4                CLR      A
000D48 93                MOVC     A,@A+DPTR
000D49 FC                MOV      R4,A
000D4A 7401              MOV      A,#01H
000D4C 93                MOVC     A,@A+DPTR
000D4D FD                MOV      R5,A
000D4E 120196            LCALL    ?C?IMUL
000D51 AA06              MOV      R2,AR6
000D53 AB07              MOV      R3,AR7
000D55 9004CC            MOV      DPTR,#c_u16_eepromSectorAddr
000D58         ?L?COM000F:
000D58 7401              MOV      A,#01H
000D5A 93                MOVC     A,@A+DPTR
000D5B 2B                ADD      A,R3
000D5C FE                MOV      R6,A
000D5D E4                CLR      A
000D5E 93                MOVC     A,@A+DPTR
000D5F 22                RET      
----- FUNCTION ?L?COM000E (END) -------


----- FUNCTION ?L?COM0006 (BEGIN) -----
000D60 F0                MOVX     @DPTR,A
000D61         ?L?COM0007:
000D61 900048            MOV      DPTR,#dat
000D64         ?L?COM0008:
000D64 E0                MOVX     A,@DPTR
000D65 FB                MOV      R3,A
000D66 A3                INC      DPTR
000D67 E0                MOVX     A,@DPTR
000D68 FA                MOV      R2,A
000D69 A3                INC      DPTR
000D6A E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 38


000D6B 22                RET      
----- FUNCTION ?L?COM0006 (END) -------


----- FUNCTION ?L?COM0033 (BEGIN) -----
000D6C 90005C            MOV      DPTR,#e2_bak_addr
000D6F E0                MOVX     A,@DPTR
000D70 FE                MOV      R6,A
000D71 A3                INC      DPTR
000D72 E0                MOVX     A,@DPTR
000D73 FF                MOV      R7,A
000D74         ?L?COM0034:
000D74 7B01              MOV      R3,#01H
000D76 7A00              MOV      R2,#HIGH e2_data_bak
000D78 7920              MOV      R1,#LOW e2_data_bak
000D7A 22                RET      
----- FUNCTION ?L?COM0033 (END) -------


----- FUNCTION ?L?COM0015 (BEGIN) -----
000D7B B192              ACALL    _sys_eepromRead
000D7D 900059            MOV      DPTR,#sector
000D80         ?L?COM0016:
000D80 E0                MOVX     A,@DPTR
000D81 75F003            MOV      B,#03H
000D84 A4                MUL      AB
000D85 24C6              ADD      A,#LOW c_s_eepromConfig+02H
000D87 F582              MOV      DPL,A
000D89 E5F0              MOV      A,B
000D8B 3404              ADDC     A,#HIGH c_s_eepromConfig+02H
000D8D F583              MOV      DPH,A
000D8F E4                CLR      A
000D90 93                MOVC     A,@A+DPTR
000D91 22                RET      
----- FUNCTION ?L?COM0015 (END) -------


----- FUNCTION _sys_eepromRead (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   84: void sys_eepromRead(UINT16 addr, UINT8 *Data, UINT16 num)
   85: {
000D92 900068            MOV      DPTR,#Data
000D95 B1C9              ACALL    ?L?COM0004
;---- Variable 'addr' assigned to Register 'R4/R5' ----
000D97 121B2D            LCALL    ?L?COM0061
   86:     IAP_CONTR = ENABLE_IAP;
   87:     IAP_CMD = CMD_READ;
000D9A 75C501            MOV      IAP_CMD,#01H
000D9D         ?C0003?SYS_EEPROM:
   88:     while(num--)
000D9D 12165E            LCALL    ?L?COM002A
000DA0 6022              JZ       ?C0004?SYS_EEPROM
   89:     {
   90:         IAP_ADDRL = addr;
000DA2 8DC4              MOV      IAP_ADDRL,R5
   91:         IAP_ADDRH = addr >> 8;
000DA4 EC                MOV      A,R4
000DA5 121AF9            LCALL    ?L?COM0047
   92:         IAP_TRIG = 0x5a;
   93:         IAP_TRIG = 0xa5;
   94:         addr++;
000DA8 0D                INC      R5
000DA9 BD0001            CJNE     R5,#00H,?C0009?SYS_EEPROM
000DAC 0C                INC      R4
000DAD         ?C0009?SYS_EEPROM:
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 39


   95:         *Data++ = IAP_DATA;
000DAD 900068            MOV      DPTR,#Data
000DB0 E0                MOVX     A,@DPTR
000DB1 FB                MOV      R3,A
000DB2 A3                INC      DPTR
000DB3 E4                CLR      A
000DB4 75F001            MOV      B,#01H
000DB7 1201FD            LCALL    ?C?ILDIX
000DBA A9F0              MOV      R1,B
000DBC FA                MOV      R2,A
000DBD E5C2              MOV      A,IAP_DATA
000DBF 120162            LCALL    ?C?CSTPTR
   96:     }
000DC2 80D9              SJMP     ?C0003?SYS_EEPROM
000DC4         ?C0004?SYS_EEPROM:
   97:     IapIdle();
000DC4 81FC              AJMP     IapIdle
----- FUNCTION _sys_eepromRead (END) -------


----- FUNCTION ?L?COM0003 (BEGIN) -----
000DC6 900048            MOV      DPTR,#dat
000DC9         ?L?COM0004:
000DC9 EB                MOV      A,R3
000DCA         ?L?COM0005:
000DCA F0                MOVX     @DPTR,A
000DCB A3                INC      DPTR
000DCC EA                MOV      A,R2
000DCD F0                MOVX     @DPTR,A
000DCE A3                INC      DPTR
000DCF E9                MOV      A,R1
000DD0 F0                MOVX     @DPTR,A
000DD1 22                RET      
----- FUNCTION ?L?COM0003 (END) -------


----- FUNCTION _hwa_mifareReadBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   57: BOOL hwa_mifareReadBlock(UINT8 *buff, UINT8 block)
   58: {
000DD2 90004E            MOV      DPTR,#buff
000DD5 B1C9              ACALL    ?L?COM0004
000DD7 A3                INC      DPTR
000DD8 ED                MOV      A,R5
000DD9 F0                MOVX     @DPTR,A
   59: 	UINT8 u8_ReadErrCount;
   60: 	UINT8 u8_Result;
   61: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
000DDA E4                CLR      A
000DDB A3                INC      DPTR
000DDC F0                MOVX     @DPTR,A
000DDD         ?C0018?HWA_MIFARE:
   62: 	{
   63: 		u8_Result = Read_Block(buff, block);
000DDD 90004E            MOV      DPTR,#buff
000DE0 B164              ACALL    ?L?COM0008
000DE2 F9                MOV      R1,A
000DE3 A3                INC      DPTR
000DE4 E0                MOVX     A,@DPTR
000DE5 FD                MOV      R5,A
000DE6 1219C3            LCALL    _Read_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   64: 		if (u8_Result == FM1702_OK)
000DE9 EF                MOV      A,R7
000DEA 7002              JNZ      ?C0021?HWA_MIFARE
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 40


   65: 		{
   66: 			return TRUE;
000DEC D3                SETB     C
000DED 22                RET      
   67: 		}
000DEE         ?C0021?HWA_MIFARE:
   68: 		else if (u8_Result == FM1702_NOTAGERR)
000DEE EF                MOV      A,R7
000DEF B40102            CJNE     A,#01H,?C0020?HWA_MIFARE
   69: 		{
   70: 			return FALSE;
000DF2 C3                CLR      C
000DF3 22                RET      
   71: 		}
   72: 	}
000DF4         ?C0020?HWA_MIFARE:
000DF4 900052            MOV      DPTR,#u8_ReadErrCount
000DF7 121B15            LCALL    ?L?COM005E
000DFA 40E1              JC       ?C0018?HWA_MIFARE
000DFC         ?C0019?HWA_MIFARE:
   73: 	return FALSE;
000DFC C3                CLR      C
   74: }
000DFD 22                RET      
----- FUNCTION _hwa_mifareReadBlock (END) -------


----- FUNCTION ?L?COM004E (BEGIN) -----
000DFE 9000C6            MOV      DPTR,#s_System+06H
000E01 E0                MOVX     A,@DPTR
000E02 FD                MOV      R5,A
----- FUNCTION _hwa_mifareReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  194: BOOL hwa_mifareReadSector(UINT8 *dat, UINT8 sector)
  195: {
000E03 B1C6              ACALL    ?L?COM0003
000E05 A3                INC      DPTR
000E06 ED                MOV      A,R5
000E07 F0                MOVX     @DPTR,A
  196: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  197: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
000E08 121AD9            LCALL    ?L?COM003F
000E0B B160              ACALL    ?L?COM0006
000E0D 4A                ORL      A,R2
000E0E 4B                ORL      A,R3
000E0F 7002              JNZ      $ + 4H
000E11 C1AB              AJMP     ?C0051?HWA_MIFARE
000E13 A3                INC      DPTR
000E14 E0                MOVX     A,@DPTR
000E15 FF                MOV      R7,A
000E16 D3                SETB     C
000E17 9400              SUBB     A,#00H
000E19 5002              JNC      $ + 4H
000E1B C1AB              AJMP     ?C0051?HWA_MIFARE
000E1D EF                MOV      A,R7
000E1E 9410              SUBB     A,#010H
000E20 4002              JC       $ + 4H
000E22 C1AB              AJMP     ?C0051?HWA_MIFARE
  198: 
  199: 	if (dat != NULL && sector > 0 && sector < 16)
  200: 	{
  201: 		if (hwa_mifareReadBlock((UINT8*)&s_NormalBuff, block) == FALSE)
000E24 1213B7            LCALL    ?L?COM001D
000E27 A3                INC      DPTR
000E28 E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 41


000E29 FD                MOV      R5,A
000E2A B1D2              ACALL    _hwa_mifareReadBlock
000E2C 4001              JC       ?C0052?HWA_MIFARE
  202: 		{
  203: 			return FALSE;
000E2E 22                RET      
  204: 		}
000E2F         ?C0052?HWA_MIFARE:
  205: 
  206: 		if (hwa_mifareReadBlock((UINT8*)&s_BackupBuff, blockBak) == FALSE)
000E2F 121365            LCALL    ?L?COM0029
000E32 90004D            MOV      DPTR,#blockBak
000E35 E0                MOVX     A,@DPTR
000E36 FD                MOV      R5,A
000E37 B1D2              ACALL    _hwa_mifareReadBlock
000E39 4001              JC       ?C0054?HWA_MIFARE
  207: 		{
  208: 			return FALSE;
000E3B 22                RET      
  209: 		}
000E3C         ?C0054?HWA_MIFARE:
  210: 
  211: 		hwa_mifareCheckBlock();
000E3C 121325            LCALL    hwa_mifareCheckBlock
  212: 
  213: 		if (NormalErrorFlag && BackupErrorFlag)				//正常块和备份块都校验错误
000E3F 30071A            JNB      NormalErrorFlag,?C0055?HWA_MIFARE
000E42 300617            JNB      BackupErrorFlag,?C0055?HWA_MIFARE
  214: 		{
  215:             if(s_System.RecoveryOldCard)
000E45 9000D0            MOV      DPTR,#s_System+010H
000E48 E0                MOVX     A,@DPTR
000E49 90004B            MOV      DPTR,#sector
000E4C 6007              JZ       ?C0056?HWA_MIFARE
  216:             {
  217:                 hwa_mifareRecoveryOldCard(sector);				//兼容旧卡
000E4E E0                MOVX     A,@DPTR
000E4F FF                MOV      R7,A
000E50 1213EF            LCALL    _hwa_mifareRecoveryOldCard
  218:             }
000E53 8005              SJMP     ?C0057?HWA_MIFARE
000E55         ?C0056?HWA_MIFARE:
  219:             else
  220:             {
  221:                 hwa_mifareRecoveryNewCard(sector);				//兼容新卡
000E55 E0                MOVX     A,@DPTR
000E56 FF                MOV      R7,A
000E57 1213BE            LCALL    _hwa_mifareRecoveryNewCard
  222:             }
000E5A         ?C0057?HWA_MIFARE:
  223: 			return FALSE;
000E5A C3                CLR      C
000E5B 22                RET      
  224: 		}
000E5C         ?C0055?HWA_MIFARE:
  225: 		else if (NormalErrorFlag)							//正常块校验错误
000E5C 30070D            JNB      NormalErrorFlag,?C0059?HWA_MIFARE
  226: 		{
  227: 			if (hwa_mifareWriteBlock((UINT8*)&s_BackupBuff, block) == FALSE)
000E5F 121365            LCALL    ?L?COM0029
000E62 90004C            MOV      DPTR,#block
000E65 E0                MOVX     A,@DPTR
000E66 FD                MOV      R5,A
000E67 F1B7              ACALL    _hwa_mifareWriteBlock
000E69 4029              JC       ?C0058?HWA_MIFARE
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 42


  228: 			{
  229: 				return FALSE;
000E6B 22                RET      
  230: 			}
  231: 		}
000E6C         ?C0059?HWA_MIFARE:
  232: 		else if (BackupErrorFlag							//备份块校验错误
000E6C 200618            JB       BackupErrorFlag,?C0063?HWA_MIFARE
000E6F 900077            MOV      DPTR,#s_BackupBuff+02H
000E72 E0                MOVX     A,@DPTR
000E73 FF                MOV      R7,A
000E74 900087            MOV      DPTR,#s_NormalBuff+02H
000E77 E0                MOVX     A,@DPTR
000E78 B5070C            CJNE     A,AR7,?C0063?HWA_MIFARE
000E7B 900078            MOV      DPTR,#s_BackupBuff+03H
000E7E E0                MOVX     A,@DPTR
000E7F FF                MOV      R7,A
000E80 900088            MOV      DPTR,#s_NormalBuff+03H
000E83 E0                MOVX     A,@DPTR
000E84 6F                XRL      A,R7
000E85 600D              JZ       ?C0058?HWA_MIFARE
000E87         ?C0063?HWA_MIFARE:
  233: 			|| s_NormalBuff.crc[0] != s_BackupBuff.crc[0]	//正常块和备份块校验正确但数据不一样，用正常块替换备份块
  234: 			|| s_NormalBuff.crc[1] != s_BackupBuff.crc[1]
  235:         )
  236: 		{
  237: 			if (hwa_mifareWriteBlock((UINT8*)&s_NormalBuff, blockBak) == FALSE)
000E87 1213B7            LCALL    ?L?COM001D
000E8A 90004D            MOV      DPTR,#blockBak
000E8D E0                MOVX     A,@DPTR
000E8E FD                MOV      R5,A
000E8F F1B7              ACALL    _hwa_mifareWriteBlock
000E91 4001              JC       ?C0058?HWA_MIFARE
  238: 			{
  239: 				return FALSE;
000E93 22                RET      
  240: 			}
  241: 		}
000E94         ?C0058?HWA_MIFARE:
  242: 		if (BackupErrorFlag)
000E94 B161              ACALL    ?L?COM0007
000E96 1215E7            LCALL    ?L?COM0059
000E99 300606            JNB      BackupErrorFlag,?C0065?HWA_MIFARE
  243: 		{
  244: 			memcpy(dat, (UINT8*)&s_NormalBuff, DATA_BLOCK_SIZE);
000E9C 7A00              MOV      R2,#HIGH s_NormalBuff
000E9E 7985              MOV      R1,#LOW s_NormalBuff
  245: 		}
000EA0 8004              SJMP     ?C0083?HWA_MIFARE
000EA2         ?C0065?HWA_MIFARE:
  246: 		else
  247: 		{
  248: 			memcpy(dat, (UINT8*)&s_BackupBuff, DATA_BLOCK_SIZE);
000EA2 7A00              MOV      R2,#HIGH s_BackupBuff
000EA4 7975              MOV      R1,#LOW s_BackupBuff
000EA6         
000EA6 121AE6            LCALL    ?L?COM0044
  249: 		}
000EA9         ?C0066?HWA_MIFARE:
  250: 		return TRUE;
000EA9 D3                SETB     C
000EAA 22                RET      
  251: 	}
000EAB         ?C0051?HWA_MIFARE:
  252: 	return FALSE;
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 43


000EAB C3                CLR      C
  253: }
000EAC 22                RET      
----- FUNCTION _hwa_mifareReadSector (END) -------


----- FUNCTION _hwa_eepromDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   51: void hwa_eepromDecrypt(UINT8 *dat, UINT16 size)        //解密
   52: {
000EAD 900066            MOV      DPTR,#dat
000EB0 B1C9              ACALL    ?L?COM0004
;---- Variable 'i' assigned to Register 'R6/R7' ----
000EB2 121603            LCALL    ?L?COM003B
000EB5         ?C0005?HWA_EEPROM_CFG:
000EB5 D3                SETB     C
000EB6 90006A            MOV      DPTR,#size+01H
000EB9 E0                MOVX     A,@DPTR
000EBA 9F                SUBB     A,R7
000EBB 900069            MOV      DPTR,#size
000EBE E0                MOVX     A,@DPTR
000EBF 9E                SUBB     A,R6
000EC0 401B              JC       ?C0008?HWA_EEPROM_CFG
   53: 	UINT16 i;
   54: 	UINT8 tmp;
   55: 	for (i = 0; i<size; i++)
   56: 	{
   57: 		tmp = dat[i];
000EC2 900066            MOV      DPTR,#dat
000EC5 B164              ACALL    ?L?COM0008
;---- Variable 'tmp' assigned to Register 'R5' ----
000EC7 121652            LCALL    ?L?COM0040
   58: 		tmp ^= SecretKey;
   59: 		tmp = (tmp << 1) | (tmp >> 7);
000ECA 25E0              ADD      A,ACC
000ECC FC                MOV      R4,A
000ECD ED                MOV      A,R5
000ECE C4                SWAP     A
000ECF 13                RRC      A
000ED0 13                RRC      A
000ED1 13                RRC      A
000ED2 5401              ANL      A,#01H
000ED4 12166B            LCALL    ?L?COM003E
000ED7 BF0001            CJNE     R7,#00H,?C0010?HWA_EEPROM_CFG
000EDA 0E                INC      R6
000EDB         ?C0010?HWA_EEPROM_CFG:
000EDB 80D8              SJMP     ?C0005?HWA_EEPROM_CFG
   60: 		tmp ^= SecretKey;
   61: 		dat[i] = tmp;
   62: 	}
   63: }
000EDD         ?C0008?HWA_EEPROM_CFG:
000EDD 22                RET      
----- FUNCTION _hwa_eepromDecrypt (END) -------


----- FUNCTION _hwa_eepromCheck (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
    6: static UINT16 hwa_eepromCheck( UINT8 *dat, UINT16 len)
    7: {
000EDE 900066            MOV      DPTR,#dat
000EE1 B1C9              ACALL    ?L?COM0004
;---- Variable 'crc' assigned to Register 'R6/R7' ----
000EE3 121647            LCALL    ?L?COM0049
000EE6         ?C0001?HWA_EEPROM:
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 44


    8:     UINT16 crc = 0xFFFF;
    9:     UINT8 i;
   10:     while(len--)
000EE6 900069            MOV      DPTR,#len
000EE9 121661            LCALL    ?L?COM002B
000EEC 6030              JZ       ?C0002?HWA_EEPROM
   11:     {
   12:         crc = crc ^*dat++;
000EEE 900066            MOV      DPTR,#dat
000EF1 12144C            LCALL    ?L?COM000A
000EF4 FD                MOV      R5,A
000EF5 ED                MOV      A,R5
000EF6 6F                XRL      A,R7
000EF7 FF                MOV      R7,A
   13:         for ( i = 0; i < 8; i++)
000EF8 E4                CLR      A
000EF9 90006B            MOV      DPTR,#i
000EFC F0                MOVX     @DPTR,A
000EFD         ?C0003?HWA_EEPROM:
000EFD 90006B            MOV      DPTR,#i
000F00 E0                MOVX     A,@DPTR
000F01 C3                CLR      C
000F02 9408              SUBB     A,#08H
000F04 50E0              JNC      ?C0001?HWA_EEPROM
   14:         {
   15:             if( ( crc & 0x0001) > 0)
000F06 12163D            LCALL    ?L?COM004C
000F09 4005              JC       ?C0006?HWA_EEPROM
   16:             {
   17:                 crc = crc >> 1;
000F0B 121678            LCALL    ?L?COM003A
   18:                 crc = crc ^ 0xa001;
   19:             }
000F0E 8006              SJMP     ?C0005?HWA_EEPROM
000F10         ?C0006?HWA_EEPROM:
   20:             else
   21:             {
   22:                 crc = crc >> 1;
000F10 C3                CLR      C
000F11 13                RRC      A
000F12 FE                MOV      R6,A
000F13 EF                MOV      A,R7
000F14 13                RRC      A
000F15 FF                MOV      R7,A
   23:             }
   24:         }
000F16         ?C0005?HWA_EEPROM:
000F16 90006B            MOV      DPTR,#i
000F19 E0                MOVX     A,@DPTR
000F1A 04                INC      A
000F1B F0                MOVX     @DPTR,A
000F1C 80DF              SJMP     ?C0003?HWA_EEPROM
   25:     }
000F1E         ?C0002?HWA_EEPROM:
   26:     return ( crc );
   27: }
000F1E 22                RET      
----- FUNCTION _hwa_eepromCheck (END) -------


----- FUNCTION ?L?COM004F (BEGIN) -----
000F1F 9000C6            MOV      DPTR,#s_System+06H
000F22 E0                MOVX     A,@DPTR
000F23 FD                MOV      R5,A
----- FUNCTION _hwa_mifareWriteSector (BEGIN) -----
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 45


 FILE: 'Hwa\hwa_mifare.c'
  255: BOOL hwa_mifareWriteSector(UINT8 *dat, UINT8 sector)
  256: {
000F24 900050            MOV      DPTR,#dat
000F27 B1C9              ACALL    ?L?COM0004
;---- Variable 'sector' assigned to Register 'R5' ----
  257: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  258: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
000F29 ED                MOV      A,R5
000F2A 121AD9            LCALL    ?L?COM003F
000F2D F0                MOVX     @DPTR,A
  259: 	UINT16 crc;
  260:     BOOL falg = FALSE;
000F2E C200              CLR      falg
  261: 	if (dat != NULL && sector > 0 && sector < 16)
000F30 900050            MOV      DPTR,#dat
000F33 B164              ACALL    ?L?COM0008
000F35 4A                ORL      A,R2
000F36 4B                ORL      A,R3
000F37 6049              JZ       ?C0067?HWA_MIFARE
000F39 ED                MOV      A,R5
000F3A D3                SETB     C
000F3B 9400              SUBB     A,#00H
000F3D 4043              JC       ?C0067?HWA_MIFARE
000F3F ED                MOV      A,R5
000F40 9410              SUBB     A,#010H
000F42 503E              JNC      ?C0067?HWA_MIFARE
  262: 	{
  263: 		crc = hwa_mifareCheckOut(dat, USE_DATA_BLOCK_LEN);
000F44 900050            MOV      DPTR,#dat
000F47 A3                INC      DPTR
000F48 A3                INC      DPTR
000F49 E0                MOVX     A,@DPTR
000F4A F9                MOV      R1,A
;---- Variable 'crc' assigned to Register 'R4/R5' ----
000F4B 12136C            LCALL    ?L?COM0036
000F4E AC06              MOV      R4,AR6
  264: 		dat[USE_DATA_BLOCK_LEN] = (UINT8)(crc >> 8);
000F50 EC                MOV      A,R4
000F51 FF                MOV      R7,A
000F52 900050            MOV      DPTR,#dat
000F55 B164              ACALL    ?L?COM0008
000F57 F9                MOV      R1,A
000F58 900002            MOV      DPTR,#02H
000F5B EF                MOV      A,R7
000F5C 120174            LCALL    ?C?CSTOPTR
  265: 		dat[USE_DATA_BLOCK_LEN + 1] = (UINT8)(crc & 0xFF);
000F5F ED                MOV      A,R5
000F60 900003            MOV      DPTR,#03H
000F63 120174            LCALL    ?C?CSTOPTR
  266: 		if (hwa_mifareWriteBlock(dat, block))
000F66 900053            MOV      DPTR,#block
000F69 E0                MOVX     A,@DPTR
000F6A FD                MOV      R5,A
000F6B F1B7              ACALL    _hwa_mifareWriteBlock
000F6D 5002              JNC      ?C0068?HWA_MIFARE
  267: 		{
  268: 			falg = TRUE;
000F6F D200              SETB     falg
  269: 		}
000F71         ?C0068?HWA_MIFARE:
  270: 		if (hwa_mifareWriteBlock(dat, blockBak))
000F71 900050            MOV      DPTR,#dat
000F74 B164              ACALL    ?L?COM0008
000F76 F9                MOV      R1,A
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 46


000F77 900054            MOV      DPTR,#blockBak
000F7A E0                MOVX     A,@DPTR
000F7B FD                MOV      R5,A
000F7C F1B7              ACALL    _hwa_mifareWriteBlock
000F7E 5002              JNC      ?C0067?HWA_MIFARE
  271: 		{
  272: 			falg = TRUE;
000F80 D200              SETB     falg
  273: 		}
  274: 	}
000F82         ?C0067?HWA_MIFARE:
  275:     return falg;
000F82 A200              MOV      C,falg
  276: }
000F84 22                RET      
----- FUNCTION _hwa_mifareWriteSector (END) -------


----- FUNCTION _hwa_mifareEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   30: void hwa_mifareEncrypt(UINT8 *pData)        //利用卡ID加密
   31: {
000F85 900057            MOV      DPTR,#pData
000F88 B1C9              ACALL    ?L?COM0004
   32: 	UINT8 i, j;
   33: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
000F8A E4                CLR      A
000F8B FE                MOV      R6,A
000F8C         ?C0004?HWA_MIFARE:
   34: 	{
   35: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
000F8C 7D04              MOV      R5,#04H
000F8E         ?C0007?HWA_MIFARE:
   36: 		{
   37: 			pData[i] ^= gCard_UID[i % 5];
000F8E 900057            MOV      DPTR,#pData
000F91 B164              ACALL    ?L?COM0008
000F93 1215C5            LCALL    ?L?COM0017
000F96 E0                MOVX     A,@DPTR
000F97 6F                XRL      A,R7
000F98 120162            LCALL    ?C?CSTPTR
   38: 			pData[i] = _cror_(pData[i], 1);
000F9B 900057            MOV      DPTR,#pData
000F9E B164              ACALL    ?L?COM0008
000FA0 121085            LCALL    ?L?COM001E
000FA3 FF                MOV      R7,A
000FA4 7801              MOV      R0,#01H
000FA6 08                INC      R0
000FA7 8001              SJMP     ?C0072?HWA_MIFARE
000FA9         ?C0071?HWA_MIFARE:
000FA9 03                RR       A
000FAA         ?C0072?HWA_MIFARE:
000FAA D8FD              DJNZ     R0,?C0071?HWA_MIFARE
000FAC 1215DF            LCALL    ?L?COM0053
   39: 		}
000FAF DDDD              DJNZ     R5,?C0007?HWA_MIFARE
   40: 	}
000FB1         ?C0006?HWA_MIFARE:
000FB1 0E                INC      R6
000FB2 EE                MOV      A,R6
000FB3 B404D6            CJNE     A,#04H,?C0004?HWA_MIFARE
   41: }
000FB6 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 47


----- FUNCTION _hwa_mifareEncrypt (END) -------


----- FUNCTION _hwa_mifareWriteBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   76: BOOL hwa_mifareWriteBlock(UINT8 *buff, UINT8 block)
   77: {
000FB7 900055            MOV      DPTR,#block
000FBA ED                MOV      A,R5
000FBB F0                MOVX     @DPTR,A
;---- Variable 'buff' assigned to Register 'R1/R2/R3' ----
   78: 	UINT8 u8_ReadErrCount;
   79: 	UINT8 u8_Result;
   80:     memcpy((UINT8*)&s_TempBuff, buff, 16);
000FBC 7895              MOV      R0,#LOW s_TempBuff
000FBE 7C00              MOV      R4,#HIGH s_TempBuff
000FC0 7D01              MOV      R5,#01H
000FC2 121AE6            LCALL    ?L?COM0044
   81:     hwa_mifareEncrypt((UINT8*)&s_TempBuff);             //利用卡ID加密
000FC5 7B01              MOV      R3,#01H
000FC7 7A00              MOV      R2,#HIGH s_TempBuff
000FC9 7995              MOV      R1,#LOW s_TempBuff
000FCB F185              ACALL    _hwa_mifareEncrypt
   82: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
000FCD E4                CLR      A
000FCE 900056            MOV      DPTR,#u8_ReadErrCount
000FD1 F0                MOVX     @DPTR,A
000FD2         ?C0025?HWA_MIFARE:
   83: 	{
   84: 		u8_Result = Write_Block((UINT8*)&s_TempBuff, block);
000FD2 7B01              MOV      R3,#01H
000FD4 7A00              MOV      R2,#HIGH s_TempBuff
000FD6 7995              MOV      R1,#LOW s_TempBuff
000FD8 900055            MOV      DPTR,#block
000FDB E0                MOVX     A,@DPTR
000FDC FD                MOV      R5,A
000FDD 121A19            LCALL    _Write_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   85: 		if (u8_Result == FM1702_OK)
000FE0 EF                MOV      A,R7
000FE1 7002              JNZ      ?C0028?HWA_MIFARE
   86: 		{
   87: 			return TRUE;
000FE3 D3                SETB     C
000FE4 22                RET      
   88: 		}
000FE5         ?C0028?HWA_MIFARE:
   89: 		else if (u8_Result == FM1702_NOTAGERR)
000FE5 EF                MOV      A,R7
000FE6 B40102            CJNE     A,#01H,?C0027?HWA_MIFARE
   90: 		{
   91: 			return FALSE;
000FE9 C3                CLR      C
000FEA 22                RET      
   92: 		}
   93: 	}
000FEB         ?C0027?HWA_MIFARE:
000FEB 900056            MOV      DPTR,#u8_ReadErrCount
000FEE 121B15            LCALL    ?L?COM005E
000FF1 40DF              JC       ?C0025?HWA_MIFARE
000FF3         ?C0026?HWA_MIFARE:
   94: 	return FALSE;
000FF3 C3                CLR      C
   95: }
000FF4 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 48


----- FUNCTION _hwa_mifareWriteBlock (END) -------


----- FUNCTION ?L?COM0030 (BEGIN) -----
000FF5 FE                MOV      R6,A
000FF6 74DA              MOV      A,#LOW gBuff+02H
000FF8 2F                ADD      A,R7
000FF9 F582              MOV      DPL,A
000FFB E4                CLR      A
000FFC 3400              ADDC     A,#HIGH gBuff+02H
000FFE         ?L?COM0031:
000FFE F583              MOV      DPH,A
001000 EE                MOV      A,R6
001001 F0                MOVX     @DPTR,A
001002 0F                INC      R7
001003 EF                MOV      A,R7
001004 22                RET      
----- FUNCTION ?L?COM0030 (END) -------


----- FUNCTION _Load_Key (BEGIN) -----
 FILE: 'Driver\mifare.c'
  406: uchar Load_Key(uchar *ramadr)
  407: {
001005 90004B            MOV      DPTR,#ramadr
001008 120DC9            LCALL    ?L?COM0004
  408: 	uchar acktemp,temp[1],i;
  409: 	uchar ucBuff[12];
  410: 	for (i=0;i<6;i++)
;---- Variable 'i' assigned to Register 'R7' ----
00100B E4                CLR      A
00100C FF                MOV      R7,A
00100D         ?C0089?MIFARE:
  411: 	{
  412: 		temp[0]=ramadr[i];
00100D 90004B            MOV      DPTR,#ramadr
001010 120D64            LCALL    ?L?COM0008
001013 F9                MOV      R1,A
001014 8F82              MOV      DPL,R7
001016 1188              ACALL    ?L?COM001F
001018 90004F            MOV      DPTR,#temp
00101B F0                MOVX     @DPTR,A
00101C FD                MOV      R5,A
  413: 		ucBuff[2*i]=(((ramadr[i]&0xf0)>>4)|((~ramadr[i])&0xf0));
00101D 54F0              ANL      A,#0F0H
00101F C4                SWAP     A
001020 540F              ANL      A,#0FH
001022 FE                MOV      R6,A
001023 8F82              MOV      DPL,R7
001025 1188              ACALL    ?L?COM001F
001027 F4                CPL      A
001028 117D              ACALL    ?L?COM005A
00102A 2450              ADD      A,#LOW ucBuff
00102C F582              MOV      DPL,A
00102E E4                CLR      A
00102F 3400              ADDC     A,#HIGH ucBuff
001031 F583              MOV      DPH,A
001033 EE                MOV      A,R6
001034 F0                MOVX     @DPTR,A
  414: 		ucBuff[2*i+1]=((temp[0]&0xf)|(~(temp[0]&0xf)<<4));
001035 ED                MOV      A,R5
001036 540F              ANL      A,#0FH
001038 FE                MOV      R6,A
001039 F4                CPL      A
00103A FD                MOV      R5,A
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 49


00103B C4                SWAP     A
00103C 117D              ACALL    ?L?COM005A
00103E 2451              ADD      A,#LOW ucBuff+01H
001040 F582              MOV      DPL,A
001042 E4                CLR      A
001043 3400              ADDC     A,#HIGH ucBuff+01H
001045 120FFE            LCALL    ?L?COM0031
001048 B406C2            CJNE     A,#06H,?C0089?MIFARE
00104B         ?C0090?MIFARE:
  415: 	}
  416: 	acktemp=Command_Send(LOAD_KEY, ucBuff, 12);
00104B 7B01              MOV      R3,#01H
00104D 7A00              MOV      R2,#HIGH ucBuff
00104F 7950              MOV      R1,#LOW ucBuff
001051 900070            MOV      DPTR,#?_Command_Send?BYTE+04H
001054 740C              MOV      A,#0CH
001056 F0                MOVX     @DPTR,A
001057 7F19              MOV      R7,#019H
001059 120607            LCALL    _Command_Send
00105C 90004E            MOV      DPTR,#acktemp
00105F EF                MOV      A,R7
001060 F0                MOVX     @DPTR,A
  417: 	temp[0] = SPIReadOne(SecondaryStatus_Reg);
001061 7F05              MOV      R7,#05H
001063 12056A            LCALL    _SPIReadOne
001066 A3                INC      DPTR
001067 EF                MOV      A,R7
001068 F0                MOVX     @DPTR,A
  418: 	if (temp[0]&0x40)
001069 30E607            JNB      ACC.6,?C0092?MIFARE
  419: 	{
  420: 		temp[0]=0x0;
00106C E4                CLR      A
00106D 120531            LCALL    ?L?COM0039
  421: 		SPIWriteOne(Command_Reg,temp[0]);
  422: 		return(0);
001070 7F00              MOV      R7,#00H
001072 22                RET      
  423: 	}
001073         ?C0092?MIFARE:
  424: 	temp[0]=0x0;
001073 E4                CLR      A
001074 90004F            MOV      DPTR,#temp
001077 120531            LCALL    ?L?COM0039
  425: 	SPIWriteOne(Command_Reg,temp[0]);
  426: 	return(1);
00107A 7F01              MOV      R7,#01H
  427: }
00107C 22                RET      
----- FUNCTION _Load_Key (END) -------


----- FUNCTION ?L?COM005A (BEGIN) -----
00107D 54F0              ANL      A,#0F0H
00107F 4E                ORL      A,R6
001080 FE                MOV      R6,A
001081 EF                MOV      A,R7
001082 25E0              ADD      A,ACC
001084 22                RET      
----- FUNCTION ?L?COM005A (END) -------


----- FUNCTION ?L?COM001E (BEGIN) -----
001085 F9                MOV      R1,A
001086 8E82              MOV      DPL,R6
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 50


001088         ?L?COM001F:
001088 758300            MOV      DPH,#00H
00108B 020135            LJMP     ?C?CLDOPTR
----- FUNCTION ?L?COM001E (END) -------


----- FUNCTION _comCheck (BEGIN) -----
 FILE: 'Hwa\hwa_uart.c'
  163: UINT8 comCheck(UINT8* dat, UINT8 len)
  164: {
00108E 120DC6            LCALL    ?L?COM0003
;---- Variable 'check' assigned to Register 'R7' ----
;---- Variable 'i' assigned to Register 'R6' ----
001091 D106              ACALL    ?L?COM003C
001093         ?C0018?HWA_UART:
001093 90004B            MOV      DPTR,#len
001096 E0                MOVX     A,@DPTR
001097 FD                MOV      R5,A
001098 EE                MOV      A,R6
001099 D3                SETB     C
00109A 9D                SUBB     A,R5
00109B 500A              JNC      ?C0019?HWA_UART
  165: 	UINT8 i, check = 0;
  166: 	for(i=0; i<=len; i++)
  167: 	{
  168: 		check ^= dat[i];
00109D 120D61            LCALL    ?L?COM0007
0010A0 1185              ACALL    ?L?COM001E
0010A2 6F                XRL      A,R7
0010A3 FF                MOV      R7,A
  169: 	}
0010A4 0E                INC      R6
0010A5 80EC              SJMP     ?C0018?HWA_UART
0010A7         ?C0019?HWA_UART:
  170: 	return check;
  171: }
0010A7 22                RET      
----- FUNCTION _comCheck (END) -------


----- FUNCTION hwa_uartHandler10ms (BEGIN) -----
 FILE: 'Hwa\hwa_uart.c'
  173: void hwa_uartHandler10ms(void)
  174: {
  175: 	UINT8 i;
  176:     UINT8 error = CE_OK;
0010A8 E4                CLR      A
0010A9 900047            MOV      DPTR,#error
0010AC F0                MOVX     @DPTR,A
  177:     if(comRxFalg)
0010AD 200802            JB       comRxFalg,$ + 5H
0010B0 2153              AJMP     ?C0022?HWA_UART
  178:     {
  179:         comRxFalg = FALSE;
0010B2 C208              CLR      comRxFalg
  180:         if(s_comRxBuff.head != 0xAA)
0010B4 E541              MOV      A,s_comRxBuff
0010B6 64AA              XRL      A,#0AAH
0010B8 6002              JZ       $ + 4H
0010BA 21C7              AJMP     ?C0024?HWA_UART
  181:         {
  182:             return;
  183:         }
0010BC         ?C0023?HWA_UART:
  184:         comTxFlag = TRUE;
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 51


0010BC D209              SETB     comTxFlag
  185:         memcpy((UINT8*)&s_comTxBuff, (UINT8*)&c_s_comTxBuff, sizeof(s_comTxBuff));
0010BE 7850              MOV      R0,#LOW s_comTxBuff
0010C0 7C00              MOV      R4,#HIGH s_comTxBuff
0010C2 7D00              MOV      R5,#00H
0010C4 7BFF              MOV      R3,#0FFH
0010C6 7A00              MOV      R2,#HIGH c_s_comTxBuff
0010C8 790E              MOV      R1,#LOW c_s_comTxBuff
0010CA 7E00              MOV      R6,#00H
0010CC 7F14              MOV      R7,#014H
0010CE 1200F6            LCALL    ?C?COPY
  186: 		if(s_comRxBuff.len > MAX_DATA_LEN
0010D1 E542              MOV      A,s_comRxBuff+01H
0010D3 D3                SETB     C
0010D4 940A              SUBB     A,#0AH
0010D6 5007              JNC      ?C0026?HWA_UART
0010D8 E542              MOV      A,s_comRxBuff+01H
0010DA C3                CLR      C
0010DB 9402              SUBB     A,#02H
0010DD 5006              JNC      ?C0025?HWA_UART
0010DF         ?C0026?HWA_UART:
  187: 			|| s_comRxBuff.len < 2)
  188: 		{
  189:             error = CE_BAD_PARAM;
0010DF 900047            MOV      DPTR,#error
0010E2 7404              MOV      A,#04H
0010E4 F0                MOVX     @DPTR,A
  190: 		}
0010E5         ?C0025?HWA_UART:
  191:         if(s_comRxBuff.head == 0xAA && s_comRxBuff.end == 0xCC)
0010E5 E541              MOV      A,s_comRxBuff
0010E7 64AA              XRL      A,#0AAH
0010E9 705C              JNZ      ?C0027?HWA_UART
0010EB E54F              MOV      A,s_comRxBuff+0EH
0010ED 64CC              XRL      A,#0CCH
0010EF 7056              JNZ      ?C0027?HWA_UART
  192:         {
  193:         	if(comCheck(&s_comRxBuff.len, s_comRxBuff.len) == s_comRxBuff.check)
0010F1 FB                MOV      R3,A
0010F2 7A00              MOV      R2,#HIGH s_comRxBuff+01H
0010F4 7942              MOV      R1,#LOW s_comRxBuff+01H
0010F6 AD42              MOV      R5,s_comRxBuff+01H
0010F8 118E              ACALL    _comCheck
0010FA EF                MOV      A,R7
0010FB 654E              XRL      A,s_comRxBuff+0DH
0010FD 7040              JNZ      ?C0028?HWA_UART
  194:         	{
  195:         		s_comTxBuff.cmd = s_comRxBuff.cmd;
0010FF 854351            MOV      s_comTxBuff+01H,s_comRxBuff+02H
  196:                 
  197:                 if(app_brushCard() == USER_CARD)
001102 B11C              ACALL    app_brushCard
001104 EF                MOV      A,R7
001105 6402              XRL      A,#02H
001107 702E              JNZ      ?C0029?HWA_UART
  198:                 {
  199:                     if(s_comRxBuff.cmd == 0x00)
001109 E543              MOV      A,s_comRxBuff+02H
00110B 7004              JNZ      ?C0030?HWA_UART
  200:                     {
  201:                         error = comfun_0x00();
00110D 5110              ACALL    comfun_0x00
  202:                     }
00110F 8017              SJMP     ?C0048?HWA_UART
001111         ?C0030?HWA_UART:
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 52


  203:                     else if(hwa_mifareReadSector(gBuff, s_System.Sector))
001111 120709            LCALL    ?L?COM0014
001114 120DFE            LCALL    ?L?COM004E
001117 501E              JNC      ?C0049?HWA_UART
  204:                     {
  205:                         switch(s_comRxBuff.cmd)
001119 E543              MOV      A,s_comRxBuff+02H
00111B 24FE              ADD      A,#0FEH
00111D 6007              JZ       ?C0035?HWA_UART
00111F 04                INC      A
001120 700D              JNZ      ?C0036?HWA_UART
  206:                         {
  207:                             case 0x01:      //Read Money
001122         ?C0034?HWA_UART:
  208:                                 error = comfun_0x01();
001122 5137              ACALL    comfun_0x01
001124         
  209:                                 break;
001124 8002              SJMP     ?C0048?HWA_UART
  210:                             case 0x02:      //Add Money
001126         ?C0035?HWA_UART:
  211:                                 error = comfun_0x02();
001126 31C8              ACALL    comfun_0x02
001128         
001128 900047            MOV      DPTR,#error
00112B EF                MOV      A,R7
00112C F0                MOVX     @DPTR,A
  212:                                 break;
00112D 801E              SJMP     ?C0040?HWA_UART
  213:                             default:        //Cmd Error
00112F         ?C0036?HWA_UART:
  214:                                 error = CE_BAD_COMMAND;
00112F 900047            MOV      DPTR,#error
001132 7403              MOV      A,#03H
001134 F0                MOVX     @DPTR,A
  215:                                 break;
001135 8016              SJMP     ?C0040?HWA_UART
  216:                         }
  217:                     }
001137         ?C0029?HWA_UART:
  218:                     else 
  219:                     {
  220:                         error = CE_ERROR;
  221:                     }
  222:                 }
  223:                 else 
  224:                 {
  225:                     error = CE_ERROR;
001137         
001137 900047            MOV      DPTR,#error
00113A 7401              MOV      A,#01H
00113C F0                MOVX     @DPTR,A
  226:                 }
  227:         	}
00113D 800E              SJMP     ?C0040?HWA_UART
00113F         ?C0028?HWA_UART:
  228:             else
  229:             {
  230:                 error = CE_CHECK_ERROR;
00113F 900047            MOV      DPTR,#error
001142 7402              MOV      A,#02H
001144 F0                MOVX     @DPTR,A
  231:             }
  232:         }
001145 8006              SJMP     ?C0040?HWA_UART
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 53


001147         ?C0027?HWA_UART:
  233:         else
  234:         {
  235:             error = CE_BAD_PARAM;
001147 900047            MOV      DPTR,#error
00114A 7404              MOV      A,#04H
00114C F0                MOVX     @DPTR,A
  236:         }
00114D         ?C0040?HWA_UART:
  237:         s_comTxBuff.value = error;
00114D 900047            MOV      DPTR,#error
001150 E0                MOVX     A,@DPTR
001151 F552              MOV      s_comTxBuff+02H,A
  238:     }
001153         ?C0022?HWA_UART:
  239:     
  240:     if(comTxFlag)
001153 300971            JNB      comTxFlag,?C0024?HWA_UART
  241:     {
  242:         comTxFlag = FALSE;
001156 C209              CLR      comTxFlag
  243:         comTxBuff[0] = s_comTxBuff.head;
001158 855031            MOV      comTxBuff,s_comTxBuff
  244:         comTxBuff[1] = s_comTxBuff.cmd;
00115B 855132            MOV      comTxBuff+01H,s_comTxBuff+01H
  245:         comTxBuff[2] = s_comTxBuff.value;
00115E 855233            MOV      comTxBuff+02H,s_comTxBuff+02H
  246:         comTxBuff[3] = s_comTxBuff.end;
001161 855334            MOV      comTxBuff+03H,s_comTxBuff+03H
  247:         if(s_comTxBuff.expand)
001164 E563              MOV      A,s_comTxBuff+013H
001166 6055              JZ       ?C0042?HWA_UART
  248:         {
  249:         	s_comTxBuff.std_dat.cmd = s_comTxBuff.cmd;
001168 855156            MOV      s_comTxBuff+06H,s_comTxBuff+01H
  250: 	        comTxBuff[4] = s_comTxBuff.std_dat.head;
00116B 855435            MOV      comTxBuff+04H,s_comTxBuff+04H
  251: 	        comTxBuff[5] = s_comTxBuff.std_dat.len;
00116E 855536            MOV      comTxBuff+05H,s_comTxBuff+05H
  252: 	        comTxBuff[6] = s_comTxBuff.std_dat.cmd;
001171 855637            MOV      comTxBuff+06H,s_comTxBuff+06H
  253: 	        for(i=0; i<s_comTxBuff.std_dat.len-2; i++)
;---- Variable 'i' assigned to Register 'R4' ----
001174 E4                CLR      A
001175 FC                MOV      R4,A
001176         ?C0043?HWA_UART:
001176 E555              MOV      A,s_comTxBuff+05H
001178 24FE              ADD      A,#0FEH
00117A FF                MOV      R7,A
00117B EC                MOV      A,R4
00117C C3                CLR      C
00117D 9F                SUBB     A,R7
00117E 500F              JNC      ?C0044?HWA_UART
  254: 	        {
  255: 	        	comTxBuff[7+i] = s_comTxBuff.std_dat.dat[i];
001180 7457              MOV      A,#LOW s_comTxBuff+07H
001182 2C                ADD      A,R4
001183 F8                MOV      R0,A
001184 E6                MOV      A,@R0
001185 FF                MOV      R7,A
001186 7438              MOV      A,#LOW comTxBuff+07H
001188 2C                ADD      A,R4
001189 F8                MOV      R0,A
00118A A607              MOV      @R0,AR7
  256: 	        }
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 54


00118C 0C                INC      R4
00118D 80E7              SJMP     ?C0043?HWA_UART
00118F         ?C0044?HWA_UART:
  257: 	        i += 7;
00118F 7407              MOV      A,#07H
001191 2C                ADD      A,R4
001192 FC                MOV      R4,A
  258:         	s_comTxBuff.std_dat.check = comCheck((UINT8*)&s_comTxBuff.std_dat.len, s_comTxBuff.std_dat.len);
001193 7B00              MOV      R3,#00H
001195 7A00              MOV      R2,#HIGH s_comTxBuff+05H
001197 7955              MOV      R1,#LOW s_comTxBuff+05H
001199 AD55              MOV      R5,s_comTxBuff+05H
00119B 118E              ACALL    _comCheck
00119D 8F61              MOV      s_comTxBuff+011H,R7
  259: 	        comTxBuff[i++] = s_comTxBuff.std_dat.check;
00119F AF04              MOV      R7,AR4
0011A1 0C                INC      R4
0011A2 7431              MOV      A,#LOW comTxBuff
0011A4 2F                ADD      A,R7
0011A5 F8                MOV      R0,A
0011A6 A661              MOV      @R0,s_comTxBuff+011H
  260: 	        comTxBuff[i++] = s_comTxBuff.std_dat.end;
0011A8 AF04              MOV      R7,AR4
0011AA 7431              MOV      A,#LOW comTxBuff
0011AC 2F                ADD      A,R7
0011AD F8                MOV      R0,A
0011AE A662              MOV      @R0,s_comTxBuff+012H
  261: 	        
  262:             sys_uartSendData(comTxBuff, 4+2+s_comTxBuff.std_dat.len+1);
0011B0 7B00              MOV      R3,#00H
0011B2 7A00              MOV      R2,#HIGH comTxBuff
0011B4 7931              MOV      R1,#LOW comTxBuff
0011B6 E555              MOV      A,s_comTxBuff+05H
0011B8 2407              ADD      A,#07H
0011BA FD                MOV      R5,A
  263:         }
0011BB 8008              SJMP     ?C0050?HWA_UART
0011BD         ?C0042?HWA_UART:
  264:         else
  265:         {
  266:             sys_uartSendData(comTxBuff, 4);
0011BD 7B00              MOV      R3,#00H
0011BF 7A00              MOV      R2,#HIGH comTxBuff
0011C1 7931              MOV      R1,#LOW comTxBuff
0011C3 7D04              MOV      R5,#04H
0011C5         
0011C5 D1F1              ACALL    _sys_uartSendData
  267:         }
  268:     }
  269: }
0011C7         ?C0024?HWA_UART:
0011C7 22                RET      
----- FUNCTION hwa_uartHandler10ms (END) -------


----- FUNCTION comfun_0x02 (BEGIN) -----
 FILE: 'Hwa\hwa_uart.c'
  132: UINT8 comfun_0x02(void)
  133: {
  134:     pMoney->money += s_comRxBuff.dat[0]*100;
  135:     if(pMoney->money > 20000)
0011C8 E544              MOV      A,s_comRxBuff+03H
0011CA 75F064            MOV      B,#064H
0011CD A4                MUL      AB
0011CE FF                MOV      R7,A
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 55


0011CF 5130              ACALL    ?L?COM004B
0011D1 E5F0              MOV      A,B
0011D3 8FF0              MOV      B,R7
0011D5 12023E            LCALL    ?C?IILDPTR
  136:     {
0011D8 5130              ACALL    ?L?COM004B
0011DA 120213            LCALL    ?C?ILDPTR
0011DD D3                SETB     C
0011DE 9420              SUBB     A,#020H
0011E0 E5F0              MOV      A,B
0011E2 944E              SUBB     A,#04EH
0011E4 4007              JC       ?C0014?HWA_UART
  137:         buzzer_SoundNumber(2);
  138:         return CE_BAD_PADATA;
0011E6 7F02              MOV      R7,#02H
0011E8 510A              ACALL    _buzzer_SoundNumber
  139:     }
0011EA 7F05              MOV      R7,#05H
0011EC 22                RET      
  140:     if(hwa_mifareWriteSector(gBuff, s_System.Sector))
0011ED         ?C0014?HWA_UART:
  141:     {
0011ED 120709            LCALL    ?L?COM0014
0011F0 120F1F            LCALL    ?L?COM004F
0011F3 500E              JNC      ?C0016?HWA_UART
  142:         s_comTxBuff.expand = TRUE;
  143:         s_comTxBuff.std_dat.dat[0] = pMoney->money/100;
0011F5 514B              ACALL    ?L?COM0001
0011F7 C006              PUSH     AR6
0011F9 C007              PUSH     AR7
0011FB 51A6              ACALL    ?L?COM0022
0011FD D007              POP      AR7
0011FF D006              POP      AR6
001201 8040              SJMP     ?L?COM0043
  144:         s_comTxBuff.std_dat.dat[1] = pMoney->money%100;
  145:         s_comTxBuff.std_dat.dat[2] = gCard_UID[0];
  146:         s_comTxBuff.std_dat.dat[3] = gCard_UID[1];
  147:         s_comTxBuff.std_dat.dat[4] = gCard_UID[2];
  148:         s_comTxBuff.std_dat.dat[5] = gCard_UID[3];
  149:         s_comTxBuff.std_dat.dat[6] = gCard_UID[4];
  150:         s_comTxBuff.std_dat.len = 9;
  151:         buzzer_SoundNumber(1);
  152:         led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
  153:         return CE_OK;
  154:     }
001203         ?C0016?HWA_UART:
;----                  JMP      ?L?COM005C
  155:     else
  156:     {
  157:         buzzer_SoundNumber(2);
  158:         return CE_ERROR;
  159:     }
----- FUNCTION comfun_0x02 (END) -------


----- FUNCTION ?L?COM005C (BEGIN) -----
001203 7F02              MOV      R7,#02H
001205 510A              ACALL    _buzzer_SoundNumber
001207 7F01              MOV      R7,#01H
001209 22                RET      
----- FUNCTION ?L?COM005C (END) -------


----- FUNCTION _buzzer_SoundNumber (BEGIN) -----
 FILE: 'Driver\buzzer.c'
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 56


   28: void buzzer_SoundNumber(UINT8 num)
   29: {
;---- Variable 'num' assigned to Register 'R7' ----
   30:     SoundNumberCount = num;
   30: }
00120A 9000FC            MOV      DPTR,#SoundNumberCount
00120D EF                MOV      A,R7
00120E F0                MOVX     @DPTR,A
   30: 
00120F 22                RET      
----- FUNCTION _buzzer_SoundNumber (END) -------


----- FUNCTION comfun_0x00 (BEGIN) -----
 FILE: 'Hwa\hwa_uart.c'
   94: UINT8 comfun_0x00(void)
   95: {
   96:     pMoney->money = 0;
   97:     if(hwa_mifareWriteSector(gBuff, s_System.Sector))
001210 5130              ACALL    ?L?COM004B
001212 E4                CLR      A
001213 F5F0              MOV      B,A
001215 120276            LCALL    ?C?ISTPTR
   98:     {
001218 120709            LCALL    ?L?COM0014
00121B 120F1F            LCALL    ?L?COM004F
00121E 500E              JNC      ?C0011?HWA_UART
   99:         s_comTxBuff.expand = TRUE;
  100:         s_comTxBuff.std_dat.dat[0] = pMoney->money/100;
001220 514B              ACALL    ?L?COM0001
001222 C006              PUSH     AR6
001224 C007              PUSH     AR7
001226 51A6              ACALL    ?L?COM0022
001228 D007              POP      AR7
00122A D006              POP      AR6
00122C 8015              SJMP     ?L?COM0043
  101:         s_comTxBuff.std_dat.dat[1] = pMoney->money%100;
  102:         s_comTxBuff.std_dat.dat[2] = gCard_UID[0];
  103:         s_comTxBuff.std_dat.dat[3] = gCard_UID[1];
  104:         s_comTxBuff.std_dat.dat[4] = gCard_UID[2];
  105:         s_comTxBuff.std_dat.dat[5] = gCard_UID[3];
  106:         s_comTxBuff.std_dat.dat[6] = gCard_UID[4];
  107:         s_comTxBuff.std_dat.len = 9;
  108:         buzzer_SoundNumber(1);
  109:         led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
  110:         return CE_OK;
  111:     }
00122E         ?C0011?HWA_UART:
  112:     buzzer_SoundNumber(2);
00122E 80D3              SJMP     ?L?COM005C
  113:     return CE_ERROR;
----- FUNCTION comfun_0x00 (END) -------


----- FUNCTION ?L?COM004B (BEGIN) -----
001230 AB08              MOV      R3,pMoney
001232 AA09              MOV      R2,pMoney+01H
001234 A90A              MOV      R1,pMoney+02H
001236 22                RET      
----- FUNCTION ?L?COM004B (END) -------


----- FUNCTION comfun_0x01 (BEGIN) -----
 FILE: 'Hwa\hwa_uart.c'
  116: UINT8 comfun_0x01(void)
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 57


  117: {
  118: 	s_comTxBuff.expand = TRUE;
  119:     s_comTxBuff.std_dat.dat[0] = pMoney->money/100;
001237 514B              ACALL    ?L?COM0001
001239 C006              PUSH     AR6
00123B C007              PUSH     AR7
00123D 51A6              ACALL    ?L?COM0022
00123F D007              POP      AR7
001241 D006              POP      AR6
;----                  JMP      ?L?COM0043
  120:     s_comTxBuff.std_dat.dat[1] = pMoney->money%100;
  121:     s_comTxBuff.std_dat.dat[2] = gCard_UID[0];
  122:     s_comTxBuff.std_dat.dat[3] = gCard_UID[1];
  123:     s_comTxBuff.std_dat.dat[4] = gCard_UID[2];
  124:     s_comTxBuff.std_dat.dat[5] = gCard_UID[3];
  125:     s_comTxBuff.std_dat.dat[6] = gCard_UID[4];
  126:     s_comTxBuff.std_dat.len = 9;
  127:     buzzer_SoundNumber(1);
  128:     led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
  129:     return CE_OK;
----- FUNCTION comfun_0x01 (END) -------


----- FUNCTION ?L?COM0043 (BEGIN) -----
001243 7B08              MOV      R3,#08H
001245 12085A            LCALL    _led_ShowNumber
001248 7F00              MOV      R7,#00H
00124A 22                RET      
----- FUNCTION ?L?COM0043 (END) -------


----- FUNCTION ?L?COM0001 (BEGIN) -----
00124B 756301            MOV      s_comTxBuff+013H,#01H
00124E AB08              MOV      R3,pMoney
001250 AA09              MOV      R2,pMoney+01H
001252 A90A              MOV      R1,pMoney+02H
001254 120213            LCALL    ?C?ILDPTR
001257 FB                MOV      R3,A
001258 AAF0              MOV      R2,B
00125A 7C00              MOV      R4,#00H
00125C 7D64              MOV      R5,#064H
00125E FF                MOV      R7,A
00125F AE02              MOV      R6,AR2
001261 1201A8            LCALL    ?C?UIDIV
001264 8F57              MOV      s_comTxBuff+07H,R7
001266 7C00              MOV      R4,#00H
001268 7D64              MOV      R5,#064H
00126A AF03              MOV      R7,AR3
00126C AE02              MOV      R6,AR2
00126E 1201A8            LCALL    ?C?UIDIV
001271 8D58              MOV      s_comTxBuff+08H,R5
001273 9000D3            MOV      DPTR,#gCard_UID
001276 E0                MOVX     A,@DPTR
001277 F559              MOV      s_comTxBuff+09H,A
001279 A3                INC      DPTR
00127A E0                MOVX     A,@DPTR
00127B F55A              MOV      s_comTxBuff+0AH,A
00127D A3                INC      DPTR
00127E E0                MOVX     A,@DPTR
00127F F55B              MOV      s_comTxBuff+0BH,A
001281 A3                INC      DPTR
001282 E0                MOVX     A,@DPTR
001283 F55C              MOV      s_comTxBuff+0CH,A
001285 A3                INC      DPTR
001286 E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 58


001287 F55D              MOV      s_comTxBuff+0DH,A
001289 755509            MOV      s_comTxBuff+05H,#09H
00128C 7F01              MOV      R7,#01H
00128E 510A              ACALL    _buzzer_SoundNumber
001290         ?L?COM0002:
001290 AB08              MOV      R3,pMoney
001292 AA09              MOV      R2,pMoney+01H
001294 A90A              MOV      R1,pMoney+02H
001296 120213            LCALL    ?C?ILDPTR
001299 FB                MOV      R3,A
00129A AAF0              MOV      R2,B
00129C 7C00              MOV      R4,#00H
00129E 7D64              MOV      R5,#064H
0012A0 FF                MOV      R7,A
0012A1 AE02              MOV      R6,AR2
0012A3 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM0001 (END) -------


----- FUNCTION ?L?COM0022 (BEGIN) -----
0012A6 7C00              MOV      R4,#00H
0012A8 7D64              MOV      R5,#064H
0012AA AF03              MOV      R7,AR3
0012AC AE02              MOV      R6,AR2
0012AE 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM0022 (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: 'System\sys_task.c'
   80: void main(void)
   81: {
   82:     sys_taskInit();
   83:     buzzer_SoundNumber(1);
0012B1 51CD              ACALL    sys_taskInit
   84:     while(1)
0012B3 7F01              MOV      R7,#01H
0012B5 510A              ACALL    _buzzer_SoundNumber
0012B7         ?C0010?SYS_TASK:
   85:     {
   86:         WDT_CONTR = 0x33;          //reset watch dog      SyttemClk is 11.0592M Over Time 568.8ms
   87:         if(taskCycle10msFlag == TRUE)
0012B7 75C133            MOV      WDT_CONTR,#033H
   88:         {
0012BA 300504            JNB      taskCycle10msFlag,?C0012?SYS_TASK
   89:             taskCycle10msFlag = FALSE;
   90:             hwa_uartHandler10ms();
0012BD C205              CLR      taskCycle10msFlag
   91:         }
0012BF 11A8              ACALL    hwa_uartHandler10ms
   92:         if(taskCycle1sFlag == TRUE)
0012C1         ?C0012?SYS_TASK:
   93:         {
0012C1 3004F3            JNB      taskCycle1sFlag,?C0010?SYS_TASK
   94:         	taskCycle1sFlag = FALSE;
   95:             app_confingHandler1s();
0012C4 C204              CLR      taskCycle1sFlag
   96:             app_brushCycle1s();
0012C6 B1EF              ACALL    app_confingHandler1s
   97:         }
0012C8 120964            LCALL    app_brushCycle1s
   98:     }
   99: }
0012CB 80EA              SJMP     ?C0010?SYS_TASK
----- FUNCTION main (END) -------
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 59




----- FUNCTION sys_taskInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   28: void sys_taskInit(void)
   29: {
   30:     WDT_CONTR = 0x33;
   31:     len_Init();
0012CD 75C133            MOV      WDT_CONTR,#033H
   32:     sys_gpioInit();
0012D0 D1AC              ACALL    len_Init
   33:     buzzer_Init();
0012D2 12000A            LCALL    sys_gpioInit
   34:     hwa_uartInit();
0012D5 B1F9              ACALL    buzzer_Init
   35:     sys_tim0Init();
0012D7 51E4              ACALL    hwa_uartInit
   36:     app_configInit();
0012D9 D186              ACALL    sys_tim0Init
   37: 	app_Show();
0012DB 120A40            LCALL    app_configInit
   38:     app_brushInit();
0012DE 120822            LCALL    app_Show
;----                  JMP      app_brushInit
----- FUNCTION sys_taskInit (END) -------


----- FUNCTION app_brushInit (BEGIN) -----
 FILE: 'App\app_brush.c'
   38: void app_brushInit(void)
   39: {
   40: 	Init_FM1702();
   41: }
0012E1 0204DB            LJMP     Init_FM1702
----- FUNCTION app_brushInit (END) -------


----- FUNCTION hwa_uartInit (BEGIN) -----
 FILE: 'Hwa\hwa_uart.c'
   55: void hwa_uartInit(void)
;----                  JMP      sys_uartInit
   56: {
----- FUNCTION hwa_uartInit (END) -------


----- FUNCTION sys_uartInit (BEGIN) -----
 FILE: 'System\sys_uart.c'
   37: void sys_uartInit(void)
   38: {
   39: //    sys_uartSetChannel(2);
   40:     SCON = 0x50;                    //8位可变波特率
0012E4 759850            MOV      SCON,#050H
   41:     T2L = (65536 - (FOSC/4/BAUD));  //设置波特率重装值
0012E7 75D7C0            MOV      T2L,#0C0H
   42:     T2H = (65536 - (FOSC/4/BAUD))>>8;
0012EA 75D6FD            MOV      T2H,#0FDH
   43:     AUXR |= 0x14;                   //T2为1T模式, 并启动定时器2
0012ED 438E14            ORL      AUXR,#014H
   44:     AUXR |= 0x01;                   //选择定时器2为串口1的波特率发生器
0012F0 438E01            ORL      AUXR,#01H
   45:     ES = 1;                         //使能串口1中断
0012F3 D2AC              SETB     ES
   46:     EA = 1;
0012F5 D2AF              SETB     EA
   47: }
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 60


0012F7 22                RET      
----- FUNCTION sys_uartInit (END) -------


----- FUNCTION _hwa_mifareDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   44: void hwa_mifareDecrypt(UINT8 *pData)        //利用卡ID解密
   45: {
0012F8 90004E            MOV      DPTR,#pData
0012FB 120DC9            LCALL    ?L?COM0004
   46: 	UINT8 i, j;
   47: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
0012FE E4                CLR      A
0012FF FE                MOV      R6,A
001300         ?C0011?HWA_MIFARE:
   48: 	{
   49: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
001300 7D04              MOV      R5,#04H
001302         ?C0014?HWA_MIFARE:
   50: 		{
   51: 			pData[i] = _crol_(pData[i], 1);
001302 90004E            MOV      DPTR,#pData
001305 120D64            LCALL    ?L?COM0008
001308 1185              ACALL    ?L?COM001E
00130A FF                MOV      R7,A
00130B 7801              MOV      R0,#01H
00130D 08                INC      R0
00130E 8001              SJMP     ?C0074?HWA_MIFARE
001310         ?C0073?HWA_MIFARE:
001310 23                RL       A
001311         ?C0074?HWA_MIFARE:
001311 D8FD              DJNZ     R0,?C0073?HWA_MIFARE
001313 B1DF              ACALL    ?L?COM0053
   52: 			pData[i] ^= gCard_UID[i % 5];
001315 E9                MOV      A,R1
001316 B1C5              ACALL    ?L?COM0017
001318 E0                MOVX     A,@DPTR
001319 6F                XRL      A,R7
00131A 120162            LCALL    ?C?CSTPTR
   53: 		}
00131D DDE3              DJNZ     R5,?C0014?HWA_MIFARE
   54: 	}
00131F         ?C0013?HWA_MIFARE:
00131F 0E                INC      R6
001320 EE                MOV      A,R6
001321 B404DC            CJNE     A,#04H,?C0011?HWA_MIFARE
   55: }
001324 22                RET      
----- FUNCTION _hwa_mifareDecrypt (END) -------


----- FUNCTION hwa_mifareCheckBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  120: void hwa_mifareCheckBlock(void)
  121: {
  122: 	UINT16 crc, crcBak;
  123: 	hwa_mifareDecrypt((UINT8*)&s_NormalBuff);        //利用卡ID解密
001325 71B7              ACALL    ?L?COM001D
001327 51F8              ACALL    _hwa_mifareDecrypt
  124: 	crc = hwa_mifareCheckOut((UINT8*)&s_NormalBuff, USE_DATA_BLOCK_LEN);
001329 71B7              ACALL    ?L?COM001D
;---- Variable 'crc' assigned to Register 'R4/R5' ----
00132B 716C              ACALL    ?L?COM0036
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 61


00132D AC06              MOV      R4,AR6
  125: 	if (crc == (s_NormalBuff.crc[0] << 8 | s_NormalBuff.crc[1]))
00132F 900087            MOV      DPTR,#s_NormalBuff+02H
001332 E0                MOVX     A,@DPTR
001333 FE                MOV      R6,A
001334 A3                INC      DPTR
001335 E0                MOVX     A,@DPTR
001336 FB                MOV      R3,A
001337 EB                MOV      A,R3
001338 B50508            CJNE     A,AR5,?C0040?HWA_MIFARE
00133B EE                MOV      A,R6
00133C B50404            CJNE     A,AR4,?C0040?HWA_MIFARE
  126: 	{
  127: 		NormalErrorFlag = FALSE;
00133F C207              CLR      NormalErrorFlag
  128: 	}
001341 8002              SJMP     ?C0041?HWA_MIFARE
001343         ?C0040?HWA_MIFARE:
  129: 	else
  130: 	{
  131: 		NormalErrorFlag = TRUE;
001343 D207              SETB     NormalErrorFlag
  132: 	}
001345         ?C0041?HWA_MIFARE:
  133: 	hwa_mifareDecrypt((UINT8*)&s_BackupBuff);        //利用卡ID解密
001345 7165              ACALL    ?L?COM0029
001347 51F8              ACALL    _hwa_mifareDecrypt
  134: 	crcBak = hwa_mifareCheckOut((UINT8*)&s_BackupBuff, USE_DATA_BLOCK_LEN);
001349 7165              ACALL    ?L?COM0029
;---- Variable 'crcBak' assigned to Register 'R4/R5' ----
00134B 716C              ACALL    ?L?COM0036
00134D AC06              MOV      R4,AR6
  135: 	if (crcBak == (s_BackupBuff.crc[0] << 8 | s_BackupBuff.crc[1]))
00134F 900077            MOV      DPTR,#s_BackupBuff+02H
001352 E0                MOVX     A,@DPTR
001353 FE                MOV      R6,A
001354 A3                INC      DPTR
001355 E0                MOVX     A,@DPTR
001356 FB                MOV      R3,A
001357 EB                MOV      A,R3
001358 B50507            CJNE     A,AR5,?C0042?HWA_MIFARE
00135B EE                MOV      A,R6
00135C B50403            CJNE     A,AR4,?C0042?HWA_MIFARE
  136: 	{
  137: 		BackupErrorFlag = FALSE;
00135F C206              CLR      BackupErrorFlag
  138: 	}
001361 22                RET      
001362         ?C0042?HWA_MIFARE:
  139: 	else
  140: 	{
  141: 		BackupErrorFlag = TRUE;
001362 D206              SETB     BackupErrorFlag
  142: 	}
  143: }
001364 22                RET      
----- FUNCTION hwa_mifareCheckBlock (END) -------


----- FUNCTION ?L?COM0029 (BEGIN) -----
001365 7B01              MOV      R3,#01H
001367 7A00              MOV      R2,#HIGH s_BackupBuff
001369 7975              MOV      R1,#LOW s_BackupBuff
00136B 22                RET      
----- FUNCTION ?L?COM0029 (END) -------
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 62




----- FUNCTION ?L?COM0036 (BEGIN) -----
00136C 7D02              MOV      R5,#02H
00136E 7C00              MOV      R4,#00H
001370 7175              ACALL    _hwa_mifareCheckOut
001372 AD07              MOV      R5,AR7
001374 22                RET      
----- FUNCTION ?L?COM0036 (END) -------


----- FUNCTION _hwa_mifareCheckOut (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   97: UINT16 hwa_mifareCheckOut(UINT8 *dat, UINT16 len)
   98: {
001375 900055            MOV      DPTR,#dat
001378 120DC9            LCALL    ?L?COM0004
;---- Variable 'crc' assigned to Register 'R6/R7' ----
00137B D147              ACALL    ?L?COM0049
00137D         ?C0032?HWA_MIFARE:
   99: 	UINT16 crc = 0xFFFF;
  100:     UINT8 i;
  101:     while(len--)
00137D 900058            MOV      DPTR,#len
001380 D161              ACALL    ?L?COM002B
001382 602D              JZ       ?C0033?HWA_MIFARE
  102:     {
  103:         crc = crc ^*dat++;
001384 900055            MOV      DPTR,#dat
001387 914C              ACALL    ?L?COM000A
001389 FD                MOV      R5,A
00138A ED                MOV      A,R5
00138B 6F                XRL      A,R7
00138C FF                MOV      R7,A
  104:         for ( i = 0; i < 8; i++)
00138D E4                CLR      A
00138E 90005A            MOV      DPTR,#i
001391 F0                MOVX     @DPTR,A
001392         ?C0034?HWA_MIFARE:
001392 90005A            MOV      DPTR,#i
001395 E0                MOVX     A,@DPTR
001396 C3                CLR      C
001397 9408              SUBB     A,#08H
001399 50E2              JNC      ?C0032?HWA_MIFARE
  105:         {
  106:             if( ( crc & 0x0001) > 0)
00139B D13D              ACALL    ?L?COM004C
00139D 4004              JC       ?C0037?HWA_MIFARE
  107:             {
  108:                 crc = crc >> 1;
00139F D178              ACALL    ?L?COM003A
  109:                 crc = crc ^ 0xa001;
  110:             }
0013A1 8006              SJMP     ?C0036?HWA_MIFARE
0013A3         ?C0037?HWA_MIFARE:
  111:             else
  112:             {
  113:                 crc = crc >> 1;
0013A3 C3                CLR      C
0013A4 13                RRC      A
0013A5 FE                MOV      R6,A
0013A6 EF                MOV      A,R7
0013A7 13                RRC      A
0013A8 FF                MOV      R7,A
  114:             }
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 63


  115:         }
0013A9         ?C0036?HWA_MIFARE:
0013A9 90005A            MOV      DPTR,#i
0013AC E0                MOVX     A,@DPTR
0013AD 04                INC      A
0013AE F0                MOVX     @DPTR,A
0013AF 80E1              SJMP     ?C0034?HWA_MIFARE
  116:     }
0013B1         ?C0033?HWA_MIFARE:
  117:     return ( crc );
  118: }
0013B1 22                RET      
----- FUNCTION _hwa_mifareCheckOut (END) -------


----- FUNCTION ?L?COM001B (BEGIN) -----
0013B2 90004E            MOV      DPTR,#sector
0013B5         ?L?COM001C:
0013B5 EF                MOV      A,R7
0013B6 F0                MOVX     @DPTR,A
0013B7         ?L?COM001D:
0013B7 7B01              MOV      R3,#01H
0013B9 7A00              MOV      R2,#HIGH s_NormalBuff
0013BB 7985              MOV      R1,#LOW s_NormalBuff
0013BD 22                RET      
----- FUNCTION ?L?COM001B (END) -------


----- FUNCTION _hwa_mifareRecoveryNewCard (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  172: static void hwa_mifareRecoveryNewCard(UINT8 sector)
  173: {
0013BE 71B2              ACALL    ?L?COM001B
0013C0 91D4              ACALL    ?L?COM0058
0013C2 7002              JNZ      ?C0077?HWA_MIFARE
0013C4 A3                INC      DPTR
0013C5 E0                MOVX     A,@DPTR
0013C6         ?C0077?HWA_MIFARE:
0013C6 700E              JNZ      ?C0048?HWA_MIFARE
0013C8 900087            MOV      DPTR,#s_NormalBuff+02H
0013CB E0                MOVX     A,@DPTR
0013CC 7008              JNZ      ?C0048?HWA_MIFARE
0013CE A3                INC      DPTR
0013CF E0                MOVX     A,@DPTR
0013D0 7004              JNZ      ?C0048?HWA_MIFARE
  174:     hwa_mifareEncrypt((UINT8*)&s_NormalBuff);             //旧卡由于未加密，校验时进行了解密操作，故此时利用卡ID
>> 用
  175: 	if (s_NormalBuff.money == 0
  176: 		&& s_NormalBuff.crc[0] == 0
  177: 		&& s_NormalBuff.crc[1] == 0
  178: 		)
  179: 	{
  180: 		hwa_mifareWriteSector((UINT8*)&s_NormalBuff, sector);
0013D2 71B7              ACALL    ?L?COM001D
0013D4 8016              SJMP     ?C0082?HWA_MIFARE
  181: 		return;
  182: 	}
0013D6         ?C0048?HWA_MIFARE:
  183:     hwa_mifareEncrypt((UINT8*)&s_BackupBuff);             //旧卡由于未加密，校验时进行了解密操作，故此时利用卡ID
>> 用
0013D6 7165              ACALL    ?L?COM0029
0013D8 91CC              ACALL    ?L?COM0056
0013DA 7002              JNZ      ?C0078?HWA_MIFARE
0013DC A3                INC      DPTR
0013DD E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 64


0013DE         ?C0078?HWA_MIFARE:
0013DE 700E              JNZ      ?C0049?HWA_MIFARE
0013E0 900077            MOV      DPTR,#s_BackupBuff+02H
0013E3 E0                MOVX     A,@DPTR
0013E4 7008              JNZ      ?C0049?HWA_MIFARE
0013E6 A3                INC      DPTR
0013E7 E0                MOVX     A,@DPTR
0013E8 7004              JNZ      ?C0049?HWA_MIFARE
  184: 	if (s_BackupBuff.money == 0
  185: 		&& s_BackupBuff.crc[0] == 0
  186: 		&& s_BackupBuff.crc[1] == 0
  187: 		)
  188: 	{
  189: 		hwa_mifareWriteSector((UINT8*)&s_BackupBuff, sector);
0013EA 7165              ACALL    ?L?COM0029
0013EC         
0013EC 91C4              ACALL    ?L?COM0052
  190: 		return;
  191: 	}
  192: }
0013EE         ?C0049?HWA_MIFARE:
0013EE 22                RET      
----- FUNCTION _hwa_mifareRecoveryNewCard (END) -------


----- FUNCTION _hwa_mifareRecoveryOldCard (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  145: static void hwa_mifareRecoveryOldCard(UINT8 sector)
  146: {
0013EF 71B2              ACALL    ?L?COM001B
0013F1 91D4              ACALL    ?L?COM0058
0013F3 90004F            MOV      DPTR,#money
0013F6 F0                MOVX     @DPTR,A
  147: 	UINT8 money;
  148:     hwa_mifareEncrypt((UINT8*)&s_NormalBuff);             //旧卡由于未加密，校验时进行了解密操作，故此时利用卡ID
>> 用
  149: 	money = *(UINT8*)&s_NormalBuff;
  150: 	if (money != 0xFF && money <= 200
0013F7 F4                CPL      A
0013F8 601D              JZ       ?C0045?HWA_MIFARE
0013FA E0                MOVX     A,@DPTR
0013FB FF                MOV      R7,A
0013FC D3                SETB     C
0013FD 94C8              SUBB     A,#0C8H
0013FF 5016              JNC      ?C0045?HWA_MIFARE
001401 900087            MOV      DPTR,#s_NormalBuff+02H
001404 E0                MOVX     A,@DPTR
001405 7010              JNZ      ?C0045?HWA_MIFARE
001407 A3                INC      DPTR
001408 E0                MOVX     A,@DPTR
001409 700C              JNZ      ?C0045?HWA_MIFARE
  151: 		&& s_NormalBuff.crc[0] == 0
  152: 		&& s_NormalBuff.crc[1] == 0
  153: 		)
  154: 	{
  155: 		s_NormalBuff.money = (UINT16)money * 100;
00140B 9142              ACALL    ?L?COM005D
00140D 900085            MOV      DPTR,#s_NormalBuff
001410 EE                MOV      A,R6
001411 F0                MOVX     @DPTR,A
001412 A3                INC      DPTR
001413 71B5              ACALL    ?L?COM001C
001415 8028              SJMP     ?C0081?HWA_MIFARE
  156: 		hwa_mifareWriteSector((UINT8*)&s_NormalBuff, sector);
  157: 		return;
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 65


  158: 	}
001417         ?C0045?HWA_MIFARE:
  159:     hwa_mifareEncrypt((UINT8*)&s_BackupBuff);             //旧卡由于未加密，校验时进行了解密操作，故此时利用卡ID
>> 用
001417 7165              ACALL    ?L?COM0029
001419 91CC              ACALL    ?L?COM0056
00141B 90004F            MOV      DPTR,#money
00141E F0                MOVX     @DPTR,A
  160: 	money = *(UINT8*)&s_BackupBuff;
  161: 	if (money != 0xFF && money <= 200
00141F F4                CPL      A
001420 601F              JZ       ?C0046?HWA_MIFARE
001422 E0                MOVX     A,@DPTR
001423 FF                MOV      R7,A
001424 D3                SETB     C
001425 94C8              SUBB     A,#0C8H
001427 5018              JNC      ?C0046?HWA_MIFARE
001429 900077            MOV      DPTR,#s_BackupBuff+02H
00142C E0                MOVX     A,@DPTR
00142D 7012              JNZ      ?C0046?HWA_MIFARE
00142F A3                INC      DPTR
001430 E0                MOVX     A,@DPTR
001431 700E              JNZ      ?C0046?HWA_MIFARE
  162: 		&& s_BackupBuff.crc[0] == 0
  163: 		&& s_BackupBuff.crc[1] == 0
  164: 		)
  165: 	{
  166: 		s_BackupBuff.money = (UINT16)money * 100;
001433 9142              ACALL    ?L?COM005D
001435 900075            MOV      DPTR,#s_BackupBuff
001438 EE                MOV      A,R6
001439 F0                MOVX     @DPTR,A
00143A A3                INC      DPTR
00143B EF                MOV      A,R7
00143C F0                MOVX     @DPTR,A
  167: 		hwa_mifareWriteSector((UINT8*)&s_BackupBuff, sector);
00143D 7165              ACALL    ?L?COM0029
00143F         
00143F 91C4              ACALL    ?L?COM0052
  168: 		return;
  169: 	}
  170: }
001441         ?C0046?HWA_MIFARE:
001441 22                RET      
----- FUNCTION _hwa_mifareRecoveryOldCard (END) -------


----- FUNCTION ?L?COM005D (BEGIN) -----
001442 FE                MOV      R6,A
001443 FC                MOV      R4,A
001444 7D64              MOV      R5,#064H
001446 020196            LJMP     ?C?IMUL
----- FUNCTION ?L?COM005D (END) -------


----- FUNCTION ?L?COM0009 (BEGIN) -----
001449 900040            MOV      DPTR,#p
00144C         ?L?COM000A:
00144C E0                MOVX     A,@DPTR
00144D FB                MOV      R3,A
00144E A3                INC      DPTR
00144F E4                CLR      A
001450 75F001            MOV      B,#01H
001453 1201FD            LCALL    ?C?ILDIX
001456 A9F0              MOV      R1,B
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 66


001458 FA                MOV      R2,A
001459 02011C            LJMP     ?C?CLDPTR
----- FUNCTION ?L?COM0009 (END) -------


----- FUNCTION hwa_uartHandler1ms (BEGIN) -----
 FILE: 'Hwa\hwa_uart.c'
   60: void hwa_uartHandler1ms(void)
   61: {
   62: 	UINT8 i;
   63:     UINT8* p = comRxBuff;
00145C 900040            MOV      DPTR,#p
00145F E4                CLR      A
001460 F0                MOVX     @DPTR,A
001461 A3                INC      DPTR
001462 7400              MOV      A,#HIGH comRxBuff
001464 F0                MOVX     @DPTR,A
001465 A3                INC      DPTR
001466 7422              MOV      A,#LOW comRxBuff
001468 F0                MOVX     @DPTR,A
   64: 	if(sys_uartOverTime1ms()!=FALSE)
001469 D196              ACALL    sys_uartOverTime1ms
00146B EF                MOV      A,R7
00146C 6055              JZ       ?C0010?HWA_UART
   65: 	{
   66: 		comRxLen = sys_uartReadData(comRxBuff);
00146E 7B00              MOV      R3,#00H
001470 7A00              MOV      R2,#HIGH comRxBuff
001472 7922              MOV      R1,#LOW comRxBuff
001474 91DC              ACALL    _sys_uartReadData
001476 8F40              MOV      comRxLen,R7
   67:         s_comRxBuff.head = *p++;
001478 9149              ACALL    ?L?COM0009
00147A F541              MOV      s_comRxBuff,A
   68:         s_comRxBuff.len = *p++;
00147C 9149              ACALL    ?L?COM0009
00147E F542              MOV      s_comRxBuff+01H,A
   69:         s_comRxBuff.cmd = *p++;
001480 9149              ACALL    ?L?COM0009
001482 F543              MOV      s_comRxBuff+02H,A
   70:         for(i=0; i<s_comRxBuff.len-2; i++)
;---- Variable 'i' assigned to Register 'R7' ----
001484 E4                CLR      A
001485 FF                MOV      R7,A
001486         ?C0003?HWA_UART:
001486 E542              MOV      A,s_comRxBuff+01H
001488 24FE              ADD      A,#0FEH
00148A FE                MOV      R6,A
00148B EF                MOV      A,R7
00148C C3                CLR      C
00148D 9E                SUBB     A,R6
00148E 5012              JNC      ?C0007?HWA_UART
   71:         {
   72:             if(i < MAX_DATA_LEN)
001490 EF                MOV      A,R7
001491 C3                CLR      C
001492 940A              SUBB     A,#0AH
001494 5009              JNC      ?C0005?HWA_UART
   73:             {
   74:                 s_comRxBuff.dat[i] = *p++;
001496 9149              ACALL    ?L?COM0009
001498 FE                MOV      R6,A
001499 7444              MOV      A,#LOW s_comRxBuff+03H
00149B 2F                ADD      A,R7
00149C F8                MOV      R0,A
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 67


00149D A606              MOV      @R0,AR6
   75:             }
   76:         }
00149F         ?C0005?HWA_UART:
00149F 0F                INC      R7
0014A0 80E4              SJMP     ?C0003?HWA_UART
   77:         for(; i<MAX_DATA_LEN; i++)
0014A2         ?C0007?HWA_UART:
0014A2 EF                MOV      A,R7
0014A3 C3                CLR      C
0014A4 940A              SUBB     A,#0AH
0014A6 5009              JNC      ?C0008?HWA_UART
   78:         {
   79:             s_comRxBuff.dat[i] = 0x00;
0014A8 7444              MOV      A,#LOW s_comRxBuff+03H
0014AA 2F                ADD      A,R7
0014AB F8                MOV      R0,A
0014AC E4                CLR      A
0014AD F6                MOV      @R0,A
   80:         }
0014AE 0F                INC      R7
0014AF 80F1              SJMP     ?C0007?HWA_UART
0014B1         ?C0008?HWA_UART:
   81:         s_comRxBuff.check = comRxBuff[s_comRxBuff.len+1];
0014B1 7423              MOV      A,#LOW comRxBuff+01H
0014B3 2542              ADD      A,s_comRxBuff+01H
0014B5 F8                MOV      R0,A
0014B6 E6                MOV      A,@R0
0014B7 F54E              MOV      s_comRxBuff+0DH,A
   82:         s_comRxBuff.end = comRxBuff[s_comRxBuff.len+2];
0014B9 7424              MOV      A,#LOW comRxBuff+02H
0014BB 2542              ADD      A,s_comRxBuff+01H
0014BD F8                MOV      R0,A
0014BE E6                MOV      A,@R0
0014BF F54F              MOV      s_comRxBuff+0EH,A
   83:         comRxFalg = TRUE;
0014C1 D208              SETB     comRxFalg
   84: 	}
   85: }
0014C3         ?C0010?HWA_UART:
0014C3 22                RET      
----- FUNCTION hwa_uartHandler1ms (END) -------


----- FUNCTION ?L?COM0052 (BEGIN) -----
0014C4 90004E            MOV      DPTR,#sector
0014C7 E0                MOVX     A,@DPTR
0014C8 FD                MOV      R5,A
0014C9 020F24            LJMP     _hwa_mifareWriteSector
----- FUNCTION ?L?COM0052 (END) -------


----- FUNCTION ?L?COM0056 (BEGIN) -----
0014CC 120F85            LCALL    _hwa_mifareEncrypt
0014CF 900075            MOV      DPTR,#s_BackupBuff
0014D2 E0                MOVX     A,@DPTR
0014D3 22                RET      
----- FUNCTION ?L?COM0056 (END) -------


----- FUNCTION ?L?COM0058 (BEGIN) -----
0014D4 120F85            LCALL    _hwa_mifareEncrypt
0014D7 900085            MOV      DPTR,#s_NormalBuff
0014DA E0                MOVX     A,@DPTR
0014DB 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 68


----- FUNCTION ?L?COM0058 (END) -------


----- FUNCTION _sys_uartReadData (BEGIN) -----
 FILE: 'System\sys_uart.c'
  107: UINT8 sys_uartReadData(UINT8 *pData)
  108: {
0014DC 900043            MOV      DPTR,#pData
0014DF 120DC9            LCALL    ?L?COM0004
  109: 	UINT8 len = u8_RxIndex;
  110: 	memcpy(pData, RxBuff, len);
0014E2 9000B8            MOV      DPTR,#u8_RxIndex
0014E5 E0                MOVX     A,@DPTR
0014E6 FF                MOV      R7,A
0014E7 900046            MOV      DPTR,#len
0014EA F0                MOVX     @DPTR,A
  111: 	memset(RxBuff, 0x00, RX_BUFF_LEN);
0014EB 7E00              MOV      R6,#00H
0014ED 900043            MOV      DPTR,#pData
0014F0 120D64            LCALL    ?L?COM0008
0014F3 B1E7              ACALL    ?L?COM0059
0014F5 7A00              MOV      R2,#HIGH RxBuff
0014F7 79A9              MOV      R1,#LOW RxBuff
0014F9 1200F6            LCALL    ?C?COPY
  112: 	u8_RxIndex = 0;
0014FC 7E00              MOV      R6,#00H
0014FE 7F0F              MOV      R7,#0FH
001500 7D00              MOV      R5,#00H
001502 7B01              MOV      R3,#01H
001504 7A00              MOV      R2,#HIGH RxBuff
001506 79A9              MOV      R1,#LOW RxBuff
001508 120363            LCALL    ?C?MEMSET
  113: 	u8_BoudOverTime = 0;
00150B E4                CLR      A
00150C 9000B8            MOV      DPTR,#u8_RxIndex
00150F F0                MOVX     @DPTR,A
  114: 	b_RxFlag = FALSE;
001510 9000A8            MOV      DPTR,#u8_BoudOverTime
001513 F0                MOVX     @DPTR,A
  115: 	return len;
001514 C20A              CLR      b_RxFlag
  116: }
001516 900046            MOV      DPTR,#len
001519 E0                MOVX     A,@DPTR
00151A FF                MOV      R7,A
  117: 
00151B 22                RET      
----- FUNCTION _sys_uartReadData (END) -------


----- FUNCTION app_brushCard (BEGIN) -----
 FILE: 'App\app_brush.c'
   48: UINT8 app_brushCard(void)
   49: {
   50: 	UINT8 Sector;
   51: 	UINT8 CardIndex;
   52:     UINT8 i;
   53: 	for (CardIndex = MEM_CARD; CardIndex <= PWD_CARD; CardIndex++)
00151C 900049            MOV      DPTR,#CardIndex
00151F 7401              MOV      A,#01H
001521 F0                MOVX     @DPTR,A
001522         ?C0005?APP_BRUSH:
   54: 	{
   55: 		if (b_FactorySystem)
001522 300C06            JNB      b_FactorySystem,?C0008?APP_BRUSH
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 69


   56: 		{
   57: 			CardIndex = PWD_CARD;
001525 900049            MOV      DPTR,#CardIndex
001528 7403              MOV      A,#03H
00152A F0                MOVX     @DPTR,A
   58: 		}
00152B         ?C0008?APP_BRUSH:
   59: 		if (CardIndex == MEM_CARD)
00152B 900049            MOV      DPTR,#CardIndex
00152E E0                MOVX     A,@DPTR
00152F B40108            CJNE     A,#01H,?C0009?APP_BRUSH
   60: 		{
   61: 			Load_Key(&s_System.MGM_Card);
001532 7B01              MOV      R3,#01H
001534 7A00              MOV      R2,#HIGH s_System
001536 79C0              MOV      R1,#LOW s_System
   62: 		}
001538 801C              SJMP     ?C0041?APP_BRUSH
00153A         ?C0009?APP_BRUSH:
   63: 		else if (CardIndex == USER_CARD)
00153A 900049            MOV      DPTR,#CardIndex
00153D E0                MOVX     A,@DPTR
00153E B40208            CJNE     A,#02H,?C0011?APP_BRUSH
   64: 		{
   65: 			Load_Key(&s_System.USER_Card);
001541 7B01              MOV      R3,#01H
001543 7A00              MOV      R2,#HIGH s_System+0AH
001545 79CA              MOV      R1,#LOW s_System+0AH
001547         
   66: 		}
001547 800D              SJMP     ?C0041?APP_BRUSH
001549         ?C0011?APP_BRUSH:
   67: 		else if (CardIndex == PWD_CARD)
001549 900049            MOV      DPTR,#CardIndex
00154C E0                MOVX     A,@DPTR
00154D B40308            CJNE     A,#03H,?C0010?APP_BRUSH
   68: 		{
   69: 			Load_Key(PWD_Card);
001550 7BFF              MOV      R3,#0FFH
001552 7A00              MOV      R2,#HIGH PWD_Card
001554 7903              MOV      R1,#LOW PWD_Card
001556         
001556 1105              ACALL    _Load_Key
   70: 		}
001558         ?C0010?APP_BRUSH:
   71: 		MIF_Halt();
001558 1207B7            LCALL    MIF_Halt
   72: 		if (Request(RF_CMD_REQUEST_STD) != FM1702_OK)
00155B 7F26              MOV      R7,#026H
00155D 12064D            LCALL    _Request
001560 EF                MOV      A,R7
001561 7051              JNZ      ?C0007?APP_BRUSH
   73: 		{
   74: 			continue;
   75: 		}
001563         ?C0014?APP_BRUSH:
   76:         for(i=0; i<2; i++)
001563 E4                CLR      A
001564 90004A            MOV      DPTR,#i
001567 F0                MOVX     @DPTR,A
001568         ?C0015?APP_BRUSH:
   77:         {
   78:             if (AntiColl() == FM1702_OK && SelectCard() == FM1702_OK)
001568 12059A            LCALL    AntiColl
00156B EF                MOV      A,R7
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 70


00156C 703A              JNZ      ?C0017?APP_BRUSH
00156E 1206A8            LCALL    SelectCard
001571 EF                MOV      A,R7
001572 7034              JNZ      ?C0017?APP_BRUSH
   79:             {
   80:                 if (CardIndex == USER_CARD)     //用户卡验证钱所在扇区
001574 900049            MOV      DPTR,#CardIndex
001577 E0                MOVX     A,@DPTR
001578 B4020A            CJNE     A,#02H,?C0019?APP_BRUSH
   81:                 {
   82:                     Sector = s_System.Sector;
00157B 9000C6            MOV      DPTR,#s_System+06H
00157E E0                MOVX     A,@DPTR
00157F 900048            MOV      DPTR,#Sector
001582 F0                MOVX     @DPTR,A
   83:                 }
001583 8006              SJMP     ?C0020?APP_BRUSH
001585         ?C0019?APP_BRUSH:
   84:                 else                            //管理和密码卡验证1扇区
   85:                 {
   86:                     Sector = 1;
001585 900048            MOV      DPTR,#Sector
001588 7401              MOV      A,#01H
00158A F0                MOVX     @DPTR,A
   87:                 }
00158B         ?C0020?APP_BRUSH:
   88:                 if (Authentication(gCard_UID, Sector, 0x60) == FM1702_OK)
00158B 7B01              MOV      R3,#01H
00158D 7A00              MOV      R2,#HIGH gCard_UID
00158F 79D3              MOV      R1,#LOW gCard_UID
001591 900048            MOV      DPTR,#Sector
001594 E0                MOVX     A,@DPTR
001595 FD                MOV      R5,A
001596 90004F            MOV      DPTR,#?_Authentication?BYTE+04H
001599 7460              MOV      A,#060H
00159B F0                MOVX     @DPTR,A
00159C 120710            LCALL    _Authentication
00159F EF                MOV      A,R7
0015A0 7006              JNZ      ?C0017?APP_BRUSH
   89:                 {
   90:                     return CardIndex;
0015A2 900049            MOV      DPTR,#CardIndex
0015A5 E0                MOVX     A,@DPTR
0015A6 FF                MOV      R7,A
0015A7 22                RET      
   91:                 }
   92:             }
   93:         }
0015A8         ?C0017?APP_BRUSH:
0015A8 90004A            MOV      DPTR,#i
0015AB E0                MOVX     A,@DPTR
0015AC 04                INC      A
0015AD F0                MOVX     @DPTR,A
0015AE E0                MOVX     A,@DPTR
0015AF C3                CLR      C
0015B0 9402              SUBB     A,#02H
0015B2 40B4              JC       ?C0015?APP_BRUSH
   94: 	}
0015B4         ?C0007?APP_BRUSH:
0015B4 900049            MOV      DPTR,#CardIndex
0015B7 E0                MOVX     A,@DPTR
0015B8 04                INC      A
0015B9 F0                MOVX     @DPTR,A
0015BA E0                MOVX     A,@DPTR
0015BB D3                SETB     C
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 71


0015BC 9403              SUBB     A,#03H
0015BE 5002              JNC      $ + 4H
0015C0 A122              AJMP     ?C0005?APP_BRUSH
0015C2         ?C0006?APP_BRUSH:
   95: 	return NONE_CARD;
0015C2 7F00              MOV      R7,#00H
   96: }
0015C4 22                RET      
----- FUNCTION app_brushCard (END) -------


----- FUNCTION ?L?COM0017 (BEGIN) -----
0015C5 2E                ADD      A,R6
0015C6 F9                MOV      R1,A
0015C7 E4                CLR      A
0015C8 3A                ADDC     A,R2
0015C9 FA                MOV      R2,A
0015CA 12011C            LCALL    ?C?CLDPTR
0015CD FF                MOV      R7,A
0015CE EE                MOV      A,R6
0015CF 75F005            MOV      B,#05H
0015D2 84                DIV      AB
0015D3 74D3              MOV      A,#LOW gCard_UID
0015D5 25F0              ADD      A,B
0015D7         ?L?COM0018:
0015D7 F582              MOV      DPL,A
0015D9 E4                CLR      A
0015DA 3400              ADDC     A,#HIGH gCard_UID
0015DC F583              MOV      DPH,A
0015DE 22                RET      
----- FUNCTION ?L?COM0017 (END) -------


----- FUNCTION ?L?COM0053 (BEGIN) -----
0015DF 8E82              MOV      DPL,R6
0015E1 758300            MOV      DPH,#00H
0015E4 020174            LJMP     ?C?CSTOPTR
----- FUNCTION ?L?COM0053 (END) -------


----- FUNCTION ?L?COM0059 (BEGIN) -----
0015E7 F8                MOV      R0,A
0015E8 AC02              MOV      R4,AR2
0015EA AD03              MOV      R5,AR3
0015EC 7B01              MOV      R3,#01H
0015EE 22                RET      
----- FUNCTION ?L?COM0059 (END) -------


----- FUNCTION app_confingHandler1s (BEGIN) -----
 FILE: 'App\app_config.c'
  113: void app_confingHandler1s(void)
  114: {
  115:     led_Switch(OFF);
  116: //    hwa_eepromReadSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
0015EF C201              CLR      ?led_Switch?BIT
0015F1 120A35            LCALL    led_Switch
  117: //    sys_uartSendData((UINT8*)&USER_Card_ID, 5);
  118: //    USER_Card_ID[0][0]++;
  119: //    hwa_eepromWriteSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
  120:     led_Switch(ON);
0015F4 D201              SETB     ?led_Switch?BIT
0015F6 020A35            LJMP     led_Switch
----- FUNCTION app_confingHandler1s (END) -------

LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 72



----- FUNCTION buzzer_Init (BEGIN) -----
 FILE: 'Driver\buzzer.c'
    8: void buzzer_Init(void)
    9: {
   10:     P3M1 &= ~0x20;      //推挽输出
   11:     P3M0 |= 0x20;
0015F9 53B1DF            ANL      P3M1,#0DFH
   12:     P3 &= ~0x20;
0015FC 43B220            ORL      P3M0,#020H
   13: }
0015FF 53B0DF            ANL      P3,#0DFH
   14: 
001602 22                RET      
----- FUNCTION buzzer_Init (END) -------


----- FUNCTION ?L?COM003B (BEGIN) -----
001603 A3                INC      DPTR
001604 EC                MOV      A,R4
001605 F0                MOVX     @DPTR,A
001606         ?L?COM003C:
001606 A3                INC      DPTR
001607 ED                MOV      A,R5
001608 F0                MOVX     @DPTR,A
001609 E4                CLR      A
00160A FF                MOV      R7,A
00160B FE                MOV      R6,A
00160C 22                RET      
----- FUNCTION ?L?COM003B (END) -------


----- FUNCTION _hwa_eepromEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   37: void hwa_eepromEncrypt(UINT8 *dat, UINT16 size)        //加密
   38: {
00160D 900056            MOV      DPTR,#dat
001610 120DC9            LCALL    ?L?COM0004
;---- Variable 'i' assigned to Register 'R6/R7' ----
001613 D103              ACALL    ?L?COM003B
001615         ?C0001?HWA_EEPROM_CFG:
001615 D3                SETB     C
001616 90005A            MOV      DPTR,#size+01H
001619 E0                MOVX     A,@DPTR
00161A 9F                SUBB     A,R7
00161B 900059            MOV      DPTR,#size
00161E E0                MOVX     A,@DPTR
00161F 9E                SUBB     A,R6
001620 401A              JC       ?C0004?HWA_EEPROM_CFG
   39: 	UINT16 i;
   40: 	UINT8 tmp;
   41: 	for (i = 0; i<size; i++)
   42: 	{
   43: 		tmp = dat[i];
001622 900056            MOV      DPTR,#dat
001625 120D64            LCALL    ?L?COM0008
;---- Variable 'tmp' assigned to Register 'R5' ----
001628 D152              ACALL    ?L?COM0040
   44: 		tmp ^= SecretKey;
   45: 		tmp = (tmp >> 1) | (tmp << 7);
00162A C4                SWAP     A
00162B 33                RLC      A
00162C 33                RLC      A
00162D 33                RLC      A
00162E 5480              ANL      A,#080H
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 73


001630 FC                MOV      R4,A
001631 ED                MOV      A,R5
001632 C3                CLR      C
001633 13                RRC      A
001634 D16B              ACALL    ?L?COM003E
001636 BF0001            CJNE     R7,#00H,?C0009?HWA_EEPROM_CFG
001639 0E                INC      R6
00163A         ?C0009?HWA_EEPROM_CFG:
00163A 80D9              SJMP     ?C0001?HWA_EEPROM_CFG
   46: 		tmp ^= SecretKey;
   47: 		dat[i] = tmp;
   48: 	}
   49: }
00163C         ?C0004?HWA_EEPROM_CFG:
00163C 22                RET      
----- FUNCTION _hwa_eepromEncrypt (END) -------


----- FUNCTION ?L?COM004C (BEGIN) -----
00163D EF                MOV      A,R7
00163E 5401              ANL      A,#01H
001640 9400              SUBB     A,#00H
001642 E4                CLR      A
001643 9400              SUBB     A,#00H
001645 EE                MOV      A,R6
001646 22                RET      
----- FUNCTION ?L?COM004C (END) -------


----- FUNCTION ?L?COM0049 (BEGIN) -----
001647 A3                INC      DPTR
001648 EC                MOV      A,R4
001649 F0                MOVX     @DPTR,A
00164A A3                INC      DPTR
00164B ED                MOV      A,R5
00164C F0                MOVX     @DPTR,A
00164D 74FF              MOV      A,#0FFH
00164F FF                MOV      R7,A
001650 FE                MOV      R6,A
001651 22                RET      
----- FUNCTION ?L?COM0049 (END) -------


----- FUNCTION ?L?COM0040 (BEGIN) -----
001652 F9                MOV      R1,A
001653 8F82              MOV      DPL,R7
001655 8E83              MOV      DPH,R6
001657 120135            LCALL    ?C?CLDOPTR
00165A 64A5              XRL      A,#0A5H
00165C FD                MOV      R5,A
00165D 22                RET      
----- FUNCTION ?L?COM0040 (END) -------


----- FUNCTION ?L?COM002A (BEGIN) -----
00165E 90006B            MOV      DPTR,#num
001661         ?L?COM002B:
001661 74FF              MOV      A,#0FFH
001663 F5F0              MOV      B,A
001665 1201FD            LCALL    ?C?ILDIX
001668 45F0              ORL      A,B
00166A 22                RET      
----- FUNCTION ?L?COM002A (END) -------


LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 74


----- FUNCTION ?L?COM003E (BEGIN) -----
00166B 4C                ORL      A,R4
00166C 64A5              XRL      A,#0A5H
00166E FD                MOV      R5,A
00166F 8F82              MOV      DPL,R7
001671 8E83              MOV      DPH,R6
001673 120174            LCALL    ?C?CSTOPTR
001676 0F                INC      R7
001677 22                RET      
----- FUNCTION ?L?COM003E (END) -------


----- FUNCTION ?L?COM003A (BEGIN) -----
001678 13                RRC      A
001679 FE                MOV      R6,A
00167A EF                MOV      A,R7
00167B 13                RRC      A
00167C FF                MOV      R7,A
00167D EE                MOV      A,R6
00167E 64A0              XRL      A,#0A0H
001680 FE                MOV      R6,A
001681 EF                MOV      A,R7
001682 6401              XRL      A,#01H
001684 FF                MOV      R7,A
001685 22                RET      
----- FUNCTION ?L?COM003A (END) -------


----- FUNCTION sys_tim0Init (BEGIN) -----
 FILE: 'System\sys_tim.c'
  101: void sys_tim0Init(void)
  102: {
  103: 	TMOD &= 0xF0;
  104: 	TH0 = (UINT8)(T1MS>>8);
001686 5389F0            ANL      TMOD,#0F0H
  105: 	TL0 = (UINT8)T1MS;
001689 758CF8            MOV      TH0,#0F8H
  106: 	ET0 = 1;
00168C 758ACD            MOV      TL0,#0CDH
  107: 	TR0 = 1;
00168F D2A9              SETB     ET0
  108: //	PT1 = 1;
001691 D28C              SETB     TR0
  109:     EA = 1;
001693 D2AF              SETB     EA
  110: }
001695 22                RET      
----- FUNCTION sys_tim0Init (END) -------


----- FUNCTION sys_uartOverTime1ms (BEGIN) -----
 FILE: 'System\sys_uart.c'
  141: UINT8 sys_uartOverTime1ms(void)
  142: {
  143: 	if(u8_BoudOverTime && b_RxFlag==FALSE)
  144: 	{
001696 9000A8            MOV      DPTR,#u8_BoudOverTime
001699 E0                MOVX     A,@DPTR
00169A 600D              JZ       ?C0016?SYS_UART
00169C 200A0A            JB       b_RxFlag,?C0016?SYS_UART
  145: 		u8_BoudOverTime--;
  146: 		if(u8_BoudOverTime==0)
00169F 14                DEC      A
0016A0 F0                MOVX     @DPTR,A
  147: 		{
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 75


0016A1 E0                MOVX     A,@DPTR
0016A2 7005              JNZ      ?C0016?SYS_UART
  148: 			b_RxFlag = TRUE;
  149: 			return TRUE;
0016A4 D20A              SETB     b_RxFlag
  150: 		}
0016A6 7F01              MOV      R7,#01H
0016A8 22                RET      
  151: 	}
  152: 	return FALSE;
0016A9         ?C0016?SYS_UART:
  153: }
0016A9 7F00              MOV      R7,#00H
  154: 
0016AB 22                RET      
----- FUNCTION sys_uartOverTime1ms (END) -------


----- FUNCTION len_Init (BEGIN) -----
 FILE: 'Driver\LED.c'
   17: void len_Init(void)
   18: {
   19:     P1M1 &= ~0xFF;      //推挽输出
   20:     P1M0 |= 0xFF;
0016AC 759100            MOV      P1M1,#00H
   21:     P2M1 &= ~0xC1;      //推挽输出
0016AF 7592FF            MOV      P1M0,#0FFH
   22:     P2M0 |= 0xC1;
0016B2 53953E            ANL      P2M1,#03EH
   23:     P5M1 &= ~0x30;      //推挽输出
0016B5 4396C1            ORL      P2M0,#0C1H
   24:     P5M0 |= 0x30;
0016B8 53C9CF            ANL      P5M1,#0CFH
   25:     P3M1 &= ~0x40;      //推挽输出
0016BB 43CA30            ORL      P5M0,#030H
   26:     P3M0 |= 0x40;
0016BE 53B1BF            ANL      P3M1,#0BFH
   27: }
0016C1 43B240            ORL      P3M0,#040H
   28: 
0016C4 22                RET      
----- FUNCTION len_Init (END) -------


----- FUNCTION _Write_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  212: void Write_FIFO(uchar *buff,uchar count)
  213: {
0016C5 900071            MOV      DPTR,#buff
0016C8 120DC9            LCALL    ?L?COM0004
0016CB A3                INC      DPTR
0016CC ED                MOV      A,R5
0016CD F0                MOVX     @DPTR,A
  214: 	uchar i;
  215: 	if(count == 0)
0016CE 6020              JZ       ?C0045?MIFARE
0016D0         ?C0044?MIFARE:
  216:         return;
  217: 	for(i=0;i<count;i++)
;---- Variable 'i' assigned to Register 'R4' ----
0016D0 E4                CLR      A
0016D1 FC                MOV      R4,A
0016D2         ?C0046?MIFARE:
0016D2 900074            MOV      DPTR,#count
0016D5 E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 76


0016D6 FF                MOV      R7,A
0016D7 EC                MOV      A,R4
0016D8 C3                CLR      C
0016D9 9F                SUBB     A,R7
0016DA 5014              JNC      ?C0045?MIFARE
  218: 		SPIWriteOne(FIFO_Reg,buff[i]);
0016DC 900071            MOV      DPTR,#buff
0016DF 120D64            LCALL    ?L?COM0008
0016E2 F9                MOV      R1,A
0016E3 8C82              MOV      DPL,R4
0016E5 1188              ACALL    ?L?COM001F
0016E7 FD                MOV      R5,A
0016E8 7F02              MOV      R7,#02H
0016EA 120535            LCALL    _SPIWriteOne
0016ED 0C                INC      R4
0016EE 80E2              SJMP     ?C0046?MIFARE
  219: //		SPIWrite(FIFO_Reg,buff,count);
  220: }
0016F0         ?C0045?MIFARE:
0016F0 22                RET      
----- FUNCTION _Write_FIFO (END) -------


----- FUNCTION _sys_uartSendData (BEGIN) -----
 FILE: 'System\sys_uart.c'
   81: void sys_uartSendData(UINT8 *pData, UINT8 len)
   82: {
0016F1 120DC6            LCALL    ?L?COM0003
;---- Variable 'len' assigned to Register 'R5' ----
   83: #ifdef ENABLE_INTERRUPT_SEND
0016F4         ?C0006?SYS_UART:
   84:     while(TxLen!=TxCnt);
0016F4 9000BA            MOV      DPTR,#TxCnt
0016F7 E0                MOVX     A,@DPTR
0016F8 FF                MOV      R7,A
0016F9 9000B9            MOV      DPTR,#TxLen
0016FC E0                MOVX     A,@DPTR
0016FD B507F4            CJNE     A,AR7,?C0006?SYS_UART
001700         ?C0007?SYS_UART:
   85:     TxLen = len;
001700 9000B9            MOV      DPTR,#TxLen
001703 ED                MOV      A,R5
001704 F0                MOVX     @DPTR,A
   86:     TxCnt = 0;
001705 E4                CLR      A
001706 A3                INC      DPTR
001707 F0                MOVX     @DPTR,A
   87:     pTxBuff = pData;
001708 900048            MOV      DPTR,#pData
00170B E0                MOVX     A,@DPTR
00170C F9                MOV      R1,A
00170D A3                INC      DPTR
00170E E0                MOVX     A,@DPTR
00170F FA                MOV      R2,A
001710 A3                INC      DPTR
001711 E0                MOVX     A,@DPTR
001712 9000A5            MOV      DPTR,#pTxBuff
001715 C9                XCH      A,R1
001716 120DCA            LCALL    ?L?COM0005
   88:     SBUF = *pData;
001719 900048            MOV      DPTR,#pData
00171C E0                MOVX     A,@DPTR
00171D FB                MOV      R3,A
00171E A3                INC      DPTR
00171F A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 77


001720 E0                MOVX     A,@DPTR
001721 F9                MOV      R1,A
001722 12011C            LCALL    ?C?CLDPTR
001725 F599              MOV      SBUF,A
   89: #else
   90:     if(len)
   91:     {
   92:         while(len--)
   93:         {
   94:             while(b_TxFlag == FALSE);
   95:             b_TxFlag = FALSE;
   96:             SBUF = *pData++;
   97:         }
   98:     }
   99: #endif
  100: }
001727 22                RET      
----- FUNCTION _sys_uartSendData (END) -------


----- FUNCTION sys_uartInterrupt (BEGIN) -----
 FILE: 'System\sys_uart.c'
   60: void sys_uartInterrupt() interrupt 4
001728 C0E0              PUSH     ACC
00172A C0F0              PUSH     B
00172C C083              PUSH     DPH
00172E C082              PUSH     DPL
001730 C0D0              PUSH     PSW
001732 75D000            MOV      PSW,#00H
001735 C000              PUSH     AR0
001737 C001              PUSH     AR1
001739 C002              PUSH     AR2
00173B C003              PUSH     AR3
00173D C004              PUSH     AR4
00173F C005              PUSH     AR5
001741 C006              PUSH     AR6
001743 C007              PUSH     AR7
   61: {
   62:     if(RI)
001745 309804            JNB      RI,?C0002?SYS_UART
   63:     {
   64:         RI = 0;
001748 C298              CLR      RI
   65:         sys_uartRxHandler();
00174A F189              ACALL    sys_uartRxHandler
   66:     }
00174C         ?C0002?SYS_UART:
   67:     if(TI)
00174C 30991F            JNB      TI,?C0005?SYS_UART
   68:     {
   69:         TI = 0;
00174F C299              CLR      TI
   70: #ifdef ENABLE_INTERRUPT_SEND
   71:         if(++TxCnt != TxLen)
001751 9000B9            MOV      DPTR,#TxLen
001754 E0                MOVX     A,@DPTR
001755 FF                MOV      R7,A
001756 A3                INC      DPTR
001757 E0                MOVX     A,@DPTR
001758 04                INC      A
001759 F0                MOVX     @DPTR,A
00175A 6F                XRL      A,R7
00175B 6011              JZ       ?C0005?SYS_UART
   72:         {
   73:             SBUF = pTxBuff[TxCnt];
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 78


00175D 9000A5            MOV      DPTR,#pTxBuff
001760 120D64            LCALL    ?L?COM0008
001763 F9                MOV      R1,A
001764 9000BA            MOV      DPTR,#TxCnt
001767 E0                MOVX     A,@DPTR
001768 F582              MOV      DPL,A
00176A 1188              ACALL    ?L?COM001F
00176C F599              MOV      SBUF,A
   74:         }
   75: #else
   76:         b_TxFlag = TRUE;
   77: #endif
   78:     }
   79: }
00176E         ?C0005?SYS_UART:
00176E D007              POP      AR7
001770 D006              POP      AR6
001772 D005              POP      AR5
001774 D004              POP      AR4
001776 D003              POP      AR3
001778 D002              POP      AR2
00177A D001              POP      AR1
00177C D000              POP      AR0
00177E D0D0              POP      PSW
001780 D082              POP      DPL
001782 D083              POP      DPH
001784 D0F0              POP      B
001786 D0E0              POP      ACC
001788 32                RETI     
----- FUNCTION sys_uartInterrupt (END) -------


----- FUNCTION sys_uartRxHandler (BEGIN) -----
 FILE: 'System\sys_uart.c'
  119: void sys_uartRxHandler(void)
  120: {
  121:     if(SBUF == 0x7F)        //0x7F auto download     boud 9600 0x7F at boud 2400 is 0xF8
  122:     {
001789 E599              MOV      A,SBUF
00178B B47F11            CJNE     A,#07FH,?C0011?SYS_UART
  123:         RxNum++;
  124:         if(RxNum >= 80)
00178E 9000BB            MOV      DPTR,#RxNum
001791 E0                MOVX     A,@DPTR
001792 04                INC      A
001793 F0                MOVX     @DPTR,A
  125:         {
001794 E0                MOVX     A,@DPTR
001795 C3                CLR      C
001796 9450              SUBB     A,#050H
001798 400A              JC       ?C0013?SYS_UART
  126:             IAP_CONTR = 0x60;
  127:         }
00179A 75C760            MOV      IAP_CONTR,#060H
  128:     }
  129:     else
00179D 8005              SJMP     ?C0013?SYS_UART
00179F         ?C0011?SYS_UART:
  130:     {
  131:         RxNum = 0;
00179F E4                CLR      A
0017A0 9000BB            MOV      DPTR,#RxNum
0017A3 F0                MOVX     @DPTR,A
  132:     }
0017A4         ?C0013?SYS_UART:
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 79


  133:     RxBuff[u8_RxIndex] = SBUF;
0017A4 9000B8            MOV      DPTR,#u8_RxIndex
0017A7 E0                MOVX     A,@DPTR
0017A8 FF                MOV      R7,A
0017A9 24A9              ADD      A,#LOW RxBuff
0017AB F582              MOV      DPL,A
0017AD E4                CLR      A
0017AE 3400              ADDC     A,#HIGH RxBuff
0017B0 F583              MOV      DPH,A
0017B2 E599              MOV      A,SBUF
0017B4 F0                MOVX     @DPTR,A
  134:     u8_BoudOverTime = BOUD_OVER_TIME;
0017B5 9000A8            MOV      DPTR,#u8_BoudOverTime
0017B8 740A              MOV      A,#0AH
0017BA F0                MOVX     @DPTR,A
  135:     if(u8_RxIndex < RX_BUFF_LEN)
0017BB EF                MOV      A,R7
0017BC C3                CLR      C
0017BD 940F              SUBB     A,#0FH
0017BF 5006              JNC      ?C0015?SYS_UART
  136:     {
  137:         u8_RxIndex++;
0017C1 9000B8            MOV      DPTR,#u8_RxIndex
0017C4 E0                MOVX     A,@DPTR
0017C5 04                INC      A
0017C6 F0                MOVX     @DPTR,A
  138:     }
  139: }
0017C7         ?C0015?SYS_UART:
0017C7 22                RET      
----- FUNCTION sys_uartRxHandler (END) -------


----- FUNCTION sys_tim0Isr (BEGIN) -----
 FILE: 'System\sys_task.c'
   41: void sys_tim0Isr(void) interrupt 1      //1ms interrupt task
0017C8 C0E0              PUSH     ACC
0017CA C0F0              PUSH     B
0017CC C083              PUSH     DPH
0017CE C082              PUSH     DPL
0017D0 C0D0              PUSH     PSW
0017D2 75D000            MOV      PSW,#00H
0017D5 C000              PUSH     AR0
0017D7 C001              PUSH     AR1
0017D9 C002              PUSH     AR2
0017DB C003              PUSH     AR3
0017DD C004              PUSH     AR4
0017DF C005              PUSH     AR5
0017E1 C006              PUSH     AR6
0017E3 C007              PUSH     AR7
   42: {
   43:     led_Handler1ms();
0017E5 121852            LCALL    led_Handler1ms
   44:     hwa_uartHandler1ms();
0017E8 915C              ACALL    hwa_uartHandler1ms
   45: 	taskHandlerCnt10ms++;
0017EA 9000FB            MOV      DPTR,#taskHandlerCnt10ms
0017ED E0                MOVX     A,@DPTR
0017EE 04                INC      A
0017EF F0                MOVX     @DPTR,A
   46:     if(taskHandlerCnt10ms>=10)
0017F0 E0                MOVX     A,@DPTR
0017F1 C3                CLR      C
0017F2 940A              SUBB     A,#0AH
0017F4 400D              JC       ?C0003?SYS_TASK
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 80


   47:     {
   48:         taskHandlerCnt10ms = 0;
0017F6 E4                CLR      A
0017F7 F0                MOVX     @DPTR,A
   49:         sys_taskHandler10ms();
0017F8 120022            LCALL    sys_taskHandler10ms
   50:         taskCycle10msFlag = TRUE;
0017FB D205              SETB     taskCycle10msFlag
   51:         taskHandlerCnt100ms++;
0017FD 9000F9            MOV      DPTR,#taskHandlerCnt100ms
001800 E0                MOVX     A,@DPTR
001801 04                INC      A
001802 F0                MOVX     @DPTR,A
   52:     }
001803         ?C0003?SYS_TASK:
   53:     if(taskHandlerCnt100ms>=10)
001803 9000F9            MOV      DPTR,#taskHandlerCnt100ms
001806 E0                MOVX     A,@DPTR
001807 C3                CLR      C
001808 940A              SUBB     A,#0AH
00180A 400A              JC       ?C0004?SYS_TASK
   54:     {
   55:         taskHandlerCnt100ms = 0;
00180C E4                CLR      A
00180D F0                MOVX     @DPTR,A
   56:         sys_taskHandler100ms();
00180E 1140              ACALL    sys_taskHandler100ms
   57:         taskHandlerCnt1s++;
001810 9000FA            MOV      DPTR,#taskHandlerCnt1s
001813 E0                MOVX     A,@DPTR
001814 04                INC      A
001815 F0                MOVX     @DPTR,A
   58:     }
001816         ?C0004?SYS_TASK:
   59:     if(taskHandlerCnt1s>=10)
001816 9000FA            MOV      DPTR,#taskHandlerCnt1s
001819 E0                MOVX     A,@DPTR
00181A C3                CLR      C
00181B 940A              SUBB     A,#0AH
00181D 4006              JC       ?C0006?SYS_TASK
   60:     {
   61:         taskHandlerCnt1s = 0;
00181F E4                CLR      A
001820 F0                MOVX     @DPTR,A
   62:         sys_taskHandler1s();
001821 1151              ACALL    sys_taskHandler1s
   63:         taskCycle1sFlag = TRUE;
001823 D204              SETB     taskCycle1sFlag
   64:     }
   65: }
001825         ?C0006?SYS_TASK:
001825 D007              POP      AR7
001827 D006              POP      AR6
001829 D005              POP      AR5
00182B D004              POP      AR4
00182D D003              POP      AR3
00182F D002              POP      AR2
001831 D001              POP      AR1
001833 D000              POP      AR0
001835 D0D0              POP      PSW
001837 D082              POP      DPL
001839 D083              POP      DPH
00183B D0F0              POP      B
00183D D0E0              POP      ACC
00183F 32                RETI     
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 81


----- FUNCTION sys_tim0Isr (END) -------


----- FUNCTION sys_taskHandler100ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   71: void sys_taskHandler100ms(void)           //100ms interrupt task
;----                  JMP      buzzer_Handler100ms
   72: {
----- FUNCTION sys_taskHandler100ms (END) -------


----- FUNCTION buzzer_Handler100ms (BEGIN) -----
 FILE: 'Driver\buzzer.c'
   15: void buzzer_Handler100ms(void)
   16: {
   17:     if(Buzzer)
   18: 	{
001840 30B503            JNB      Buzzer,?C0002?BUZZER
   19: 		Buzzer = 0;
   20: 	}
001843 C2B5              CLR      Buzzer
   21: 	else if(SoundNumberCount)
001845 22                RET      
001846         ?C0002?BUZZER:
   22: 	{
001846 9000FC            MOV      DPTR,#SoundNumberCount
001849 E0                MOVX     A,@DPTR
00184A 6004              JZ       ?C0005?BUZZER
   23: 		Buzzer = 1;
   24: 		SoundNumberCount--;
00184C D2B5              SETB     Buzzer
   25: 	}
00184E 14                DEC      A
00184F F0                MOVX     @DPTR,A
   26: }
   27: 
001850         ?C0005?BUZZER:
001850 22                RET      
----- FUNCTION buzzer_Handler100ms (END) -------


----- FUNCTION sys_taskHandler1s (BEGIN) -----
 FILE: 'System\sys_task.c'
   76: void sys_taskHandler1s(void)              //1s interrupt task
   77: {
   78: }
   79: 
001851 22                RET      
----- FUNCTION sys_taskHandler1s (END) -------


----- FUNCTION led_Handler1ms (BEGIN) -----
 FILE: 'Driver\LED.c'
   30: void led_Handler1ms(void)
   31: {
   32:     if(ledsw)
   33:     {
001852 200D02            JB       ledsw,$ + 5H
001855 2156              AJMP     ?C0033?LED
   34:     	if (gCurLed<5)
   35:     		gCurLed++;
001857 9000F7            MOV      DPTR,#gCurLed
00185A E0                MOVX     A,@DPTR
00185B C3                CLR      C
00185C 9405              SUBB     A,#05H
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 82


00185E 5005              JNC      ?C0003?LED
   36:     	else
001860 E0                MOVX     A,@DPTR
001861 04                INC      A
001862 F0                MOVX     @DPTR,A
001863 8005              SJMP     ?C0004?LED
001865         ?C0003?LED:
   37:     		gCurLed=0;
001865 E4                CLR      A
001866 9000F7            MOV      DPTR,#gCurLed
001869 F0                MOVX     @DPTR,A
00186A         ?C0004?LED:
   38:     	LED_CS0 = 1;
00186A 3157              ACALL    ?L?COM003D
   39:     	LED_CS1 = 1;
   40:     	LED_CS2 = 1;
   41:     	LED_CS3 = 1;
   42:     	LED_CS4 = 1;
   43:     	LED_CS5 = 1;
   44:     	switch ( gLedBuf[gCurLed])		 //switch case 语句中 switch中的条件case都不满足就执行default
00186C 9000F7            MOV      DPTR,#gCurLed
00186F E0                MOVX     A,@DPTR
001870 FF                MOV      R7,A
001871 24F1              ADD      A,#LOW gLedBuf
001873 F582              MOV      DPL,A
001875 E4                CLR      A
001876 3400              ADDC     A,#HIGH gLedBuf
001878 F583              MOV      DPH,A
00187A E0                MOVX     A,@DPTR
00187B B41100            CJNE     A,#011H,?C0045?LED
00187E         ?C0045?LED:
00187E 4002              JC       $ + 4H
001880 210E              AJMP     ?C0023?LED
001882 901889            MOV      DPTR,#01889H
001885 F8                MOV      R0,A
001886 28                ADD      A,R0
001887 28                ADD      A,R0
001888 73                JMP      @A+DPTR
001889         ?C0046?LED:
001889 0218BC            LJMP     ?C0006?LED
00188C 0218C1            LJMP     ?C0007?LED
00188F 0218C6            LJMP     ?C0008?LED
001892 0218CB            LJMP     ?C0009?LED
001895 0218D0            LJMP     ?C0010?LED
001898 0218D5            LJMP     ?C0011?LED
00189B 0218DA            LJMP     ?C0012?LED
00189E 0218DF            LJMP     ?C0013?LED
0018A1 0218E4            LJMP     ?C0014?LED
0018A4 0218E9            LJMP     ?C0015?LED
0018A7 0218EE            LJMP     ?C0016?LED
0018AA 0218F3            LJMP     ?C0017?LED
0018AD 0218F8            LJMP     ?C0018?LED
0018B0 0218FA            LJMP     ?C0019?LED
0018B3 0218FF            LJMP     ?C0020?LED
0018B6 021904            LJMP     ?C0021?LED
0018B9 021909            LJMP     ?C0022?LED
   45:     	{
   46:     	    case 0:	P1 = 0xeb; break;//0X88
0018BC         ?C0006?LED:
0018BC 7590EB            MOV      P1,#0EBH
0018BF 8050              SJMP     ?C0005?LED
   47:     		case 1:	P1 = 0x88; break;//0XEB
0018C1         ?C0007?LED:
0018C1 759088            MOV      P1,#088H
0018C4 804B              SJMP     ?C0005?LED
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 83


   48:     		case 2:	P1 = 0xB3; break;//0X92
0018C6         ?C0008?LED:
0018C6 7590B3            MOV      P1,#0B3H
0018C9 8046              SJMP     ?C0005?LED
   49:     		case 3:	P1 = 0xba; break;//0XC2
0018CB         ?C0009?LED:
0018CB 7590BA            MOV      P1,#0BAH
0018CE 8041              SJMP     ?C0005?LED
   50:     		case 4:	P1 = 0xd8; break;//0XE1
0018D0         ?C0010?LED:
0018D0 7590D8            MOV      P1,#0D8H
0018D3 803C              SJMP     ?C0005?LED
   51:     		case 5:	P1 = 0x7a; break;//0XC4
0018D5         ?C0011?LED:
0018D5 75907A            MOV      P1,#07AH
0018D8 8037              SJMP     ?C0005?LED
   52:     		case 6:	P1 = 0x7b; break;//0X84
0018DA         ?C0012?LED:
0018DA 75907B            MOV      P1,#07BH
0018DD 8032              SJMP     ?C0005?LED
   53:     		case 7:	P1 = 0xa8; break;//0XEA
0018DF         ?C0013?LED:
0018DF 7590A8            MOV      P1,#0A8H
0018E2 802D              SJMP     ?C0005?LED
   54:     		case 8:	P1 = 0xfb; break;//0X80
0018E4         ?C0014?LED:
0018E4 7590FB            MOV      P1,#0FBH
0018E7 8028              SJMP     ?C0005?LED
   55:     		case 9:	P1 = 0xfa; break;//0XC0
0018E9         ?C0015?LED:
0018E9 7590FA            MOV      P1,#0FAH
0018EC 8023              SJMP     ?C0005?LED
   56:     		case 10:P1 = 0xcb; break;//0XC0 U
0018EE         ?C0016?LED:
0018EE 7590CB            MOV      P1,#0CBH
0018F1 801E              SJMP     ?C0005?LED
   57:     		case 11:P1 = 0xbe; break;//3.
0018F3         ?C0017?LED:
0018F3 7590BE            MOV      P1,#0BEH
0018F6 8019              SJMP     ?C0005?LED
   58:     		case 12:P1 = 0x00; break;//空
0018F8         ?C0018?LED:
0018F8 8014              SJMP     ?C0049?LED
   59:     		case 13:P1 = 0x7e; break;//5.
0018FA         ?C0019?LED:
0018FA 75907E            MOV      P1,#07EH
0018FD 8012              SJMP     ?C0005?LED
   60:             case 14:P1 = 0xf1;break;//P
0018FF         ?C0020?LED:
0018FF 7590F1            MOV      P1,#0F1H
001902 800D              SJMP     ?C0005?LED
   61:             case 15:P1 = 0x10;break;//-
001904         ?C0021?LED:
001904 759010            MOV      P1,#010H
001907 8008              SJMP     ?C0005?LED
   62:             case 16:P1 = 0xf9;break;//A
001909         ?C0022?LED:
001909 7590F9            MOV      P1,#0F9H
00190C 8003              SJMP     ?C0005?LED
   63:     		default:P1 = 0x00; break;
00190E         ?C0023?LED:
00190E         
00190E E4                CLR      A
00190F F590              MOV      P1,A
   64:     	}
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 84


001911         ?C0005?LED:
   65:         if(gShowDot & (1<<gCurLed))//show dot
001911 7401              MOV      A,#01H
001913 7E00              MOV      R6,#00H
001915 A807              MOV      R0,AR7
001917 08                INC      R0
001918 8005              SJMP     ?C0048?LED
00191A         ?C0047?LED:
00191A C3                CLR      C
00191B 33                RLC      A
00191C CE                XCH      A,R6
00191D 33                RLC      A
00191E CE                XCH      A,R6
00191F         ?C0048?LED:
00191F D8F9              DJNZ     R0,?C0047?LED
001921 FF                MOV      R7,A
001922 9000F8            MOV      DPTR,#gShowDot
001925 E0                MOVX     A,@DPTR
001926 FD                MOV      R5,A
001927 EF                MOV      A,R7
001928 5D                ANL      A,R5
001929 6003              JZ       ?C0024?LED
   66:         {
   67:      		P1 |= 0X04;
00192B 439004            ORL      P1,#04H
   68:         }
00192E         ?C0024?LED:
   69:     	switch (gCurLed)
00192E 9000F7            MOV      DPTR,#gCurLed
001931 E0                MOVX     A,@DPTR
001932 14                DEC      A
001933 6013              JZ       ?C0027?LED
001935 14                DEC      A
001936 6013              JZ       ?C0028?LED
001938 14                DEC      A
001939 6013              JZ       ?C0029?LED
00193B 14                DEC      A
00193C 6013              JZ       ?C0030?LED
00193E 14                DEC      A
00193F 6013              JZ       ?C0031?LED
001941 2405              ADD      A,#05H
001943 7011              JNZ      ?C0033?LED
   70:     	{
   71:     		case 0:
001945         ?C0026?LED:
   72:     			LED_CS0 = 0;
001945 C2A6              CLR      LED_CS0
   73:     			break;
001947 22                RET      
   74:     		case 1:
001948         ?C0027?LED:
   75:     			LED_CS1 = 0;
001948 C2A7              CLR      LED_CS1
   76:     			break;
00194A 22                RET      
   77:     		case 2:
00194B         ?C0028?LED:
   78:     			LED_CS2 = 0;
00194B C2A0              CLR      LED_CS2
   79:     			break;
00194D 22                RET      
   80:     		case 3:
00194E         ?C0029?LED:
   81:     			LED_CS3 = 0;
00194E C2CD              CLR      LED_CS3
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 85


   82:     			break;
001950 22                RET      
   83:     		case 4:
001951         ?C0030?LED:
   84:     			LED_CS4 = 0;
001951 C2CC              CLR      LED_CS4
   85:     			break;
001953 22                RET      
   86:     		case 5:
001954         ?C0031?LED:
   87:     			LED_CS5 = 0;
001954 C2B6              CLR      LED_CS5
   88:     			break;
   89:     		default:
   90:     			break;
   91:     	}
   92:     }
   93: }
001956         ?C0033?LED:
001956 22                RET      
----- FUNCTION led_Handler1ms (END) -------


----- FUNCTION ?L?COM003D (BEGIN) -----
001957 D2A6              SETB     LED_CS0
001959 D2A7              SETB     LED_CS1
00195B D2A0              SETB     LED_CS2
00195D D2CD              SETB     LED_CS3
00195F D2CC              SETB     LED_CS4
001961 D2B6              SETB     LED_CS5
001963 22                RET      
----- FUNCTION ?L?COM003D (END) -------


----- FUNCTION Clear_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  190: uchar Clear_FIFO(void)
  191: {
  192:     uchar ucResult,i;
  193:     ucResult = SPIReadOne(Control_Reg);
001964 7F09              MOV      R7,#09H
;---- Variable 'ucResult' assigned to Register 'R4' ----
001966 1207EF            LCALL    ?L?COM0038
001969 4401              ORL      A,#01H
00196B FC                MOV      R4,A
  194:     ucResult |=0x01;
  195:     SPIWriteOne(Control_Reg,ucResult);
00196C FD                MOV      R5,A
00196D 7F09              MOV      R7,#09H
00196F 120535            LCALL    _SPIWriteOne
  196:     for(i=0;i<0xA0;i++)
;---- Variable 'i' assigned to Register 'R5' ----
001972 E4                CLR      A
001973 FD                MOV      R5,A
001974         ?C0039?MIFARE:
  197:     {
  198:         ucResult = SPIReadOne(FIFOLength_Reg);
001974 7F04              MOV      R7,#04H
001976 1207EF            LCALL    ?L?COM0038
001979 7003              JNZ      ?C0041?MIFARE
  199:         if(ucResult == 0)
  200:             return TRUE;
00197B 7F01              MOV      R7,#01H
00197D 22                RET      
  201:     }
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 86


00197E         ?C0041?MIFARE:
00197E 0D                INC      R5
00197F ED                MOV      A,R5
001980 B4A0F1            CJNE     A,#0A0H,?C0039?MIFARE
001983         ?C0040?MIFARE:
  202:     return FALSE;
001983 7F00              MOV      R7,#00H
  203: }
001985 22                RET      
----- FUNCTION Clear_FIFO (END) -------


----- FUNCTION _Read_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  228: uchar Read_FIFO(uchar *buff)
  229: {
001986 90006C            MOV      DPTR,#buff
001989 120DC9            LCALL    ?L?COM0004
  230: 	uchar	ucResult,i;
  231: 	ucResult = SPIReadOne(FIFOLength_Reg);
;---- Variable 'ucResult' assigned to Register 'R5' ----
00198C 31BA              ACALL    ?L?COM0041
00198E 6005              JZ       ?C0050?MIFARE
001990 D3                SETB     C
001991 9410              SUBB     A,#010H
001993 4003              JC       ?C0049?MIFARE
001995         ?C0050?MIFARE:
  232: 	if(ucResult == 0 || ucResult>16)
  233: 		return 0;
001995 7F00              MOV      R7,#00H
001997 22                RET      
001998         ?C0049?MIFARE:
  234: 	for(i=0;i<ucResult;i++)
;---- Variable 'i' assigned to Register 'R4' ----
001998 E4                CLR      A
001999 FC                MOV      R4,A
00199A         ?C0052?MIFARE:
00199A EC                MOV      A,R4
00199B C3                CLR      C
00199C 9D                SUBB     A,R5
00199D 5018              JNC      ?C0053?MIFARE
  235: 	{
  236: 		buff[i] = SPIReadOne(FIFO_Reg);
00199F 7F02              MOV      R7,#02H
0019A1 12056A            LCALL    _SPIReadOne
0019A4 90006C            MOV      DPTR,#buff
0019A7 120D64            LCALL    ?L?COM0008
0019AA F9                MOV      R1,A
0019AB 8C82              MOV      DPL,R4
0019AD 758300            MOV      DPH,#00H
0019B0 EF                MOV      A,R7
0019B1 120174            LCALL    ?C?CSTOPTR
  237: 	}
0019B4 0C                INC      R4
0019B5 80E3              SJMP     ?C0052?MIFARE
0019B7         ?C0053?MIFARE:
  238: 
  239: 	return ucResult;
0019B7 AF05              MOV      R7,AR5
  240: }
0019B9 22                RET      
----- FUNCTION _Read_FIFO (END) -------


----- FUNCTION ?L?COM0041 (BEGIN) -----
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 87


0019BA 7F04              MOV      R7,#04H
0019BC         ?L?COM0042:
0019BC 12056A            LCALL    _SPIReadOne
0019BF AD07              MOV      R5,AR7
0019C1 ED                MOV      A,R5
0019C2 22                RET      
----- FUNCTION ?L?COM0041 (END) -------


----- FUNCTION _Read_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  532: uchar Read_Block(uchar *buff,uchar index)
  533: {
0019C3 900053            MOV      DPTR,#buff
0019C6 120DC9            LCALL    ?L?COM0004
;---- Variable 'index' assigned to Register 'R4' ----
0019C9 AC05              MOV      R4,AR5
  534:     uchar ucCmdLine[2],ucResult;
  535:     SPIWriteOne(ChannelRedundancy_Reg,0x0F);
0019CB 1207F5            LCALL    ?L?COM0055
  536:     ucCmdLine[0] = RF_CMD_READ;
0019CE A3                INC      DPTR
0019CF 7430              MOV      A,#030H
0019D1 F0                MOVX     @DPTR,A
  537:     ucCmdLine[1] = index;
0019D2 A3                INC      DPTR
0019D3 EC                MOV      A,R4
0019D4 F0                MOVX     @DPTR,A
  538:     ucResult = Command_Send(Transceive,ucCmdLine,2);
0019D5 7B01              MOV      R3,#01H
0019D7 7A00              MOV      R2,#HIGH ucCmdLine
0019D9 7956              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
0019DB 510C              ACALL    ?L?COM0027
0019DD 7003              JNZ      ?C0108?MIFARE
  539:     if(ucResult == FALSE)
  540:         return FM1702_NOTAGERR;   //无卡
0019DF 7F01              MOV      R7,#01H
0019E1 22                RET      
0019E2         ?C0108?MIFARE:
  541:     ucResult = SPIReadOne(ErrorFlag_Reg);
0019E2 1207E1            LCALL    ?L?COM002F
0019E5 30E103            JNB      ACC.1,?C0110?MIFARE
0019E8 7F05              MOV      R7,#05H
0019EA 22                RET      
0019EB         ?C0110?MIFARE:
  542: 	if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
  543: 	if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
0019EB EF                MOV      A,R7
0019EC 30E203            JNB      ACC.2,?C0111?MIFARE
0019EF 7F14              MOV      R7,#014H
0019F1 22                RET      
0019F2         ?C0111?MIFARE:
  544: 	if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
0019F2 EF                MOV      A,R7
0019F3 30E303            JNB      ACC.3,?C0112?MIFARE
0019F6 7F02              MOV      R7,#02H
0019F8 22                RET      
0019F9         ?C0112?MIFARE:
  545:     ucResult = Read_FIFO(buff);
0019F9 900053            MOV      DPTR,#buff
0019FC 120D64            LCALL    ?L?COM0008
0019FF F9                MOV      R1,A
001A00 3186              ACALL    _Read_FIFO
  546:     if(ucResult!=0x10)
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 88


001A02 EF                MOV      A,R7
001A03 6410              XRL      A,#010H
001A05 7F00              MOV      R7,#00H
001A07 6002              JZ       ?C0113?MIFARE
  547:         return FM1702_BYTECOUNTERR;
001A09 7F0C              MOV      R7,#0CH
001A0B         ?C0113?MIFARE:
  548:     else
  549:         return FM1702_OK;
  550: }
001A0B 22                RET      
----- FUNCTION _Read_Block (END) -------


----- FUNCTION ?L?COM0027 (BEGIN) -----
001A0C 900070            MOV      DPTR,#?_Command_Send?BYTE+04H
001A0F 7402              MOV      A,#02H
001A11         ?L?COM0028:
001A11 F0                MOVX     @DPTR,A
001A12 7F1E              MOV      R7,#01EH
001A14 120607            LCALL    _Command_Send
001A17 EF                MOV      A,R7
001A18 22                RET      
----- FUNCTION ?L?COM0027 (END) -------


----- FUNCTION _Write_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  566: uchar Write_Block(uchar *buff,uchar index)
  567: {
001A19 900057            MOV      DPTR,#buff
001A1C 120DC9            LCALL    ?L?COM0004
;---- Variable 'index' assigned to Register 'R4' ----
001A1F AC05              MOV      R4,AR5
  568:     uchar ucCmdLine[2],ucResult,ucData[16];
  569:     SPIWriteOne(ChannelRedundancy_Reg,0x07);   /* Note: this line is for 1702, different from RC500*/
001A21 7D07              MOV      R5,#07H
001A23 7F22              MOV      R7,#022H
001A25 120535            LCALL    _SPIWriteOne
  570:     ucCmdLine[0] = RF_CMD_WRITE;
001A28 A3                INC      DPTR
001A29 74A0              MOV      A,#0A0H
001A2B F0                MOVX     @DPTR,A
  571:     ucCmdLine[1] = index;
001A2C A3                INC      DPTR
001A2D EC                MOV      A,R4
001A2E F0                MOVX     @DPTR,A
  572:     ucResult = Command_Send(Transceive,ucCmdLine,2);
001A2F 7B01              MOV      R3,#01H
001A31 7A00              MOV      R2,#HIGH ucCmdLine
001A33 795A              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
001A35 510C              ACALL    ?L?COM0027
001A37 7003              JNZ      ?C0115?MIFARE
  573:     if(ucResult == FALSE)
  574:         return FM1702_NOTAGERR;
001A39 7F01              MOV      R7,#01H
001A3B 22                RET      
001A3C         ?C0115?MIFARE:
  575:     ucResult = Read_FIFO(ucData);
001A3C 7B01              MOV      R3,#01H
001A3E 7A00              MOV      R2,#HIGH ucData
001A40 795C              MOV      R1,#LOW ucData
001A42 3186              ACALL    _Read_FIFO
  576:     if(ucResult == 0)
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 89


001A44 EF                MOV      A,R7
001A45 7003              JNZ      ?C0117?MIFARE
  577:         return FM1702_BYTECOUNTERR;
001A47 7F0C              MOV      R7,#0CH
001A49 22                RET      
001A4A         ?C0117?MIFARE:
  578:     switch(ucData[0])
001A4A 90005C            MOV      DPTR,#ucData
001A4D E0                MOVX     A,@DPTR
001A4E 14                DEC      A
001A4F 6015              JZ       ?C0122?MIFARE
001A51 24FD              ADD      A,#0FDH
001A53 600E              JZ       ?C0120?MIFARE
001A55 14                DEC      A
001A56 6011              JZ       ?C0123?MIFARE
001A58 24FB              ADD      A,#0FBH
001A5A 6013              JZ       ?C0118?MIFARE
001A5C 240A              ADD      A,#0AH
001A5E 700C              JNZ      ?C0124?MIFARE
  579:     {
  580: 	    case 0x00:	return(FM1702_NOTAUTHERR);	
001A60         ?C0119?MIFARE:
001A60 7F0A              MOV      R7,#0AH
001A62 22                RET      
  581: 	    case 0x04:	return(FM1702_EMPTY);
001A63         ?C0120?MIFARE:
001A63 7F03              MOV      R7,#03H
001A65 22                RET      
  582: 	    case 0x0a:	break;                   //正常
  583: 	    case 0x01:	return(FM1702_CRCERR);
001A66         ?C0122?MIFARE:
001A66 7F02              MOV      R7,#02H
001A68 22                RET      
  584: 	    case 0x05:	return(FM1702_PARITYERR); 
001A69         ?C0123?MIFARE:
001A69 7F05              MOV      R7,#05H
001A6B 22                RET      
  585: 	    default:	return(FM1702_WRITEERR);
001A6C         ?C0124?MIFARE:
001A6C 7F0F              MOV      R7,#0FH
001A6E 22                RET      
  586:     }
001A6F         ?C0118?MIFARE:
  587:     ucResult = Command_Send(Transceive,buff,16);
001A6F 900057            MOV      DPTR,#buff
001A72 120D64            LCALL    ?L?COM0008
001A75 F9                MOV      R1,A
001A76 900070            MOV      DPTR,#?_Command_Send?BYTE+04H
001A79 7410              MOV      A,#010H
001A7B 5111              ACALL    ?L?COM0028
001A7D B40103            CJNE     A,#01H,?C0125?MIFARE
  588:     if(ucResult == TRUE)
  589:         return FM1702_OK;
001A80 7F00              MOV      R7,#00H
001A82 22                RET      
001A83         ?C0125?MIFARE:
  590:     else
  591:     {
  592:         ucResult = SPIReadOne(ErrorFlag_Reg);
001A83 1207E1            LCALL    ?L?COM002F
001A86 30E103            JNB      ACC.1,?C0127?MIFARE
001A89 7F05              MOV      R7,#05H
001A8B 22                RET      
001A8C         ?C0127?MIFARE:
  593: 	    if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 90


  594: 	    else if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
001A8C EF                MOV      A,R7
001A8D 30E203            JNB      ACC.2,?C0129?MIFARE
001A90 7F14              MOV      R7,#014H
001A92 22                RET      
001A93         ?C0129?MIFARE:
  595: 	    else if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
001A93 EF                MOV      A,R7
001A94 7F0F              MOV      R7,#0FH
001A96 30E302            JNB      ACC.3,?C0131?MIFARE
001A99 7F02              MOV      R7,#02H
001A9B         ?C0131?MIFARE:
  596:         else return FM1702_WRITEERR;
  597:     }
  598: }
001A9B 22                RET      
----- FUNCTION _Write_Block (END) -------


----- FUNCTION ?L?COM0026 (BEGIN) -----
001A9C 9000F1            MOV      DPTR,#gLedBuf
001A9F 740C              MOV      A,#0CH
001AA1 F0                MOVX     @DPTR,A
001AA2 A3                INC      DPTR
001AA3 740F              MOV      A,#0FH
001AA5 F0                MOVX     @DPTR,A
001AA6 A3                INC      DPTR
001AA7 F0                MOVX     @DPTR,A
001AA8 A3                INC      DPTR
001AA9 F0                MOVX     @DPTR,A
001AAA A3                INC      DPTR
001AAB F0                MOVX     @DPTR,A
001AAC A3                INC      DPTR
001AAD 740C              MOV      A,#0CH
001AAF F0                MOVX     @DPTR,A
001AB0 E4                CLR      A
001AB1 9000F8            MOV      DPTR,#gShowDot
001AB4 F0                MOVX     @DPTR,A
001AB5 22                RET      
----- FUNCTION ?L?COM0026 (END) -------


----- FUNCTION ?L?COM002C (BEGIN) -----
001AB6 E0                MOVX     A,@DPTR
001AB7 FB                MOV      R3,A
001AB8 75F003            MOV      B,#03H
001ABB A4                MUL      AB
001ABC 24C4              ADD      A,#LOW c_s_eepromConfig
001ABE F582              MOV      DPL,A
001AC0 E5F0              MOV      A,B
001AC2 3404              ADDC     A,#HIGH c_s_eepromConfig
001AC4 F583              MOV      DPH,A
001AC6 E4                CLR      A
001AC7 93                MOVC     A,@A+DPTR
001AC8 FC                MOV      R4,A
001AC9 7401              MOV      A,#01H
001ACB 93                MOVC     A,@A+DPTR
001ACC FD                MOV      R5,A
001ACD 22                RET      
----- FUNCTION ?L?COM002C (END) -------


----- FUNCTION ?L?COM0035 (BEGIN) -----
001ACE 74D8              MOV      A,#LOW gBuff
001AD0 2C                ADD      A,R4
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 91


001AD1 F582              MOV      DPL,A
001AD3 E4                CLR      A
001AD4 3400              ADDC     A,#HIGH gBuff
001AD6 F583              MOV      DPH,A
001AD8 22                RET      
----- FUNCTION ?L?COM0035 (END) -------


----- FUNCTION ?L?COM003F (BEGIN) -----
001AD9 25E0              ADD      A,ACC
001ADB 25E0              ADD      A,ACC
001ADD FE                MOV      R6,A
001ADE 04                INC      A
001ADF A3                INC      DPTR
001AE0 F0                MOVX     @DPTR,A
001AE1 EE                MOV      A,R6
001AE2 2402              ADD      A,#02H
001AE4 A3                INC      DPTR
001AE5 22                RET      
----- FUNCTION ?L?COM003F (END) -------


----- FUNCTION ?L?COM0044 (BEGIN) -----
001AE6 7E00              MOV      R6,#00H
001AE8 7F10              MOV      R7,#010H
001AEA 0200F6            LJMP     ?C?COPY
----- FUNCTION ?L?COM0044 (END) -------


----- FUNCTION ?L?COM0045 (BEGIN) -----
001AED E0                MOVX     A,@DPTR
001AEE FE                MOV      R6,A
001AEF A3                INC      DPTR
001AF0 E0                MOVX     A,@DPTR
001AF1 FF                MOV      R7,A
001AF2 7800              MOV      R0,#LOW e2_data
001AF4 7C00              MOV      R4,#HIGH e2_data
001AF6 7D01              MOV      R5,#01H
001AF8 22                RET      
----- FUNCTION ?L?COM0045 (END) -------


----- FUNCTION ?L?COM0047 (BEGIN) -----
001AF9 F5C3              MOV      IAP_ADDRH,A
001AFB         ?L?COM0048:
001AFB 75C65A            MOV      IAP_TRIG,#05AH
001AFE 75C6A5            MOV      IAP_TRIG,#0A5H
001B01 22                RET      
----- FUNCTION ?L?COM0047 (END) -------


----- FUNCTION ?L?COM004D (BEGIN) -----
001B02 9004C3            MOV      DPTR,#c_u8_eepromSectorNum
001B05 E4                CLR      A
001B06 93                MOVC     A,@A+DPTR
001B07 FF                MOV      R7,A
001B08 ED                MOV      A,R5
001B09 C3                CLR      C
001B0A 9F                SUBB     A,R7
001B0B 22                RET      
----- FUNCTION ?L?COM004D (END) -------


----- FUNCTION ?L?COM0054 (BEGIN) -----
001B0C 900052            MOV      DPTR,#Size
LX51 LINKER/LOCATER V4.66.1.0                                                         02/02/2016  20:46:19  PAGE 92


001B0F E0                MOVX     A,@DPTR
001B10 FC                MOV      R4,A
001B11 A3                INC      DPTR
001B12 E0                MOVX     A,@DPTR
001B13 FD                MOV      R5,A
001B14 22                RET      
----- FUNCTION ?L?COM0054 (END) -------


----- FUNCTION ?L?COM005E (BEGIN) -----
001B15 E0                MOVX     A,@DPTR
001B16 04                INC      A
001B17 F0                MOVX     @DPTR,A
001B18 E0                MOVX     A,@DPTR
001B19 C3                CLR      C
001B1A 9403              SUBB     A,#03H
001B1C 22                RET      
----- FUNCTION ?L?COM005E (END) -------


----- FUNCTION ?L?COM005F (BEGIN) -----
001B1D F0                MOVX     @DPTR,A
001B1E A3                INC      DPTR
001B1F CE                XCH      A,R6
001B20 F0                MOVX     @DPTR,A
001B21 9004CE            MOV      DPTR,#c_u16_eepromSectorBakAddr
001B24 22                RET      
----- FUNCTION ?L?COM005F (END) -------


----- FUNCTION ?L?COM0060 (BEGIN) -----
001B25 3C                ADDC     A,R4
001B26 F583              MOV      DPH,A
001B28 E0                MOVX     A,@DPTR
001B29 FD                MOV      R5,A
001B2A ED                MOV      A,R5
001B2B FF                MOV      R7,A
001B2C 22                RET      
----- FUNCTION ?L?COM0060 (END) -------


----- FUNCTION ?L?COM0061 (BEGIN) -----
001B2D AD07              MOV      R5,AR7
001B2F AC06              MOV      R4,AR6
001B31 75C780            MOV      IAP_CONTR,#080H
001B34 22                RET      
----- FUNCTION ?L?COM0061 (END) -------


