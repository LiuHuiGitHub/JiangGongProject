LX51 LINKER/LOCATER V4.66.41.0                                                          12/03/2015  23:04:50  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  .\Debug\PP01_12 (SYS_DELAY)


----- FUNCTION sys_gpioInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   23: void sys_gpioInit(void)
   24: {
   25: }
   26: 
000009 22                RET      
----- FUNCTION sys_gpioInit (END) -------


----- FUNCTION sys_taskHandler10ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   64: void sys_taskHandler10ms(void)            //10ms interrupt task
   65: {
   66: }
   67: 
00000A 22                RET      
----- FUNCTION sys_taskHandler10ms (END) -------


00000B 02170D            LJMP     0170DH
----- FUNCTION sys_taskHandler1s (BEGIN) -----
 FILE: 'System\sys_task.c'
   73: void sys_taskHandler1s(void)              //1s interrupt task
   74: {
   75: }
   76: 
000021 22                RET      
----- FUNCTION sys_taskHandler1s (END) -------


----- FUNCTION hwa_eepromInit (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   33: void hwa_eepromInit(void)
   34: {
   35: }
   36: 
000022 22                RET      
----- FUNCTION hwa_eepromInit (END) -------


000023 0217AD            LJMP     017ADH
----- FUNCTION _sys_delayus (BEGIN) -----
 FILE: 'System\sys_delay.c'
    5: void sys_delayus(UINT16 xus)
    6: {
;---- Variable 'xus' assigned to Register 'R6/R7' ----
    7:     while(xus--);
00065D         ?C0001?SYS_DELAY:
    8: }
00065D EF                MOV      A,R7
00065E 1F                DEC      R7
00065F AC06              MOV      R4,AR6
000661 7001              JNZ      ?C0012?SYS_DELAY
000663 1E                DEC      R6
000664         ?C0012?SYS_DELAY:
000664 4C                ORL      A,R4
000665 70F6              JNZ      ?C0001?SYS_DELAY
    9: 
000667 22                RET      
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 2


----- FUNCTION _sys_delayus (END) -------


----- FUNCTION Init_FM1702 (BEGIN) -----
 FILE: 'Driver\mifare.c'
  104: void Init_FM1702(void)
  105: {
  106: 	uchar temp;
  107: 	uint i;
  108: 	RC500SCK = 0;
000668 C2A1              CLR      RC500SCK
  109: 	RC500SO = 1;
00066A D2A2              SETB     RC500SO
  110: 	RC500SI = 1;
00066C D2A4              SETB     RC500SI
  111: 	RC500RST = 1;	// FM1702复位 
00066E D2A5              SETB     RC500RST
  112: 	sys_delayms(2);
000670 7F02              MOV      R7,#02H
000672 7E00              MOV      R6,#00H
000674 120822            LCALL    _sys_delayms
  113: 	RC500RST = 0;	
000677 C2A5              CLR      RC500RST
  114: 	//进入复位阶段，需要512个FM1702SL的时钟周期，约38us
  115: 	sys_delayus(100); 
000679 7F64              MOV      R7,#064H
00067B 7E00              MOV      R6,#00H
00067D D15D              ACALL    _sys_delayus
00067F         ?C0024?MIFARE:
  116: 	//进入初始化阶段，需要128个时钟周期，约10us
  117: 	do{ 		// 等待Command = 0,FM1702复位成功
  118: 		temp = SPIReadOne(Command_Reg);	 //(Command_Reg<<1)|0x80 = 0x82
;---- Variable 'temp' assigned to Register 'R4' ----
00067F F1D6              ACALL    ?L?COM0036
000681 70FC              JNZ      ?C0024?MIFARE
  119: 	}while(temp!=0);
  120: ///////////////////////////////////////////////////////////////////////////////////
  121: 	SPIWriteOne(Page_Reg,0x80);	//初始化SPI接口
000683 7D80              MOV      R5,#080H
000685 FF                MOV      R7,A
000686 D1C2              ACALL    _SPIWriteOne
  122: 	for(i = 0; i < 0x1fff; i++) // 延时
;---- Variable 'i' assigned to Register 'R2/R3' ----
000688 E4                CLR      A
000689 FB                MOV      R3,A
00068A FA                MOV      R2,A
00068B         ?C0025?MIFARE:
  123: 	{
  124: 		temp = SPIReadOne(Command_Reg);
00068B F1D6              ACALL    ?L?COM0036
00068D 7006              JNZ      ?C0027?MIFARE
  125: 		if(temp == 0x00)	//SPI初始化成功
  126: 		{
  127: 			SPIWriteOne(Page_Reg,0);//可以使用SPI接口
00068F FD                MOV      R5,A
000690 FF                MOV      R7,A
000691 D1C2              ACALL    _SPIWriteOne
  128: 			break;
000693 800B              SJMP     ?C0026?MIFARE
  129: 		}
  130: 	}
000695         ?C0027?MIFARE:
000695 0B                INC      R3
000696 BB0001            CJNE     R3,#00H,?C0138?MIFARE
000699 0A                INC      R2
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 3


00069A         ?C0138?MIFARE:
00069A BA1FEE            CJNE     R2,#01FH,?C0025?MIFARE
00069D BBFFEB            CJNE     R3,#0FFH,?C0025?MIFARE
0006A0         ?C0026?MIFARE:
  131: ////////////////////////////////////////////////////////////////////////////////////
  132: 	SPIWriteOne(InterruptEn_Reg,0x7F);	//  禁止所有中断请求（最高位置0）
0006A0 7D7F              MOV      R5,#07FH
0006A2 7F06              MOV      R7,#06H
0006A4 D1C2              ACALL    _SPIWriteOne
  133: 	SPIWriteOne(InterruptRq_Reg,0x7F);	// 禁止所有中断请求标识置0（最高位置0）
0006A6 7D7F              MOV      R5,#07FH
0006A8 7F07              MOV      R7,#07H
0006AA D1C2              ACALL    _SPIWriteOne
  134: 	
  135: 	//设置调制器的输入源为内部编码器, 并且设置TX1和TX2
  136: 	SPIWriteOne(TxControl_Reg,0x5B); 		// 发送控制寄存器 
0006AC 7D5B              MOV      R5,#05BH
0006AE 7F11              MOV      R7,#011H
0006B0 D1C2              ACALL    _SPIWriteOne
  137: 	SPIWriteOne(RxControl2_Reg,0x01);
0006B2 7D01              MOV      R5,#01H
0006B4 7F1E              MOV      R7,#01EH
0006B6 D1C2              ACALL    _SPIWriteOne
  138: 	SPIWriteOne(RxWait_Reg,5);
0006B8 7D05              MOV      R5,#05H
0006BA 7F21              MOV      R7,#021H
0006BC 8004              SJMP     _SPIWriteOne
----- FUNCTION Init_FM1702 (END) -------


----- FUNCTION ?L?COM0039 (BEGIN) -----
0006BE F0                MOVX     @DPTR,A
0006BF FD                MOV      R5,A
0006C0 7F01              MOV      R7,#01H
----- FUNCTION _SPIWriteOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   65: void SPIWriteOne(uchar SpiAddress,uchar wData)
   66: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
;---- Variable 'wData' assigned to Register 'R5' ----
   67: 	uchar i;
   68: 	SpiAddress = SpiAddress<<1;
0006C2 EF                MOV      A,R7
0006C3 25E0              ADD      A,ACC
   69: 	SpiAddress = SpiAddress & 0x7E;
0006C5 547E              ANL      A,#07EH
0006C7 FF                MOV      R7,A
   70: 
   71: 	//传输地址 从高位到低位传输
   72: 	RC500CS = 0;
0006C8 C2A3              CLR      RC500CS
   73: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
0006CA E4                CLR      A
0006CB FE                MOV      R6,A
0006CC         ?C0011?MIFARE:
   74: 	{
   75: 		if(SpiAddress&0x80)
0006CC EF                MOV      A,R7
0006CD 30E704            JNB      ACC.7,?C0014?MIFARE
   76: 			RC500SO = 1;
0006D0 D2A2              SETB     RC500SO
0006D2 8002              SJMP     ?C0015?MIFARE
0006D4         ?C0014?MIFARE:
   77: 		else
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 4


   78: 			RC500SO = 0;
0006D4 C2A2              CLR      RC500SO
0006D6         ?C0015?MIFARE:
   79: 		RC500SCK = 1;
0006D6 F1F1              ACALL    ?L?COM0049
0006D8 B408F1            CJNE     A,#08H,?C0011?MIFARE
0006DB         ?C0012?MIFARE:
   80: 		SpiAddress = SpiAddress<<1;
   81: 		RC500SCK = 0;
   82: 	}
   83: 	//传输数据，从高位开始
   84: 	for (i=0;i<8;i++)
0006DB E4                CLR      A
0006DC FE                MOV      R6,A
0006DD         ?C0016?MIFARE:
   85: 	{
   86: 		if(wData & 0x80)
0006DD ED                MOV      A,R5
0006DE 30E704            JNB      ACC.7,?C0019?MIFARE
   87: 			RC500SO = 1;
0006E1 D2A2              SETB     RC500SO
0006E3 8002              SJMP     ?C0020?MIFARE
0006E5         ?C0019?MIFARE:
   88: 		else
   89: 			RC500SO = 0;
0006E5 C2A2              CLR      RC500SO
0006E7         ?C0020?MIFARE:
   90: 		RC500SCK = 1;
0006E7 D2A1              SETB     RC500SCK
   91: 		wData = wData<<1;
0006E9 ED                MOV      A,R5
0006EA 25E0              ADD      A,ACC
0006EC FD                MOV      R5,A
   92: 		RC500SCK = 0;
0006ED C2A1              CLR      RC500SCK
   93: 	}
0006EF 0E                INC      R6
0006F0 EE                MOV      A,R6
0006F1 B408E9            CJNE     A,#08H,?C0016?MIFARE
0006F4         ?C0017?MIFARE:
   94: 	RC500CS = 1;
0006F4 D2A3              SETB     RC500CS
   95: }
0006F6 22                RET      
----- FUNCTION _SPIWriteOne (END) -------


----- FUNCTION _SPIReadOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   24: uchar SPIReadOne(uchar SpiAddress)
   25: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
   26: 	uchar i,rdata; 
   27: 	//地址字节最高位置1，表示为读数据，最低位固定为0，中间6位为地址
   28: 	SpiAddress = SpiAddress<<1;
0006F7 EF                MOV      A,R7
0006F8 25E0              ADD      A,ACC
   29: 	SpiAddress = SpiAddress | 0x80;
0006FA 4480              ORL      A,#080H
0006FC FF                MOV      R7,A
   30: 	//传输地址 从高位到低位传输
   31: 	RC500CS = 0;
0006FD C2A3              CLR      RC500CS
   32: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 5


0006FF E4                CLR      A
000700 FE                MOV      R6,A
000701         ?C0001?MIFARE:
   33: 	{
   34: 		if(SpiAddress&0x80)
000701 EF                MOV      A,R7
000702 30E704            JNB      ACC.7,?C0004?MIFARE
   35: 			RC500SO = 1;
000705 D2A2              SETB     RC500SO
000707 8002              SJMP     ?C0005?MIFARE
000709         ?C0004?MIFARE:
   36: 		else
   37: 			RC500SO = 0;
000709 C2A2              CLR      RC500SO
00070B         ?C0005?MIFARE:
   38: 		RC500SCK = 1;
00070B F1F1              ACALL    ?L?COM0049
00070D B408F1            CJNE     A,#08H,?C0001?MIFARE
000710         ?C0002?MIFARE:
   39: 		SpiAddress = SpiAddress<<1;
   40: 		RC500SCK = 0;
   41: 	}
   42: 	
   43: 	//接收数据
   44: 	rdata = 0;
;---- Variable 'rdata' assigned to Register 'R7' ----
000710 E4                CLR      A
000711 FF                MOV      R7,A
   45: 	for (i=0;i<8;i++)
000712 FE                MOV      R6,A
000713         ?C0006?MIFARE:
   46: 	{
   47: 		RC500SCK = 1;
000713 D2A1              SETB     RC500SCK
   48: 		rdata = rdata<<1;
000715 EF                MOV      A,R7
000716 25E0              ADD      A,ACC
000718 FF                MOV      R7,A
   49: 		if (RC500SI)
000719 30A401            JNB      RC500SI,?C0009?MIFARE
   50: 			rdata+= 1;
00071C 0F                INC      R7
00071D         ?C0009?MIFARE:
   51: 		RC500SCK = 0;
00071D C2A1              CLR      RC500SCK
   52: 	}
00071F 0E                INC      R6
000720 EE                MOV      A,R6
000721 B408EF            CJNE     A,#08H,?C0006?MIFARE
000724         ?C0007?MIFARE:
   53: 	RC500CS=1;
000724 D2A3              SETB     RC500CS
   54: 	return (rdata);
   55: }
000726 22                RET      
----- FUNCTION _SPIReadOne (END) -------


----- FUNCTION AntiColl (BEGIN) -----
 FILE: 'Driver\mifare.c'
  278: uchar AntiColl(void)
  279: {
  280: 	
  281: 	uchar	temp,i;
  282: 
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 6


  283: 	//选择TX1、TX2的发射天线阻抗
  284: 	SPIWriteOne(CwConductance_Reg,0x3f);
000727 1215E9            LCALL    ?L?COM001F
00072A 7493              MOV      A,#093H
00072C F0                MOVX     @DPTR,A
  285: 	//选择数据校验种类和模式
  286: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  287: 	
  288: 	gBuff[0] = RF_CMD_ANTICOL;
  289: 	gBuff[1] = 0x20;
00072D A3                INC      DPTR
00072E 7420              MOV      A,#020H
000730 120B4A            LCALL    ?L?COM000F
000733 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
000736 7402              MOV      A,#02H
000738 F0                MOVX     @DPTR,A
000739 7F1E              MOV      R7,#01EH
00073B F191              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R5' ----
00073D AD07              MOV      R5,AR7
  290: 	temp = Command_Send(Transceive,gBuff,2);
  291: 	if (temp==0)
00073F ED                MOV      A,R5
000740 7003              JNZ      ?C0062?MIFARE
  292: 	{
  293: 		return(FM1702_NOTAGERR);
000742 7F01              MOV      R7,#01H
000744 22                RET      
  294: 	}
000745         ?C0062?MIFARE:
  295: 
  296: 	temp = SPIReadOne(FIFOLength_Reg);
000745 F1DE              ACALL    ?L?COM0041
000747 7003              JNZ      ?C0064?MIFARE
  297: 	if (temp == 0)
  298: 	{
  299: 		return FM1702_BYTECOUNTERR;
000749 7F0C              MOV      R7,#0CH
00074B 22                RET      
  300: 	}
00074C         ?C0064?MIFARE:
  301: 
  302: 	for(i=0;i<temp;i++)
;---- Variable 'i' assigned to Register 'R4' ----
00074C E4                CLR      A
00074D FC                MOV      R4,A
00074E         ?C0065?MIFARE:
00074E EC                MOV      A,R4
00074F C3                CLR      C
000750 9D                SUBB     A,R5
000751 500B              JNC      ?C0066?MIFARE
  303: 	{
  304: 		gBuff[i] = SPIReadOne(FIFO_Reg);
000753 7F02              MOV      R7,#02H
000755 D1F7              ACALL    _SPIReadOne
000757 F1E6              ACALL    ?L?COM0034
000759 EF                MOV      A,R7
00075A F0                MOVX     @DPTR,A
  305: 	}
00075B 0C                INC      R4
00075C 80F0              SJMP     ?C0065?MIFARE
00075E         ?C0066?MIFARE:
  306: 	temp = SPIReadOne(ErrorFlag_Reg);	// 判断接数据是否有冲突位
00075E 7F0A              MOV      R7,#0AH
000760 F1E0              ACALL    ?L?COM0042
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 7


000762 5401              ANL      A,#01H
000764 FD                MOV      R5,A
  307: 	temp = temp & 0x01;
  308: 	if (temp == 0x00)
000765 7027              JNZ      ?C0068?MIFARE
  309: 	{
  310: 		for (i=0;i<5;i++)
000767 FC                MOV      R4,A
000768         ?C0069?MIFARE:
  311: 			temp^=gBuff[i];
000768 F1E6              ACALL    ?L?COM0034
00076A E0                MOVX     A,@DPTR
00076B 6D                XRL      A,R5
00076C FD                MOV      R5,A
00076D 0C                INC      R4
00076E EC                MOV      A,R4
00076F B405F6            CJNE     A,#05H,?C0069?MIFARE
000772         ?C0070?MIFARE:
  312: 		if (temp)
000772 ED                MOV      A,R5
000773 6003              JZ       ?C0072?MIFARE
  313: 			return(FM1702_SERNRERR);
000775 7F08              MOV      R7,#08H
000777 22                RET      
000778         ?C0072?MIFARE:
  314:         for (i=0;i<5;i++)
000778 E4                CLR      A
000779 FC                MOV      R4,A
00077A         ?C0073?MIFARE:
  315:         {
  316:             gCard_UID[i]=gBuff[i];
00077A F1E6              ACALL    ?L?COM0034
00077C E0                MOVX     A,@DPTR
00077D FF                MOV      R7,A
00077E 74B4              MOV      A,#LOW gCard_UID
000780 2C                ADD      A,R4
000781 121A95            LCALL    ?L?COM0056
000784 EF                MOV      A,R7
000785 F0                MOVX     @DPTR,A
  317:         }
000786 0C                INC      R4
000787 EC                MOV      A,R4
000788 B405EF            CJNE     A,#05H,?C0073?MIFARE
00078B         ?C0074?MIFARE:
  318: 		return(FM1702_OK);
00078B 7F00              MOV      R7,#00H
00078D 22                RET      
  319: 	}
00078E         ?C0068?MIFARE:
  320: 	else //有冲突位
  321: 		return FM1702_SERNRERR;
00078E 7F08              MOV      R7,#08H
  322: }
000790 22                RET      
----- FUNCTION AntiColl (END) -------


----- FUNCTION _Command_Send (BEGIN) -----
 FILE: 'Driver\mifare.c'
  251: uchar Command_Send(uchar Comm_Set,uchar *buff, uchar count)
  252: {
000791 900094            MOV      DPTR,#Comm_Set
000794 EF                MOV      A,R7
000795 F0                MOVX     @DPTR,A
;---- Variable 'buff' assigned to Register 'R1/R2/R3' ----
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 8


  253:     uchar ucResult1,ucResult2,i;
  254:     SPIWriteOne(Command_Reg,0x00);
000796 E4                CLR      A
000797 FD                MOV      R5,A
000798 7F01              MOV      R7,#01H
00079A D1C2              ACALL    _SPIWriteOne
  255:     if(Clear_FIFO()==FALSE)
00079C F1FC              ACALL    Clear_FIFO
00079E EF                MOV      A,R7
00079F 7002              JNZ      ?C0055?MIFARE
  256:         return FALSE;
0007A1 FF                MOV      R7,A
0007A2 22                RET      
0007A3         ?C0055?MIFARE:
  257:     Write_FIFO(buff,count);
0007A3 900098            MOV      DPTR,#count
0007A6 E0                MOVX     A,@DPTR
0007A7 FD                MOV      R5,A
0007A8 121994            LCALL    _Write_FIFO
  258: 	SPIWriteOne(Command_Reg,Comm_Set);
0007AB 900094            MOV      DPTR,#Comm_Set
0007AE E0                MOVX     A,@DPTR
0007AF FD                MOV      R5,A
0007B0 7F01              MOV      R7,#01H
0007B2 D1C2              ACALL    _SPIWriteOne
  259: 	for (i=0;i<0xA0;i++)
;---- Variable 'i' assigned to Register 'R5' ----
0007B4 E4                CLR      A
0007B5 FD                MOV      R5,A
0007B6         ?C0057?MIFARE:
  260: 	{
  261:         ucResult1 = SPIReadOne(Command_Reg);
0007B6 7F01              MOV      R7,#01H
0007B8 D1F7              ACALL    _SPIReadOne
;---- Variable 'ucResult1' assigned to Register 'R4' ----
0007BA AC07              MOV      R4,AR7
  262:         ucResult2 = SPIReadOne(InterruptRq_Reg) & 0x80;
0007BC 7F07              MOV      R7,#07H
0007BE D1F7              ACALL    _SPIReadOne
0007C0 EF                MOV      A,R7
0007C1 5480              ANL      A,#080H
0007C3 FF                MOV      R7,A
;---- Variable 'ucResult2' assigned to Register 'R7' ----
  263:         if(ucResult1 == 0 || ucResult2 ==0x80)
0007C4 EC                MOV      A,R4
0007C5 6004              JZ       ?C0061?MIFARE
0007C7 EF                MOV      A,R7
0007C8 B48003            CJNE     A,#080H,?C0059?MIFARE
0007CB         ?C0061?MIFARE:
  264:             return TRUE;
0007CB 7F01              MOV      R7,#01H
0007CD 22                RET      
  265: 	}
0007CE         ?C0059?MIFARE:
0007CE 0D                INC      R5
0007CF ED                MOV      A,R5
0007D0 B4A0E3            CJNE     A,#0A0H,?C0057?MIFARE
0007D3         ?C0058?MIFARE:
  266: 	return FALSE;
0007D3 7F00              MOV      R7,#00H
  267: }
0007D5 22                RET      
----- FUNCTION _Command_Send (END) -------


LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 9


----- FUNCTION ?L?COM0036 (BEGIN) -----
0007D6 7F01              MOV      R7,#01H
0007D8         ?L?COM0037:
0007D8 D1F7              ACALL    _SPIReadOne
0007DA AC07              MOV      R4,AR7
0007DC EC                MOV      A,R4
0007DD 22                RET      
----- FUNCTION ?L?COM0036 (END) -------


----- FUNCTION ?L?COM0041 (BEGIN) -----
0007DE 7F04              MOV      R7,#04H
0007E0         ?L?COM0042:
0007E0 D1F7              ACALL    _SPIReadOne
0007E2 AD07              MOV      R5,AR7
0007E4 ED                MOV      A,R5
0007E5 22                RET      
----- FUNCTION ?L?COM0041 (END) -------


----- FUNCTION ?L?COM0034 (BEGIN) -----
0007E6 74B9              MOV      A,#LOW gBuff
0007E8 2C                ADD      A,R4
0007E9 F582              MOV      DPL,A
0007EB E4                CLR      A
0007EC 3400              ADDC     A,#HIGH gBuff
0007EE F583              MOV      DPH,A
0007F0 22                RET      
----- FUNCTION ?L?COM0034 (END) -------


----- FUNCTION ?L?COM0049 (BEGIN) -----
0007F1 D2A1              SETB     RC500SCK
0007F3 EF                MOV      A,R7
0007F4 25E0              ADD      A,ACC
0007F6 FF                MOV      R7,A
0007F7 C2A1              CLR      RC500SCK
0007F9 0E                INC      R6
0007FA EE                MOV      A,R6
0007FB 22                RET      
----- FUNCTION ?L?COM0049 (END) -------


----- FUNCTION Clear_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  190: uchar Clear_FIFO(void)
  191: {
  192:     uchar ucResult,i;
  193:     ucResult = SPIReadOne(Control_Reg);
0007FC 7F09              MOV      R7,#09H
;---- Variable 'ucResult' assigned to Register 'R4' ----
0007FE 1207D8            LCALL    ?L?COM0037
000801 4401              ORL      A,#01H
000803 FC                MOV      R4,A
  194:     ucResult |=0x01;
  195:     SPIWriteOne(Control_Reg,ucResult);
000804 FD                MOV      R5,A
000805 7F09              MOV      R7,#09H
000807 1206C2            LCALL    _SPIWriteOne
  196:     for(i=0;i<0xA0;i++)
;---- Variable 'i' assigned to Register 'R5' ----
00080A E4                CLR      A
00080B FD                MOV      R5,A
00080C         ?C0039?MIFARE:
  197:     {
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 10


  198:         ucResult = SPIReadOne(FIFOLength_Reg);
00080C 7F04              MOV      R7,#04H
00080E 1207D8            LCALL    ?L?COM0037
000811 7003              JNZ      ?C0041?MIFARE
  199:         if(ucResult == 0)
  200:             return TRUE;
000813 7F01              MOV      R7,#01H
000815 22                RET      
  201:     }
000816         ?C0041?MIFARE:
000816 0D                INC      R5
000817 ED                MOV      A,R5
000818 B4A0F1            CJNE     A,#0A0H,?C0039?MIFARE
00081B         ?C0040?MIFARE:
  202:     return FALSE;
00081B 7F00              MOV      R7,#00H
  203: }
00081D 22                RET      
----- FUNCTION Clear_FIFO (END) -------


----- FUNCTION ?L?COM0046 (BEGIN) -----
00081E 7FE8              MOV      R7,#0E8H
000820 7E03              MOV      R6,#03H
----- FUNCTION _sys_delayms (BEGIN) -----
 FILE: 'System\sys_delay.c'
   10: void sys_delayms(UINT16 xms)
   11: {   
;---- Variable 'xms' assigned to Register 'R6/R7' ----
   12:     UINT8 i, j;
000822         ?C0004?SYS_DELAY:
   13: 	while(xms--)
000822 EF                MOV      A,R7
000823 1F                DEC      R7
000824 AC06              MOV      R4,AR6
000826 7001              JNZ      ?C0013?SYS_DELAY
000828 1E                DEC      R6
000829         ?C0013?SYS_DELAY:
000829 4C                ORL      A,R4
00082A 600D              JZ       ?C0011?SYS_DELAY
   14:     {
   15:     	WDT_CONTR |= 0x35;
00082C 43C135            ORL      WDT_CONTR,#035H
   16:         i = 22;
;---- Variable 'i' assigned to Register 'R5' ----
00082F 7D16              MOV      R5,#016H
   17:         j = 128;
;---- Variable 'j' assigned to Register 'R4' ----
000831 7C80              MOV      R4,#080H
   18:         do
   19:         {
000833         ?C0009?SYS_DELAY:
   20:             while (--j);
000833 DCFE              DJNZ     R4,?C0009?SYS_DELAY
000835         ?C0010?SYS_DELAY:
   21:         } while (--i);
000835         ?C0006?SYS_DELAY:
000835 DDFC              DJNZ     R5,?C0009?SYS_DELAY
   22:     }
000837 80E9              SJMP     ?C0004?SYS_DELAY
   22: }
000839         ?C0011?SYS_DELAY:
000839 22                RET      
----- FUNCTION _sys_delayms (END) -------

LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 11



----- FUNCTION app_Show (BEGIN) -----
 FILE: 'App\app_brush.c'
   20: void app_Show(void)
   21: {
   22:     if(!b_FactorySystem)
   23:     {
00083A 20081D            JB       b_FactorySystem,?C0002?APP_BRUSH
   24:         sys_delayms(1000);
   25:         led_ShowNumber(MoneySum/100, MoneySum%100, 0);
00083D 111E              ACALL    ?L?COM0046
   26:         sys_delayms(1000);
00083F 115B              ACALL    ?L?COM0027
000841 C006              PUSH     AR6
000843 C007              PUSH     AR7
000845 115B              ACALL    ?L?COM0027
000847 AF03              MOV      R7,AR3
000849 AD07              MOV      R5,AR7
00084B D007              POP      AR7
00084D D006              POP      AR6
00084F E4                CLR      A
000850 FB                MOV      R3,A
000851 1172              ACALL    _led_ShowNumber
   27:         gLedBuf[0] = 12;
000853 111E              ACALL    ?L?COM0046
   28:         gLedBuf[1] = 15;
000855 1219FE            LCALL    ?L?COM0022
   29:         gLedBuf[2] = 15;
   30:         gLedBuf[3] = 15;
   31:         gLedBuf[4] = 15;
   32:         gLedBuf[5] = 12;
   33:         gShowDot = 0;
   34:         sys_delayms(1000);
000858 111E              ACALL    ?L?COM0046
   35:     }
   36: }
00085A         ?C0002?APP_BRUSH:
00085A 22                RET      
----- FUNCTION app_Show (END) -------


----- FUNCTION ?L?COM0027 (BEGIN) -----
00085B E4                CLR      A
00085C 7B64              MOV      R3,#064H
00085E FA                MOV      R2,A
00085F F9                MOV      R1,A
000860 F8                MOV      R0,A
000861 90009D            MOV      DPTR,#MoneySum
000864 E0                MOVX     A,@DPTR
000865 FC                MOV      R4,A
000866 A3                INC      DPTR
000867 E0                MOVX     A,@DPTR
000868 FD                MOV      R5,A
000869 A3                INC      DPTR
00086A E0                MOVX     A,@DPTR
00086B FE                MOV      R6,A
00086C A3                INC      DPTR
00086D E0                MOVX     A,@DPTR
00086E FF                MOV      R7,A
00086F 0202D1            LJMP     ?C?ULDIV
----- FUNCTION ?L?COM0027 (END) -------


----- FUNCTION _led_ShowNumber (BEGIN) -----
 FILE: 'Driver\LED.c'
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 12


   95: void led_ShowNumber(UINT16 L_num, UINT8 R_num, UINT8 DotPlace)
   96: {
000872 F1FD              ACALL    ?L?COM0050
;---- Variable 'R_num' assigned to Register 'R2' ----
000874 AA05              MOV      R2,AR5
;---- Variable 'DotPlace' assigned to Register 'R3' ----
   97:     if(L_num>9999)
   98:     {
000876 D3                SETB     C
000877 E0                MOVX     A,@DPTR
000878 940F              SUBB     A,#0FH
00087A 900070            MOV      DPTR,#L_num
00087D E0                MOVX     A,@DPTR
00087E 9427              SUBB     A,#027H
000880 4007              JC       ?C0034?LED
   99:         L_num = 9999;
  100:     }
000882 7427              MOV      A,#027H
000884 F0                MOVX     @DPTR,A
000885 A3                INC      DPTR
000886 740F              MOV      A,#0FH
000888 F0                MOVX     @DPTR,A
  101:     if(R_num>99)
000889         ?C0034?LED:
  102:     {
000889 EA                MOV      A,R2
00088A D3                SETB     C
00088B 9463              SUBB     A,#063H
00088D 4002              JC       ?C0035?LED
  103:         R_num = 99;
  104:     }
00088F 7A63              MOV      R2,#063H
  105:     gLedBuf[0] = L_num/1000;
000891         ?C0035?LED:
  106:     gLedBuf[1] = L_num/100%10;
000891 900070            MOV      DPTR,#L_num
000894 E0                MOVX     A,@DPTR
000895 FE                MOV      R6,A
000896 A3                INC      DPTR
000897 E0                MOVX     A,@DPTR
000898 FF                MOV      R7,A
000899 7C03              MOV      R4,#03H
00089B 7DE8              MOV      R5,#0E8H
00089D 1201A8            LCALL    ?C?UIDIV
0008A0 9000D2            MOV      DPTR,#gLedBuf
0008A3 EF                MOV      A,R7
0008A4 7158              ACALL    ?L?COM0019
0008A6 7D64              MOV      R5,#064H
0008A8 11C8              ACALL    ?L?COM0003
0008AA 11DF              ACALL    ?L?COM0006
0008AC 9000D4            MOV      DPTR,#gLedBuf+02H
0008AF 11D5              ACALL    ?L?COM0004
0008B1 9000D5            MOV      DPTR,#gLedBuf+03H
0008B4 ED                MOV      A,R5
0008B5 F0                MOVX     @DPTR,A
  107:     gLedBuf[2] = L_num/10%10;
  108:     gLedBuf[3] = L_num%10;
  109:     gLedBuf[4] = R_num/10%10;
0008B6 EA                MOV      A,R2
0008B7 75F00A            MOV      B,#0AH
0008BA 84                DIV      AB
0008BB 121A7D            LCALL    ?L?COM0051
  110:     gLedBuf[5] = R_num%10;
0008BE EA                MOV      A,R2
0008BF 121A7D            LCALL    ?L?COM0051
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 13


  111:     gShowDot = DotPlace;
0008C2 9000D9            MOV      DPTR,#gShowDot
0008C5 EB                MOV      A,R3
0008C6 F0                MOVX     @DPTR,A
  112: }
0008C7 22                RET      
----- FUNCTION _led_ShowNumber (END) -------


----- FUNCTION ?L?COM0003 (BEGIN) -----
0008C8 1201A8            LCALL    ?C?UIDIV
0008CB 7C00              MOV      R4,#00H
0008CD 7D0A              MOV      R5,#0AH
0008CF 1201A8            LCALL    ?C?UIDIV
0008D2 9000D3            MOV      DPTR,#gLedBuf+01H
0008D5         ?L?COM0004:
0008D5 ED                MOV      A,R5
0008D6 F0                MOVX     @DPTR,A
0008D7 900070            MOV      DPTR,#L_num
0008DA         ?L?COM0005:
0008DA E0                MOVX     A,@DPTR
0008DB FE                MOV      R6,A
0008DC A3                INC      DPTR
0008DD E0                MOVX     A,@DPTR
0008DE FF                MOV      R7,A
0008DF         ?L?COM0006:
0008DF 7C00              MOV      R4,#00H
0008E1 7D0A              MOV      R5,#0AH
0008E3 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM0003 (END) -------


----- FUNCTION _led_ShowNumber1 (BEGIN) -----
 FILE: 'Driver\LED.c'
  114: void led_ShowNumber1(UINT16 L_num, UINT16 R_num, UINT8 DotPlace)
  115: {
0008E6 900072            MOV      DPTR,#R_num
0008E9 EC                MOV      A,R4
0008EA F0                MOVX     @DPTR,A
0008EB A3                INC      DPTR
0008EC ED                MOV      A,R5
0008ED F0                MOVX     @DPTR,A
0008EE F1FD              ACALL    ?L?COM0050
;---- Variable 'DotPlace' assigned to Register 'R3' ----
  116:     if(L_num>999)
  117:     {
0008F0 D3                SETB     C
0008F1 94E7              SUBB     A,#0E7H
0008F3 EE                MOV      A,R6
0008F4 9403              SUBB     A,#03H
0008F6 4006              JC       ?C0037?LED
  118:         L_num = 999;
  119:     }
0008F8 900070            MOV      DPTR,#L_num
0008FB 121A9D            LCALL    ?L?COM0058
  120:     if(R_num>999)
0008FE         ?C0037?LED:
  121:     {
0008FE D3                SETB     C
0008FF 900073            MOV      DPTR,#R_num+01H
000902 E0                MOVX     A,@DPTR
000903 94E7              SUBB     A,#0E7H
000905 900072            MOV      DPTR,#R_num
000908 E0                MOVX     A,@DPTR
000909 9403              SUBB     A,#03H
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 14


00090B 4003              JC       ?C0038?LED
  122:         R_num = 999;
  123:     }
00090D 121A9D            LCALL    ?L?COM0058
  124:     gLedBuf[0] = L_num/100%10;
000910         ?C0038?LED:
  125:     gLedBuf[1] = L_num/10%10;
000910 7159              ACALL    ?L?COM001A
000912 7D64              MOV      R5,#064H
000914 1201A8            LCALL    ?C?UIDIV
000917 11DF              ACALL    ?L?COM0006
000919 9000D2            MOV      DPTR,#gLedBuf
00091C ED                MOV      A,R5
00091D 7158              ACALL    ?L?COM0019
00091F 7D0A              MOV      R5,#0AH
000921 11C8              ACALL    ?L?COM0003
000923 9000D4            MOV      DPTR,#gLedBuf+02H
000926 ED                MOV      A,R5
000927 F0                MOVX     @DPTR,A
  126:     gLedBuf[2] = L_num%10;
  127:     gLedBuf[3] = R_num/100;
000928 900072            MOV      DPTR,#R_num
00092B 715C              ACALL    ?L?COM001B
00092D 7D64              MOV      R5,#064H
00092F 1201A8            LCALL    ?C?UIDIV
000932 9000D5            MOV      DPTR,#gLedBuf+03H
000935 EF                MOV      A,R7
000936 F0                MOVX     @DPTR,A
  128:     if(gLedBuf[3] == 0)
000937 7003              JNZ      ?C0039?LED
  129:     {
  130:         gLedBuf[3] = 12;
000939 740C              MOV      A,#0CH
00093B F0                MOVX     @DPTR,A
  131:     }
00093C         ?C0039?LED:
  132:     gLedBuf[4] = R_num/10%10;
00093C 900072            MOV      DPTR,#R_num
00093F 11DA              ACALL    ?L?COM0005
000941 11DF              ACALL    ?L?COM0006
000943 AF05              MOV      R7,AR5
000945 9000D6            MOV      DPTR,#gLedBuf+04H
000948 EF                MOV      A,R7
000949 F0                MOVX     @DPTR,A
  133:     if(gLedBuf[4] == 0)
00094A 7003              JNZ      ?C0040?LED
  134:     {
  135:         gLedBuf[4] = 12;
00094C 740C              MOV      A,#0CH
00094E F0                MOVX     @DPTR,A
  136:     }
00094F         ?C0040?LED:
  137:     gLedBuf[5] = R_num%10;
00094F 900072            MOV      DPTR,#R_num
000952 11DA              ACALL    ?L?COM0005
000954 9000D7            MOV      DPTR,#gLedBuf+05H
000957 ED                MOV      A,R5
000958 F0                MOVX     @DPTR,A
  138:     gShowDot = DotPlace;
000959 9000D9            MOV      DPTR,#gShowDot
00095C EB                MOV      A,R3
00095D F0                MOVX     @DPTR,A
  139: }
00095E 22                RET      
----- FUNCTION _led_ShowNumber1 (END) -------
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 15




----- FUNCTION app_brushCycle1s (BEGIN) -----
 FILE: 'App\app_brush.c'
  114: void app_brushCycle1s(void)
  115: {
  116:     switch (app_brushCard())
  117:     {
00095F 121449            LCALL    app_brushCard
000962 EF                MOV      A,R7
000963 24FE              ADD      A,#0FEH
000965 7002              JNZ      $ + 4H
000967 414B              AJMP     ?C0039?APP_BRUSH
000969 14                DEC      A
00096A 7002              JNZ      $ + 4H
00096C 410C              AJMP     ?C0033?APP_BRUSH
00096E 2402              ADD      A,#02H
000970 6002              JZ       $ + 4H
000972 6131              AJMP     ?C0023?APP_BRUSH
  118:         case MEM_CARD:
  119:             if(hwa_mifareReadBlock(gBuff,4))
000974         ?C0024?APP_BRUSH:
  120:             {
000974 714B              ACALL    ?L?COM0010
000976 7D04              MOV      R5,#04H
000978 718B              ACALL    _hwa_mifareReadBlock
00097A 4002              JC       $ + 4H
00097C 6131              AJMP     ?C0023?APP_BRUSH
  121:                 if(u8_FirstBrushCardDly)
  122:                 {
00097E 9000D1            MOV      DPTR,#u8_FirstBrushCardDly
000981 E0                MOVX     A,@DPTR
000982 607A              JZ       ?C0026?APP_BRUSH
  123:                     if(gBuff[0]==0x01 && gBuff[1]==0x0A)
  124:                     {
000984 9000B9            MOV      DPTR,#gBuff
000987 E0                MOVX     A,@DPTR
000988 6401              XRL      A,#01H
00098A 7032              JNZ      ?C0027?APP_BRUSH
00098C A3                INC      DPTR
00098D E0                MOVX     A,@DPTR
00098E B40A2D            CJNE     A,#0AH,?C0027?APP_BRUSH
  125:                         s_System.Money += 1000;
  126: 						if (s_System.Money > 20000)
000991 9000B3            MOV      DPTR,#s_System+012H
000994 E0                MOVX     A,@DPTR
000995 24E8              ADD      A,#0E8H
000997 F0                MOVX     @DPTR,A
000998 9000B2            MOV      DPTR,#s_System+011H
00099B E0                MOVX     A,@DPTR
00099C 3403              ADDC     A,#03H
00099E F0                MOVX     @DPTR,A
  127: 						{
00099F D3                SETB     C
0009A0 A3                INC      DPTR
0009A1 12110A            LCALL    ?L?COM002F
0009A4 4004              JC       ?C0028?APP_BRUSH
  128: 							s_System.Money = 0;
  129: 						}
0009A6 E4                CLR      A
0009A7 F0                MOVX     @DPTR,A
0009A8 A3                INC      DPTR
0009A9 F0                MOVX     @DPTR,A
  130:                         s_System.Money -= s_System.Money%1000;
0009AA         ?C0028?APP_BRUSH:
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 16


  131:                     }
0009AA 9000B2            MOV      DPTR,#s_System+011H
0009AD F1C2              ACALL    ?L?COM0030
0009AF C3                CLR      C
0009B0 EB                MOV      A,R3
0009B1 9D                SUBB     A,R5
0009B2 FE                MOV      R6,A
0009B3 EA                MOV      A,R2
0009B4 9C                SUBB     A,R4
0009B5 9000B2            MOV      DPTR,#s_System+011H
0009B8 F0                MOVX     @DPTR,A
0009B9 A3                INC      DPTR
0009BA CE                XCH      A,R6
0009BB F0                MOVX     @DPTR,A
  132:                     else if(gBuff[0]==0xFA && gBuff[1]==0x01)
0009BC 8040              SJMP     ?C0026?APP_BRUSH
0009BE         ?C0027?APP_BRUSH:
  133:                     {
0009BE 9000B9            MOV      DPTR,#gBuff
0009C1 E0                MOVX     A,@DPTR
0009C2 64FA              XRL      A,#0FAH
0009C4 7038              JNZ      ?C0026?APP_BRUSH
0009C6 A3                INC      DPTR
0009C7 E0                MOVX     A,@DPTR
0009C8 6401              XRL      A,#01H
0009CA 7032              JNZ      ?C0026?APP_BRUSH
  134:                         if(s_System.Money<20000)
  135:                         {
0009CC C3                CLR      C
0009CD 121107            LCALL    ?L?COM002E
0009D0 502C              JNC      ?C0026?APP_BRUSH
  136:                             s_System.Money += 100;
  137:                             if (s_System.Money % 1000 == 0 && s_System.Money/1000>0)
0009D2 A3                INC      DPTR
0009D3 E0                MOVX     A,@DPTR
0009D4 2464              ADD      A,#064H
0009D6 F0                MOVX     @DPTR,A
0009D7 9000B2            MOV      DPTR,#s_System+011H
0009DA E0                MOVX     A,@DPTR
0009DB 3400              ADDC     A,#00H
0009DD F0                MOVX     @DPTR,A
  138:                             {
0009DE F1C2              ACALL    ?L?COM0030
0009E0 ED                MOV      A,R5
0009E1 4C                ORL      A,R4
0009E2 701A              JNZ      ?C0026?APP_BRUSH
0009E4 7C03              MOV      R4,#03H
0009E6 7DE8              MOV      R5,#0E8H
0009E8 F1EE              ACALL    ?L?COM005D
0009EA D3                SETB     C
0009EB EF                MOV      A,R7
0009EC 9400              SUBB     A,#00H
0009EE EE                MOV      A,R6
0009EF 9400              SUBB     A,#00H
0009F1 400B              JC       ?C0026?APP_BRUSH
  139:                                 s_System.Money -= 1000;
  140:                             }
0009F3 E0                MOVX     A,@DPTR
0009F4 2418              ADD      A,#018H
0009F6 F0                MOVX     @DPTR,A
0009F7 9000B2            MOV      DPTR,#s_System+011H
0009FA E0                MOVX     A,@DPTR
0009FB 34FC              ADDC     A,#0FCH
0009FD F0                MOVX     @DPTR,A
  141:                         }
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 17


  142:                     }
  143:                 }
  144:                 led_ShowNumber1(s_System.Money/100, u8_BrushNum, 0);
0009FE         ?C0026?APP_BRUSH:
  145:                 u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
0009FE B1C0              ACALL    ?L?COM0038
000A00 7170              ACALL    ?L?COM000C
000A02 7182              ACALL    ?L?COM003B
  146:                 buzzer_SoundNumber(1);
000A04 7F01              MOV      R7,#01H
000A06 7152              ACALL    _buzzer_SoundNumber
  147:                 b_SettingChange = TRUE;
000A08 D207              SETB     b_SettingChange
  148:             }
  149:             break;
000A0A 6131              AJMP     ?C0023?APP_BRUSH
  150:             
  151:         case PWD_CARD:                                 //从初始卡中读取管理卡密码，并储存至E2
000A0C         ?C0033?APP_BRUSH:
  152:             if(hwa_mifareReadBlock(gBuff,4))       //读取管理卡密码
000A0C 714B              ACALL    ?L?COM0010
000A0E 7D04              MOV      R5,#04H
000A10 718B              ACALL    _hwa_mifareReadBlock
000A12 4002              JC       $ + 4H
000A14 6131              AJMP     ?C0023?APP_BRUSH
  153:             {
  154:                 memcpy(&s_System, gBuff, 16);
000A16 78A1              MOV      R0,#LOW s_System
000A18 7C00              MOV      R4,#HIGH s_System
000A1A 7D01              MOV      R5,#01H
000A1C 714B              ACALL    ?L?COM0010
000A1E F1BB              ACALL    ?L?COM0043
  155: 
  156: 	            if (hwa_mifareReadBlock(gBuff, 5))			//读取管理卡和用户卡密码以及扇区
000A20 714B              ACALL    ?L?COM0010
000A22 7D05              MOV      R5,#05H
000A24 718B              ACALL    _hwa_mifareReadBlock
000A26 4002              JC       $ + 4H
000A28 6131              AJMP     ?C0023?APP_BRUSH
  157: 	            {
  158: 	                if(gBuff[0] == 0x01)
000A2A 9000B9            MOV      DPTR,#gBuff
000A2D E0                MOVX     A,@DPTR
000A2E B40108            CJNE     A,#01H,?C0036?APP_BRUSH
  159: 	                {
  160: 	                    s_System.RecoveryOldCard = 1;
000A31 9000B1            MOV      DPTR,#s_System+010H
000A34 7401              MOV      A,#01H
000A36 F0                MOVX     @DPTR,A
  161: 	                }
000A37 8005              SJMP     ?C0038?APP_BRUSH
000A39         ?C0036?APP_BRUSH:
  162: 	                else
  163: 	                {
  164: 	                    s_System.RecoveryOldCard = 0;
000A39 E4                CLR      A
000A3A 9000B1            MOV      DPTR,#s_System+010H
000A3D F0                MOVX     @DPTR,A
  165: 	                }
  166: 	            }
  167: 	            else
  168: 	            {
  169: 	                break;
  170: 	            }
000A3E         ?C0038?APP_BRUSH:
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 18


  171:                 app_configWrite(SYSTEM_SETTING_SECTOR);
000A3E E4                CLR      A
000A3F FF                MOV      R7,A
000A40 1210C1            LCALL    _app_configWrite
  172:                 buzzer_SoundNumber(1);
000A43 7F01              MOV      R7,#01H
000A45 7152              ACALL    _buzzer_SoundNumber
  173:                 b_FactorySystem = FALSE;
000A47 C208              CLR      b_FactorySystem
  174:             }
  175:             break;
000A49 6131              AJMP     ?C0023?APP_BRUSH
  176:             
  177:         case USER_CARD:
000A4B         ?C0039?APP_BRUSH:
  178: //            pMoney->money = 1000;
  179: //            hwa_mifareWriteSector(gBuff, s_System.Sector);
  180: //            break;
  181:             if(hwa_mifareReadSector(gBuff, s_System.Sector))
000A4B 714B              ACALL    ?L?COM0010
000A4D 9000A7            MOV      DPTR,#s_System+06H
000A50 E0                MOVX     A,@DPTR
000A51 FD                MOV      R5,A
000A52 71B6              ACALL    _hwa_mifareReadSector
000A54 4002              JC       $ + 4H
000A56 6131              AJMP     ?C0023?APP_BRUSH
  182:             {
  183:                 if(b_SettingChange == FALSE)
000A58 200726            JB       b_SettingChange,?C0041?APP_BRUSH
  184:                 {
  185:                     led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
000A5B AB08              MOV      R3,pMoney
000A5D AA09              MOV      R2,pMoney+01H
000A5F A90A              MOV      R1,pMoney+02H
000A61 120213            LCALL    ?C?ILDPTR
000A64 FB                MOV      R3,A
000A65 AAF0              MOV      R2,B
000A67 7C00              MOV      R4,#00H
000A69 7D64              MOV      R5,#064H
000A6B F1CB              ACALL    ?L?COM0031
000A6D C006              PUSH     AR6
000A6F C007              PUSH     AR7
000A71 7C00              MOV      R4,#00H
000A73 7D64              MOV      R5,#064H
000A75 F1EE              ACALL    ?L?COM005D
000A77 D007              POP      AR7
000A79 D006              POP      AR6
000A7B 7B08              MOV      R3,#08H
000A7D 1172              ACALL    _led_ShowNumber
  186:                     u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
  187:                     buzzer_SoundNumber(1);
  188:                 }
000A7F 611C              AJMP     ?C0065?APP_BRUSH
000A81         ?C0041?APP_BRUSH:
  189:                 else
  190:                 {
  191:                     if ((pMoney->money+s_System.Money <= 20000
000A81 1219DF            LCALL    ?L?COM0014
000A84 5009              JNC      ?C0045?APP_BRUSH
000A86 121A2C            LCALL    ?L?COM0035
000A89 12050B            LCALL    ?C?MEMCMP
000A8C EF                MOV      A,R7
000A8D 700C              JNZ      ?C0044?APP_BRUSH
000A8F         ?C0045?APP_BRUSH:
000A8F 9000B2            MOV      DPTR,#s_System+011H
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 19


000A92 E0                MOVX     A,@DPTR
000A93 7002              JNZ      ?C0060?APP_BRUSH
000A95 A3                INC      DPTR
000A96 E0                MOVX     A,@DPTR
000A97         ?C0060?APP_BRUSH:
000A97 6002              JZ       $ + 4H
000A99 6122              AJMP     ?C0043?APP_BRUSH
000A9B         ?C0044?APP_BRUSH:
  192:                         && memcmp(LastCardId, gCard_UID, 5))
  193:                         || s_System.Money == 0)
  194:                     {
  195:                         if(s_System.Money == 0)
000A9B 9000B2            MOV      DPTR,#s_System+011H
000A9E E0                MOVX     A,@DPTR
000A9F 7002              JNZ      ?C0061?APP_BRUSH
000AA1 A3                INC      DPTR
000AA2 E0                MOVX     A,@DPTR
000AA3         ?C0061?APP_BRUSH:
000AA3 701B              JNZ      ?C0046?APP_BRUSH
  196:                         {
  197:                             pMoney->money = 0;
000AA5 AB08              MOV      R3,pMoney
000AA7 AA09              MOV      R2,pMoney+01H
000AA9 A90A              MOV      R1,pMoney+02H
000AAB F5F0              MOV      B,A
000AAD 120276            LCALL    ?C?ISTPTR
  198:                             if(hwa_mifareWriteSector(gBuff, s_System.Sector))
000AB0 714B              ACALL    ?L?COM0010
000AB2 9186              ACALL    ?L?COM004F
000AB4 5071              JNC      ?C0066?APP_BRUSH
  199:                             {
  200:                                 buzzer_SoundNumber(1);
000AB6 7F01              MOV      R7,#01H
000AB8 7152              ACALL    _buzzer_SoundNumber
  201:                                 led_ShowNumber1(pMoney->money/100, u8_BrushNum, 0);
000ABA 7164              ACALL    ?L?COM000B
000ABC 7182              ACALL    ?L?COM003B
  202:                                 u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
  203:                                 break;
000ABE 8071              SJMP     ?C0023?APP_BRUSH
  204:                             }
000AC0         ?C0046?APP_BRUSH:
  205:                             else
  206:                             {
  207:                                 buzzer_SoundNumber(2);
  208:                             }
  209:                         }
  210:                         else
  211:                         {
  212:                             pMoney->money += s_System.Money;
000AC0 B1C0              ACALL    ?L?COM0038
000AC2 AB08              MOV      R3,pMoney
000AC4 AA09              MOV      R2,pMoney+01H
000AC6 A90A              MOV      R1,pMoney+02H
000AC8 EE                MOV      A,R6
000AC9 8FF0              MOV      B,R7
000ACB 12023E            LCALL    ?C?IILDPTR
  213:                             if(hwa_mifareWriteSector(gBuff, s_System.Sector))
000ACE 714B              ACALL    ?L?COM0010
000AD0 9186              ACALL    ?L?COM004F
000AD2 5057              JNC      ?C0042?APP_BRUSH
  214:                             {
  215:                                 MoneySum += s_System.Money/100;
000AD4 90009D            MOV      DPTR,#MoneySum
000AD7 E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 20


000AD8 F8                MOV      R0,A
000AD9 A3                INC      DPTR
000ADA E0                MOVX     A,@DPTR
000ADB F9                MOV      R1,A
000ADC A3                INC      DPTR
000ADD E0                MOVX     A,@DPTR
000ADE FA                MOV      R2,A
000ADF A3                INC      DPTR
000AE0 E0                MOVX     A,@DPTR
000AE1 FB                MOV      R3,A
000AE2 C000              PUSH     AR0
000AE4 9000B2            MOV      DPTR,#s_System+011H
000AE7 715C              ACALL    ?L?COM001B
000AE9 7D64              MOV      R5,#064H
000AEB 1201A8            LCALL    ?C?UIDIV
000AEE E4                CLR      A
000AEF FC                MOV      R4,A
000AF0 FD                MOV      R5,A
000AF1 D000              POP      AR0
000AF3 EB                MOV      A,R3
000AF4 2F                ADD      A,R7
000AF5 FF                MOV      R7,A
000AF6 EA                MOV      A,R2
000AF7 3E                ADDC     A,R6
000AF8 FE                MOV      R6,A
000AF9 ED                MOV      A,R5
000AFA 39                ADDC     A,R1
000AFB FD                MOV      R5,A
000AFC EC                MOV      A,R4
000AFD 38                ADDC     A,R0
000AFE FC                MOV      R4,A
000AFF 90009D            MOV      DPTR,#MoneySum
000B02 120379            LCALL    ?C?LSTXDATA
  216:                                 u8_BrushNum++;
000B05 9000D0            MOV      DPTR,#u8_BrushNum+01H
000B08 E0                MOVX     A,@DPTR
000B09 04                INC      A
000B0A F0                MOVX     @DPTR,A
000B0B 7006              JNZ      ?C0062?APP_BRUSH
000B0D 9000CF            MOV      DPTR,#u8_BrushNum
000B10 E0                MOVX     A,@DPTR
000B11 04                INC      A
000B12 F0                MOVX     @DPTR,A
000B13         ?C0062?APP_BRUSH:
  217:                                 app_configWrite(MONEY_SECTOR);
000B13 7F01              MOV      R7,#01H
000B15 1210C1            LCALL    _app_configWrite
  218:                                 led_ShowNumber1(pMoney->money/100, u8_BrushNum, 0);
000B18 7164              ACALL    ?L?COM000B
000B1A 11E6              ACALL    _led_ShowNumber1
  219:                                 u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
000B1C         
000B1C 7184              ACALL    ?L?COM003C
  220:                                 buzzer_SoundNumber(1);
000B1E 7F01              MOV      R7,#01H
  221:                             }
  222:                         }
  223:                     }
000B20 8007              SJMP     ?C0067?APP_BRUSH
000B22         ?C0043?APP_BRUSH:
  224:                     else if(pMoney->money+s_System.Money > 20000)
000B22 1219DF            LCALL    ?L?COM0014
000B25 4004              JC       ?C0042?APP_BRUSH
  225:                     {
  226:                         buzzer_SoundNumber(2);
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 21


000B27         
000B27 7F02              MOV      R7,#02H
000B29         
000B29 7152              ACALL    _buzzer_SoundNumber
  227:                     }
  228:                 }
000B2B         ?C0042?APP_BRUSH:
  229:                 memcpy(LastCardId, gCard_UID, 5);
000B2B 121A2C            LCALL    ?L?COM0035
000B2E 1200F6            LCALL    ?C?COPY
  230:             }
  231:             break;
  232:             
  233:         default:
  234:             break;
  235:     }
000B31         ?C0023?APP_BRUSH:
  236:     
  237:     if(u8_FirstBrushCardDly)
000B31 9000D1            MOV      DPTR,#u8_FirstBrushCardDly
000B34 E0                MOVX     A,@DPTR
000B35 6003              JZ       ?C0054?APP_BRUSH
  238:     {
  239:         u8_FirstBrushCardDly--;
000B37 14                DEC      A
000B38 F0                MOVX     @DPTR,A
  240:     }
000B39 22                RET      
000B3A         ?C0054?APP_BRUSH:
  241:     else if(!b_FactorySystem)
000B3A 20080C            JB       b_FactorySystem,?C0059?APP_BRUSH
  242:     {
  243:         if(b_SettingChange)
000B3D 300706            JNB      b_SettingChange,?C0057?APP_BRUSH
  244:         {
  245:             led_ShowNumber1(s_System.Money/100, u8_BrushNum, 0);
000B40 B1C0              ACALL    ?L?COM0038
000B42 7170              ACALL    ?L?COM000C
000B44 01E6              AJMP     _led_ShowNumber1
  246:         }
000B46         ?C0057?APP_BRUSH:
  247:         else
  248:         {
  249:             gLedBuf[0] = 12;
000B46 1219FE            LCALL    ?L?COM0022
  250:             gLedBuf[1] = 15;
  251:             gLedBuf[2] = 15;
  252:             gLedBuf[3] = 15;
  253:             gLedBuf[4] = 15;
  254:             gLedBuf[5] = 12;
  255:             gShowDot = 0;
  256:         }
  257:     }
  258: }
000B49         ?C0059?APP_BRUSH:
000B49 22                RET      
----- FUNCTION app_brushCycle1s (END) -------


----- FUNCTION ?L?COM000F (BEGIN) -----
000B4A F0                MOVX     @DPTR,A
000B4B         ?L?COM0010:
000B4B 7B01              MOV      R3,#01H
000B4D 7A00              MOV      R2,#HIGH gBuff
000B4F 79B9              MOV      R1,#LOW gBuff
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 22


000B51 22                RET      
----- FUNCTION ?L?COM000F (END) -------


----- FUNCTION _buzzer_SoundNumber (BEGIN) -----
 FILE: 'Driver\buzzer.c'
   28: void buzzer_SoundNumber(UINT8 num)
   29: {
;---- Variable 'num' assigned to Register 'R7' ----
   30:     SoundNumberCount = num;
   30: }
000B52 9000DE            MOV      DPTR,#SoundNumberCount
000B55 EF                MOV      A,R7
000B56 F0                MOVX     @DPTR,A
   30: 
000B57 22                RET      
----- FUNCTION _buzzer_SoundNumber (END) -------


----- FUNCTION ?L?COM0019 (BEGIN) -----
000B58 F0                MOVX     @DPTR,A
000B59         ?L?COM001A:
000B59 900070            MOV      DPTR,#L_num
000B5C         ?L?COM001B:
000B5C E0                MOVX     A,@DPTR
000B5D FE                MOV      R6,A
000B5E A3                INC      DPTR
000B5F E0                MOVX     A,@DPTR
000B60 FF                MOV      R7,A
000B61 7C00              MOV      R4,#00H
000B63 22                RET      
----- FUNCTION ?L?COM0019 (END) -------


----- FUNCTION ?L?COM000B (BEGIN) -----
000B64 AB08              MOV      R3,pMoney
000B66 AA09              MOV      R2,pMoney+01H
000B68 A90A              MOV      R1,pMoney+02H
000B6A 120213            LCALL    ?C?ILDPTR
000B6D FF                MOV      R7,A
000B6E AEF0              MOV      R6,B
000B70         ?L?COM000C:
000B70 7C00              MOV      R4,#00H
000B72 7D64              MOV      R5,#064H
000B74 1201A8            LCALL    ?C?UIDIV
000B77 9000CF            MOV      DPTR,#u8_BrushNum
000B7A E0                MOVX     A,@DPTR
000B7B FC                MOV      R4,A
000B7C A3                INC      DPTR
000B7D E0                MOVX     A,@DPTR
000B7E FD                MOV      R5,A
000B7F E4                CLR      A
000B80 FB                MOV      R3,A
000B81 22                RET      
----- FUNCTION ?L?COM000B (END) -------


----- FUNCTION ?L?COM003B (BEGIN) -----
000B82 11E6              ACALL    _led_ShowNumber1
000B84         ?L?COM003C:
000B84 9000D1            MOV      DPTR,#u8_FirstBrushCardDly
000B87 7403              MOV      A,#03H
000B89 F0                MOVX     @DPTR,A
000B8A 22                RET      
----- FUNCTION ?L?COM003B (END) -------
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 23




----- FUNCTION _hwa_mifareReadBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   55: BOOL hwa_mifareReadBlock(UINT8 *buff, UINT8 block)
   56: {
000B8B 900076            MOV      DPTR,#buff
000B8E B1CC              ACALL    ?L?COM0008
000B90 A3                INC      DPTR
000B91 ED                MOV      A,R5
000B92 F0                MOVX     @DPTR,A
   57: 	UINT8 u8_ReadErrCount;
   58: 	UINT8 u8_Result;
   59: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
000B93 E4                CLR      A
000B94 A3                INC      DPTR
000B95 F0                MOVX     @DPTR,A
000B96         ?C0018?HWA_MIFARE:
   60: 	{
   61: 		u8_Result = Read_Block(buff, block);
000B96 900076            MOV      DPTR,#buff
000B99 917E              ACALL    ?L?COM0002
000B9B F9                MOV      R1,A
000B9C A3                INC      DPTR
000B9D E0                MOVX     A,@DPTR
000B9E FD                MOV      R5,A
000B9F 1216C4            LCALL    _Read_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   62: 		if (u8_Result == FM1702_OK)
000BA2 EF                MOV      A,R7
000BA3 7002              JNZ      ?C0021?HWA_MIFARE
   63: 		{
   64: 			return TRUE;
000BA5 D3                SETB     C
000BA6 22                RET      
   65: 		}
000BA7         ?C0021?HWA_MIFARE:
   66: 		else if (u8_Result == FM1702_NOTAGERR)
000BA7 EF                MOV      A,R7
000BA8 B40102            CJNE     A,#01H,?C0020?HWA_MIFARE
   67: 		{
   68: 			return FALSE;
000BAB C3                CLR      C
000BAC 22                RET      
   69: 		}
   70: 	}
000BAD         ?C0020?HWA_MIFARE:
000BAD 90007A            MOV      DPTR,#u8_ReadErrCount
000BB0 F1F5              ACALL    ?L?COM005A
000BB2 40E2              JC       ?C0018?HWA_MIFARE
000BB4         ?C0019?HWA_MIFARE:
   71: 	return FALSE;
000BB4 C3                CLR      C
   72: }
000BB5 22                RET      
----- FUNCTION _hwa_mifareReadBlock (END) -------


----- FUNCTION _hwa_mifareReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  159: BOOL hwa_mifareReadSector(UINT8 *dat, UINT8 sector)
  160: {
000BB6 900070            MOV      DPTR,#dat
000BB9 B1CC              ACALL    ?L?COM0008
000BBB A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 24


000BBC ED                MOV      A,R5
000BBD F0                MOVX     @DPTR,A
  161: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  162: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
000BBE 121A3D            LCALL    ?L?COM003A
  163: 
  164: 	if (dat != NULL && sector > 0 && sector < 16)
000BC1 900070            MOV      DPTR,#dat
000BC4 917E              ACALL    ?L?COM0002
000BC6 4A                ORL      A,R2
000BC7 4B                ORL      A,R3
000BC8 7002              JNZ      $ + 4H
000BCA 8179              AJMP     ?C0044?HWA_MIFARE
000BCC A3                INC      DPTR
000BCD E0                MOVX     A,@DPTR
000BCE FF                MOV      R7,A
000BCF D3                SETB     C
000BD0 9400              SUBB     A,#00H
000BD2 5002              JNC      $ + 4H
000BD4 8179              AJMP     ?C0044?HWA_MIFARE
000BD6 EF                MOV      A,R7
000BD7 9410              SUBB     A,#010H
000BD9 4002              JC       $ + 4H
000BDB 8179              AJMP     ?C0044?HWA_MIFARE
  165: 	{
  166: 		if (hwa_mifareReadBlock((UINT8*)&s_NormalBuff, block) == FALSE)
000BDD B1B9              ACALL    ?L?COM0026
000BDF A3                INC      DPTR
000BE0 E0                MOVX     A,@DPTR
000BE1 FD                MOV      R5,A
000BE2 718B              ACALL    _hwa_mifareReadBlock
000BE4 4001              JC       ?C0045?HWA_MIFARE
  167: 		{
  168: 			return FALSE;
000BE6 22                RET      
  169: 		}
000BE7         ?C0045?HWA_MIFARE:
  170: 
  171: 		if (hwa_mifareReadBlock((UINT8*)&s_BackupBuff, block) == FALSE)
000BE7 121A4B            LCALL    ?L?COM0044
000BEA 718B              ACALL    _hwa_mifareReadBlock
000BEC 4001              JC       ?C0047?HWA_MIFARE
  172: 		{
  173: 			return FALSE;
000BEE 22                RET      
  174: 		}
000BEF         ?C0047?HWA_MIFARE:
  175: 
  176: 		hwa_mifareCheckBlock();
000BEF 121348            LCALL    hwa_mifareCheckBlock
  177: 
  178: 		if (NormalErrorFlag && BackupErrorFlag)				//正常块和备份块都校验错误
000BF2 300512            JNB      NormalErrorFlag,?C0048?HWA_MIFARE
000BF5 30040F            JNB      BackupErrorFlag,?C0048?HWA_MIFARE
  179: 		{
  180:             if(s_System.RecoveryOldCard)
000BF8 9000B1            MOV      DPTR,#s_System+010H
000BFB E0                MOVX     A,@DPTR
000BFC 6007              JZ       ?C0049?HWA_MIFARE
  181:             {
  182:                 hwa_mifareRecoveryOldCard(sector);				//兼容旧卡
000BFE 900073            MOV      DPTR,#sector
000C01 E0                MOVX     A,@DPTR
000C02 FF                MOV      R7,A
000C03 B152              ACALL    _hwa_mifareRecoveryOldCard
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 25


  183:             }
000C05         ?C0049?HWA_MIFARE:
  184: 			return FALSE;
000C05 C3                CLR      C
000C06 22                RET      
  185: 		}
000C07         ?C0048?HWA_MIFARE:
  186: 		else if (NormalErrorFlag)							//正常块校验错误
000C07 30050A            JNB      NormalErrorFlag,?C0051?HWA_MIFARE
  187: 		{
  188:             hwa_mifareEncrypt((UINT8*)&s_BackupBuff);
000C0A 91E9              ACALL    ?L?COM004C
  189: 			if (hwa_mifareWriteBlock((UINT8*)&s_BackupBuff, block) == FALSE)
000C0C 121A4B            LCALL    ?L?COM0044
000C0F B116              ACALL    _hwa_mifareWriteBlock
000C11 402C              JC       ?C0050?HWA_MIFARE
  190: 			{
  191: 				return FALSE;
000C13 22                RET      
  192: 			}
  193: 		}
000C14         ?C0051?HWA_MIFARE:
  194: 		else if (BackupErrorFlag							//备份块校验错误
000C14 200418            JB       BackupErrorFlag,?C0055?HWA_MIFARE
000C17 900042            MOV      DPTR,#s_BackupBuff+02H
000C1A E0                MOVX     A,@DPTR
000C1B FF                MOV      R7,A
000C1C 900052            MOV      DPTR,#s_NormalBuff+02H
000C1F E0                MOVX     A,@DPTR
000C20 B5070C            CJNE     A,AR7,?C0055?HWA_MIFARE
000C23 900043            MOV      DPTR,#s_BackupBuff+03H
000C26 E0                MOVX     A,@DPTR
000C27 FF                MOV      R7,A
000C28 900053            MOV      DPTR,#s_NormalBuff+03H
000C2B E0                MOVX     A,@DPTR
000C2C 6F                XRL      A,R7
000C2D 6010              JZ       ?C0050?HWA_MIFARE
000C2F         ?C0055?HWA_MIFARE:
  195: 			|| s_NormalBuff.crc[0] != s_BackupBuff.crc[0]	//正常块和备份块校验正确但数据不一样，用备份块替换正常块
  196: 			|| s_NormalBuff.crc[1] != s_BackupBuff.crc[1]
  197:         )
  198: 		{
  199:             hwa_mifareEncrypt((UINT8*)&s_NormalBuff);
000C2F B1B9              ACALL    ?L?COM0026
000C31 91EF              ACALL    _hwa_mifareEncrypt
  200: 			if (hwa_mifareWriteBlock((UINT8*)&s_NormalBuff, blockBak) == FALSE)
000C33 B1B9              ACALL    ?L?COM0026
000C35 900075            MOV      DPTR,#blockBak
000C38 E0                MOVX     A,@DPTR
000C39 FD                MOV      R5,A
000C3A B116              ACALL    _hwa_mifareWriteBlock
000C3C 4001              JC       ?C0050?HWA_MIFARE
  201: 			{
  202: 				return FALSE;
000C3E 22                RET      
  203: 			}
  204: 		}
000C3F         ?C0050?HWA_MIFARE:
  205: 		if (BackupErrorFlag)
000C3F 900070            MOV      DPTR,#dat
000C42 917E              ACALL    ?L?COM0002
000C44 F8                MOV      R0,A
000C45 AC02              MOV      R4,AR2
000C47 AD03              MOV      R5,AR3
000C49 7B01              MOV      R3,#01H
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 26


000C4B 300406            JNB      BackupErrorFlag,?C0057?HWA_MIFARE
  206: 		{
  207: 			memcpy(dat, (UINT8*)&s_NormalBuff, DATA_BLOCK_SIZE);
000C4E 7A00              MOV      R2,#HIGH s_NormalBuff
000C50 7950              MOV      R1,#LOW s_NormalBuff
  208: 		}
000C52 8004              SJMP     ?C0073?HWA_MIFARE
000C54         ?C0057?HWA_MIFARE:
  209: 		else
  210: 		{
  211: 			memcpy(dat, (UINT8*)&s_BackupBuff, DATA_BLOCK_SIZE);
000C54 7A00              MOV      R2,#HIGH s_BackupBuff
000C56 7940              MOV      R1,#LOW s_BackupBuff
000C58         
000C58 F1BB              ACALL    ?L?COM0043
  212: 		}
000C5A         ?C0058?HWA_MIFARE:
  213: 		if (*(UINT16*)dat > 50000)
000C5A 900070            MOV      DPTR,#dat
000C5D 917E              ACALL    ?L?COM0002
000C5F F9                MOV      R1,A
000C60 120213            LCALL    ?C?ILDPTR
000C63 FF                MOV      R7,A
000C64 AEF0              MOV      R6,B
000C66 E4                CLR      A
000C67 FC                MOV      R4,A
000C68 FD                MOV      R5,A
000C69 7B50              MOV      R3,#050H
000C6B 7AC3              MOV      R2,#0C3H
000C6D F9                MOV      R1,A
000C6E F8                MOV      R0,A
000C6F C3                CLR      C
000C70 120363            LCALL    ?C?SLCMP
000C73 5002              JNC      ?C0059?HWA_MIFARE
  214: 		{
  215: 			return FALSE;
000C75 C3                CLR      C
000C76 22                RET      
  216: 		}
000C77         ?C0059?HWA_MIFARE:
  217: 		return TRUE;
000C77 D3                SETB     C
000C78 22                RET      
  218: 	}
000C79         ?C0044?HWA_MIFARE:
  219: 	return FALSE;
000C79 C3                CLR      C
  220: }
000C7A 22                RET      
----- FUNCTION _hwa_mifareReadSector (END) -------


----- FUNCTION ?L?COM0001 (BEGIN) -----
000C7B 90007F            MOV      DPTR,#buff
000C7E         ?L?COM0002:
000C7E E0                MOVX     A,@DPTR
000C7F FB                MOV      R3,A
000C80 A3                INC      DPTR
000C81 E0                MOVX     A,@DPTR
000C82 FA                MOV      R2,A
000C83 A3                INC      DPTR
000C84 E0                MOVX     A,@DPTR
000C85 22                RET      
----- FUNCTION ?L?COM0001 (END) -------

LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 27



----- FUNCTION ?L?COM004F (BEGIN) -----
000C86 9000A7            MOV      DPTR,#s_System+06H
000C89 E0                MOVX     A,@DPTR
000C8A FD                MOV      R5,A
----- FUNCTION _hwa_mifareWriteSector (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  222: BOOL hwa_mifareWriteSector(UINT8 *dat, UINT8 sector)
  223: {
000C8B 900078            MOV      DPTR,#dat
000C8E B1CC              ACALL    ?L?COM0008
;---- Variable 'sector' assigned to Register 'R5' ----
  224: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  225: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
000C90 ED                MOV      A,R5
000C91 121A3D            LCALL    ?L?COM003A
  226: 	UINT16 crc;
  227:     BOOL falg = FALSE;
000C94 C200              CLR      falg
  228: 	if (dat != NULL && sector > 0 && sector < 16)
000C96 900078            MOV      DPTR,#dat
000C99 917E              ACALL    ?L?COM0002
000C9B 4A                ORL      A,R2
000C9C 4B                ORL      A,R3
000C9D 6047              JZ       ?C0060?HWA_MIFARE
000C9F ED                MOV      A,R5
000CA0 D3                SETB     C
000CA1 9400              SUBB     A,#00H
000CA3 4041              JC       ?C0060?HWA_MIFARE
000CA5 ED                MOV      A,R5
000CA6 9410              SUBB     A,#010H
000CA8 503C              JNC      ?C0060?HWA_MIFARE
  229: 	{
  230: 		crc = hwa_mifareCheckOut(dat, USE_DATA_BLOCK_LEN);
000CAA 900078            MOV      DPTR,#dat
000CAD A3                INC      DPTR
000CAE A3                INC      DPTR
000CAF E0                MOVX     A,@DPTR
000CB0 F9                MOV      R1,A
;---- Variable 'crc' assigned to Register 'R4/R5' ----
000CB1 12138E            LCALL    ?L?COM0028
  231: 		dat[USE_DATA_BLOCK_LEN] = (UINT8)(crc >> 8);
000CB4 EC                MOV      A,R4
000CB5 FF                MOV      R7,A
000CB6 900078            MOV      DPTR,#dat
000CB9 917E              ACALL    ?L?COM0002
000CBB F9                MOV      R1,A
000CBC 900002            MOV      DPTR,#02H
000CBF EF                MOV      A,R7
000CC0 120174            LCALL    ?C?CSTOPTR
  232: 		dat[USE_DATA_BLOCK_LEN + 1] = (UINT8)(crc & 0xFF);
000CC3 ED                MOV      A,R5
000CC4 900003            MOV      DPTR,#03H
000CC7 120174            LCALL    ?C?CSTOPTR
  233: 		if (hwa_mifareWriteBlock(dat, block))
000CCA 90007B            MOV      DPTR,#block
000CCD E0                MOVX     A,@DPTR
000CCE FD                MOV      R5,A
000CCF B116              ACALL    _hwa_mifareWriteBlock
000CD1 5002              JNC      ?C0061?HWA_MIFARE
  234: 		{
  235: 			falg = TRUE;
000CD3 D200              SETB     falg
  236: 		}
000CD5         ?C0061?HWA_MIFARE:
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 28


  237: 		if (hwa_mifareWriteBlock(dat, blockBak))
000CD5 900078            MOV      DPTR,#dat
000CD8 917E              ACALL    ?L?COM0002
000CDA F9                MOV      R1,A
000CDB 90007C            MOV      DPTR,#blockBak
000CDE E0                MOVX     A,@DPTR
000CDF FD                MOV      R5,A
000CE0 B116              ACALL    _hwa_mifareWriteBlock
000CE2 5002              JNC      ?C0060?HWA_MIFARE
  238: 		{
  239: 			falg = TRUE;
000CE4 D200              SETB     falg
  240: 		}
  241: 	}
000CE6         ?C0060?HWA_MIFARE:
  242:     return falg;
000CE6 A200              MOV      C,falg
  243: }
000CE8 22                RET      
----- FUNCTION _hwa_mifareWriteSector (END) -------


----- FUNCTION ?L?COM004C (BEGIN) -----
000CE9 7B01              MOV      R3,#01H
000CEB 7A00              MOV      R2,#HIGH s_BackupBuff
000CED 7940              MOV      R1,#LOW s_BackupBuff
----- FUNCTION _hwa_mifareEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   29: void hwa_mifareEncrypt(UINT8 *pData)        //利用卡ID加密
   30: {
000CEF B1C9              ACALL    ?L?COM0007
   31: 	UINT8 i, j;
   32: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
000CF1 E4                CLR      A
000CF2 FE                MOV      R6,A
000CF3         ?C0004?HWA_MIFARE:
   33: 	{
   34: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
000CF3 7D04              MOV      R5,#04H
000CF5         ?C0007?HWA_MIFARE:
   35: 		{
   36: 			pData[i] ^= gCard_UID[i % 5];
000CF5 917B              ACALL    ?L?COM0001
000CF7 1219C1            LCALL    ?L?COM0013
   37: 			pData[i] = _cror_(pData[i], 1);
000CFA 917B              ACALL    ?L?COM0001
000CFC F9                MOV      R1,A
000CFD 8E82              MOV      DPL,R6
000CFF 1213C9            LCALL    ?L?COM001E
000D02 FF                MOV      R7,A
000D03 7801              MOV      R0,#01H
000D05 08                INC      R0
000D06 8001              SJMP     ?C0065?HWA_MIFARE
000D08         ?C0064?HWA_MIFARE:
000D08 03                RR       A
000D09         ?C0065?HWA_MIFARE:
000D09 D8FD              DJNZ     R0,?C0064?HWA_MIFARE
000D0B 121A86            LCALL    ?L?COM0052
   38: 		}
000D0E DDE5              DJNZ     R5,?C0007?HWA_MIFARE
   39: 	}
000D10         ?C0006?HWA_MIFARE:
000D10 0E                INC      R6
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 29


000D11 EE                MOV      A,R6
000D12 B404DE            CJNE     A,#04H,?C0004?HWA_MIFARE
   40: }
000D15 22                RET      
----- FUNCTION _hwa_mifareEncrypt (END) -------


----- FUNCTION _hwa_mifareWriteBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   74: BOOL hwa_mifareWriteBlock(UINT8 *buff, UINT8 block)
   75: {
000D16 90007D            MOV      DPTR,#block
000D19 ED                MOV      A,R5
000D1A F0                MOVX     @DPTR,A
;---- Variable 'buff' assigned to Register 'R1/R2/R3' ----
   76: 	UINT8 u8_ReadErrCount;
   77: 	UINT8 u8_Result;
   78:     memcpy((UINT8*)&s_TempBuff, buff, 16);
000D1B 7860              MOV      R0,#LOW s_TempBuff
000D1D 7C00              MOV      R4,#HIGH s_TempBuff
000D1F 7D01              MOV      R5,#01H
000D21 F1BB              ACALL    ?L?COM0043
   79:     hwa_mifareEncrypt((UINT8*)&s_TempBuff);
000D23 7B01              MOV      R3,#01H
000D25 7A00              MOV      R2,#HIGH s_TempBuff
000D27 7960              MOV      R1,#LOW s_TempBuff
000D29 91EF              ACALL    _hwa_mifareEncrypt
   80: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
000D2B E4                CLR      A
000D2C 90007E            MOV      DPTR,#u8_ReadErrCount
000D2F F0                MOVX     @DPTR,A
000D30         ?C0025?HWA_MIFARE:
   81: 	{
   82: 		u8_Result = Write_Block((UINT8*)&s_TempBuff, block);
000D30 7B01              MOV      R3,#01H
000D32 7A00              MOV      R2,#HIGH s_TempBuff
000D34 7960              MOV      R1,#LOW s_TempBuff
000D36 90007D            MOV      DPTR,#block
000D39 E0                MOVX     A,@DPTR
000D3A FD                MOV      R5,A
000D3B 1215FB            LCALL    _Write_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   83: 		if (u8_Result == FM1702_OK)
000D3E EF                MOV      A,R7
000D3F 7002              JNZ      ?C0028?HWA_MIFARE
   84: 		{
   85: 			return TRUE;
000D41 D3                SETB     C
000D42 22                RET      
   86: 		}
000D43         ?C0028?HWA_MIFARE:
   87: 		else if (u8_Result == FM1702_NOTAGERR)
000D43 EF                MOV      A,R7
000D44 B40102            CJNE     A,#01H,?C0027?HWA_MIFARE
   88: 		{
   89: 			return FALSE;
000D47 C3                CLR      C
000D48 22                RET      
   90: 		}
   91: 	}
000D49         ?C0027?HWA_MIFARE:
000D49 90007E            MOV      DPTR,#u8_ReadErrCount
000D4C F1F5              ACALL    ?L?COM005A
000D4E 40E0              JC       ?C0025?HWA_MIFARE
000D50         ?C0026?HWA_MIFARE:
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 30


   92: 	return FALSE;
000D50 C3                CLR      C
   93: }
000D51 22                RET      
----- FUNCTION _hwa_mifareWriteBlock (END) -------


----- FUNCTION _hwa_mifareRecoveryOldCard (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  132: static void hwa_mifareRecoveryOldCard(UINT8 sector)
  133: {
000D52 900076            MOV      DPTR,#sector
000D55 B1B7              ACALL    ?L?COM0025
000D57 91EF              ACALL    _hwa_mifareEncrypt
  134: 	UINT8 money;
  135: 	hwa_mifareEncrypt((UINT8*)&s_NormalBuff);
  136: 	money = *(UINT8*)&s_NormalBuff;
000D59 900050            MOV      DPTR,#s_NormalBuff
000D5C E0                MOVX     A,@DPTR
000D5D 900077            MOV      DPTR,#money
000D60 F0                MOVX     @DPTR,A
  137: 	if (money != 0xFF && money <= 200
000D61 F4                CPL      A
000D62 601D              JZ       ?C0041?HWA_MIFARE
000D64 E0                MOVX     A,@DPTR
000D65 FF                MOV      R7,A
000D66 D3                SETB     C
000D67 94C8              SUBB     A,#0C8H
000D69 5016              JNC      ?C0041?HWA_MIFARE
000D6B 900052            MOV      DPTR,#s_NormalBuff+02H
000D6E E0                MOVX     A,@DPTR
000D6F 7010              JNZ      ?C0041?HWA_MIFARE
000D71 A3                INC      DPTR
000D72 E0                MOVX     A,@DPTR
000D73 700C              JNZ      ?C0041?HWA_MIFARE
  138: 		&& s_NormalBuff.crc[0] == 0
  139: 		&& s_NormalBuff.crc[1] == 0
  140: 		)
  141: 	{
  142: 		s_NormalBuff.money = (UINT16)money * 100;
000D75 F1E7              ACALL    ?L?COM0059
000D77 900050            MOV      DPTR,#s_NormalBuff
000D7A EE                MOV      A,R6
000D7B F0                MOVX     @DPTR,A
000D7C A3                INC      DPTR
000D7D B1B7              ACALL    ?L?COM0025
000D7F 802E              SJMP     ?C0072?HWA_MIFARE
  143: 		hwa_mifareWriteSector((UINT8*)&s_NormalBuff, sector);
  144: 		return;
  145: 	}
000D81         ?C0041?HWA_MIFARE:
  146: 	hwa_mifareEncrypt((UINT8*)&s_BackupBuff);
000D81 91E9              ACALL    ?L?COM004C
  147: 	money = *(UINT8*)&s_BackupBuff;
000D83 900040            MOV      DPTR,#s_BackupBuff
000D86 E0                MOVX     A,@DPTR
000D87 900077            MOV      DPTR,#money
000D8A F0                MOVX     @DPTR,A
  148: 	if (money != 0xFF && money <= 200
000D8B F4                CPL      A
000D8C 6028              JZ       ?C0042?HWA_MIFARE
000D8E E0                MOVX     A,@DPTR
000D8F FF                MOV      R7,A
000D90 D3                SETB     C
000D91 94C8              SUBB     A,#0C8H
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 31


000D93 5021              JNC      ?C0042?HWA_MIFARE
000D95 900042            MOV      DPTR,#s_BackupBuff+02H
000D98 E0                MOVX     A,@DPTR
000D99 701B              JNZ      ?C0042?HWA_MIFARE
000D9B A3                INC      DPTR
000D9C E0                MOVX     A,@DPTR
000D9D 7017              JNZ      ?C0042?HWA_MIFARE
  149: 		&& s_BackupBuff.crc[0] == 0
  150: 		&& s_BackupBuff.crc[1] == 0
  151: 		)
  152: 	{
  153: 		s_BackupBuff.money = (UINT16)money * 100;
000D9F F1E7              ACALL    ?L?COM0059
000DA1 900040            MOV      DPTR,#s_BackupBuff
000DA4 EE                MOV      A,R6
000DA5 F0                MOVX     @DPTR,A
000DA6 A3                INC      DPTR
000DA7 EF                MOV      A,R7
000DA8 F0                MOVX     @DPTR,A
  154: 		hwa_mifareWriteSector((UINT8*)&s_BackupBuff, sector);
000DA9 7B01              MOV      R3,#01H
000DAB 7A00              MOV      R2,#HIGH s_BackupBuff
000DAD 7940              MOV      R1,#LOW s_BackupBuff
000DAF         
000DAF 900076            MOV      DPTR,#sector
000DB2 E0                MOVX     A,@DPTR
000DB3 FD                MOV      R5,A
000DB4 918B              ACALL    _hwa_mifareWriteSector
  155: 		return;
  156: 	}
  157: }
000DB6         ?C0042?HWA_MIFARE:
000DB6 22                RET      
----- FUNCTION _hwa_mifareRecoveryOldCard (END) -------


----- FUNCTION ?L?COM0025 (BEGIN) -----
000DB7 EF                MOV      A,R7
000DB8 F0                MOVX     @DPTR,A
000DB9         ?L?COM0026:
000DB9 7B01              MOV      R3,#01H
000DBB 7A00              MOV      R2,#HIGH s_NormalBuff
000DBD 7950              MOV      R1,#LOW s_NormalBuff
000DBF 22                RET      
----- FUNCTION ?L?COM0025 (END) -------


----- FUNCTION ?L?COM0038 (BEGIN) -----
000DC0 9000B2            MOV      DPTR,#s_System+011H
000DC3 E0                MOVX     A,@DPTR
000DC4 FE                MOV      R6,A
000DC5 A3                INC      DPTR
000DC6 E0                MOVX     A,@DPTR
000DC7 FF                MOV      R7,A
000DC8 22                RET      
----- FUNCTION ?L?COM0038 (END) -------


----- FUNCTION ?L?COM0007 (BEGIN) -----
000DC9 90007F            MOV      DPTR,#buff
000DCC         ?L?COM0008:
000DCC EB                MOV      A,R3
000DCD F0                MOVX     @DPTR,A
000DCE A3                INC      DPTR
000DCF EA                MOV      A,R2
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 32


000DD0 F0                MOVX     @DPTR,A
000DD1 A3                INC      DPTR
000DD2 E9                MOV      A,R1
000DD3 F0                MOVX     @DPTR,A
000DD4 22                RET      
----- FUNCTION ?L?COM0007 (END) -------


----- FUNCTION _Authentication (BEGIN) -----
 FILE: 'Driver\mifare.c'
  472: uchar Authentication(uchar *UID, uchar SecNR, uchar mode)
  473: {
000DD5 900073            MOV      DPTR,#UID
000DD8 B1CC              ACALL    ?L?COM0008
;---- Variable 'SecNR' assigned to Register 'R4' ----
000DDA AC05              MOV      R4,AR5
  474: 	uchar i;
  475: 	uchar temp, temp1;
  476: 
  477: 	if(SecNR >= 16)
000DDC EC                MOV      A,R4
000DDD C3                CLR      C
000DDE 9410              SUBB     A,#010H
000DE0 4004              JC       ?C0094?MIFARE
  478: 		SecNR = SecNR % 16;
000DE2 EC                MOV      A,R4
000DE3 540F              ANL      A,#0FH
000DE5 FC                MOV      R4,A
000DE6         ?C0094?MIFARE:
  479: 	
  480: 	//选择数据校验种类和模式
  481: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
000DE6 121A8E            LCALL    ?L?COM0054
  482: 	gBuff[0] = mode;
000DE9 900077            MOV      DPTR,#mode
000DEC E0                MOVX     A,@DPTR
000DED 9000B9            MOV      DPTR,#gBuff
000DF0 F0                MOVX     @DPTR,A
  483: 	gBuff[1] = SecNR * 4 + 3;
000DF1 EC                MOV      A,R4
000DF2 25E0              ADD      A,ACC
000DF4 25E0              ADD      A,ACC
000DF6 2403              ADD      A,#03H
000DF8 A3                INC      DPTR
000DF9 F0                MOVX     @DPTR,A
  484: 	for(i = 0; i < 4; i++)
;---- Variable 'i' assigned to Register 'R7' ----
000DFA E4                CLR      A
000DFB FF                MOV      R7,A
000DFC         ?C0095?MIFARE:
  485: 	{
  486: 		gBuff[2 + i] = UID[i];
000DFC 900073            MOV      DPTR,#UID
000DFF 917E              ACALL    ?L?COM0002
000E01 1213C6            LCALL    ?L?COM001C
000E04 12167F            LCALL    ?L?COM002B
000E07 B404F2            CJNE     A,#04H,?C0095?MIFARE
000E0A         ?C0096?MIFARE:
  487: 	}
  488: 
  489: 	temp = Command_Send(Authent1, gBuff,6 );
000E0A 714B              ACALL    ?L?COM0010
000E0C 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
000E0F 7406              MOV      A,#06H
000E11 F0                MOVX     @DPTR,A
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 33


000E12 7F0C              MOV      R7,#0CH
000E14 120791            LCALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  490: 	if(temp==0)
000E17 EF                MOV      A,R7
000E18 7003              JNZ      ?C0098?MIFARE
  491: 	{
  492: 		return 0x99;
000E1A 7F99              MOV      R7,#099H
000E1C 22                RET      
  493: 	}
000E1D         ?C0098?MIFARE:
  494: 
  495: 	temp = SPIReadOne(ErrorFlag_Reg);   
000E1D F1E0              ACALL    ?L?COM002A
000E1F 30E103            JNB      ACC.1,?C0100?MIFARE
000E22 7F05              MOV      R7,#05H
000E24 22                RET      
000E25         ?C0100?MIFARE:
  496: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  497: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
000E25 EF                MOV      A,R7
000E26 30E203            JNB      ACC.2,?C0101?MIFARE
000E29 7F14              MOV      R7,#014H
000E2B 22                RET      
000E2C         ?C0101?MIFARE:
  498: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
000E2C EF                MOV      A,R7
000E2D 30E303            JNB      ACC.3,?C0102?MIFARE
000E30 7F02              MOV      R7,#02H
000E32 22                RET      
000E33         ?C0102?MIFARE:
  499: 	temp = Command_Send(Authent2, gBuff,0 );	
000E33 714B              ACALL    ?L?COM0010
000E35 E4                CLR      A
000E36 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
000E39 F0                MOVX     @DPTR,A
000E3A 7F14              MOV      R7,#014H
000E3C 120791            LCALL    _Command_Send
  500: 	if(temp ==0)
000E3F EF                MOV      A,R7
000E40 7003              JNZ      ?C0103?MIFARE
  501: 	{
  502: 		return 0x88;
000E42 7F88              MOV      R7,#088H
000E44 22                RET      
  503: 	}
000E45         ?C0103?MIFARE:
  504: 
  505: 	temp = SPIReadOne(ErrorFlag_Reg);
000E45 F1E0              ACALL    ?L?COM002A
000E47 30E103            JNB      ACC.1,?C0104?MIFARE
000E4A 7F05              MOV      R7,#05H
000E4C 22                RET      
000E4D         ?C0104?MIFARE:
  506: //	Show(temp,0);
  507: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  508: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
000E4D EF                MOV      A,R7
000E4E 30E203            JNB      ACC.2,?C0105?MIFARE
000E51 7F14              MOV      R7,#014H
000E53 22                RET      
000E54         ?C0105?MIFARE:
  509: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
000E54 EF                MOV      A,R7
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 34


000E55 30E303            JNB      ACC.3,?C0106?MIFARE
000E58 7F02              MOV      R7,#02H
000E5A 22                RET      
000E5B         ?C0106?MIFARE:
  510: 	temp1 = SPIReadOne(Control_Reg);
000E5B 7F09              MOV      R7,#09H
000E5D 1206F7            LCALL    _SPIReadOne
;---- Variable 'temp1' assigned to Register 'R7' ----
  511: 	temp1 = temp1 & 0x08;	
000E60 EF                MOV      A,R7
000E61 5408              ANL      A,#08H
  512: 	if(temp1 == 0x08)
000E63 7F04              MOV      R7,#04H
000E65 B40802            CJNE     A,#08H,?C0107?MIFARE
  513: 	{
  514: 		return FM1702_OK;
000E68 7F00              MOV      R7,#00H
  515: 	}
000E6A         ?C0107?MIFARE:
  516: 
  517: 	return FM1702_AUTHERR;
  518: }
000E6A 22                RET      
----- FUNCTION _Authentication (END) -------


----- FUNCTION _hwa_eepromReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   37: BOOL hwa_eepromReadSector(UINT8 *dat, UINT8 sector)
   38: {
000E6B B1C9              ACALL    ?L?COM0007
000E6D A3                INC      DPTR
000E6E ED                MOV      A,R5
000E6F F0                MOVX     @DPTR,A
   39: 	BOOL e2_error = FALSE, e2_bak_error = FALSE;
   40: 	UINT16 e2_addr, e2_bak_addr;
000E70 C202              CLR      e2_error
000E72 C203              CLR      e2_bak_error
   41: 	UINT16 e2_check_sum, e2_bak_check_sum;
   42: 	UINT16 Size, SectorSize;
   43: 
   44: 	if (sector >= c_u8_eepromSectorNum)
000E74 121A6A            LCALL    ?L?COM004D
000E77 4001              JC       ?C0002?HWA_EEPROM
   45: 	{
   46: 		return FALSE;
000E79 22                RET      
   47: 	}
000E7A         ?C0002?HWA_EEPROM:
   48: 	Size = c_s_eepromConfig[sector].UseSize;
000E7A 900082            MOV      DPTR,#sector
000E7D 121A18            LCALL    ?L?COM0029
000E80 7401              MOV      A,#01H
000E82 93                MOVC     A,@A+DPTR
000E83 FD                MOV      R5,A
000E84 90008B            MOV      DPTR,#Size
000E87 121236            LCALL    ?L?COM0009
000E8A 900083            MOV      DPTR,#e2_addr
000E8D 121AA5            LCALL    ?L?COM005B
000E90 12125D            LCALL    ?L?COM000A
000E93 900085            MOV      DPTR,#e2_bak_addr
000E96 F0                MOVX     @DPTR,A
000E97 A3                INC      DPTR
000E98 CE                XCH      A,R6
000E99 F0                MOVX     @DPTR,A
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 35


   49: 	SectorSize = Size + 2;
   50: 
   51: 	e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
   52: 	e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
   53: 
   54: 	sys_eepromRead(e2_addr, e2_data, SectorSize);
000E9A 121A74            LCALL    ?L?COM004E
000E9D F1A5              ACALL    ?L?COM0016
000E9F 90008D            MOV      DPTR,#SectorSize
000EA2 121229            LCALL    ?L?COM000E
000EA5 1212A1            LCALL    ?L?COM0011
000EA8 6007              JZ       ?C0004?HWA_EEPROM
   55: 	if (c_s_eepromConfig[sector].Encrypt)
   56: 	{
   57: 		hwa_eepromDecrypt(e2_data, Size);
000EAA F1A5              ACALL    ?L?COM0016
000EAC F1B2              ACALL    ?L?COM0018
000EAE 12180C            LCALL    _hwa_eepromDecrypt
   58: 	}
000EB1         ?C0004?HWA_EEPROM:
   59: 	e2_check_sum = e2_data[Size] << 8 | e2_data[Size + 1];
000EB1 F1B2              ACALL    ?L?COM0018
000EB3 2400              ADD      A,#LOW e2_data
000EB5 F582              MOV      DPL,A
000EB7 7400              MOV      A,#HIGH e2_data
000EB9 3C                ADDC     A,R4
000EBA F583              MOV      DPH,A
000EBC E0                MOVX     A,@DPTR
000EBD FE                MOV      R6,A
000EBE 7401              MOV      A,#LOW e2_data+01H
000EC0 2D                ADD      A,R5
000EC1 F582              MOV      DPL,A
000EC3 7400              MOV      A,#HIGH e2_data+01H
000EC5 121AAD            LCALL    ?L?COM005C
000EC8 900087            MOV      DPTR,#e2_check_sum
000ECB EE                MOV      A,R6
000ECC F0                MOVX     @DPTR,A
000ECD A3                INC      DPTR
000ECE EF                MOV      A,R7
000ECF F0                MOVX     @DPTR,A
   60: 
   61: 	sys_eepromRead(e2_bak_addr, e2_data_bak, SectorSize);
000ED0 F1D1              ACALL    ?L?COM0032
000ED2 90008D            MOV      DPTR,#SectorSize
000ED5 121229            LCALL    ?L?COM000E
000ED8 1212A1            LCALL    ?L?COM0011
000EDB 6005              JZ       ?C0005?HWA_EEPROM
   62: 	if (c_s_eepromConfig[sector].Encrypt)
   63: 	{
   64: 		hwa_eepromDecrypt(e2_data_bak, Size);
000EDD F1AC              ACALL    ?L?COM0017
000EDF 12180C            LCALL    _hwa_eepromDecrypt
   65: 	}
000EE2         ?C0005?HWA_EEPROM:
   66: 	e2_bak_check_sum = e2_data_bak[Size] << 8 | e2_data_bak[Size + 1];
000EE2 F1B2              ACALL    ?L?COM0018
000EE4 2420              ADD      A,#LOW e2_data_bak
000EE6 F582              MOV      DPL,A
000EE8 7400              MOV      A,#HIGH e2_data_bak
000EEA 3C                ADDC     A,R4
000EEB F583              MOV      DPH,A
000EED E0                MOVX     A,@DPTR
000EEE FE                MOV      R6,A
000EEF 7421              MOV      A,#LOW e2_data_bak+01H
000EF1 2D                ADD      A,R5
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 36


000EF2 F582              MOV      DPL,A
000EF4 7400              MOV      A,#HIGH e2_data_bak+01H
000EF6 121AAD            LCALL    ?L?COM005C
000EF9 900089            MOV      DPTR,#e2_bak_check_sum
000EFC F1A0              ACALL    ?L?COM0015
000EFE A3                INC      DPTR
000EFF A3                INC      DPTR
000F00 E0                MOVX     A,@DPTR
000F01 FD                MOV      R5,A
000F02 1212FA            LCALL    _hwa_mifareCheckOut
000F05 900087            MOV      DPTR,#e2_check_sum
000F08 E0                MOVX     A,@DPTR
000F09 6E                XRL      A,R6
000F0A 7003              JNZ      ?C0017?HWA_EEPROM
000F0C A3                INC      DPTR
000F0D E0                MOVX     A,@DPTR
000F0E 6F                XRL      A,R7
000F0F         ?C0017?HWA_EEPROM:
000F0F 6002              JZ       ?C0006?HWA_EEPROM
   67: 
   68: 	if (e2_check_sum != hwa_mifareCheckOut(e2_data, Size))
   69: 	{
   70: 		e2_error = TRUE;
000F11 D202              SETB     e2_error
   71: 	}
000F13         ?C0006?HWA_EEPROM:
   72: 	if (e2_bak_check_sum != hwa_mifareCheckOut(e2_data_bak, Size))
000F13 F1AC              ACALL    ?L?COM0017
000F15 1212FA            LCALL    _hwa_mifareCheckOut
000F18 900089            MOV      DPTR,#e2_bak_check_sum
000F1B E0                MOVX     A,@DPTR
000F1C 6E                XRL      A,R6
000F1D 7003              JNZ      ?C0018?HWA_EEPROM
000F1F A3                INC      DPTR
000F20 E0                MOVX     A,@DPTR
000F21 6F                XRL      A,R7
000F22         ?C0018?HWA_EEPROM:
000F22 6002              JZ       ?C0007?HWA_EEPROM
   73: 	{
   74: 		e2_bak_error = TRUE;
000F24 D203              SETB     e2_bak_error
   75: 	}
000F26         ?C0007?HWA_EEPROM:
   76: 
   77: 	if (e2_error && e2_bak_error)    //~1~备份块和正常块都校验错误，返回错误
000F26 300205            JNB      e2_error,?C0008?HWA_EEPROM
000F29 300302            JNB      e2_bak_error,?C0008?HWA_EEPROM
   78: 	{
   79: 		return FALSE;
000F2C C3                CLR      C
000F2D 22                RET      
   80: 	}
000F2E         ?C0008?HWA_EEPROM:
   81: 	else if (e2_error)                                 //~2~备份块校验错误，恢复正常块
000F2E 300218            JNB      e2_error,?C0010?HWA_EEPROM
   82: 	{
   83: 		memcpy(e2_data, e2_data_bak, SectorSize);
000F31 90008D            MOV      DPTR,#SectorSize
000F34 121A57            LCALL    ?L?COM0045
000F37 F1D9              ACALL    ?L?COM0033
000F39 1200F6            LCALL    ?C?COPY
   84: 		sys_eepromEraseSector(e2_addr);
000F3C 900083            MOV      DPTR,#e2_addr
000F3F 1211D8            LCALL    ?L?COM002D
   85: 		sys_eepromWrite(e2_addr, e2_data, SectorSize);
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 37


000F42 121A74            LCALL    ?L?COM004E
000F45 F1A5              ACALL    ?L?COM0016
   86: 	}
000F47 8038              SJMP     ?C0020?HWA_EEPROM
000F49         ?C0010?HWA_EEPROM:
   87: 	else if (e2_bak_error ||                          //~3~正常块校验错误，恢复备份块
000F49 20031A            JB       e2_bak_error,?C0013?HWA_EEPROM
000F4C 20023B            JB       e2_error,?C0009?HWA_EEPROM
000F4F 200338            JB       e2_bak_error,?C0009?HWA_EEPROM
000F52 900089            MOV      DPTR,#e2_bak_check_sum
000F55 E0                MOVX     A,@DPTR
000F56 FE                MOV      R6,A
000F57 A3                INC      DPTR
000F58 E0                MOVX     A,@DPTR
000F59 FF                MOV      R7,A
000F5A 900087            MOV      DPTR,#e2_check_sum
000F5D E0                MOVX     A,@DPTR
000F5E 6E                XRL      A,R6
000F5F 7003              JNZ      ?C0019?HWA_EEPROM
000F61 A3                INC      DPTR
000F62 E0                MOVX     A,@DPTR
000F63 6F                XRL      A,R7
000F64         ?C0019?HWA_EEPROM:
000F64 6024              JZ       ?C0009?HWA_EEPROM
000F66         ?C0013?HWA_EEPROM:
   88: 		(e2_error == FALSE                                //~4~正常块、备份块都检验正确，但数据不同，则以
   89: 		&& e2_bak_error == FALSE                         //   最新写入的正常块覆盖备份块
   90: 		&& e2_check_sum != e2_bak_check_sum)
   91: 		)
   92: 	{
   93: 		memcpy(e2_data_bak, e2_data, SectorSize);
000F66 90008D            MOV      DPTR,#SectorSize
000F69 E0                MOVX     A,@DPTR
000F6A FE                MOV      R6,A
000F6B A3                INC      DPTR
000F6C E0                MOVX     A,@DPTR
000F6D FF                MOV      R7,A
000F6E 7820              MOV      R0,#LOW e2_data_bak
000F70 7C00              MOV      R4,#HIGH e2_data_bak
000F72 7D01              MOV      R5,#01H
000F74 F1A5              ACALL    ?L?COM0016
000F76 1200F6            LCALL    ?C?COPY
   94: 		sys_eepromEraseSector(e2_bak_addr);
000F79 900085            MOV      DPTR,#e2_bak_addr
000F7C 1211D8            LCALL    ?L?COM002D
   95: 		sys_eepromWrite(e2_bak_addr, e2_data_bak, SectorSize);
000F7F F1D1              ACALL    ?L?COM0032
000F81         
000F81 90008D            MOV      DPTR,#SectorSize
000F84 121229            LCALL    ?L?COM000E
000F87 1211F6            LCALL    _sys_eepromWrite
   96: 	}
000F8A         ?C0009?HWA_EEPROM:
   97: 	memcpy(dat, e2_data, Size);
000F8A 90008B            MOV      DPTR,#Size
000F8D E0                MOVX     A,@DPTR
000F8E FE                MOV      R6,A
000F8F A3                INC      DPTR
000F90 E0                MOVX     A,@DPTR
000F91 FF                MOV      R7,A
000F92 917B              ACALL    ?L?COM0001
000F94 F8                MOV      R0,A
000F95 AC02              MOV      R4,AR2
000F97 AD03              MOV      R5,AR3
000F99 F1A5              ACALL    ?L?COM0016
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 38


000F9B 1200F6            LCALL    ?C?COPY
   98: 	return TRUE;
000F9E D3                SETB     C
   99: }
000F9F 22                RET      
----- FUNCTION _hwa_eepromReadSector (END) -------


----- FUNCTION ?L?COM0015 (BEGIN) -----
000FA0 EE                MOV      A,R6
000FA1 F0                MOVX     @DPTR,A
000FA2 A3                INC      DPTR
000FA3 EF                MOV      A,R7
000FA4 F0                MOVX     @DPTR,A
000FA5         ?L?COM0016:
000FA5 7B01              MOV      R3,#01H
000FA7 7A00              MOV      R2,#HIGH e2_data
000FA9 7900              MOV      R1,#LOW e2_data
000FAB 22                RET      
----- FUNCTION ?L?COM0015 (END) -------


----- FUNCTION ?L?COM0017 (BEGIN) -----
000FAC 7B01              MOV      R3,#01H
000FAE 7A00              MOV      R2,#HIGH e2_data_bak
000FB0 7920              MOV      R1,#LOW e2_data_bak
000FB2         ?L?COM0018:
000FB2 90008B            MOV      DPTR,#Size
000FB5 E0                MOVX     A,@DPTR
000FB6 FC                MOV      R4,A
000FB7 A3                INC      DPTR
000FB8 E0                MOVX     A,@DPTR
000FB9 FD                MOV      R5,A
000FBA 22                RET      
----- FUNCTION ?L?COM0017 (END) -------


----- FUNCTION ?L?COM0043 (BEGIN) -----
000FBB 7E00              MOV      R6,#00H
000FBD 7F10              MOV      R7,#010H
000FBF 0200F6            LJMP     ?C?COPY
----- FUNCTION ?L?COM0043 (END) -------


----- FUNCTION ?L?COM0030 (BEGIN) -----
000FC2 E0                MOVX     A,@DPTR
000FC3 FA                MOV      R2,A
000FC4 A3                INC      DPTR
000FC5 E0                MOVX     A,@DPTR
000FC6 FB                MOV      R3,A
000FC7 7C03              MOV      R4,#03H
000FC9 7DE8              MOV      R5,#0E8H
000FCB         ?L?COM0031:
000FCB FF                MOV      R7,A
000FCC AE02              MOV      R6,AR2
000FCE 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM0030 (END) -------


----- FUNCTION ?L?COM0032 (BEGIN) -----
000FD1 900085            MOV      DPTR,#e2_bak_addr
000FD4 E0                MOVX     A,@DPTR
000FD5 FE                MOV      R6,A
000FD6 A3                INC      DPTR
000FD7 E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 39


000FD8 FF                MOV      R7,A
000FD9         ?L?COM0033:
000FD9 7B01              MOV      R3,#01H
000FDB 7A00              MOV      R2,#HIGH e2_data_bak
000FDD 7920              MOV      R1,#LOW e2_data_bak
000FDF 22                RET      
----- FUNCTION ?L?COM0032 (END) -------


----- FUNCTION ?L?COM002A (BEGIN) -----
000FE0 7F0A              MOV      R7,#0AH
000FE2 1206F7            LCALL    _SPIReadOne
000FE5 EF                MOV      A,R7
000FE6 22                RET      
----- FUNCTION ?L?COM002A (END) -------


----- FUNCTION ?L?COM0059 (BEGIN) -----
000FE7 FE                MOV      R6,A
000FE8 FC                MOV      R4,A
000FE9 7D64              MOV      R5,#064H
000FEB 020196            LJMP     ?C?IMUL
----- FUNCTION ?L?COM0059 (END) -------


----- FUNCTION ?L?COM005D (BEGIN) -----
000FEE AF03              MOV      R7,AR3
000FF0 AE02              MOV      R6,AR2
000FF2 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM005D (END) -------


----- FUNCTION ?L?COM005A (BEGIN) -----
000FF5 E0                MOVX     A,@DPTR
000FF6 04                INC      A
000FF7 F0                MOVX     @DPTR,A
000FF8 E0                MOVX     A,@DPTR
000FF9 C3                CLR      C
000FFA 9403              SUBB     A,#03H
000FFC 22                RET      
----- FUNCTION ?L?COM005A (END) -------


----- FUNCTION ?L?COM0050 (BEGIN) -----
000FFD 900070            MOV      DPTR,#L_num
001000 EE                MOV      A,R6
001001 F0                MOVX     @DPTR,A
001002 A3                INC      DPTR
001003 EF                MOV      A,R7
001004 F0                MOVX     @DPTR,A
001005 22                RET      
----- FUNCTION ?L?COM0050 (END) -------


----- FUNCTION sys_tim0Init (BEGIN) -----
 FILE: 'System\sys_tim.c'
  101: void sys_tim0Init(void)
  102: {
  103: 	TMOD &= 0xF0;
  104: 	TH0 = (UINT8)(T1MS>>8);
001006 5389F0            ANL      TMOD,#0F0H
  105: 	TL0 = (UINT8)T1MS;
001009 758CF8            MOV      TH0,#0F8H
  106: 	ET0 = 1;
00100C 758ACD            MOV      TL0,#0CDH
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 40


  107: 	TR0 = 1;
00100F D2A9              SETB     ET0
  108: //	PT1 = 1;
001011 D28C              SETB     TR0
  109:     EA = 1;
001013 D2AF              SETB     EA
  110: }
001015 22                RET      
----- FUNCTION sys_tim0Init (END) -------


----- FUNCTION sys_taskInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   27: void sys_taskInit(void)
   28: {
   29:     WDT_CONTR = 0x33;
   30:     len_Init();
001016 75C133            MOV      WDT_CONTR,#033H
   31:     sys_gpioInit();
001019 121869            LCALL    len_Init
   32:     buzzer_Init();
00101C 120009            LCALL    sys_gpioInit
   33:     sys_uartInit();
00101F 12185F            LCALL    buzzer_Init
   34:     sys_tim0Init();
001022 F193              ACALL    sys_uartInit
   35:     app_configInit();
001024 1106              ACALL    sys_tim0Init
   36: 	app_Show();
001026 112E              ACALL    app_configInit
   37:     app_brushInit();
001028 12083A            LCALL    app_Show
;----                  JMP      app_brushInit
----- FUNCTION sys_taskInit (END) -------


----- FUNCTION app_brushInit (BEGIN) -----
 FILE: 'App\app_brush.c'
   38: void app_brushInit(void)
   39: {
   40: 	Init_FM1702();
   41: }
00102B 020668            LJMP     Init_FM1702
----- FUNCTION app_brushInit (END) -------


----- FUNCTION app_configInit (BEGIN) -----
 FILE: 'App\app_config.c'
   47: void app_configInit(void)
   48: {
   49:     BOOL state = FALSE;
   50:     led_Switch(OFF);
00102E C200              CLR      state
   51:     hwa_eepromInit();
001030 C201              CLR      ?led_Switch?BIT
001032 11B6              ACALL    led_Switch
   52:     if(app_configRead(SYSTEM_SETTING_SECTOR) == FALSE)
001034 120022            LCALL    hwa_eepromInit
   53:     {
001037 E4                CLR      A
001038 FF                MOV      R7,A
001039 11E5              ACALL    _app_configRead
00103B 4022              JC       ?C0001?APP_CONFIG
   54:         memcpy(&s_System, &s_FactorySystem, sizeof(s_System));
   55:         b_FactorySystem = TRUE;
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 41


00103D 78A1              MOV      R0,#LOW s_System
00103F 7C00              MOV      R4,#HIGH s_System
001041 7D01              MOV      R5,#01H
001043 7BFF              MOV      R3,#0FFH
001045 7A00              MOV      R2,#HIGH s_FactorySystem
001047 790E              MOV      R1,#LOW s_FactorySystem
001049 7E00              MOV      R6,#00H
00104B 7F13              MOV      R7,#013H
00104D 1200F6            LCALL    ?C?COPY
   56:         led_ShowNumber(8888,88,0xFF);
001050 D208              SETB     b_FactorySystem
   57:     }
001052 7BFF              MOV      R3,#0FFH
001054 7D58              MOV      R5,#058H
001056 7FB8              MOV      R7,#0B8H
001058 7E22              MOV      R6,#022H
00105A 120872            LCALL    _led_ShowNumber
   58:     else
00105D 803C              SJMP     ?C0002?APP_CONFIG
00105F         ?C0001?APP_CONFIG:
   59:     {
   60:         if(s_System.Sector > 16 || s_System.Sector < 1)                 //钱包分区不在1~16
00105F 9000A7            MOV      DPTR,#s_System+06H
001062 E0                MOVX     A,@DPTR
001063 FF                MOV      R7,A
001064 D3                SETB     C
001065 9410              SUBB     A,#010H
001067 5006              JNC      ?C0004?APP_CONFIG
001069 EF                MOV      A,R7
00106A C3                CLR      C
00106B 9401              SUBB     A,#01H
00106D 500B              JNC      ?C0003?APP_CONFIG
00106F         ?C0004?APP_CONFIG:
   61:         {
   62:             s_System.Sector = s_FactorySystem.Sector;
00106F 900014            MOV      DPTR,#s_FactorySystem+06H
001072 E4                CLR      A
001073 93                MOVC     A,@A+DPTR
001074 9000A7            MOV      DPTR,#s_System+06H
001077 F0                MOVX     @DPTR,A
   63:             state = TRUE;
001078 D200              SETB     state
   64:         }
00107A         ?C0003?APP_CONFIG:
   65:         if(s_System.Money > 20000)                                        //金额大于200
00107A D3                SETB     C
00107B 3107              ACALL    ?L?COM002E
00107D 4013              JC       ?C0005?APP_CONFIG
   66:         {
   67:             s_System.Money = s_FactorySystem.Money;
00107F 90001F            MOV      DPTR,#s_FactorySystem+011H
001082 E4                CLR      A
001083 93                MOVC     A,@A+DPTR
001084 FF                MOV      R7,A
001085 7401              MOV      A,#01H
001087 93                MOVC     A,@A+DPTR
001088 9000B2            MOV      DPTR,#s_System+011H
00108B CF                XCH      A,R7
00108C F0                MOVX     @DPTR,A
00108D A3                INC      DPTR
00108E EF                MOV      A,R7
00108F F0                MOVX     @DPTR,A
   68:             state = TRUE;
001090 D200              SETB     state
   69:         }
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 42


001092         ?C0005?APP_CONFIG:
   70:         if(state)
001092 300006            JNB      state,?C0002?APP_CONFIG
   71:         {
   72: 			app_configWrite(SYSTEM_SETTING_SECTOR);
001095 E4                CLR      A
001096 FF                MOV      R7,A
001097 11C1              ACALL    _app_configWrite
   73:             b_FactorySystem = TRUE;
001099 D208              SETB     b_FactorySystem
   74:         }
   75:     }
00109B         ?C0002?APP_CONFIG:
   76:     
   77:     if(app_configRead(MONEY_SECTOR) == FALSE)
00109B 7F01              MOV      R7,#01H
00109D 11E5              ACALL    _app_configRead
00109F 4013              JC       ?C0007?APP_CONFIG
   78:     {
   79:         memset(&MoneySum, 0x00, sizeof(MoneySum));
0010A1 7E00              MOV      R6,#00H
0010A3 7F04              MOV      R7,#04H
0010A5 7D00              MOV      R5,#00H
0010A7 7B01              MOV      R3,#01H
0010A9 7A00              MOV      R2,#HIGH MoneySum
0010AB 799D              MOV      R1,#LOW MoneySum
0010AD 12052F            LCALL    ?C?MEMSET
   80: 		app_configWrite(MONEY_SECTOR);
0010B0 7F01              MOV      R7,#01H
0010B2 11C1              ACALL    _app_configWrite
   81:     }
0010B4         ?C0007?APP_CONFIG:
   82:     led_Switch(ON);
0010B4 D201              SETB     ?led_Switch?BIT
;----                  JMP      led_Switch
----- FUNCTION app_configInit (END) -------


----- FUNCTION led_Switch (BEGIN) -----
 FILE: 'Driver\LED.c'
  152: void led_Switch(bit sw)
  153: {
  154:     ledsw = sw;
  155:     if(ledsw==0)
0010B6 A201              MOV      C,sw
0010B8 9209              MOV      ledsw,C
  156:     {
0010BA 200903            JB       ledsw,?C0044?LED
  157:     	LED_CS0 = 1;
  158:     	LED_CS1 = 1;
0010BD 121987            LCALL    ?L?COM003D
  159:     	LED_CS2 = 1;
  160:     	LED_CS3 = 1;
  161:     	LED_CS4 = 1;
  162:     	LED_CS5 = 1;
  163:     }
  164: }
0010C0         ?C0044?LED:
0010C0 22                RET      
----- FUNCTION led_Switch (END) -------


----- FUNCTION _app_configWrite (BEGIN) -----
 FILE: 'App\app_config.c'
   99: void app_configWrite(UINT8 Sector)
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 43


  100: {
0010C1 900070            MOV      DPTR,#Sector
0010C4 EF                MOV      A,R7
0010C5 F0                MOVX     @DPTR,A
  101:     led_Switch(OFF);
  102:     if(Sector == SYSTEM_SETTING_SECTOR)
0010C6 C201              CLR      ?led_Switch?BIT
0010C8 11B6              ACALL    led_Switch
  103:     {
0010CA 900070            MOV      DPTR,#Sector
0010CD E0                MOVX     A,@DPTR
0010CE 7B01              MOV      R3,#01H
0010D0 7007              JNZ      ?C0012?APP_CONFIG
  104:         hwa_eepromWriteSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
  105:     }
0010D2 7A00              MOV      R2,#HIGH s_System
0010D4 79A1              MOV      R1,#LOW s_System
0010D6 FD                MOV      R5,A
  106:     else
0010D7 8006              SJMP     ?C0017?APP_CONFIG
0010D9         ?C0012?APP_CONFIG:
  107:     {
  108:         hwa_eepromWriteSector((UINT8*)&MoneySum, MONEY_SECTOR);
0010D9 7A00              MOV      R2,#HIGH MoneySum
0010DB 799D              MOV      R1,#LOW MoneySum
0010DD 7D01              MOV      R5,#01H
0010DF         
0010DF 312A              ACALL    _hwa_eepromWriteSector
  109:     }
0010E1         ?C0013?APP_CONFIG:
  110:     led_Switch(ON);
0010E1 D201              SETB     ?led_Switch?BIT
0010E3 80D1              SJMP     led_Switch
----- FUNCTION _app_configWrite (END) -------


----- FUNCTION _app_configRead (BEGIN) -----
 FILE: 'App\app_config.c'
   85: BOOL app_configRead(UINT8 Sector)
   86: {
;---- Variable 'Sector' assigned to Register 'R7' ----
   87:     BOOL state;
   88:     if(Sector == SYSTEM_SETTING_SECTOR)
0010E5 EF                MOV      A,R7
0010E6 7B01              MOV      R3,#01H
0010E8 7007              JNZ      ?C0009?APP_CONFIG
   89:     {
   90:         state = hwa_eepromReadSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
0010EA 7A00              MOV      R2,#HIGH s_System
0010EC 79A1              MOV      R1,#LOW s_System
0010EE FD                MOV      R5,A
   91:     }
0010EF 8006              SJMP     ?C0016?APP_CONFIG
0010F1         ?C0009?APP_CONFIG:
   92:     else
   93:     {
   94:         state = hwa_eepromReadSector((UINT8*)&MoneySum, MONEY_SECTOR);
0010F1 7A00              MOV      R2,#HIGH MoneySum
0010F3 799D              MOV      R1,#LOW MoneySum
0010F5 7D01              MOV      R5,#01H
0010F7         
0010F7 120E6B            LCALL    _hwa_eepromReadSector
0010FA 9201              MOV      state,C
   95:     }
0010FC         ?C0010?APP_CONFIG:
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 44


   96:     return state;
0010FC A201              MOV      C,state
   97: }
0010FE 22                RET      
----- FUNCTION _app_configRead (END) -------


----- FUNCTION app_confingHandler1s (BEGIN) -----
 FILE: 'App\app_config.c'
  113: void app_confingHandler1s(void)
  114: {
  115:     led_Switch(OFF);
  116: //    hwa_eepromReadSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
0010FF C201              CLR      ?led_Switch?BIT
001101 11B6              ACALL    led_Switch
  117: //    sys_uartSendData((UINT8*)&USER_Card_ID, 5);
  118: //    USER_Card_ID[0][0]++;
  119: //    hwa_eepromWriteSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
  120:     led_Switch(ON);
001103 D201              SETB     ?led_Switch?BIT
001105 80AF              SJMP     led_Switch
----- FUNCTION app_confingHandler1s (END) -------


----- FUNCTION ?L?COM002E (BEGIN) -----
001107 9000B3            MOV      DPTR,#s_System+012H
00110A         ?L?COM002F:
00110A E0                MOVX     A,@DPTR
00110B 9420              SUBB     A,#020H
00110D 9000B2            MOV      DPTR,#s_System+011H
001110 E0                MOVX     A,@DPTR
001111 944E              SUBB     A,#04EH
001113 22                RET      
----- FUNCTION ?L?COM002E (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: 'System\sys_task.c'
   77: void main(void)
   78: {
   79:     sys_taskInit();
   80:     buzzer_SoundNumber(1);
001114 1116              ACALL    sys_taskInit
   81:     while(1)
001116 7F01              MOV      R7,#01H
001118 120B52            LCALL    _buzzer_SoundNumber
00111B         ?C0010?SYS_TASK:
   82:     {
   83:         WDT_CONTR = 0x33;          //reset watch dog      SyttemClk is 11.0592M Over Time 568.8ms
   84:         if(taskCycle1sFlag == TRUE)
00111B 75C133            MOV      WDT_CONTR,#033H
   85:         {
00111E 3006FA            JNB      taskCycle1sFlag,?C0010?SYS_TASK
   86:         	taskCycle1sFlag = FALSE;
   87:             app_confingHandler1s();
001121 C206              CLR      taskCycle1sFlag
   88:             app_brushCycle1s();
001123 11FF              ACALL    app_confingHandler1s
   89:         }
001125 12095F            LCALL    app_brushCycle1s
   90:     }
   91: }
001128 80F1              SJMP     ?C0010?SYS_TASK
----- FUNCTION main (END) -------

LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 45



----- FUNCTION _hwa_eepromWriteSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
  101: BOOL hwa_eepromWriteSector(UINT8 *dat, UINT8 sector)
  102: {
00112A 900071            MOV      DPTR,#dat
00112D 120DCC            LCALL    ?L?COM0008
001130 A3                INC      DPTR
001131 ED                MOV      A,R5
001132 F0                MOVX     @DPTR,A
  103: 	UINT16 e2_addr, e2_bak_addr;
  104: 	UINT16 e2_check_sum;
  105: 
  106: 	UINT16 Size, SectorSize;
  107: 
  108: 	if (sector >= c_u8_eepromSectorNum)
001133 121A6A            LCALL    ?L?COM004D
001136 4001              JC       ?C0014?HWA_EEPROM
  109: 	{
  110: 		return FALSE;
001138 22                RET      
  111: 	}
001139         ?C0014?HWA_EEPROM:
  112: 	Size = c_s_eepromConfig[sector].UseSize;
001139 900074            MOV      DPTR,#sector
00113C 121A18            LCALL    ?L?COM0029
00113F 7401              MOV      A,#01H
001141 93                MOVC     A,@A+DPTR
001142 FD                MOV      R5,A
001143 90007B            MOV      DPTR,#Size
001146 5136              ACALL    ?L?COM0009
001148 900075            MOV      DPTR,#e2_addr
00114B 121AA5            LCALL    ?L?COM005B
00114E 515D              ACALL    ?L?COM000A
001150 900077            MOV      DPTR,#e2_bak_addr
001153 F0                MOVX     @DPTR,A
001154 A3                INC      DPTR
001155 CE                XCH      A,R6
001156 F0                MOVX     @DPTR,A
  113: 	SectorSize = Size + 2;
  114: 
  115: 	e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
  116: 	e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
  117: 	e2_check_sum = hwa_mifareCheckOut(dat, Size);
001157 900071            MOV      DPTR,#dat
00115A 120C7E            LCALL    ?L?COM0002
00115D F9                MOV      R1,A
00115E 31CF              ACALL    ?L?COM0053
001160 51FA              ACALL    _hwa_mifareCheckOut
001162 900079            MOV      DPTR,#e2_check_sum
001165 120FA0            LCALL    ?L?COM0015
001168 900074            MOV      DPTR,#sector
00116B E0                MOVX     A,@DPTR
00116C FD                MOV      R5,A
00116D 120E6B            LCALL    _hwa_eepromReadSector
  118: 
  119: 	hwa_eepromReadSector(e2_data, sector);                                  //  写入之前，如果有错误块，先恢复
  120: 
  121: 	memcpy(e2_data, dat, Size);
001170 90007B            MOV      DPTR,#Size
001173 121A57            LCALL    ?L?COM0045
001176 900071            MOV      DPTR,#dat
001179 120C7E            LCALL    ?L?COM0002
00117C F9                MOV      R1,A
00117D 1200F6            LCALL    ?C?COPY
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 46


  122: 
  123: 	if (c_s_eepromConfig[sector].Encrypt)
001180 900074            MOV      DPTR,#sector
001183 51A6              ACALL    ?L?COM0012
001185 6007              JZ       ?C0016?HWA_EEPROM
  124: 	{
  125: 		hwa_eepromEncrypt(e2_data, Size);
001187 120FA5            LCALL    ?L?COM0016
00118A 31CF              ACALL    ?L?COM0053
00118C 51CD              ACALL    _hwa_eepromEncrypt
  126: 	}
00118E         ?C0016?HWA_EEPROM:
  127: 	e2_data[Size] = (UINT8)(e2_check_sum >> 8);
00118E 900079            MOV      DPTR,#e2_check_sum
001191 E0                MOVX     A,@DPTR
001192 FC                MOV      R4,A
001193 A3                INC      DPTR
001194 E0                MOVX     A,@DPTR
001195 FD                MOV      R5,A
001196 EC                MOV      A,R4
001197 FF                MOV      R7,A
001198 A3                INC      DPTR
001199 E0                MOVX     A,@DPTR
00119A FA                MOV      R2,A
00119B A3                INC      DPTR
00119C E0                MOVX     A,@DPTR
00119D FB                MOV      R3,A
00119E 2400              ADD      A,#LOW e2_data
0011A0 F582              MOV      DPL,A
0011A2 7400              MOV      A,#HIGH e2_data
0011A4 3A                ADDC     A,R2
0011A5 F583              MOV      DPH,A
0011A7 EF                MOV      A,R7
0011A8 F0                MOVX     @DPTR,A
  128: 	e2_data[Size + 1] = (UINT8)(e2_check_sum & 0xFF);
0011A9 7401              MOV      A,#LOW e2_data+01H
0011AB 2B                ADD      A,R3
0011AC F582              MOV      DPL,A
0011AE 7400              MOV      A,#HIGH e2_data+01H
0011B0 3A                ADDC     A,R2
0011B1 F583              MOV      DPH,A
0011B3 ED                MOV      A,R5
0011B4 F0                MOVX     @DPTR,A
  129: 	sys_eepromEraseSector(e2_addr);
0011B5 900075            MOV      DPTR,#e2_addr
0011B8 31D8              ACALL    ?L?COM002D
  130: 	sys_eepromWrite(e2_addr, e2_data, SectorSize);
0011BA 900075            MOV      DPTR,#e2_addr
0011BD 511B              ACALL    ?L?COM000D
0011BF 31F6              ACALL    _sys_eepromWrite
  131: 
  132: 	//    memcpy(e2_data_bak, e2_data, SectorSize);
  133: 	sys_eepromEraseSector(e2_bak_addr);
0011C1 900077            MOV      DPTR,#e2_bak_addr
0011C4 31D8              ACALL    ?L?COM002D
  134: 	sys_eepromWrite(e2_bak_addr, e2_data, SectorSize);
0011C6 900077            MOV      DPTR,#e2_bak_addr
0011C9 511B              ACALL    ?L?COM000D
0011CB 31F6              ACALL    _sys_eepromWrite
  135: 	return TRUE;
0011CD D3                SETB     C
  136: }
0011CE 22                RET      
----- FUNCTION _hwa_eepromWriteSector (END) -------

LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 47



----- FUNCTION ?L?COM0053 (BEGIN) -----
0011CF 90007B            MOV      DPTR,#Size
0011D2 E0                MOVX     A,@DPTR
0011D3 FC                MOV      R4,A
0011D4 A3                INC      DPTR
0011D5 E0                MOVX     A,@DPTR
0011D6 FD                MOV      R5,A
0011D7 22                RET      
----- FUNCTION ?L?COM0053 (END) -------


----- FUNCTION ?L?COM002D (BEGIN) -----
0011D8 E0                MOVX     A,@DPTR
0011D9 FE                MOV      R6,A
0011DA A3                INC      DPTR
0011DB E0                MOVX     A,@DPTR
0011DC FF                MOV      R7,A
----- FUNCTION _sys_eepromEraseSector (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   72: void sys_eepromEraseSector(UINT16 addr)
   73: {
;---- Variable 'addr' assigned to Register 'R6/R7' ----
   74:     IAP_CONTR = ENABLE_IAP;         //使能IAP
   75:     IAP_CMD = CMD_ERASE;            //设置IAP命令
0011DD 75C780            MOV      IAP_CONTR,#080H
   76:     IAP_ADDRL = addr;               //设置IAP低地址
0011E0 75C503            MOV      IAP_CMD,#03H
   77:     IAP_ADDRH = addr >> 8;          //设置IAP高地址
0011E3 8FC4              MOV      IAP_ADDRL,R7
   78:     IAP_TRIG = 0x5a;                //写触发命令(0x5a)
0011E5 EE                MOV      A,R6
0011E6 5166              ACALL    ?L?COM0047
   79:     IAP_TRIG = 0xa5;                //写触发命令(0xa5)
   80:     _nop_();                        //等待ISP/IAP/EEPROM操作完成
0011E8 00                NOP      
;----                  JMP      IapIdle
   81:     IapIdle();
----- FUNCTION _sys_eepromEraseSector (END) -------


----- FUNCTION IapIdle (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   24: void IapIdle(void)
   25: {
   26:     IAP_CONTR = 0;                  //关闭IAP功能
   27:     IAP_CMD = 0;                    //清除命令寄存器
0011E9 E4                CLR      A
0011EA F5C7              MOV      IAP_CONTR,A
   28:     IAP_TRIG = 0;                   //清除触发寄存器
0011EC F5C5              MOV      IAP_CMD,A
   29:     IAP_ADDRH = 0x80;               //将地址设置到非IAP区域
0011EE F5C6              MOV      IAP_TRIG,A
   30:     IAP_ADDRL = 0;
0011F0 75C380            MOV      IAP_ADDRH,#080H
   31: }
0011F3 F5C4              MOV      IAP_ADDRL,A
   32: 
0011F5 22                RET      
----- FUNCTION IapIdle (END) -------


----- FUNCTION _sys_eepromWrite (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
  100: void sys_eepromWrite(UINT16 addr, UINT8 *Data, UINT16 num)
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 48


  101: {
;---- Variable 'Data' assigned to Register 'R1/R2/R3' ----
;---- Variable 'addr' assigned to Register 'R4/R5' ----
0011F6 51B8              ACALL    ?L?COM005E
  102:     IAP_CONTR = ENABLE_IAP;
  103:     IAP_CMD = CMD_PROGRAM;
0011F8 75C502            MOV      IAP_CMD,#02H
0011FB         ?C0006?SYS_EEPROM:
  104:     while(num--)
0011FB 51C0              ACALL    ?L?COM003F
0011FD 601A              JZ       ?C0007?SYS_EEPROM
  105:     {
  106:         IAP_ADDRL = addr;
0011FF 8DC4              MOV      IAP_ADDRL,R5
  107:         IAP_ADDRH = addr >> 8;
001201 EC                MOV      A,R4
001202 F5C3              MOV      IAP_ADDRH,A
  108:         IAP_DATA = *Data;
001204 12011C            LCALL    ?C?CLDPTR
001207 F5C2              MOV      IAP_DATA,A
  109:         IAP_TRIG = 0x5a;
001209 5168              ACALL    ?L?COM0048
  110:         IAP_TRIG = 0xa5;
  111:         addr++;
00120B 0D                INC      R5
00120C BD0001            CJNE     R5,#00H,?C0010?SYS_EEPROM
00120F 0C                INC      R4
001210         ?C0010?SYS_EEPROM:
  112:         Data++;
001210 7401              MOV      A,#01H
001212 29                ADD      A,R1
001213 F9                MOV      R1,A
001214 E4                CLR      A
001215 3A                ADDC     A,R2
001216 FA                MOV      R2,A
  113:     }
001217 80E2              SJMP     ?C0006?SYS_EEPROM
001219         ?C0007?SYS_EEPROM:
  114:     IapIdle();
001219 80CE              SJMP     IapIdle
----- FUNCTION _sys_eepromWrite (END) -------


----- FUNCTION ?L?COM000D (BEGIN) -----
00121B E0                MOVX     A,@DPTR
00121C FE                MOV      R6,A
00121D A3                INC      DPTR
00121E E0                MOVX     A,@DPTR
00121F FF                MOV      R7,A
001220 7B01              MOV      R3,#01H
001222 7A00              MOV      R2,#HIGH e2_data
001224 7900              MOV      R1,#LOW e2_data
001226 90007D            MOV      DPTR,#SectorSize
001229         ?L?COM000E:
001229 E0                MOVX     A,@DPTR
00122A FD                MOV      R5,A
00122B A3                INC      DPTR
00122C E0                MOVX     A,@DPTR
00122D 900094            MOV      DPTR,#?_sys_eepromWrite?BYTE+05H
001230 CD                XCH      A,R5
001231 F0                MOVX     @DPTR,A
001232 A3                INC      DPTR
001233 ED                MOV      A,R5
001234 F0                MOVX     @DPTR,A
001235 22                RET      
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 49


----- FUNCTION ?L?COM000D (END) -------


----- FUNCTION ?L?COM0009 (BEGIN) -----
001236 EC                MOV      A,R4
001237 F0                MOVX     @DPTR,A
001238 A3                INC      DPTR
001239 ED                MOV      A,R5
00123A F0                MOVX     @DPTR,A
00123B 2402              ADD      A,#02H
00123D FE                MOV      R6,A
00123E E4                CLR      A
00123F 3C                ADDC     A,R4
001240 A3                INC      DPTR
001241 F0                MOVX     @DPTR,A
001242 A3                INC      DPTR
001243 CE                XCH      A,R6
001244 F0                MOVX     @DPTR,A
001245 EB                MOV      A,R3
001246 FF                MOV      R7,A
001247 7E00              MOV      R6,#00H
001249 900657            MOV      DPTR,#c_u16_eepromSectorSize
00124C E4                CLR      A
00124D 93                MOVC     A,@A+DPTR
00124E FC                MOV      R4,A
00124F 7401              MOV      A,#01H
001251 93                MOVC     A,@A+DPTR
001252 FD                MOV      R5,A
001253 120196            LCALL    ?C?IMUL
001256 AA06              MOV      R2,AR6
001258 AB07              MOV      R3,AR7
00125A 900659            MOV      DPTR,#c_u16_eepromSectorAddr
00125D         ?L?COM000A:
00125D 7401              MOV      A,#01H
00125F 93                MOVC     A,@A+DPTR
001260 2B                ADD      A,R3
001261 FE                MOV      R6,A
001262 E4                CLR      A
001263 93                MOVC     A,@A+DPTR
001264 3A                ADDC     A,R2
001265 22                RET      
----- FUNCTION ?L?COM0009 (END) -------


----- FUNCTION ?L?COM0047 (BEGIN) -----
001266 F5C3              MOV      IAP_ADDRH,A
001268         ?L?COM0048:
001268 75C65A            MOV      IAP_TRIG,#05AH
00126B 75C6A5            MOV      IAP_TRIG,#0A5H
00126E 22                RET      
----- FUNCTION ?L?COM0047 (END) -------


----- FUNCTION _sys_eepromRead (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   84: void sys_eepromRead(UINT16 addr, UINT8 *Data, UINT16 num)
   85: {
00126F 900091            MOV      DPTR,#Data
001272 120DCC            LCALL    ?L?COM0008
;---- Variable 'addr' assigned to Register 'R4/R5' ----
001275 51B8              ACALL    ?L?COM005E
   86:     IAP_CONTR = ENABLE_IAP;
   87:     IAP_CMD = CMD_READ;
001277 75C501            MOV      IAP_CMD,#01H
00127A         ?C0003?SYS_EEPROM:
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 50


   88:     while(num--)
00127A 51C0              ACALL    ?L?COM003F
00127C 6021              JZ       ?C0004?SYS_EEPROM
   89:     {
   90:         IAP_ADDRL = addr;
00127E 8DC4              MOV      IAP_ADDRL,R5
   91:         IAP_ADDRH = addr >> 8;
001280 EC                MOV      A,R4
001281 5166              ACALL    ?L?COM0047
   92:         IAP_TRIG = 0x5a;
   93:         IAP_TRIG = 0xa5;
   94:         addr++;
001283 0D                INC      R5
001284 BD0001            CJNE     R5,#00H,?C0009?SYS_EEPROM
001287 0C                INC      R4
001288         ?C0009?SYS_EEPROM:
   95:         *Data++ = IAP_DATA;
001288 900091            MOV      DPTR,#Data
00128B E0                MOVX     A,@DPTR
00128C FB                MOV      R3,A
00128D A3                INC      DPTR
00128E E4                CLR      A
00128F 75F001            MOV      B,#01H
001292 1201FD            LCALL    ?C?ILDIX
001295 A9F0              MOV      R1,B
001297 FA                MOV      R2,A
001298 E5C2              MOV      A,IAP_DATA
00129A 120162            LCALL    ?C?CSTPTR
   96:     }
00129D 80DB              SJMP     ?C0003?SYS_EEPROM
00129F         ?C0004?SYS_EEPROM:
   97:     IapIdle();
00129F 21E9              AJMP     IapIdle
----- FUNCTION _sys_eepromRead (END) -------


----- FUNCTION ?L?COM0011 (BEGIN) -----
0012A1 516F              ACALL    _sys_eepromRead
0012A3 900082            MOV      DPTR,#sector
0012A6         ?L?COM0012:
0012A6 E0                MOVX     A,@DPTR
0012A7 75F003            MOV      B,#03H
0012AA A4                MUL      AB
0012AB 2453              ADD      A,#LOW c_s_eepromConfig+02H
0012AD F582              MOV      DPL,A
0012AF E5F0              MOV      A,B
0012B1 3406              ADDC     A,#HIGH c_s_eepromConfig+02H
0012B3 F583              MOV      DPH,A
0012B5 E4                CLR      A
0012B6 93                MOVC     A,@A+DPTR
0012B7 22                RET      
----- FUNCTION ?L?COM0011 (END) -------


----- FUNCTION ?L?COM005E (BEGIN) -----
0012B8 AD07              MOV      R5,AR7
0012BA AC06              MOV      R4,AR6
0012BC 75C780            MOV      IAP_CONTR,#080H
0012BF 22                RET      
----- FUNCTION ?L?COM005E (END) -------


----- FUNCTION ?L?COM003F (BEGIN) -----
0012C0 900094            MOV      DPTR,#num
0012C3 74FF              MOV      A,#0FFH
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 51


0012C5 F5F0              MOV      B,A
0012C7 1201FD            LCALL    ?C?ILDIX
0012CA 45F0              ORL      A,B
0012CC 22                RET      
----- FUNCTION ?L?COM003F (END) -------


----- FUNCTION _hwa_eepromEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   37: void hwa_eepromEncrypt(UINT8 *dat, UINT16 size)        //加密
   38: {
0012CD 120DC9            LCALL    ?L?COM0007
;---- Variable 'i' assigned to Register 'R6/R7' ----
0012D0 12183C            LCALL    ?L?COM004B
0012D3         ?C0001?HWA_EEPROM_CFG:
0012D3 D3                SETB     C
0012D4 900083            MOV      DPTR,#size+01H
0012D7 E0                MOVX     A,@DPTR
0012D8 9F                SUBB     A,R7
0012D9 900082            MOV      DPTR,#size
0012DC E0                MOVX     A,@DPTR
0012DD 9E                SUBB     A,R6
0012DE 4019              JC       ?C0004?HWA_EEPROM_CFG
   39: 	UINT16 i;
   40: 	UINT8 tmp;
   41: 	for (i = 0; i<size; i++)
   42: 	{
   43: 		tmp = dat[i];
0012E0 120C7B            LCALL    ?L?COM0001
;---- Variable 'tmp' assigned to Register 'R5' ----
0012E3 121846            LCALL    ?L?COM0040
   44: 		tmp ^= SecretKey;
   45: 		tmp = (tmp >> 1) | (tmp << 7);
0012E6 C4                SWAP     A
0012E7 33                RLC      A
0012E8 33                RLC      A
0012E9 33                RLC      A
0012EA 5480              ANL      A,#080H
0012EC FC                MOV      R4,A
0012ED ED                MOV      A,R5
0012EE C3                CLR      C
0012EF 13                RRC      A
0012F0 121852            LCALL    ?L?COM003E
0012F3 BF0001            CJNE     R7,#00H,?C0009?HWA_EEPROM_CFG
0012F6 0E                INC      R6
0012F7         ?C0009?HWA_EEPROM_CFG:
0012F7 80DA              SJMP     ?C0001?HWA_EEPROM_CFG
   46: 		tmp ^= SecretKey;
   47: 		dat[i] = tmp;
   48: 	}
   49: }
0012F9         ?C0004?HWA_EEPROM_CFG:
0012F9 22                RET      
----- FUNCTION _hwa_eepromEncrypt (END) -------


----- FUNCTION _hwa_mifareCheckOut (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   95: UINT16 hwa_mifareCheckOut(UINT8 *dat, UINT16 len)
   96: {
0012FA 90008F            MOV      DPTR,#dat
0012FD 120DCC            LCALL    ?L?COM0008
;---- Variable 'len' assigned to Register 'R4/R5' ----
   97: 	UINT16 Sum = 0;
   98: 	UINT8 i;
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 52


001300 E4                CLR      A
001301 121A63            LCALL    ?L?COM004A
001304         ?C0032?HWA_MIFARE:
001304 900094            MOV      DPTR,#i
001307 E0                MOVX     A,@DPTR
001308 C3                CLR      C
001309 9D                SUBB     A,R5
00130A E4                CLR      A
00130B 9C                SUBB     A,R4
00130C 5025              JNC      ?C0033?HWA_MIFARE
   99: 	for (i = 0; i < len; i++)
  100: 	{
  101: 		Sum += dat[i];
00130E 90008F            MOV      DPTR,#dat
001311 120C7E            LCALL    ?L?COM0002
001314 F9                MOV      R1,A
001315 900094            MOV      DPTR,#i
001318 E0                MOVX     A,@DPTR
001319 F582              MOV      DPL,A
00131B 71C9              ACALL    ?L?COM001E
00131D FF                MOV      R7,A
00131E 900093            MOV      DPTR,#Sum+01H
001321 E0                MOVX     A,@DPTR
001322 2F                ADD      A,R7
001323 F0                MOVX     @DPTR,A
001324 900092            MOV      DPTR,#Sum
001327 E0                MOVX     A,@DPTR
001328 3400              ADDC     A,#00H
00132A F0                MOVX     @DPTR,A
  102: 	}
00132B 900094            MOV      DPTR,#i
00132E E0                MOVX     A,@DPTR
00132F 04                INC      A
001330 F0                MOVX     @DPTR,A
001331 80D1              SJMP     ?C0032?HWA_MIFARE
001333         ?C0033?HWA_MIFARE:
  103: 	Sum ^= 0xABCD;
001333 900092            MOV      DPTR,#Sum
001336 E0                MOVX     A,@DPTR
001337 64AB              XRL      A,#0ABH
001339 FE                MOV      R6,A
00133A A3                INC      DPTR
00133B E0                MOVX     A,@DPTR
00133C 64CD              XRL      A,#0CDH
00133E FF                MOV      R7,A
00133F 900092            MOV      DPTR,#Sum
001342 EE                MOV      A,R6
001343 F0                MOVX     @DPTR,A
001344 A3                INC      DPTR
001345 EF                MOV      A,R7
001346 F0                MOVX     @DPTR,A
  104: 	return Sum;
  105: }
001347 22                RET      
----- FUNCTION _hwa_mifareCheckOut (END) -------


----- FUNCTION hwa_mifareCheckBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  107: void hwa_mifareCheckBlock(void)
  108: {
  109: 	UINT16 crc, crcBak;
  110: 	hwa_mifareDecrypt((UINT8*)&s_NormalBuff);
001348 120DB9            LCALL    ?L?COM0026
00134B 7199              ACALL    _hwa_mifareDecrypt
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 53


  111: 	crc = hwa_mifareCheckOut((UINT8*)&s_NormalBuff, USE_DATA_BLOCK_LEN);
00134D 120DB9            LCALL    ?L?COM0026
;---- Variable 'crc' assigned to Register 'R4/R5' ----
001350 718E              ACALL    ?L?COM0028
  112: 	if (crc == (s_NormalBuff.crc[0] << 8 | s_NormalBuff.crc[1]))
001352 900052            MOV      DPTR,#s_NormalBuff+02H
001355 E0                MOVX     A,@DPTR
001356 FE                MOV      R6,A
001357 A3                INC      DPTR
001358 E0                MOVX     A,@DPTR
001359 FB                MOV      R3,A
00135A EB                MOV      A,R3
00135B B50508            CJNE     A,AR5,?C0036?HWA_MIFARE
00135E EE                MOV      A,R6
00135F B50404            CJNE     A,AR4,?C0036?HWA_MIFARE
  113: 	{
  114: 		NormalErrorFlag = FALSE;
001362 C205              CLR      NormalErrorFlag
  115: 	}
001364 8002              SJMP     ?C0037?HWA_MIFARE
001366         ?C0036?HWA_MIFARE:
  116: 	else
  117: 	{
  118: 		NormalErrorFlag = TRUE;
001366 D205              SETB     NormalErrorFlag
  119: 	}
001368         ?C0037?HWA_MIFARE:
  120: 	hwa_mifareDecrypt((UINT8*)&s_BackupBuff);
001368 7B01              MOV      R3,#01H
00136A 7A00              MOV      R2,#HIGH s_BackupBuff
00136C 7940              MOV      R1,#LOW s_BackupBuff
00136E 7199              ACALL    _hwa_mifareDecrypt
  121: 	crcBak = hwa_mifareCheckOut((UINT8*)&s_BackupBuff, USE_DATA_BLOCK_LEN);
001370 7B01              MOV      R3,#01H
001372 7A00              MOV      R2,#HIGH s_BackupBuff
001374 7940              MOV      R1,#LOW s_BackupBuff
;---- Variable 'crcBak' assigned to Register 'R4/R5' ----
001376 718E              ACALL    ?L?COM0028
  122: 	if (crcBak == (s_BackupBuff.crc[0] << 8 | s_BackupBuff.crc[1]))
001378 900042            MOV      DPTR,#s_BackupBuff+02H
00137B E0                MOVX     A,@DPTR
00137C FE                MOV      R6,A
00137D A3                INC      DPTR
00137E E0                MOVX     A,@DPTR
00137F FB                MOV      R3,A
001380 EB                MOV      A,R3
001381 B50507            CJNE     A,AR5,?C0038?HWA_MIFARE
001384 EE                MOV      A,R6
001385 B50403            CJNE     A,AR4,?C0038?HWA_MIFARE
  123: 	{
  124: 		BackupErrorFlag = FALSE;
001388 C204              CLR      BackupErrorFlag
  125: 	}
00138A 22                RET      
00138B         ?C0038?HWA_MIFARE:
  126: 	else
  127: 	{
  128: 		BackupErrorFlag = TRUE;
00138B D204              SETB     BackupErrorFlag
  129: 	}
  130: }
00138D 22                RET      
----- FUNCTION hwa_mifareCheckBlock (END) -------


LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 54


----- FUNCTION ?L?COM0028 (BEGIN) -----
00138E 7D02              MOV      R5,#02H
001390 7C00              MOV      R4,#00H
001392 51FA              ACALL    _hwa_mifareCheckOut
001394 AD07              MOV      R5,AR7
001396 AC06              MOV      R4,AR6
001398 22                RET      
----- FUNCTION ?L?COM0028 (END) -------


----- FUNCTION _hwa_mifareDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   42: void hwa_mifareDecrypt(UINT8 *pData)        //利用卡ID解密
   43: {
001399 900076            MOV      DPTR,#pData
00139C 120DCC            LCALL    ?L?COM0008
   44: 	UINT8 i, j;
   45: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
00139F E4                CLR      A
0013A0 FE                MOV      R6,A
0013A1         ?C0011?HWA_MIFARE:
   46: 	{
   47: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
0013A1 7D04              MOV      R5,#04H
0013A3         ?C0014?HWA_MIFARE:
   48: 		{
   49: 			pData[i] = _crol_(pData[i], 1);
0013A3 900076            MOV      DPTR,#pData
0013A6 120C7E            LCALL    ?L?COM0002
0013A9 F9                MOV      R1,A
0013AA 8E82              MOV      DPL,R6
0013AC 71C9              ACALL    ?L?COM001E
0013AE FF                MOV      R7,A
0013AF 7801              MOV      R0,#01H
0013B1 08                INC      R0
0013B2 8001              SJMP     ?C0067?HWA_MIFARE
0013B4         ?C0066?HWA_MIFARE:
0013B4 23                RL       A
0013B5         ?C0067?HWA_MIFARE:
0013B5 D8FD              DJNZ     R0,?C0066?HWA_MIFARE
0013B7 121A86            LCALL    ?L?COM0052
   50: 			pData[i] ^= gCard_UID[i % 5];
0013BA E9                MOV      A,R1
0013BB 1219C1            LCALL    ?L?COM0013
   51: 		}
0013BE DDE3              DJNZ     R5,?C0014?HWA_MIFARE
   52: 	}
0013C0         ?C0013?HWA_MIFARE:
0013C0 0E                INC      R6
0013C1 EE                MOV      A,R6
0013C2 B404DC            CJNE     A,#04H,?C0011?HWA_MIFARE
   53: }
0013C5 22                RET      
----- FUNCTION _hwa_mifareDecrypt (END) -------


----- FUNCTION ?L?COM001C (BEGIN) -----
0013C6 F9                MOV      R1,A
0013C7         ?L?COM001D:
0013C7 8F82              MOV      DPL,R7
0013C9         ?L?COM001E:
0013C9 758300            MOV      DPH,#00H
0013CC 020135            LJMP     ?C?CLDOPTR
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 55


----- FUNCTION ?L?COM001C (END) -------


----- FUNCTION _Load_Key (BEGIN) -----
 FILE: 'Driver\mifare.c'
  406: uchar Load_Key(uchar *ramadr)
  407: {
0013CF 900073            MOV      DPTR,#ramadr
0013D2 120DCC            LCALL    ?L?COM0008
  408: 	uchar acktemp,temp[1],i;
  409: 	uchar ucBuff[12];
  410: 	for (i=0;i<6;i++)
;---- Variable 'i' assigned to Register 'R7' ----
0013D5 E4                CLR      A
0013D6 FF                MOV      R7,A
0013D7         ?C0089?MIFARE:
  411: 	{
  412: 		temp[0]=ramadr[i];
0013D7 900073            MOV      DPTR,#ramadr
0013DA 120C7E            LCALL    ?L?COM0002
0013DD 71C6              ACALL    ?L?COM001C
0013DF 900077            MOV      DPTR,#temp
0013E2 F0                MOVX     @DPTR,A
0013E3 FD                MOV      R5,A
  413: 		ucBuff[2*i]=(((ramadr[i]&0xf0)>>4)|((~ramadr[i])&0xf0));
0013E4 54F0              ANL      A,#0F0H
0013E6 C4                SWAP     A
0013E7 540F              ANL      A,#0FH
0013E9 FE                MOV      R6,A
0013EA 71C7              ACALL    ?L?COM001D
0013EC F4                CPL      A
0013ED 9141              ACALL    ?L?COM0057
0013EF 2478              ADD      A,#LOW ucBuff
0013F1 F582              MOV      DPL,A
0013F3 E4                CLR      A
0013F4 3400              ADDC     A,#HIGH ucBuff
0013F6 F583              MOV      DPH,A
0013F8 EE                MOV      A,R6
0013F9 F0                MOVX     @DPTR,A
  414: 		ucBuff[2*i+1]=((temp[0]&0xf)|(~(temp[0]&0xf)<<4));
0013FA ED                MOV      A,R5
0013FB 540F              ANL      A,#0FH
0013FD FE                MOV      R6,A
0013FE F4                CPL      A
0013FF FD                MOV      R5,A
001400 C4                SWAP     A
001401 9141              ACALL    ?L?COM0057
001403 2479              ADD      A,#LOW ucBuff+01H
001405 F582              MOV      DPL,A
001407 E4                CLR      A
001408 3400              ADDC     A,#HIGH ucBuff+01H
00140A D188              ACALL    ?L?COM002C
00140C B406C8            CJNE     A,#06H,?C0089?MIFARE
00140F         ?C0090?MIFARE:
  415: 	}
  416: 	acktemp=Command_Send(LOAD_KEY, ucBuff, 12);
00140F 7B01              MOV      R3,#01H
001411 7A00              MOV      R2,#HIGH ucBuff
001413 7978              MOV      R1,#LOW ucBuff
001415 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
001418 740C              MOV      A,#0CH
00141A F0                MOVX     @DPTR,A
00141B 7F19              MOV      R7,#019H
00141D 120791            LCALL    _Command_Send
001420 900076            MOV      DPTR,#acktemp
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 56


001423 EF                MOV      A,R7
001424 F0                MOVX     @DPTR,A
  417: 	temp[0] = SPIReadOne(SecondaryStatus_Reg);
001425 7F05              MOV      R7,#05H
001427 1206F7            LCALL    _SPIReadOne
00142A A3                INC      DPTR
00142B EF                MOV      A,R7
00142C F0                MOVX     @DPTR,A
  418: 	if (temp[0]&0x40)
00142D 30E607            JNB      ACC.6,?C0092?MIFARE
  419: 	{
  420: 		temp[0]=0x0;
001430 E4                CLR      A
001431 1206BE            LCALL    ?L?COM0039
  421: 		SPIWriteOne(Command_Reg,temp[0]);
  422: 		return(0);
001434 7F00              MOV      R7,#00H
001436 22                RET      
  423: 	}
001437         ?C0092?MIFARE:
  424: 	temp[0]=0x0;
001437 E4                CLR      A
001438 900077            MOV      DPTR,#temp
00143B 1206BE            LCALL    ?L?COM0039
  425: 	SPIWriteOne(Command_Reg,temp[0]);
  426: 	return(1);
00143E 7F01              MOV      R7,#01H
  427: }
001440 22                RET      
----- FUNCTION _Load_Key (END) -------


----- FUNCTION ?L?COM0057 (BEGIN) -----
001441 54F0              ANL      A,#0F0H
001443 4E                ORL      A,R6
001444 FE                MOV      R6,A
001445 EF                MOV      A,R7
001446 25E0              ADD      A,ACC
001448 22                RET      
----- FUNCTION ?L?COM0057 (END) -------


----- FUNCTION app_brushCard (BEGIN) -----
 FILE: 'App\app_brush.c'
   58: UINT8 app_brushCard(void)
   59: {
   60: 	UINT8 Sector;
   61: 	UINT8 CardIndex;
   62:     UINT8 i;
   63: 	for (CardIndex = MEM_CARD; CardIndex <= PWD_CARD; CardIndex++)
001449 900071            MOV      DPTR,#CardIndex
00144C 7401              MOV      A,#01H
00144E F0                MOVX     @DPTR,A
00144F         ?C0005?APP_BRUSH:
   64: 	{
   65: 		if (b_FactorySystem)
00144F 300806            JNB      b_FactorySystem,?C0008?APP_BRUSH
   66: 		{
   67: 			CardIndex = PWD_CARD;
001452 900071            MOV      DPTR,#CardIndex
001455 7403              MOV      A,#03H
001457 F0                MOVX     @DPTR,A
   68: 		}
001458         ?C0008?APP_BRUSH:
   69: 		if (CardIndex == MEM_CARD)
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 57


001458 900071            MOV      DPTR,#CardIndex
00145B E0                MOVX     A,@DPTR
00145C B40108            CJNE     A,#01H,?C0009?APP_BRUSH
   70: 		{
   71: 			Load_Key(&s_System.MGM_Card);
00145F 7B01              MOV      R3,#01H
001461 7A00              MOV      R2,#HIGH s_System
001463 79A1              MOV      R1,#LOW s_System
   72: 		}
001465 801C              SJMP     ?C0064?APP_BRUSH
001467         ?C0009?APP_BRUSH:
   73: 		else if (CardIndex == USER_CARD)
001467 900071            MOV      DPTR,#CardIndex
00146A E0                MOVX     A,@DPTR
00146B B40208            CJNE     A,#02H,?C0011?APP_BRUSH
   74: 		{
   75: 			Load_Key(&s_System.USER_Card);
00146E 7B01              MOV      R3,#01H
001470 7A00              MOV      R2,#HIGH s_System+0AH
001472 79AB              MOV      R1,#LOW s_System+0AH
001474         
   76: 		}
001474 800D              SJMP     ?C0064?APP_BRUSH
001476         ?C0011?APP_BRUSH:
   77: 		else if (CardIndex == PWD_CARD)
001476 900071            MOV      DPTR,#CardIndex
001479 E0                MOVX     A,@DPTR
00147A B40308            CJNE     A,#03H,?C0010?APP_BRUSH
   78: 		{
   79: 			Load_Key(PWD_Card);
00147D 7BFF              MOV      R3,#0FFH
00147F 7A00              MOV      R2,#HIGH PWD_Card
001481 7903              MOV      R1,#LOW PWD_Card
001483         
001483 71CF              ACALL    _Load_Key
   80: 		}
001485         ?C0010?APP_BRUSH:
   81: 		MIF_Halt();
001485 91EF              ACALL    MIF_Halt
   82: 		if (Request(RF_CMD_REQUEST_STD) != FM1702_OK)
001487 7F26              MOV      R7,#026H
001489 B11D              ACALL    _Request
00148B EF                MOV      A,R7
00148C 7050              JNZ      ?C0007?APP_BRUSH
   83: 		{
   84: 			continue;
   85: 		}
00148E         ?C0014?APP_BRUSH:
   86:         for(i=0; i<2; i++)
00148E E4                CLR      A
00148F 900072            MOV      DPTR,#i
001492 F0                MOVX     @DPTR,A
001493         ?C0015?APP_BRUSH:
   87:         {
   88:             if (AntiColl() == FM1702_OK && SelectCard() == FM1702_OK)
001493 120727            LCALL    AntiColl
001496 EF                MOV      A,R7
001497 7039              JNZ      ?C0017?APP_BRUSH
001499 B188              ACALL    SelectCard
00149B EF                MOV      A,R7
00149C 7034              JNZ      ?C0017?APP_BRUSH
   89:             {
   90:                 if (CardIndex == USER_CARD)     //用户卡验证钱所在扇区
00149E 900071            MOV      DPTR,#CardIndex
0014A1 E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 58


0014A2 B4020A            CJNE     A,#02H,?C0019?APP_BRUSH
   91:                 {
   92:                     Sector = s_System.Sector;
0014A5 9000A7            MOV      DPTR,#s_System+06H
0014A8 E0                MOVX     A,@DPTR
0014A9 900070            MOV      DPTR,#Sector
0014AC F0                MOVX     @DPTR,A
   93:                 }
0014AD 8006              SJMP     ?C0020?APP_BRUSH
0014AF         ?C0019?APP_BRUSH:
   94:                 else                            //管理和密码卡验证1扇区
   95:                 {
   96:                     Sector = 1;
0014AF 900070            MOV      DPTR,#Sector
0014B2 7401              MOV      A,#01H
0014B4 F0                MOVX     @DPTR,A
   97:                 }
0014B5         ?C0020?APP_BRUSH:
   98:                 if (Authentication(gCard_UID, Sector, 0x60) == FM1702_OK)
0014B5 7B01              MOV      R3,#01H
0014B7 7A00              MOV      R2,#HIGH gCard_UID
0014B9 79B4              MOV      R1,#LOW gCard_UID
0014BB 900070            MOV      DPTR,#Sector
0014BE E0                MOVX     A,@DPTR
0014BF FD                MOV      R5,A
0014C0 900077            MOV      DPTR,#?_Authentication?BYTE+04H
0014C3 7460              MOV      A,#060H
0014C5 F0                MOVX     @DPTR,A
0014C6 120DD5            LCALL    _Authentication
0014C9 EF                MOV      A,R7
0014CA 7006              JNZ      ?C0017?APP_BRUSH
   99:                 {
  100:                     return CardIndex;
0014CC 900071            MOV      DPTR,#CardIndex
0014CF E0                MOVX     A,@DPTR
0014D0 FF                MOV      R7,A
0014D1 22                RET      
  101:                 }
  102:             }
  103:         }
0014D2         ?C0017?APP_BRUSH:
0014D2 900072            MOV      DPTR,#i
0014D5 E0                MOVX     A,@DPTR
0014D6 04                INC      A
0014D7 F0                MOVX     @DPTR,A
0014D8 E0                MOVX     A,@DPTR
0014D9 C3                CLR      C
0014DA 9402              SUBB     A,#02H
0014DC 40B5              JC       ?C0015?APP_BRUSH
  104: 	}
0014DE         ?C0007?APP_BRUSH:
0014DE 900071            MOV      DPTR,#CardIndex
0014E1 E0                MOVX     A,@DPTR
0014E2 04                INC      A
0014E3 F0                MOVX     @DPTR,A
0014E4 E0                MOVX     A,@DPTR
0014E5 D3                SETB     C
0014E6 9403              SUBB     A,#03H
0014E8 5002              JNC      $ + 4H
0014EA 814F              AJMP     ?C0005?APP_BRUSH
0014EC         ?C0006?APP_BRUSH:
  105: 	return NONE_CARD;
0014EC 7F00              MOV      R7,#00H
  106: }
0014EE 22                RET      
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 59


----- FUNCTION app_brushCard (END) -------


----- FUNCTION MIF_Halt (BEGIN) -----
 FILE: 'Driver\mifare.c'
  610: uchar MIF_Halt(void)
  611: {
  612: 	uchar	temp;
  613: 	//选择TX1、TX2的发射天线阻抗
  614: 	SPIWriteOne(CwConductance_Reg,0x3f);
0014EF B1E9              ACALL    ?L?COM001F
0014F1 7450              MOV      A,#050H
0014F3 F0                MOVX     @DPTR,A
  615: 	//选择数据校验种类和模式
  616: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  617: 	*gBuff = RF_CMD_HALT;
  618: 	*(gBuff + 1) = 0x00;
0014F4 E4                CLR      A
0014F5 A3                INC      DPTR
0014F6 120B4A            LCALL    ?L?COM000F
0014F9 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
0014FC 7402              MOV      A,#02H
0014FE F0                MOVX     @DPTR,A
0014FF 7F1A              MOV      R7,#01AH
001501 120791            LCALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  619: 	temp = Command_Send(Transmit, gBuff, 2);//发送FIFO缓存地址
  620: 	if(temp == TRUE)
001504 EF                MOV      A,R7
001505 B40103            CJNE     A,#01H,?C0133?MIFARE
  621: 		return FM1702_OK;
001508 7F00              MOV      R7,#00H
00150A 22                RET      
00150B         ?C0133?MIFARE:
  622: 	else
  623: 	{
  624: 		temp = SPIReadOne(ErrorFlag_Reg);
00150B 120FE0            LCALL    ?L?COM002A
00150E 30E103            JNB      ACC.1,?C0136?MIFARE
  625: 		if((temp & 0x02) == 0x02)
  626: 		{
  627: 			return(FM1702_PARITYERR);
001511 7F05              MOV      R7,#05H
001513 22                RET      
  628: 		}
001514         ?C0136?MIFARE:
  629: 
  630: 		if((temp & 0x04) == 0x04)
001514 EF                MOV      A,R7
001515 7F01              MOV      R7,#01H
001517 30E202            JNB      ACC.2,?C0137?MIFARE
  631: 		{
  632: 			return(FM1702_FRAMINGERR);
00151A 7F14              MOV      R7,#014H
  633: 		}
00151C         ?C0137?MIFARE:
  634: 		return(FM1702_NOTAGERR);
  635: 	}
  636: }
00151C 22                RET      
----- FUNCTION MIF_Halt (END) -------


----- FUNCTION _Request (BEGIN) -----
 FILE: 'Driver\mifare.c'
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 60


  152: uchar Request(uchar mode)
  153: {
;---- Variable 'mode' assigned to Register 'R4' ----
00151D AC07              MOV      R4,AR7
  154: 	
  155: 	uchar temp;
  156: 	
  157: 	//选择TX1、TX2的发射天线阻抗
  158: 	SPIWriteOne(CwConductance_Reg,0x3f);
00151F D178              ACALL    ?L?COM0055
  159: 	//选择数据校验种类和模式
  160: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
001521 7D03              MOV      R5,#03H
001523 7F22              MOV      R7,#022H
001525 1206C2            LCALL    _SPIWriteOne
  161: 	//调整面向bit的格式
  162: 	SPIWriteOne(BitFraming_Reg,0x07);
001528 7D07              MOV      R5,#07H
00152A 7F0F              MOV      R7,#0FH
00152C B1F4              ACALL    ?L?COM0021
00152E EC                MOV      A,R4
00152F F0                MOVX     @DPTR,A
  163: 	gBuff[0] = mode;		//Request模式选择 
  164: 	temp = SPIReadOne(Control_Reg);
001530 7F09              MOV      R7,#09H
001532 1206F7            LCALL    _SPIReadOne
;---- Variable 'temp' assigned to Register 'R7' ----
  165: 	temp = temp & (0xf7);	
001535 EF                MOV      A,R7
001536 54F7              ANL      A,#0F7H
  166: 	SPIWriteOne(Control_Reg,temp);			//Control reset value is 00
001538 FD                MOV      R5,A
001539 7F09              MOV      R7,#09H
00153B 1206C2            LCALL    _SPIWriteOne
  167: 	temp = Command_Send(Transceive, gBuff,1 );   //发送接收命令 
00153E 120B4B            LCALL    ?L?COM0010
001541 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
001544 7401              MOV      A,#01H
001546 B180              ACALL    ?L?COM0024
001548 7003              JNZ      ?C0030?MIFARE
  168: 	if(temp==0 )
  169: 	{
  170: 		return FM1702_NOTAGERR;
00154A 7F01              MOV      R7,#01H
00154C 22                RET      
  171: 	}
00154D         ?C0030?MIFARE:
  172: 
  173: 	temp=Read_FIFO(gBuff);		//从FIFO中读取应答信息到gBuff中 
00154D 120B4B            LCALL    ?L?COM0010
001550 D18F              ACALL    _Read_FIFO
  174: 	// 判断应答信号是否正确 
  175: 	// 2  	Mifare Pro 卡
  176: 	//4 		Mifare One 卡
  177: 	if((gBuff[0] == 0x04) & (gBuff[1] == 0x0) &(temp == 2))
001552 9000BA            MOV      DPTR,#gBuff+01H
001555 E0                MOVX     A,@DPTR
001556 7E00              MOV      R6,#00H
001558 7002              JNZ      ?C0033?MIFARE
00155A 7E01              MOV      R6,#01H
00155C         ?C0033?MIFARE:
00155C         ?C0034?MIFARE:
00155C 9000B9            MOV      DPTR,#gBuff
00155F E0                MOVX     A,@DPTR
001560 7D00              MOV      R5,#00H
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 61


001562 B40402            CJNE     A,#04H,?C0035?MIFARE
001565 7D01              MOV      R5,#01H
001567         ?C0035?MIFARE:
001567         ?C0036?MIFARE:
001567 ED                MOV      A,R5
001568 5E                ANL      A,R6
001569 FE                MOV      R6,A
00156A EF                MOV      A,R7
00156B 7F00              MOV      R7,#00H
00156D B40202            CJNE     A,#02H,?C0037?MIFARE
001570 7F01              MOV      R7,#01H
001572         ?C0037?MIFARE:
001572         ?C0038?MIFARE:
001572 EF                MOV      A,R7
001573 5E                ANL      A,R6
001574 7F15              MOV      R7,#015H
001576 6002              JZ       ?C0032?MIFARE
  178: 	{
  179: 			return FM1702_OK;
001578 7F00              MOV      R7,#00H
  180: 	}
00157A         ?C0032?MIFARE:
  181: 	return FM1702_REQERR;
  182: }
00157A 22                RET      
----- FUNCTION _Request (END) -------


----- FUNCTION ?L?COM0023 (BEGIN) -----
00157B 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
00157E 7402              MOV      A,#02H
001580         ?L?COM0024:
001580 F0                MOVX     @DPTR,A
001581 7F1E              MOV      R7,#01EH
001583 120791            LCALL    _Command_Send
001586 EF                MOV      A,R7
001587 22                RET      
----- FUNCTION ?L?COM0023 (END) -------


----- FUNCTION SelectCard (BEGIN) -----
 FILE: 'Driver\mifare.c'
  335: uchar SelectCard(void)
  336: {
  337: 	
  338: 	uchar	temp, i;
  339: 	
  340: 	//选择TX1、TX2的发射天线阻抗
  341: 	SPIWriteOne(CwConductance_Reg,0x3f);
001588 D178              ACALL    ?L?COM0055
  342: 	//选择数据校验种类和模式
  343: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
00158A 7D0F              MOV      R5,#0FH
00158C B1F2              ACALL    ?L?COM0020
00158E 7493              MOV      A,#093H
001590 F0                MOVX     @DPTR,A
  344: 
  345: 	gBuff[0] = RF_CMD_SELECT;
  346: 	gBuff[1] = 0x70;
001591 A3                INC      DPTR
001592 7470              MOV      A,#070H
001594 F0                MOVX     @DPTR,A
  347: 	for(i = 0; i < 5; i++)
;---- Variable 'i' assigned to Register 'R7' ----
001595 E4                CLR      A
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 62


001596 FF                MOV      R7,A
001597         ?C0077?MIFARE:
  348: 	{
  349: 		gBuff[i + 2] = gCard_UID[i];
001597 74B4              MOV      A,#LOW gCard_UID
001599 2F                ADD      A,R7
00159A 121A95            LCALL    ?L?COM0056
00159D E0                MOVX     A,@DPTR
00159E D17F              ACALL    ?L?COM002B
0015A0 B405F4            CJNE     A,#05H,?C0077?MIFARE
0015A3         ?C0078?MIFARE:
  350: 	}
  351: 	temp = Command_Send(Transceive, gBuff,7 );
0015A3 120B4B            LCALL    ?L?COM0010
0015A6 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
0015A9 7407              MOV      A,#07H
;---- Variable 'temp' assigned to Register 'R7' ----
0015AB B180              ACALL    ?L?COM0024
0015AD 7003              JNZ      ?C0080?MIFARE
  352: 	if(temp==0 )
  353: 	{
  354: 		return(FM1702_NOTAGERR);
0015AF 7F01              MOV      R7,#01H
0015B1 22                RET      
  355: 	}
0015B2         ?C0080?MIFARE:
  356: 	else
  357: 	{
  358: 		temp = SPIReadOne(ErrorFlag_Reg);
0015B2 120FE0            LCALL    ?L?COM002A
0015B5 30E103            JNB      ACC.1,?C0083?MIFARE
0015B8 7F05              MOV      R7,#05H
0015BA 22                RET      
0015BB         ?C0083?MIFARE:
  359: 		if((temp & 0x02) == 0x02) return(FM1702_PARITYERR);
  360: 		if((temp & 0x04) == 0x04) return(FM1702_FRAMINGERR);
0015BB EF                MOV      A,R7
0015BC 30E203            JNB      ACC.2,?C0084?MIFARE
0015BF 7F14              MOV      R7,#014H
0015C1 22                RET      
0015C2         ?C0084?MIFARE:
  361: 		if((temp & 0x08) == 0x08) return(FM1702_CRCERR);
0015C2 EF                MOV      A,R7
0015C3 30E303            JNB      ACC.3,?C0085?MIFARE
0015C6 7F02              MOV      R7,#02H
0015C8 22                RET      
0015C9         ?C0085?MIFARE:
  362: 		temp = SPIReadOne(FIFOLength_Reg);
0015C9 7F04              MOV      R7,#04H
0015CB 1206F7            LCALL    _SPIReadOne
  363: 		if(temp != 1) return(FM1702_BYTECOUNTERR);
0015CE EF                MOV      A,R7
0015CF 6401              XRL      A,#01H
0015D1 6003              JZ       ?C0086?MIFARE
0015D3 7F0C              MOV      R7,#0CH
0015D5 22                RET      
0015D6         ?C0086?MIFARE:
  364: //		SPIRead(FIFO_Reg,gBuff,temp);	//从FIFO中读取应答信息
  365: 		gBuff[0] = SPIReadOne(FIFO_Reg);
0015D6 7F02              MOV      R7,#02H
0015D8 1206F7            LCALL    _SPIReadOne
0015DB 9000B9            MOV      DPTR,#gBuff
0015DE EF                MOV      A,R7
0015DF F0                MOVX     @DPTR,A
  366: 		if(gBuff[0]==0x08) 	  	// 判断应答信号是否正确 
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 63


0015E0 BF0803            CJNE     R7,#08H,?C0087?MIFARE
  367: 			return(FM1702_OK);
0015E3 7F00              MOV      R7,#00H
0015E5 22                RET      
0015E6         ?C0087?MIFARE:
  368: 		else
  369: 			return(FM1702_SELERR);
0015E6 7F16              MOV      R7,#016H
  370: 	}
  371: }
0015E8 22                RET      
----- FUNCTION SelectCard (END) -------


----- FUNCTION ?L?COM001F (BEGIN) -----
0015E9 7D3F              MOV      R5,#03FH
0015EB 7F12              MOV      R7,#012H
0015ED 1206C2            LCALL    _SPIWriteOne
0015F0 7D03              MOV      R5,#03H
0015F2         ?L?COM0020:
0015F2 7F22              MOV      R7,#022H
0015F4         ?L?COM0021:
0015F4 1206C2            LCALL    _SPIWriteOne
0015F7 9000B9            MOV      DPTR,#gBuff
0015FA 22                RET      
----- FUNCTION ?L?COM001F (END) -------


----- FUNCTION _Write_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  566: uchar Write_Block(uchar *buff,uchar index)
  567: {
0015FB 120DC9            LCALL    ?L?COM0007
;---- Variable 'index' assigned to Register 'R4' ----
0015FE AC05              MOV      R4,AR5
  568:     uchar ucCmdLine[2],ucResult,ucData[16];
  569:     SPIWriteOne(ChannelRedundancy_Reg,0x07);   /* Note: this line is for 1702, different from RC500*/
001600 7D07              MOV      R5,#07H
001602 7F22              MOV      R7,#022H
001604 1206C2            LCALL    _SPIWriteOne
  570:     ucCmdLine[0] = RF_CMD_WRITE;
001607 A3                INC      DPTR
001608 74A0              MOV      A,#0A0H
00160A F0                MOVX     @DPTR,A
  571:     ucCmdLine[1] = index;
00160B A3                INC      DPTR
00160C EC                MOV      A,R4
00160D F0                MOVX     @DPTR,A
  572:     ucResult = Command_Send(Transceive,ucCmdLine,2);
00160E 7B01              MOV      R3,#01H
001610 7A00              MOV      R2,#HIGH ucCmdLine
001612 7982              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
001614 B17B              ACALL    ?L?COM0023
001616 7003              JNZ      ?C0115?MIFARE
  573:     if(ucResult == FALSE)
  574:         return FM1702_NOTAGERR;
001618 7F01              MOV      R7,#01H
00161A 22                RET      
00161B         ?C0115?MIFARE:
  575:     ucResult = Read_FIFO(ucData);
00161B 7B01              MOV      R3,#01H
00161D 7A00              MOV      R2,#HIGH ucData
00161F 7984              MOV      R1,#LOW ucData
001621 D18F              ACALL    _Read_FIFO
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 64


  576:     if(ucResult == 0)
001623 EF                MOV      A,R7
001624 7003              JNZ      ?C0117?MIFARE
  577:         return FM1702_BYTECOUNTERR;
001626 7F0C              MOV      R7,#0CH
001628 22                RET      
001629         ?C0117?MIFARE:
  578:     switch(ucData[0])
001629 900084            MOV      DPTR,#ucData
00162C E0                MOVX     A,@DPTR
00162D 14                DEC      A
00162E 6015              JZ       ?C0122?MIFARE
001630 24FD              ADD      A,#0FDH
001632 600E              JZ       ?C0120?MIFARE
001634 14                DEC      A
001635 6011              JZ       ?C0123?MIFARE
001637 24FB              ADD      A,#0FBH
001639 6013              JZ       ?C0118?MIFARE
00163B 240A              ADD      A,#0AH
00163D 700C              JNZ      ?C0124?MIFARE
  579:     {
  580: 	    case 0x00:	return(FM1702_NOTAUTHERR);	
00163F         ?C0119?MIFARE:
00163F 7F0A              MOV      R7,#0AH
001641 22                RET      
  581: 	    case 0x04:	return(FM1702_EMPTY);
001642         ?C0120?MIFARE:
001642 7F03              MOV      R7,#03H
001644 22                RET      
  582: 	    case 0x0a:	break;                   //正常
  583: 	    case 0x01:	return(FM1702_CRCERR);
001645         ?C0122?MIFARE:
001645 7F02              MOV      R7,#02H
001647 22                RET      
  584: 	    case 0x05:	return(FM1702_PARITYERR); 
001648         ?C0123?MIFARE:
001648 7F05              MOV      R7,#05H
00164A 22                RET      
  585: 	    default:	return(FM1702_WRITEERR);
00164B         ?C0124?MIFARE:
00164B 7F0F              MOV      R7,#0FH
00164D 22                RET      
  586:     }
00164E         ?C0118?MIFARE:
  587:     ucResult = Command_Send(Transceive,buff,16);
00164E 120C7B            LCALL    ?L?COM0001
001651 F9                MOV      R1,A
001652 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
001655 7410              MOV      A,#010H
001657 B180              ACALL    ?L?COM0024
001659 B40103            CJNE     A,#01H,?C0125?MIFARE
  588:     if(ucResult == TRUE)
  589:         return FM1702_OK;
00165C 7F00              MOV      R7,#00H
00165E 22                RET      
00165F         ?C0125?MIFARE:
  590:     else
  591:     {
  592:         ucResult = SPIReadOne(ErrorFlag_Reg);
00165F 120FE0            LCALL    ?L?COM002A
001662 30E103            JNB      ACC.1,?C0127?MIFARE
001665 7F05              MOV      R7,#05H
001667 22                RET      
001668         ?C0127?MIFARE:
  593: 	    if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 65


  594: 	    else if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
001668 EF                MOV      A,R7
001669 30E203            JNB      ACC.2,?C0129?MIFARE
00166C 7F14              MOV      R7,#014H
00166E 22                RET      
00166F         ?C0129?MIFARE:
  595: 	    else if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
00166F EF                MOV      A,R7
001670 7F0F              MOV      R7,#0FH
001672 30E302            JNB      ACC.3,?C0131?MIFARE
001675 7F02              MOV      R7,#02H
001677         ?C0131?MIFARE:
  596:         else return FM1702_WRITEERR;
  597:     }
  598: }
001677 22                RET      
----- FUNCTION _Write_Block (END) -------


----- FUNCTION ?L?COM0055 (BEGIN) -----
001678 7D3F              MOV      R5,#03FH
00167A 7F12              MOV      R7,#012H
00167C 0206C2            LJMP     _SPIWriteOne
----- FUNCTION ?L?COM0055 (END) -------


----- FUNCTION ?L?COM002B (BEGIN) -----
00167F FE                MOV      R6,A
001680 74BB              MOV      A,#LOW gBuff+02H
001682 2F                ADD      A,R7
001683 F582              MOV      DPL,A
001685 E4                CLR      A
001686 3400              ADDC     A,#HIGH gBuff+02H
001688         ?L?COM002C:
001688 F583              MOV      DPH,A
00168A EE                MOV      A,R6
00168B F0                MOVX     @DPTR,A
00168C 0F                INC      R7
00168D EF                MOV      A,R7
00168E 22                RET      
----- FUNCTION ?L?COM002B (END) -------


----- FUNCTION _Read_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  228: uchar Read_FIFO(uchar *buff)
  229: {
00168F 900094            MOV      DPTR,#buff
001692 120DCC            LCALL    ?L?COM0008
  230: 	uchar	ucResult,i;
  231: 	ucResult = SPIReadOne(FIFOLength_Reg);
;---- Variable 'ucResult' assigned to Register 'R5' ----
001695 1207DE            LCALL    ?L?COM0041
001698 6005              JZ       ?C0050?MIFARE
00169A D3                SETB     C
00169B 9410              SUBB     A,#010H
00169D 4003              JC       ?C0049?MIFARE
00169F         ?C0050?MIFARE:
  232: 	if(ucResult == 0 || ucResult>16)
  233: 		return 0;
00169F 7F00              MOV      R7,#00H
0016A1 22                RET      
0016A2         ?C0049?MIFARE:
  234: 	for(i=0;i<ucResult;i++)
;---- Variable 'i' assigned to Register 'R4' ----
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 66


0016A2 E4                CLR      A
0016A3 FC                MOV      R4,A
0016A4         ?C0052?MIFARE:
0016A4 EC                MOV      A,R4
0016A5 C3                CLR      C
0016A6 9D                SUBB     A,R5
0016A7 5018              JNC      ?C0053?MIFARE
  235: 	{
  236: 		buff[i] = SPIReadOne(FIFO_Reg);
0016A9 7F02              MOV      R7,#02H
0016AB 1206F7            LCALL    _SPIReadOne
0016AE 900094            MOV      DPTR,#buff
0016B1 120C7E            LCALL    ?L?COM0002
0016B4 F9                MOV      R1,A
0016B5 8C82              MOV      DPL,R4
0016B7 758300            MOV      DPH,#00H
0016BA EF                MOV      A,R7
0016BB 120174            LCALL    ?C?CSTOPTR
  237: 	}
0016BE 0C                INC      R4
0016BF 80E3              SJMP     ?C0052?MIFARE
0016C1         ?C0053?MIFARE:
  238: 
  239: 	return ucResult;
0016C1 AF05              MOV      R7,AR5
  240: }
0016C3 22                RET      
----- FUNCTION _Read_FIFO (END) -------


----- FUNCTION _Read_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  532: uchar Read_Block(uchar *buff,uchar index)
  533: {
0016C4 90007B            MOV      DPTR,#buff
0016C7 120DCC            LCALL    ?L?COM0008
;---- Variable 'index' assigned to Register 'R4' ----
0016CA AC05              MOV      R4,AR5
  534:     uchar ucCmdLine[2],ucResult;
  535:     SPIWriteOne(ChannelRedundancy_Reg,0x0F);
0016CC 121A8E            LCALL    ?L?COM0054
  536:     ucCmdLine[0] = RF_CMD_READ;
0016CF A3                INC      DPTR
0016D0 7430              MOV      A,#030H
0016D2 F0                MOVX     @DPTR,A
  537:     ucCmdLine[1] = index;
0016D3 A3                INC      DPTR
0016D4 EC                MOV      A,R4
0016D5 F0                MOVX     @DPTR,A
  538:     ucResult = Command_Send(Transceive,ucCmdLine,2);
0016D6 7B01              MOV      R3,#01H
0016D8 7A00              MOV      R2,#HIGH ucCmdLine
0016DA 797E              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
0016DC B17B              ACALL    ?L?COM0023
0016DE 7003              JNZ      ?C0108?MIFARE
  539:     if(ucResult == FALSE)
  540:         return FM1702_NOTAGERR;   //无卡
0016E0 7F01              MOV      R7,#01H
0016E2 22                RET      
0016E3         ?C0108?MIFARE:
  541:     ucResult = SPIReadOne(ErrorFlag_Reg);
0016E3 120FE0            LCALL    ?L?COM002A
0016E6 30E103            JNB      ACC.1,?C0110?MIFARE
0016E9 7F05              MOV      R7,#05H
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 67


0016EB 22                RET      
0016EC         ?C0110?MIFARE:
  542: 	if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
  543: 	if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
0016EC EF                MOV      A,R7
0016ED 30E203            JNB      ACC.2,?C0111?MIFARE
0016F0 7F14              MOV      R7,#014H
0016F2 22                RET      
0016F3         ?C0111?MIFARE:
  544: 	if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
0016F3 EF                MOV      A,R7
0016F4 30E303            JNB      ACC.3,?C0112?MIFARE
0016F7 7F02              MOV      R7,#02H
0016F9 22                RET      
0016FA         ?C0112?MIFARE:
  545:     ucResult = Read_FIFO(buff);
0016FA 90007B            MOV      DPTR,#buff
0016FD 120C7E            LCALL    ?L?COM0002
001700 F9                MOV      R1,A
001701 D18F              ACALL    _Read_FIFO
  546:     if(ucResult!=0x10)
001703 EF                MOV      A,R7
001704 6410              XRL      A,#010H
001706 7F00              MOV      R7,#00H
001708 6002              JZ       ?C0113?MIFARE
  547:         return FM1702_BYTECOUNTERR;
00170A 7F0C              MOV      R7,#0CH
00170C         ?C0113?MIFARE:
  548:     else
  549:         return FM1702_OK;
  550: }
00170C 22                RET      
----- FUNCTION _Read_Block (END) -------


----- FUNCTION sys_tim0Isr (BEGIN) -----
 FILE: 'System\sys_task.c'
   40: void sys_tim0Isr(void) interrupt 1      //1ms interrupt task
00170D C0E0              PUSH     ACC
00170F C0F0              PUSH     B
001711 C083              PUSH     DPH
001713 C082              PUSH     DPL
001715 C0D0              PUSH     PSW
001717 75D000            MOV      PSW,#00H
00171A C000              PUSH     AR0
00171C C001              PUSH     AR1
00171E C002              PUSH     AR2
001720 C003              PUSH     AR3
001722 C004              PUSH     AR4
001724 C005              PUSH     AR5
001726 C006              PUSH     AR6
001728 C007              PUSH     AR7
   41: {
   42:     led_Handler1ms();
00172A 121882            LCALL    led_Handler1ms
   43: 	taskHandlerCnt10ms++;
00172D 9000DC            MOV      DPTR,#taskHandlerCnt10ms
001730 E0                MOVX     A,@DPTR
001731 04                INC      A
001732 F0                MOVX     @DPTR,A
   44:     if(taskHandlerCnt10ms>=10)
001733 E0                MOVX     A,@DPTR
001734 C3                CLR      C
001735 940A              SUBB     A,#0AH
001737 400B              JC       ?C0003?SYS_TASK
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 68


   45:     {
   46:         taskHandlerCnt10ms = 0;
001739 E4                CLR      A
00173A F0                MOVX     @DPTR,A
   47:         sys_taskHandler10ms();
00173B 12000A            LCALL    sys_taskHandler10ms
   48:         taskHandlerCnt100ms++;
00173E 9000DA            MOV      DPTR,#taskHandlerCnt100ms
001741 E0                MOVX     A,@DPTR
001742 04                INC      A
001743 F0                MOVX     @DPTR,A
   49:     }
001744         ?C0003?SYS_TASK:
   50:     if(taskHandlerCnt100ms>=10)
001744 9000DA            MOV      DPTR,#taskHandlerCnt100ms
001747 E0                MOVX     A,@DPTR
001748 C3                CLR      C
001749 940A              SUBB     A,#0AH
00174B 400A              JC       ?C0004?SYS_TASK
   51:     {
   52:         taskHandlerCnt100ms = 0;
00174D E4                CLR      A
00174E F0                MOVX     @DPTR,A
   53:         sys_taskHandler100ms();
00174F F182              ACALL    sys_taskHandler100ms
   54:         taskHandlerCnt1s++;
001751 9000DB            MOV      DPTR,#taskHandlerCnt1s
001754 E0                MOVX     A,@DPTR
001755 04                INC      A
001756 F0                MOVX     @DPTR,A
   55:     }
001757         ?C0004?SYS_TASK:
   56:     if(taskHandlerCnt1s>=10)
001757 9000DB            MOV      DPTR,#taskHandlerCnt1s
00175A E0                MOVX     A,@DPTR
00175B C3                CLR      C
00175C 940A              SUBB     A,#0AH
00175E 4007              JC       ?C0006?SYS_TASK
   57:     {
   58:         taskHandlerCnt1s = 0;
001760 E4                CLR      A
001761 F0                MOVX     @DPTR,A
   59:         sys_taskHandler1s();
001762 120021            LCALL    sys_taskHandler1s
   60:         taskCycle1sFlag = TRUE;
001765 D206              SETB     taskCycle1sFlag
   61:     }
   62: }
001767         ?C0006?SYS_TASK:
001767 D007              POP      AR7
001769 D006              POP      AR6
00176B D005              POP      AR5
00176D D004              POP      AR4
00176F D003              POP      AR3
001771 D002              POP      AR2
001773 D001              POP      AR1
001775 D000              POP      AR0
001777 D0D0              POP      PSW
001779 D082              POP      DPL
00177B D083              POP      DPH
00177D D0F0              POP      B
00177F D0E0              POP      ACC
001781 32                RETI     
----- FUNCTION sys_tim0Isr (END) -------

LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 69



----- FUNCTION sys_taskHandler100ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   68: void sys_taskHandler100ms(void)           //100ms interrupt task
;----                  JMP      buzzer_Handler100ms
   69: {
----- FUNCTION sys_taskHandler100ms (END) -------


----- FUNCTION buzzer_Handler100ms (BEGIN) -----
 FILE: 'Driver\buzzer.c'
   15: void buzzer_Handler100ms(void)
   16: {
   17:     if(Buzzer)
   18: 	{
001782 30B503            JNB      Buzzer,?C0002?BUZZER
   19: 		Buzzer = 0;
   20: 	}
001785 C2B5              CLR      Buzzer
   21: 	else if(SoundNumberCount)
001787 22                RET      
001788         ?C0002?BUZZER:
   22: 	{
001788 9000DE            MOV      DPTR,#SoundNumberCount
00178B E0                MOVX     A,@DPTR
00178C 6004              JZ       ?C0005?BUZZER
   23: 		Buzzer = 1;
   24: 		SoundNumberCount--;
00178E D2B5              SETB     Buzzer
   25: 	}
001790 14                DEC      A
001791 F0                MOVX     @DPTR,A
   26: }
   27: 
001792         ?C0005?BUZZER:
001792 22                RET      
----- FUNCTION buzzer_Handler100ms (END) -------


----- FUNCTION sys_uartInit (BEGIN) -----
 FILE: 'System\sys_uart.c'
   13: void sys_uartInit(void)
   14: {
   15:     ACC = P_SW1;
   16:     ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
001793 E5A2              MOV      A,P_SW1
   17:     P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
001795 543F              ANL      A,#03FH
   18:     SCON = 0x50;                //8位可变波特率
001797 F5A2              MOV      P_SW1,A
   19:     T2L = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
001799 759850            MOV      SCON,#050H
   20:     T2H = (65536 - (FOSC/4/BAUD))>>8;
00179C 75D7E0            MOV      T2L,#0E0H
   21:     AUXR |= 0x14;                //T2为1T模式, 并启动定时器2
00179F 75D6FE            MOV      T2H,#0FEH
   22:     AUXR |= 0x01;               //选择定时器2为串口1的波特率发生器
0017A2 438E14            ORL      AUXR,#014H
   23:     ES = 1;                     //使能串口1中断
0017A5 438E01            ORL      AUXR,#01H
   24:     EA = 1;
0017A8 D2AC              SETB     ES
   25: }
0017AA D2AF              SETB     EA
   26: 
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 70


0017AC 22                RET      
----- FUNCTION sys_uartInit (END) -------


----- FUNCTION sys_uartInterrupt (BEGIN) -----
 FILE: 'System\sys_uart.c'
   27: void sys_uartInterrupt() interrupt 4
0017AD C0E0              PUSH     ACC
0017AF C0F0              PUSH     B
0017B1 C083              PUSH     DPH
0017B3 C082              PUSH     DPL
0017B5 C0D0              PUSH     PSW
0017B7 75D000            MOV      PSW,#00H
0017BA C000              PUSH     AR0
0017BC C001              PUSH     AR1
0017BE C002              PUSH     AR2
0017C0 C003              PUSH     AR3
0017C2 C004              PUSH     AR4
0017C4 C005              PUSH     AR5
0017C6 C006              PUSH     AR6
0017C8 C007              PUSH     AR7
   28: {
   29:     if(RI)
0017CA 309804            JNB      RI,?C0002?SYS_UART
   30:     {
   31:         RI = 0;
0017CD C298              CLR      RI
   32:         sys_uartRxHandler();
0017CF F1F1              ACALL    sys_uartRxHandler
   33:     }
0017D1         ?C0002?SYS_UART:
   34:     if(TI)
0017D1 309902            JNB      TI,?C0004?SYS_UART
   35:     {
   36:         TI = 0;
0017D4 C299              CLR      TI
   37:     }
   38: }
0017D6         ?C0004?SYS_UART:
0017D6 D007              POP      AR7
0017D8 D006              POP      AR6
0017DA D005              POP      AR5
0017DC D004              POP      AR4
0017DE D003              POP      AR3
0017E0 D002              POP      AR2
0017E2 D001              POP      AR1
0017E4 D000              POP      AR0
0017E6 D0D0              POP      PSW
0017E8 D082              POP      DPL
0017EA D083              POP      DPH
0017EC D0F0              POP      B
0017EE D0E0              POP      ACC
0017F0 32                RETI     
----- FUNCTION sys_uartInterrupt (END) -------


----- FUNCTION sys_uartRxHandler (BEGIN) -----
 FILE: 'System\sys_uart.c'
   41: void sys_uartRxHandler(void)
   42: {
   43:     if(SBUF == 0x7F)        //0x7F auto download     boud 2400 0x7F at boud 9600 is 0xF8
   44:     {
0017F1 E599              MOV      A,SBUF
0017F3 B47F10            CJNE     A,#07FH,?C0005?SYS_UART
   45:         RxNum++;
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 71


   46:         if(RxNum >= 40)
0017F6 9000DD            MOV      DPTR,#RxNum
0017F9 E0                MOVX     A,@DPTR
0017FA 04                INC      A
0017FB F0                MOVX     @DPTR,A
   47:         {
0017FC E0                MOVX     A,@DPTR
0017FD C3                CLR      C
0017FE 9428              SUBB     A,#028H
001800 4009              JC       ?C0008?SYS_UART
   48:             IAP_CONTR = 0x60;
   49:         }
001802 75C760            MOV      IAP_CONTR,#060H
   50:     }
   51:     else
001805 22                RET      
001806         ?C0005?SYS_UART:
   52:     {
   53:         RxNum = 0;
001806 E4                CLR      A
001807 9000DD            MOV      DPTR,#RxNum
00180A F0                MOVX     @DPTR,A
   54:     }
   55: }
00180B         ?C0008?SYS_UART:
00180B 22                RET      
----- FUNCTION sys_uartRxHandler (END) -------


----- FUNCTION _hwa_eepromDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   51: void hwa_eepromDecrypt(UINT8 *dat, UINT16 size)        //解密
   52: {
00180C 90008F            MOV      DPTR,#dat
00180F 120DCC            LCALL    ?L?COM0008
;---- Variable 'i' assigned to Register 'R6/R7' ----
001812 113C              ACALL    ?L?COM004B
001814         ?C0005?HWA_EEPROM_CFG:
001814 D3                SETB     C
001815 900093            MOV      DPTR,#size+01H
001818 E0                MOVX     A,@DPTR
001819 9F                SUBB     A,R7
00181A 900092            MOV      DPTR,#size
00181D E0                MOVX     A,@DPTR
00181E 9E                SUBB     A,R6
00181F 401A              JC       ?C0008?HWA_EEPROM_CFG
   53: 	UINT16 i;
   54: 	UINT8 tmp;
   55: 	for (i = 0; i<size; i++)
   56: 	{
   57: 		tmp = dat[i];
001821 90008F            MOV      DPTR,#dat
001824 120C7E            LCALL    ?L?COM0002
;---- Variable 'tmp' assigned to Register 'R5' ----
001827 1146              ACALL    ?L?COM0040
   58: 		tmp ^= SecretKey;
   59: 		tmp = (tmp << 1) | (tmp >> 7);
001829 25E0              ADD      A,ACC
00182B FC                MOV      R4,A
00182C ED                MOV      A,R5
00182D C4                SWAP     A
00182E 13                RRC      A
00182F 13                RRC      A
001830 13                RRC      A
001831 5401              ANL      A,#01H
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 72


001833 1152              ACALL    ?L?COM003E
001835 BF0001            CJNE     R7,#00H,?C0010?HWA_EEPROM_CFG
001838 0E                INC      R6
001839         ?C0010?HWA_EEPROM_CFG:
001839 80D9              SJMP     ?C0005?HWA_EEPROM_CFG
   60: 		tmp ^= SecretKey;
   61: 		dat[i] = tmp;
   62: 	}
   63: }
00183B         ?C0008?HWA_EEPROM_CFG:
00183B 22                RET      
----- FUNCTION _hwa_eepromDecrypt (END) -------


----- FUNCTION ?L?COM004B (BEGIN) -----
00183C A3                INC      DPTR
00183D EC                MOV      A,R4
00183E F0                MOVX     @DPTR,A
00183F A3                INC      DPTR
001840 ED                MOV      A,R5
001841 F0                MOVX     @DPTR,A
001842 E4                CLR      A
001843 FF                MOV      R7,A
001844 FE                MOV      R6,A
001845 22                RET      
----- FUNCTION ?L?COM004B (END) -------


----- FUNCTION ?L?COM0040 (BEGIN) -----
001846 F9                MOV      R1,A
001847 8F82              MOV      DPL,R7
001849 8E83              MOV      DPH,R6
00184B 120135            LCALL    ?C?CLDOPTR
00184E 64A5              XRL      A,#0A5H
001850 FD                MOV      R5,A
001851 22                RET      
----- FUNCTION ?L?COM0040 (END) -------


----- FUNCTION ?L?COM003E (BEGIN) -----
001852 4C                ORL      A,R4
001853 64A5              XRL      A,#0A5H
001855 FD                MOV      R5,A
001856 8F82              MOV      DPL,R7
001858 8E83              MOV      DPH,R6
00185A 120174            LCALL    ?C?CSTOPTR
00185D 0F                INC      R7
00185E 22                RET      
----- FUNCTION ?L?COM003E (END) -------


----- FUNCTION buzzer_Init (BEGIN) -----
 FILE: 'Driver\buzzer.c'
    8: void buzzer_Init(void)
    9: {
   10:     P3M1 &= ~0x20;      //推挽输出
   11:     P3M0 |= 0x20;
00185F 53B1DF            ANL      P3M1,#0DFH
   12:     P3 &= ~0x20;
001862 43B220            ORL      P3M0,#020H
   13: }
001865 53B0DF            ANL      P3,#0DFH
   14: 
001868 22                RET      
----- FUNCTION buzzer_Init (END) -------
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 73




----- FUNCTION len_Init (BEGIN) -----
 FILE: 'Driver\LED.c'
   17: void len_Init(void)
   18: {
   19:     P1M1 &= ~0xFF;      //推挽输出
   20:     P1M0 |= 0xFF;
001869 759100            MOV      P1M1,#00H
   21:     P2M1 &= ~0xC1;      //推挽输出
00186C 7592FF            MOV      P1M0,#0FFH
   22:     P2M0 |= 0xC1;
00186F 53953E            ANL      P2M1,#03EH
   23:     P5M1 &= ~0x30;      //推挽输出
001872 4396C1            ORL      P2M0,#0C1H
   24:     P5M0 |= 0x30;
001875 53C9CF            ANL      P5M1,#0CFH
   25:     P3M1 &= ~0x40;      //推挽输出
001878 43CA30            ORL      P5M0,#030H
   26:     P3M0 |= 0x40;
00187B 53B1BF            ANL      P3M1,#0BFH
   27: }
00187E 43B240            ORL      P3M0,#040H
   28: 
001881 22                RET      
----- FUNCTION len_Init (END) -------


----- FUNCTION led_Handler1ms (BEGIN) -----
 FILE: 'Driver\LED.c'
   30: void led_Handler1ms(void)
   31: {
   32:     if(ledsw)
   33:     {
001882 200902            JB       ledsw,$ + 5H
001885 2186              AJMP     ?C0033?LED
   34:     	if (gCurLed<5)
   35:     		gCurLed++;
001887 9000D8            MOV      DPTR,#gCurLed
00188A E0                MOVX     A,@DPTR
00188B C3                CLR      C
00188C 9405              SUBB     A,#05H
00188E 5005              JNC      ?C0003?LED
   36:     	else
001890 E0                MOVX     A,@DPTR
001891 04                INC      A
001892 F0                MOVX     @DPTR,A
001893 8005              SJMP     ?C0004?LED
001895         ?C0003?LED:
   37:     		gCurLed=0;
001895 E4                CLR      A
001896 9000D8            MOV      DPTR,#gCurLed
001899 F0                MOVX     @DPTR,A
00189A         ?C0004?LED:
   38:     	LED_CS0 = 1;
00189A 3187              ACALL    ?L?COM003D
   39:     	LED_CS1 = 1;
   40:     	LED_CS2 = 1;
   41:     	LED_CS3 = 1;
   42:     	LED_CS4 = 1;
   43:     	LED_CS5 = 1;
   44:     	switch ( gLedBuf[gCurLed])		 //switch case 语句中 switch中的条件case都不满足就执行default
00189C 9000D8            MOV      DPTR,#gCurLed
00189F E0                MOVX     A,@DPTR
0018A0 FF                MOV      R7,A
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 74


0018A1 24D2              ADD      A,#LOW gLedBuf
0018A3 F582              MOV      DPL,A
0018A5 E4                CLR      A
0018A6 3400              ADDC     A,#HIGH gLedBuf
0018A8 F583              MOV      DPH,A
0018AA E0                MOVX     A,@DPTR
0018AB B41100            CJNE     A,#011H,?C0045?LED
0018AE         ?C0045?LED:
0018AE 4002              JC       $ + 4H
0018B0 213E              AJMP     ?C0023?LED
0018B2 9018B9            MOV      DPTR,#018B9H
0018B5 F8                MOV      R0,A
0018B6 28                ADD      A,R0
0018B7 28                ADD      A,R0
0018B8 73                JMP      @A+DPTR
0018B9         ?C0046?LED:
0018B9 0218EC            LJMP     ?C0006?LED
0018BC 0218F1            LJMP     ?C0007?LED
0018BF 0218F6            LJMP     ?C0008?LED
0018C2 0218FB            LJMP     ?C0009?LED
0018C5 021900            LJMP     ?C0010?LED
0018C8 021905            LJMP     ?C0011?LED
0018CB 02190A            LJMP     ?C0012?LED
0018CE 02190F            LJMP     ?C0013?LED
0018D1 021914            LJMP     ?C0014?LED
0018D4 021919            LJMP     ?C0015?LED
0018D7 02191E            LJMP     ?C0016?LED
0018DA 021923            LJMP     ?C0017?LED
0018DD 021928            LJMP     ?C0018?LED
0018E0 02192A            LJMP     ?C0019?LED
0018E3 02192F            LJMP     ?C0020?LED
0018E6 021934            LJMP     ?C0021?LED
0018E9 021939            LJMP     ?C0022?LED
   45:     	{
   46:     	    case 0:	P1 = 0xeb; break;//0X88
0018EC         ?C0006?LED:
0018EC 7590EB            MOV      P1,#0EBH
0018EF 8050              SJMP     ?C0005?LED
   47:     		case 1:	P1 = 0x88; break;//0XEB
0018F1         ?C0007?LED:
0018F1 759088            MOV      P1,#088H
0018F4 804B              SJMP     ?C0005?LED
   48:     		case 2:	P1 = 0xB3; break;//0X92
0018F6         ?C0008?LED:
0018F6 7590B3            MOV      P1,#0B3H
0018F9 8046              SJMP     ?C0005?LED
   49:     		case 3:	P1 = 0xba; break;//0XC2
0018FB         ?C0009?LED:
0018FB 7590BA            MOV      P1,#0BAH
0018FE 8041              SJMP     ?C0005?LED
   50:     		case 4:	P1 = 0xd8; break;//0XE1
001900         ?C0010?LED:
001900 7590D8            MOV      P1,#0D8H
001903 803C              SJMP     ?C0005?LED
   51:     		case 5:	P1 = 0x7a; break;//0XC4
001905         ?C0011?LED:
001905 75907A            MOV      P1,#07AH
001908 8037              SJMP     ?C0005?LED
   52:     		case 6:	P1 = 0x7b; break;//0X84
00190A         ?C0012?LED:
00190A 75907B            MOV      P1,#07BH
00190D 8032              SJMP     ?C0005?LED
   53:     		case 7:	P1 = 0xa8; break;//0XEA
00190F         ?C0013?LED:
00190F 7590A8            MOV      P1,#0A8H
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 75


001912 802D              SJMP     ?C0005?LED
   54:     		case 8:	P1 = 0xfb; break;//0X80
001914         ?C0014?LED:
001914 7590FB            MOV      P1,#0FBH
001917 8028              SJMP     ?C0005?LED
   55:     		case 9:	P1 = 0xfa; break;//0XC0
001919         ?C0015?LED:
001919 7590FA            MOV      P1,#0FAH
00191C 8023              SJMP     ?C0005?LED
   56:     		case 10:P1 = 0xcb; break;//0XC0 U
00191E         ?C0016?LED:
00191E 7590CB            MOV      P1,#0CBH
001921 801E              SJMP     ?C0005?LED
   57:     		case 11:P1 = 0xbe; break;//3.
001923         ?C0017?LED:
001923 7590BE            MOV      P1,#0BEH
001926 8019              SJMP     ?C0005?LED
   58:     		case 12:P1 = 0x00; break;//空
001928         ?C0018?LED:
001928 8014              SJMP     ?C0049?LED
   59:     		case 13:P1 = 0x7e; break;//5.
00192A         ?C0019?LED:
00192A 75907E            MOV      P1,#07EH
00192D 8012              SJMP     ?C0005?LED
   60:             case 14:P1 = 0xf1;break;//P
00192F         ?C0020?LED:
00192F 7590F1            MOV      P1,#0F1H
001932 800D              SJMP     ?C0005?LED
   61:             case 15:P1 = 0x10;break;//-
001934         ?C0021?LED:
001934 759010            MOV      P1,#010H
001937 8008              SJMP     ?C0005?LED
   62:             case 16:P1 = 0xf9;break;//A
001939         ?C0022?LED:
001939 7590F9            MOV      P1,#0F9H
00193C 8003              SJMP     ?C0005?LED
   63:     		default:P1 = 0x00; break;
00193E         ?C0023?LED:
00193E         
00193E E4                CLR      A
00193F F590              MOV      P1,A
   64:     	}
001941         ?C0005?LED:
   65:         if(gShowDot & (1<<gCurLed))//show dot
001941 7401              MOV      A,#01H
001943 7E00              MOV      R6,#00H
001945 A807              MOV      R0,AR7
001947 08                INC      R0
001948 8005              SJMP     ?C0048?LED
00194A         ?C0047?LED:
00194A C3                CLR      C
00194B 33                RLC      A
00194C CE                XCH      A,R6
00194D 33                RLC      A
00194E CE                XCH      A,R6
00194F         ?C0048?LED:
00194F D8F9              DJNZ     R0,?C0047?LED
001951 FF                MOV      R7,A
001952 9000D9            MOV      DPTR,#gShowDot
001955 E0                MOVX     A,@DPTR
001956 FD                MOV      R5,A
001957 EF                MOV      A,R7
001958 5D                ANL      A,R5
001959 6003              JZ       ?C0024?LED
   66:         {
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 76


   67:      		P1 |= 0X04;
00195B 439004            ORL      P1,#04H
   68:         }
00195E         ?C0024?LED:
   69:     	switch (gCurLed)
00195E 9000D8            MOV      DPTR,#gCurLed
001961 E0                MOVX     A,@DPTR
001962 14                DEC      A
001963 6013              JZ       ?C0027?LED
001965 14                DEC      A
001966 6013              JZ       ?C0028?LED
001968 14                DEC      A
001969 6013              JZ       ?C0029?LED
00196B 14                DEC      A
00196C 6013              JZ       ?C0030?LED
00196E 14                DEC      A
00196F 6013              JZ       ?C0031?LED
001971 2405              ADD      A,#05H
001973 7011              JNZ      ?C0033?LED
   70:     	{
   71:     		case 0:
001975         ?C0026?LED:
   72:     			LED_CS0 = 0;
001975 C2A6              CLR      LED_CS0
   73:     			break;
001977 22                RET      
   74:     		case 1:
001978         ?C0027?LED:
   75:     			LED_CS1 = 0;
001978 C2A7              CLR      LED_CS1
   76:     			break;
00197A 22                RET      
   77:     		case 2:
00197B         ?C0028?LED:
   78:     			LED_CS2 = 0;
00197B C2A0              CLR      LED_CS2
   79:     			break;
00197D 22                RET      
   80:     		case 3:
00197E         ?C0029?LED:
   81:     			LED_CS3 = 0;
00197E C2CD              CLR      LED_CS3
   82:     			break;
001980 22                RET      
   83:     		case 4:
001981         ?C0030?LED:
   84:     			LED_CS4 = 0;
001981 C2CC              CLR      LED_CS4
   85:     			break;
001983 22                RET      
   86:     		case 5:
001984         ?C0031?LED:
   87:     			LED_CS5 = 0;
001984 C2B6              CLR      LED_CS5
   88:     			break;
   89:     		default:
   90:     			break;
   91:     	}
   92:     }
   93: }
001986         ?C0033?LED:
001986 22                RET      
----- FUNCTION led_Handler1ms (END) -------


LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 77


----- FUNCTION ?L?COM003D (BEGIN) -----
001987 D2A6              SETB     LED_CS0
001989 D2A7              SETB     LED_CS1
00198B D2A0              SETB     LED_CS2
00198D D2CD              SETB     LED_CS3
00198F D2CC              SETB     LED_CS4
001991 D2B6              SETB     LED_CS5
001993 22                RET      
----- FUNCTION ?L?COM003D (END) -------


----- FUNCTION _Write_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  212: void Write_FIFO(uchar *buff,uchar count)
  213: {
001994 900099            MOV      DPTR,#buff
001997 120DCC            LCALL    ?L?COM0008
00199A A3                INC      DPTR
00199B ED                MOV      A,R5
00199C F0                MOVX     @DPTR,A
  214: 	uchar i;
  215: 	if(count == 0)
00199D 6021              JZ       ?C0045?MIFARE
00199F         ?C0044?MIFARE:
  216:         return;
  217: 	for(i=0;i<count;i++)
;---- Variable 'i' assigned to Register 'R4' ----
00199F E4                CLR      A
0019A0 FC                MOV      R4,A
0019A1         ?C0046?MIFARE:
0019A1 90009C            MOV      DPTR,#count
0019A4 E0                MOVX     A,@DPTR
0019A5 FF                MOV      R7,A
0019A6 EC                MOV      A,R4
0019A7 C3                CLR      C
0019A8 9F                SUBB     A,R7
0019A9 5015              JNC      ?C0045?MIFARE
  218: 		SPIWriteOne(FIFO_Reg,buff[i]);
0019AB 900099            MOV      DPTR,#buff
0019AE 120C7E            LCALL    ?L?COM0002
0019B1 F9                MOV      R1,A
0019B2 8C82              MOV      DPL,R4
0019B4 1213C9            LCALL    ?L?COM001E
0019B7 FD                MOV      R5,A
0019B8 7F02              MOV      R7,#02H
0019BA 1206C2            LCALL    _SPIWriteOne
0019BD 0C                INC      R4
0019BE 80E1              SJMP     ?C0046?MIFARE
  219: //		SPIWrite(FIFO_Reg,buff,count);
  220: }
0019C0         ?C0045?MIFARE:
0019C0 22                RET      
----- FUNCTION _Write_FIFO (END) -------


----- FUNCTION ?L?COM0013 (BEGIN) -----
0019C1 2E                ADD      A,R6
0019C2 F9                MOV      R1,A
0019C3 E4                CLR      A
0019C4 3A                ADDC     A,R2
0019C5 FA                MOV      R2,A
0019C6 12011C            LCALL    ?C?CLDPTR
0019C9 FF                MOV      R7,A
0019CA EE                MOV      A,R6
0019CB 75F005            MOV      B,#05H
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 78


0019CE 84                DIV      AB
0019CF 74B4              MOV      A,#LOW gCard_UID
0019D1 25F0              ADD      A,B
0019D3 F582              MOV      DPL,A
0019D5 E4                CLR      A
0019D6 3400              ADDC     A,#HIGH gCard_UID
0019D8 F583              MOV      DPH,A
0019DA E0                MOVX     A,@DPTR
0019DB 6F                XRL      A,R7
0019DC 020162            LJMP     ?C?CSTPTR
----- FUNCTION ?L?COM0013 (END) -------


----- FUNCTION ?L?COM0014 (BEGIN) -----
0019DF AB08              MOV      R3,pMoney
0019E1 AA09              MOV      R2,pMoney+01H
0019E3 A90A              MOV      R1,pMoney+02H
0019E5 120213            LCALL    ?C?ILDPTR
0019E8 FF                MOV      R7,A
0019E9 9000B3            MOV      DPTR,#s_System+012H
0019EC E0                MOVX     A,@DPTR
0019ED 2F                ADD      A,R7
0019EE FF                MOV      R7,A
0019EF 9000B2            MOV      DPTR,#s_System+011H
0019F2 E0                MOVX     A,@DPTR
0019F3 35F0              ADDC     A,B
0019F5 FE                MOV      R6,A
0019F6 D3                SETB     C
0019F7 EF                MOV      A,R7
0019F8 9420              SUBB     A,#020H
0019FA EE                MOV      A,R6
0019FB 944E              SUBB     A,#04EH
0019FD 22                RET      
----- FUNCTION ?L?COM0014 (END) -------


----- FUNCTION ?L?COM0022 (BEGIN) -----
0019FE 9000D2            MOV      DPTR,#gLedBuf
001A01 740C              MOV      A,#0CH
001A03 F0                MOVX     @DPTR,A
001A04 A3                INC      DPTR
001A05 740F              MOV      A,#0FH
001A07 F0                MOVX     @DPTR,A
001A08 A3                INC      DPTR
001A09 F0                MOVX     @DPTR,A
001A0A A3                INC      DPTR
001A0B F0                MOVX     @DPTR,A
001A0C A3                INC      DPTR
001A0D F0                MOVX     @DPTR,A
001A0E A3                INC      DPTR
001A0F 740C              MOV      A,#0CH
001A11 F0                MOVX     @DPTR,A
001A12 E4                CLR      A
001A13 9000D9            MOV      DPTR,#gShowDot
001A16 F0                MOVX     @DPTR,A
001A17 22                RET      
----- FUNCTION ?L?COM0022 (END) -------


----- FUNCTION ?L?COM0029 (BEGIN) -----
001A18 E0                MOVX     A,@DPTR
001A19 FB                MOV      R3,A
001A1A 75F003            MOV      B,#03H
001A1D A4                MUL      AB
001A1E 2451              ADD      A,#LOW c_s_eepromConfig
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 79


001A20 F582              MOV      DPL,A
001A22 E5F0              MOV      A,B
001A24 3406              ADDC     A,#HIGH c_s_eepromConfig
001A26 F583              MOV      DPH,A
001A28 E4                CLR      A
001A29 93                MOVC     A,@A+DPTR
001A2A FC                MOV      R4,A
001A2B 22                RET      
----- FUNCTION ?L?COM0029 (END) -------


----- FUNCTION ?L?COM0035 (BEGIN) -----
001A2C 78CA              MOV      R0,#LOW LastCardId
001A2E 7C00              MOV      R4,#HIGH LastCardId
001A30 7D01              MOV      R5,#01H
001A32 7B01              MOV      R3,#01H
001A34 7A00              MOV      R2,#HIGH gCard_UID
001A36 79B4              MOV      R1,#LOW gCard_UID
001A38 7E00              MOV      R6,#00H
001A3A 7F05              MOV      R7,#05H
001A3C 22                RET      
----- FUNCTION ?L?COM0035 (END) -------


----- FUNCTION ?L?COM003A (BEGIN) -----
001A3D 25E0              ADD      A,ACC
001A3F 25E0              ADD      A,ACC
001A41 FE                MOV      R6,A
001A42 04                INC      A
001A43 A3                INC      DPTR
001A44 F0                MOVX     @DPTR,A
001A45 EE                MOV      A,R6
001A46 2402              ADD      A,#02H
001A48 A3                INC      DPTR
001A49 F0                MOVX     @DPTR,A
001A4A 22                RET      
----- FUNCTION ?L?COM003A (END) -------


----- FUNCTION ?L?COM0044 (BEGIN) -----
001A4B 7B01              MOV      R3,#01H
001A4D 7A00              MOV      R2,#HIGH s_BackupBuff
001A4F 7940              MOV      R1,#LOW s_BackupBuff
001A51 900074            MOV      DPTR,#block
001A54 E0                MOVX     A,@DPTR
001A55 FD                MOV      R5,A
001A56 22                RET      
----- FUNCTION ?L?COM0044 (END) -------


----- FUNCTION ?L?COM0045 (BEGIN) -----
001A57 E0                MOVX     A,@DPTR
001A58 FE                MOV      R6,A
001A59 A3                INC      DPTR
001A5A E0                MOVX     A,@DPTR
001A5B FF                MOV      R7,A
001A5C 7800              MOV      R0,#LOW e2_data
001A5E 7C00              MOV      R4,#HIGH e2_data
001A60 7D01              MOV      R5,#01H
001A62 22                RET      
----- FUNCTION ?L?COM0045 (END) -------


----- FUNCTION ?L?COM004A (BEGIN) -----
001A63 A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 80


001A64 F0                MOVX     @DPTR,A
001A65 A3                INC      DPTR
001A66 F0                MOVX     @DPTR,A
001A67 A3                INC      DPTR
001A68 F0                MOVX     @DPTR,A
001A69 22                RET      
----- FUNCTION ?L?COM004A (END) -------


----- FUNCTION ?L?COM004D (BEGIN) -----
001A6A 900650            MOV      DPTR,#c_u8_eepromSectorNum
001A6D E4                CLR      A
001A6E 93                MOVC     A,@A+DPTR
001A6F FF                MOV      R7,A
001A70 ED                MOV      A,R5
001A71 C3                CLR      C
001A72 9F                SUBB     A,R7
001A73 22                RET      
----- FUNCTION ?L?COM004D (END) -------


----- FUNCTION ?L?COM004E (BEGIN) -----
001A74 900083            MOV      DPTR,#e2_addr
001A77 E0                MOVX     A,@DPTR
001A78 FE                MOV      R6,A
001A79 A3                INC      DPTR
001A7A E0                MOVX     A,@DPTR
001A7B FF                MOV      R7,A
001A7C 22                RET      
----- FUNCTION ?L?COM004E (END) -------


----- FUNCTION ?L?COM0051 (BEGIN) -----
001A7D 75F00A            MOV      B,#0AH
001A80 84                DIV      AB
001A81 A3                INC      DPTR
001A82 E5F0              MOV      A,B
001A84 F0                MOVX     @DPTR,A
001A85 22                RET      
----- FUNCTION ?L?COM0051 (END) -------


----- FUNCTION ?L?COM0052 (BEGIN) -----
001A86 8E82              MOV      DPL,R6
001A88 758300            MOV      DPH,#00H
001A8B 020174            LJMP     ?C?CSTOPTR
----- FUNCTION ?L?COM0052 (END) -------


----- FUNCTION ?L?COM0054 (BEGIN) -----
001A8E 7D0F              MOV      R5,#0FH
001A90 7F22              MOV      R7,#022H
001A92 0206C2            LJMP     _SPIWriteOne
----- FUNCTION ?L?COM0054 (END) -------


----- FUNCTION ?L?COM0056 (BEGIN) -----
001A95 F582              MOV      DPL,A
001A97 E4                CLR      A
001A98 3400              ADDC     A,#HIGH gCard_UID
001A9A F583              MOV      DPH,A
001A9C 22                RET      
----- FUNCTION ?L?COM0056 (END) -------


LX51 LINKER/LOCATER V4.66.41.0                                                        12/03/2015  23:04:50  PAGE 81


----- FUNCTION ?L?COM0058 (BEGIN) -----
001A9D 7403              MOV      A,#03H
001A9F F0                MOVX     @DPTR,A
001AA0 A3                INC      DPTR
001AA1 74E7              MOV      A,#0E7H
001AA3 F0                MOVX     @DPTR,A
001AA4 22                RET      
----- FUNCTION ?L?COM0058 (END) -------


----- FUNCTION ?L?COM005B (BEGIN) -----
001AA5 F0                MOVX     @DPTR,A
001AA6 A3                INC      DPTR
001AA7 CE                XCH      A,R6
001AA8 F0                MOVX     @DPTR,A
001AA9 90065B            MOV      DPTR,#c_u16_eepromSectorBakAddr
001AAC 22                RET      
----- FUNCTION ?L?COM005B (END) -------


----- FUNCTION ?L?COM005C (BEGIN) -----
001AAD 3C                ADDC     A,R4
001AAE F583              MOV      DPH,A
001AB0 E0                MOVX     A,@DPTR
001AB1 FD                MOV      R5,A
001AB2 ED                MOV      A,R5
001AB3 FF                MOV      R7,A
001AB4 22                RET      
----- FUNCTION ?L?COM005C (END) -------


