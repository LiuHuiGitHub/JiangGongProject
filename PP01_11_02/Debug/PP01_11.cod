LX51 LINKER/LOCATER V4.66.1.0                                                           12/01/2015  20:04:53  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  .\Debug\PP01_11 (SYS_DELAY)


----- FUNCTION sys_gpioInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   23: void sys_gpioInit(void)
   24: {
   25: }
   26: 
000009 22                RET      
----- FUNCTION sys_gpioInit (END) -------


----- FUNCTION sys_taskHandler10ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   64: void sys_taskHandler10ms(void)            //10ms interrupt task
   65: {
   66: }
   67: 
00000A 22                RET      
----- FUNCTION sys_taskHandler10ms (END) -------


00000B 0212F2            LJMP     012F2H
----- FUNCTION sys_taskHandler1s (BEGIN) -----
 FILE: 'System\sys_task.c'
   73: void sys_taskHandler1s(void)              //1s interrupt task
   74: {
   75: }
   76: 
000021 22                RET      
----- FUNCTION sys_taskHandler1s (END) -------


----- FUNCTION hwa_eepromInit (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   33: void hwa_eepromInit(void)
   34: {
   35: }
   36: 
000022 22                RET      
----- FUNCTION hwa_eepromInit (END) -------


000023 0214A3            LJMP     014A3H
----- FUNCTION _sys_delayus (BEGIN) -----
 FILE: 'System\sys_delay.c'
    5: void sys_delayus(UINT16 xus)
    6: {
;---- Variable 'xus' assigned to Register 'R6/R7' ----
    7:     while(xus--);
00065D         ?C0001?SYS_DELAY:
    8: }
00065D EF                MOV      A,R7
00065E 1F                DEC      R7
00065F AC06              MOV      R4,AR6
000661 7001              JNZ      ?C0012?SYS_DELAY
000663 1E                DEC      R6
000664         ?C0012?SYS_DELAY:
000664 4C                ORL      A,R4
000665 70F6              JNZ      ?C0001?SYS_DELAY
    9: 
000667 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 2


----- FUNCTION _sys_delayus (END) -------


----- FUNCTION Init_FM1702 (BEGIN) -----
 FILE: 'Driver\mifare.c'
  104: void Init_FM1702(void)
  105: {
  106: 	uchar temp;
  107: 	uint i;
  108: 	RC500SCK = 0;
000668 C2A1              CLR      RC500SCK
  109: 	RC500SO = 1;
00066A D2A2              SETB     RC500SO
  110: 	RC500SI = 1;
00066C D2A4              SETB     RC500SI
  111: 	RC500RST = 1;	// FM1702复位 
00066E D2A5              SETB     RC500RST
  112: 	sys_delayms(2);
000670 7F02              MOV      R7,#02H
000672 7E00              MOV      R6,#00H
000674 120807            LCALL    _sys_delayms
  113: 	RC500RST = 0;	
000677 C2A5              CLR      RC500RST
  114: 	//进入复位阶段，需要512个FM1702SL的时钟周期，约38us
  115: 	sys_delayus(100); 
000679 7F64              MOV      R7,#064H
00067B 7E00              MOV      R6,#00H
00067D D15D              ACALL    _sys_delayus
00067F         ?C0024?MIFARE:
  116: 	//进入初始化阶段，需要128个时钟周期，约10us
  117: 	do{ 		// 等待Command = 0,FM1702复位成功
  118: 		temp = SPIReadOne(Command_Reg);	 //(Command_Reg<<1)|0x80 = 0x82
;---- Variable 'temp' assigned to Register 'R4' ----
00067F F1DB              ACALL    ?L?COM0038
000681 70FC              JNZ      ?C0024?MIFARE
  119: 	}while(temp!=0);
  120: ///////////////////////////////////////////////////////////////////////////////////
  121: 	SPIWriteOne(Page_Reg,0x80);	//初始化SPI接口
000683 7D80              MOV      R5,#080H
000685 FF                MOV      R7,A
000686 D1C2              ACALL    _SPIWriteOne
  122: 	for(i = 0; i < 0x1fff; i++) // 延时
;---- Variable 'i' assigned to Register 'R2/R3' ----
000688 E4                CLR      A
000689 FB                MOV      R3,A
00068A FA                MOV      R2,A
00068B         ?C0025?MIFARE:
  123: 	{
  124: 		temp = SPIReadOne(Command_Reg);
00068B F1DB              ACALL    ?L?COM0038
00068D 7006              JNZ      ?C0027?MIFARE
  125: 		if(temp == 0x00)	//SPI初始化成功
  126: 		{
  127: 			SPIWriteOne(Page_Reg,0);//可以使用SPI接口
00068F FD                MOV      R5,A
000690 FF                MOV      R7,A
000691 D1C2              ACALL    _SPIWriteOne
  128: 			break;
000693 800B              SJMP     ?C0026?MIFARE
  129: 		}
  130: 	}
000695         ?C0027?MIFARE:
000695 0B                INC      R3
000696 BB0001            CJNE     R3,#00H,?C0138?MIFARE
000699 0A                INC      R2
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 3


00069A         ?C0138?MIFARE:
00069A BA1FEE            CJNE     R2,#01FH,?C0025?MIFARE
00069D BBFFEB            CJNE     R3,#0FFH,?C0025?MIFARE
0006A0         ?C0026?MIFARE:
  131: ////////////////////////////////////////////////////////////////////////////////////
  132: 	SPIWriteOne(InterruptEn_Reg,0x7F);	//  禁止所有中断请求（最高位置0）
0006A0 7D7F              MOV      R5,#07FH
0006A2 7F06              MOV      R7,#06H
0006A4 D1C2              ACALL    _SPIWriteOne
  133: 	SPIWriteOne(InterruptRq_Reg,0x7F);	// 禁止所有中断请求标识置0（最高位置0）
0006A6 7D7F              MOV      R5,#07FH
0006A8 7F07              MOV      R7,#07H
0006AA D1C2              ACALL    _SPIWriteOne
  134: 	
  135: 	//设置调制器的输入源为内部编码器, 并且设置TX1和TX2
  136: 	SPIWriteOne(TxControl_Reg,0x5B); 		// 发送控制寄存器 
0006AC 7D5B              MOV      R5,#05BH
0006AE 7F11              MOV      R7,#011H
0006B0 D1C2              ACALL    _SPIWriteOne
  137: 	SPIWriteOne(RxControl2_Reg,0x01);
0006B2 7D01              MOV      R5,#01H
0006B4 7F1E              MOV      R7,#01EH
0006B6 D1C2              ACALL    _SPIWriteOne
  138: 	SPIWriteOne(RxWait_Reg,5);
0006B8 7D05              MOV      R5,#05H
0006BA 7F21              MOV      R7,#021H
0006BC 8004              SJMP     _SPIWriteOne
----- FUNCTION Init_FM1702 (END) -------


----- FUNCTION ?L?COM003B (BEGIN) -----
0006BE F0                MOVX     @DPTR,A
0006BF FD                MOV      R5,A
0006C0 7F01              MOV      R7,#01H
----- FUNCTION _SPIWriteOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   65: void SPIWriteOne(uchar SpiAddress,uchar wData)
   66: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
;---- Variable 'wData' assigned to Register 'R5' ----
   67: 	uchar i;
   68: 	SpiAddress = SpiAddress<<1;
0006C2 EF                MOV      A,R7
0006C3 25E0              ADD      A,ACC
   69: 	SpiAddress = SpiAddress & 0x7E;
0006C5 547E              ANL      A,#07EH
0006C7 FF                MOV      R7,A
   70: 
   71: 	//传输地址 从高位到低位传输
   72: 	RC500CS = 0;
0006C8 C2A3              CLR      RC500CS
   73: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
0006CA E4                CLR      A
0006CB FE                MOV      R6,A
0006CC         ?C0011?MIFARE:
   74: 	{
   75: 		if(SpiAddress&0x80)
0006CC EF                MOV      A,R7
0006CD 30E704            JNB      ACC.7,?C0014?MIFARE
   76: 			RC500SO = 1;
0006D0 D2A2              SETB     RC500SO
0006D2 8002              SJMP     ?C0015?MIFARE
0006D4         ?C0014?MIFARE:
   77: 		else
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 4


   78: 			RC500SO = 0;
0006D4 C2A2              CLR      RC500SO
0006D6         ?C0015?MIFARE:
   79: 		RC500SCK = 1;
0006D6 F1F8              ACALL    ?L?COM004A
0006D8 B408F1            CJNE     A,#08H,?C0011?MIFARE
0006DB         ?C0012?MIFARE:
   80: 		SpiAddress = SpiAddress<<1;
   81: 		RC500SCK = 0;
   82: 	}
   83: 	//传输数据，从高位开始
   84: 	for (i=0;i<8;i++)
0006DB E4                CLR      A
0006DC FE                MOV      R6,A
0006DD         ?C0016?MIFARE:
   85: 	{
   86: 		if(wData & 0x80)
0006DD ED                MOV      A,R5
0006DE 30E704            JNB      ACC.7,?C0019?MIFARE
   87: 			RC500SO = 1;
0006E1 D2A2              SETB     RC500SO
0006E3 8002              SJMP     ?C0020?MIFARE
0006E5         ?C0019?MIFARE:
   88: 		else
   89: 			RC500SO = 0;
0006E5 C2A2              CLR      RC500SO
0006E7         ?C0020?MIFARE:
   90: 		RC500SCK = 1;
0006E7 D2A1              SETB     RC500SCK
   91: 		wData = wData<<1;
0006E9 ED                MOV      A,R5
0006EA 25E0              ADD      A,ACC
0006EC FD                MOV      R5,A
   92: 		RC500SCK = 0;
0006ED C2A1              CLR      RC500SCK
   93: 	}
0006EF 0E                INC      R6
0006F0 EE                MOV      A,R6
0006F1 B408E9            CJNE     A,#08H,?C0016?MIFARE
0006F4         ?C0017?MIFARE:
   94: 	RC500CS = 1;
0006F4 D2A3              SETB     RC500CS
   95: }
0006F6 22                RET      
----- FUNCTION _SPIWriteOne (END) -------


----- FUNCTION _SPIReadOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   24: uchar SPIReadOne(uchar SpiAddress)
   25: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
   26: 	uchar i,rdata; 
   27: 	//地址字节最高位置1，表示为读数据，最低位固定为0，中间6位为地址
   28: 	SpiAddress = SpiAddress<<1;
0006F7 EF                MOV      A,R7
0006F8 25E0              ADD      A,ACC
   29: 	SpiAddress = SpiAddress | 0x80;
0006FA 4480              ORL      A,#080H
0006FC FF                MOV      R7,A
   30: 	//传输地址 从高位到低位传输
   31: 	RC500CS = 0;
0006FD C2A3              CLR      RC500CS
   32: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 5


0006FF E4                CLR      A
000700 FE                MOV      R6,A
000701         ?C0001?MIFARE:
   33: 	{
   34: 		if(SpiAddress&0x80)
000701 EF                MOV      A,R7
000702 30E704            JNB      ACC.7,?C0004?MIFARE
   35: 			RC500SO = 1;
000705 D2A2              SETB     RC500SO
000707 8002              SJMP     ?C0005?MIFARE
000709         ?C0004?MIFARE:
   36: 		else
   37: 			RC500SO = 0;
000709 C2A2              CLR      RC500SO
00070B         ?C0005?MIFARE:
   38: 		RC500SCK = 1;
00070B F1F8              ACALL    ?L?COM004A
00070D B408F1            CJNE     A,#08H,?C0001?MIFARE
000710         ?C0002?MIFARE:
   39: 		SpiAddress = SpiAddress<<1;
   40: 		RC500SCK = 0;
   41: 	}
   42: 	
   43: 	//接收数据
   44: 	rdata = 0;
;---- Variable 'rdata' assigned to Register 'R7' ----
000710 E4                CLR      A
000711 FF                MOV      R7,A
   45: 	for (i=0;i<8;i++)
000712 FE                MOV      R6,A
000713         ?C0006?MIFARE:
   46: 	{
   47: 		RC500SCK = 1;
000713 D2A1              SETB     RC500SCK
   48: 		rdata = rdata<<1;
000715 EF                MOV      A,R7
000716 25E0              ADD      A,ACC
000718 FF                MOV      R7,A
   49: 		if (RC500SI)
000719 30A401            JNB      RC500SI,?C0009?MIFARE
   50: 			rdata+= 1;
00071C 0F                INC      R7
00071D         ?C0009?MIFARE:
   51: 		RC500SCK = 0;
00071D C2A1              CLR      RC500SCK
   52: 	}
00071F 0E                INC      R6
000720 EE                MOV      A,R6
000721 B408EF            CJNE     A,#08H,?C0006?MIFARE
000724         ?C0007?MIFARE:
   53: 	RC500CS=1;
000724 D2A3              SETB     RC500CS
   54: 	return (rdata);
   55: }
000726 22                RET      
----- FUNCTION _SPIReadOne (END) -------


----- FUNCTION AntiColl (BEGIN) -----
 FILE: 'Driver\mifare.c'
  278: uchar AntiColl(void)
  279: {
  280: 	
  281: 	uchar	temp,i;
  282: 
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 6


  283: 	//选择TX1、TX2的发射天线阻抗
  284: 	SPIWriteOne(CwConductance_Reg,0x3f);
000727 1217F0            LCALL    ?L?COM0022
00072A 7493              MOV      A,#093H
00072C F0                MOVX     @DPTR,A
  285: 	//选择数据校验种类和模式
  286: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  287: 	
  288: 	gBuff[0] = RF_CMD_ANTICOL;
  289: 	gBuff[1] = 0x20;
00072D A3                INC      DPTR
00072E 7420              MOV      A,#020H
000730 120B33            LCALL    ?L?COM000F
000733 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
000736 7402              MOV      A,#02H
000738 F0                MOVX     @DPTR,A
000739 7F1E              MOV      R7,#01EH
00073B F195              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R5' ----
00073D AD07              MOV      R5,AR7
  290: 	temp = Command_Send(Transceive,gBuff,2);
  291: 	if (temp==0)
00073F ED                MOV      A,R5
000740 7003              JNZ      ?C0062?MIFARE
  292: 	{
  293: 		return(FM1702_NOTAGERR);
000742 7F01              MOV      R7,#01H
000744 22                RET      
  294: 	}
000745         ?C0062?MIFARE:
  295: 
  296: 	temp = SPIReadOne(FIFOLength_Reg);
000745 F1E3              ACALL    ?L?COM0043
000747 7003              JNZ      ?C0064?MIFARE
  297: 	if (temp == 0)
  298: 	{
  299: 		return FM1702_BYTECOUNTERR;
000749 7F0C              MOV      R7,#0CH
00074B 22                RET      
  300: 	}
00074C         ?C0064?MIFARE:
  301: 
  302: 	for(i=0;i<temp;i++)
;---- Variable 'i' assigned to Register 'R4' ----
00074C E4                CLR      A
00074D FC                MOV      R4,A
00074E         ?C0065?MIFARE:
00074E EC                MOV      A,R4
00074F C3                CLR      C
000750 9D                SUBB     A,R5
000751 500B              JNC      ?C0066?MIFARE
  303: 	{
  304: 		gBuff[i] = SPIReadOne(FIFO_Reg);
000753 7F02              MOV      R7,#02H
000755 D1F7              ACALL    _SPIReadOne
000757 F1EB              ACALL    ?L?COM0036
000759 EF                MOV      A,R7
00075A F0                MOVX     @DPTR,A
  305: 	}
00075B 0C                INC      R4
00075C 80F0              SJMP     ?C0065?MIFARE
00075E         ?C0066?MIFARE:
  306: 	temp = SPIReadOne(ErrorFlag_Reg);	// 判断接数据是否有冲突位
00075E 7F0A              MOV      R7,#0AH
000760 F1E5              ACALL    ?L?COM0044
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 7


000762 5401              ANL      A,#01H
000764 FD                MOV      R5,A
  307: 	temp = temp & 0x01;
  308: 	if (temp == 0x00)
000765 702B              JNZ      ?C0068?MIFARE
  309: 	{
  310: 		for (i=0;i<5;i++)
000767 FC                MOV      R4,A
000768         ?C0069?MIFARE:
  311: 			temp^=gBuff[i];
000768 F1EB              ACALL    ?L?COM0036
00076A E0                MOVX     A,@DPTR
00076B 6D                XRL      A,R5
00076C FD                MOV      R5,A
00076D 0C                INC      R4
00076E EC                MOV      A,R4
00076F B405F6            CJNE     A,#05H,?C0069?MIFARE
000772         ?C0070?MIFARE:
  312: 		if (temp)
000772 ED                MOV      A,R5
000773 6003              JZ       ?C0072?MIFARE
  313: 			return(FM1702_SERNRERR);
000775 7F08              MOV      R7,#08H
000777 22                RET      
000778         ?C0072?MIFARE:
  314:         for (i=0;i<5;i++)
000778 E4                CLR      A
000779 FC                MOV      R4,A
00077A         ?C0073?MIFARE:
  315:         {
  316:             gCard_UID[i]=gBuff[i];
00077A F1EB              ACALL    ?L?COM0036
00077C E0                MOVX     A,@DPTR
00077D FF                MOV      R7,A
00077E 74A7              MOV      A,#LOW gCard_UID
000780 2C                ADD      A,R4
000781 F582              MOV      DPL,A
000783 E4                CLR      A
000784 3400              ADDC     A,#HIGH gCard_UID
000786 F583              MOV      DPH,A
000788 EF                MOV      A,R7
000789 F0                MOVX     @DPTR,A
  317:         }
00078A 0C                INC      R4
00078B EC                MOV      A,R4
00078C B405EB            CJNE     A,#05H,?C0073?MIFARE
00078F         ?C0074?MIFARE:
  318: 		return(FM1702_OK);
00078F 7F00              MOV      R7,#00H
000791 22                RET      
  319: 	}
000792         ?C0068?MIFARE:
  320: 	else //有冲突位
  321: 		return FM1702_SERNRERR;
000792 7F08              MOV      R7,#08H
  322: }
000794 22                RET      
----- FUNCTION AntiColl (END) -------


----- FUNCTION _Command_Send (BEGIN) -----
 FILE: 'Driver\mifare.c'
  251: uchar Command_Send(uchar Comm_Set,uchar *buff, uchar count)
  252: {
000795 900067            MOV      DPTR,#Comm_Set
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 8


000798 EF                MOV      A,R7
000799 F0                MOVX     @DPTR,A
;---- Variable 'buff' assigned to Register 'R1/R2/R3' ----
  253:     uchar ucResult1,ucResult2,i;
  254:     SPIWriteOne(Command_Reg,0x00);
00079A E4                CLR      A
00079B FD                MOV      R5,A
00079C 7F01              MOV      R7,#01H
00079E D1C2              ACALL    _SPIWriteOne
  255:     if(Clear_FIFO()==FALSE)
0007A0 12191D            LCALL    Clear_FIFO
0007A3 EF                MOV      A,R7
0007A4 7002              JNZ      ?C0055?MIFARE
  256:         return FALSE;
0007A6 FF                MOV      R7,A
0007A7 22                RET      
0007A8         ?C0055?MIFARE:
  257:     Write_FIFO(buff,count);
0007A8 90006B            MOV      DPTR,#count
0007AB E0                MOVX     A,@DPTR
0007AC FD                MOV      R5,A
0007AD 12193F            LCALL    _Write_FIFO
  258: 	SPIWriteOne(Command_Reg,Comm_Set);
0007B0 900067            MOV      DPTR,#Comm_Set
0007B3 E0                MOVX     A,@DPTR
0007B4 FD                MOV      R5,A
0007B5 7F01              MOV      R7,#01H
0007B7 D1C2              ACALL    _SPIWriteOne
  259: 	for (i=0;i<0xA0;i++)
;---- Variable 'i' assigned to Register 'R5' ----
0007B9 E4                CLR      A
0007BA FD                MOV      R5,A
0007BB         ?C0057?MIFARE:
  260: 	{
  261:         ucResult1 = SPIReadOne(Command_Reg);
0007BB 7F01              MOV      R7,#01H
0007BD D1F7              ACALL    _SPIReadOne
;---- Variable 'ucResult1' assigned to Register 'R4' ----
0007BF AC07              MOV      R4,AR7
  262:         ucResult2 = SPIReadOne(InterruptRq_Reg) & 0x80;
0007C1 7F07              MOV      R7,#07H
0007C3 D1F7              ACALL    _SPIReadOne
0007C5 EF                MOV      A,R7
0007C6 5480              ANL      A,#080H
0007C8 FF                MOV      R7,A
;---- Variable 'ucResult2' assigned to Register 'R7' ----
  263:         if(ucResult1 == 0 || ucResult2 ==0x80)
0007C9 EC                MOV      A,R4
0007CA 6004              JZ       ?C0061?MIFARE
0007CC EF                MOV      A,R7
0007CD B48003            CJNE     A,#080H,?C0059?MIFARE
0007D0         ?C0061?MIFARE:
  264:             return TRUE;
0007D0 7F01              MOV      R7,#01H
0007D2 22                RET      
  265: 	}
0007D3         ?C0059?MIFARE:
0007D3 0D                INC      R5
0007D4 ED                MOV      A,R5
0007D5 B4A0E3            CJNE     A,#0A0H,?C0057?MIFARE
0007D8         ?C0058?MIFARE:
  266: 	return FALSE;
0007D8 7F00              MOV      R7,#00H
  267: }
0007DA 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 9


----- FUNCTION _Command_Send (END) -------


----- FUNCTION ?L?COM0038 (BEGIN) -----
0007DB 7F01              MOV      R7,#01H
0007DD         ?L?COM0039:
0007DD D1F7              ACALL    _SPIReadOne
0007DF AC07              MOV      R4,AR7
0007E1 EC                MOV      A,R4
0007E2 22                RET      
----- FUNCTION ?L?COM0038 (END) -------


----- FUNCTION ?L?COM0043 (BEGIN) -----
0007E3 7F04              MOV      R7,#04H
0007E5         ?L?COM0044:
0007E5 D1F7              ACALL    _SPIReadOne
0007E7 AD07              MOV      R5,AR7
0007E9 ED                MOV      A,R5
0007EA 22                RET      
----- FUNCTION ?L?COM0043 (END) -------


----- FUNCTION ?L?COM0036 (BEGIN) -----
0007EB 74AC              MOV      A,#LOW gBuff
0007ED 2C                ADD      A,R4
0007EE F582              MOV      DPL,A
0007F0 E4                CLR      A
0007F1 3400              ADDC     A,#HIGH gBuff
0007F3 F583              MOV      DPH,A
0007F5 22                RET      
----- FUNCTION ?L?COM0036 (END) -------


----- FUNCTION app_brushInit (BEGIN) -----
 FILE: 'App\app_brush.c'
   38: void app_brushInit(void)
   39: {
   40: 	Init_FM1702();
   41: }
0007F6 C168              AJMP     Init_FM1702
----- FUNCTION app_brushInit (END) -------


----- FUNCTION ?L?COM004A (BEGIN) -----
0007F8 D2A1              SETB     RC500SCK
0007FA EF                MOV      A,R7
0007FB 25E0              ADD      A,ACC
0007FD FF                MOV      R7,A
0007FE C2A1              CLR      RC500SCK
000800 0E                INC      R6
000801 EE                MOV      A,R6
000802 22                RET      
----- FUNCTION ?L?COM004A (END) -------


----- FUNCTION ?L?COM0047 (BEGIN) -----
000803 7FE8              MOV      R7,#0E8H
000805 7E03              MOV      R6,#03H
----- FUNCTION _sys_delayms (BEGIN) -----
 FILE: 'System\sys_delay.c'
   10: void sys_delayms(UINT16 xms)
   11: {   
;---- Variable 'xms' assigned to Register 'R6/R7' ----
   12:     UINT8 i, j;
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 10


000807         ?C0004?SYS_DELAY:
   13: 	while(xms--)
000807 EF                MOV      A,R7
000808 1F                DEC      R7
000809 AC06              MOV      R4,AR6
00080B 7001              JNZ      ?C0013?SYS_DELAY
00080D 1E                DEC      R6
00080E         ?C0013?SYS_DELAY:
00080E 4C                ORL      A,R4
00080F 600D              JZ       ?C0011?SYS_DELAY
   14:     {
   15:     	WDT_CONTR |= 0x35;
000811 43C135            ORL      WDT_CONTR,#035H
   16:         i = 22;
;---- Variable 'i' assigned to Register 'R5' ----
000814 7D16              MOV      R5,#016H
   17:         j = 128;
;---- Variable 'j' assigned to Register 'R4' ----
000816 7C80              MOV      R4,#080H
   18:         do
   19:         {
000818         ?C0009?SYS_DELAY:
   20:             while (--j);
000818 DCFE              DJNZ     R4,?C0009?SYS_DELAY
00081A         ?C0010?SYS_DELAY:
   21:         } while (--i);
00081A         ?C0006?SYS_DELAY:
00081A DDFC              DJNZ     R5,?C0009?SYS_DELAY
   22:     }
00081C 80E9              SJMP     ?C0004?SYS_DELAY
   22: }
00081E         ?C0011?SYS_DELAY:
00081E 22                RET      
----- FUNCTION _sys_delayms (END) -------


----- FUNCTION app_Show (BEGIN) -----
 FILE: 'App\app_brush.c'
   20: void app_Show(void)
   21: {
   22:     if(!b_FactorySystem)
   23:     {
00081F 20081D            JB       b_FactorySystem,?C0002?APP_BRUSH
   24:         sys_delayms(1000);
   25:         led_ShowNumber(MoneySum/100, MoneySum%100, 0);
000822 1103              ACALL    ?L?COM0047
   26:         sys_delayms(1000);
000824 1140              ACALL    ?L?COM0029
000826 C006              PUSH     AR6
000828 C007              PUSH     AR7
00082A 1140              ACALL    ?L?COM0029
00082C AF03              MOV      R7,AR3
00082E AD07              MOV      R5,AR7
000830 D007              POP      AR7
000832 D006              POP      AR6
000834 E4                CLR      A
000835 FB                MOV      R3,A
000836 1157              ACALL    _led_ShowNumber
   27:         gLedBuf[0] = 12;
000838 1103              ACALL    ?L?COM0047
   28:         gLedBuf[1] = 15;
00083A 121A20            LCALL    ?L?COM0025
   29:         gLedBuf[2] = 15;
   30:         gLedBuf[3] = 15;
   31:         gLedBuf[4] = 15;
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 11


   32:         gLedBuf[5] = 12;
   33:         gShowDot = 0;
   34:         sys_delayms(1000);
00083D 1103              ACALL    ?L?COM0047
   35:     }
   36: }
00083F         ?C0002?APP_BRUSH:
00083F 22                RET      
----- FUNCTION app_Show (END) -------


----- FUNCTION ?L?COM0029 (BEGIN) -----
000840 E4                CLR      A
000841 7B64              MOV      R3,#064H
000843 FA                MOV      R2,A
000844 F9                MOV      R1,A
000845 F8                MOV      R0,A
000846 900090            MOV      DPTR,#MoneySum
000849 E0                MOVX     A,@DPTR
00084A FC                MOV      R4,A
00084B A3                INC      DPTR
00084C E0                MOVX     A,@DPTR
00084D FD                MOV      R5,A
00084E A3                INC      DPTR
00084F E0                MOVX     A,@DPTR
000850 FE                MOV      R6,A
000851 A3                INC      DPTR
000852 E0                MOVX     A,@DPTR
000853 FF                MOV      R7,A
000854 0202D1            LJMP     ?C?ULDIV
----- FUNCTION ?L?COM0029 (END) -------


----- FUNCTION _led_ShowNumber (BEGIN) -----
 FILE: 'Driver\LED.c'
   95: void led_ShowNumber(UINT16 L_num, UINT8 R_num, UINT8 DotPlace)
   96: {
000857 121A78            LCALL    ?L?COM0050
;---- Variable 'R_num' assigned to Register 'R2' ----
00085A AA05              MOV      R2,AR5
;---- Variable 'DotPlace' assigned to Register 'R3' ----
   97:     if(L_num>9999)
   98:     {
00085C D3                SETB     C
00085D E0                MOVX     A,@DPTR
00085E 940F              SUBB     A,#0FH
000860 900040            MOV      DPTR,#L_num
000863 E0                MOVX     A,@DPTR
000864 9427              SUBB     A,#027H
000866 4007              JC       ?C0034?LED
   99:         L_num = 9999;
  100:     }
000868 7427              MOV      A,#027H
00086A F0                MOVX     @DPTR,A
00086B A3                INC      DPTR
00086C 740F              MOV      A,#0FH
00086E F0                MOVX     @DPTR,A
  101:     if(R_num>99)
00086F         ?C0034?LED:
  102:     {
00086F EA                MOV      A,R2
000870 D3                SETB     C
000871 9463              SUBB     A,#063H
000873 4002              JC       ?C0035?LED
  103:         R_num = 99;
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 12


  104:     }
000875 7A63              MOV      R2,#063H
  105:     gLedBuf[0] = L_num/1000;
000877         ?C0035?LED:
  106:     gLedBuf[1] = L_num/100%10;
000877 900040            MOV      DPTR,#L_num
00087A E0                MOVX     A,@DPTR
00087B FE                MOV      R6,A
00087C A3                INC      DPTR
00087D E0                MOVX     A,@DPTR
00087E FF                MOV      R7,A
00087F 7C03              MOV      R4,#03H
000881 7DE8              MOV      R5,#0E8H
000883 1201A8            LCALL    ?C?UIDIV
000886 9000C5            MOV      DPTR,#gLedBuf
000889 EF                MOV      A,R7
00088A 7141              ACALL    ?L?COM001C
00088C 7D64              MOV      R5,#064H
00088E 11AE              ACALL    ?L?COM0003
000890 11C5              ACALL    ?L?COM0006
000892 9000C7            MOV      DPTR,#gLedBuf+02H
000895 11BB              ACALL    ?L?COM0004
000897 9000C8            MOV      DPTR,#gLedBuf+03H
00089A ED                MOV      A,R5
00089B F0                MOVX     @DPTR,A
  107:     gLedBuf[2] = L_num/10%10;
  108:     gLedBuf[3] = L_num%10;
  109:     gLedBuf[4] = R_num/10%10;
00089C EA                MOV      A,R2
00089D 75F00A            MOV      B,#0AH
0008A0 84                DIV      AB
0008A1 121A81            LCALL    ?L?COM0051
  110:     gLedBuf[5] = R_num%10;
0008A4 EA                MOV      A,R2
0008A5 121A81            LCALL    ?L?COM0051
  111:     gShowDot = DotPlace;
0008A8 9000CC            MOV      DPTR,#gShowDot
0008AB EB                MOV      A,R3
0008AC F0                MOVX     @DPTR,A
  112: }
0008AD 22                RET      
----- FUNCTION _led_ShowNumber (END) -------


----- FUNCTION ?L?COM0003 (BEGIN) -----
0008AE 1201A8            LCALL    ?C?UIDIV
0008B1 7C00              MOV      R4,#00H
0008B3 7D0A              MOV      R5,#0AH
0008B5 1201A8            LCALL    ?C?UIDIV
0008B8 9000C6            MOV      DPTR,#gLedBuf+01H
0008BB         ?L?COM0004:
0008BB ED                MOV      A,R5
0008BC F0                MOVX     @DPTR,A
0008BD 900040            MOV      DPTR,#L_num
0008C0         ?L?COM0005:
0008C0 E0                MOVX     A,@DPTR
0008C1 FE                MOV      R6,A
0008C2 A3                INC      DPTR
0008C3 E0                MOVX     A,@DPTR
0008C4 FF                MOV      R7,A
0008C5         ?L?COM0006:
0008C5 7C00              MOV      R4,#00H
0008C7 7D0A              MOV      R5,#0AH
0008C9 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM0003 (END) -------
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 13




----- FUNCTION _led_ShowNumber1 (BEGIN) -----
 FILE: 'Driver\LED.c'
  114: void led_ShowNumber1(UINT16 L_num, UINT16 R_num, UINT8 DotPlace)
  115: {
0008CC 900042            MOV      DPTR,#R_num
0008CF EC                MOV      A,R4
0008D0 F0                MOVX     @DPTR,A
0008D1 A3                INC      DPTR
0008D2 ED                MOV      A,R5
0008D3 F0                MOVX     @DPTR,A
0008D4 121A78            LCALL    ?L?COM0050
;---- Variable 'DotPlace' assigned to Register 'R3' ----
  116:     if(L_num>999)
  117:     {
0008D7 D3                SETB     C
0008D8 94E7              SUBB     A,#0E7H
0008DA EE                MOV      A,R6
0008DB 9403              SUBB     A,#03H
0008DD 4006              JC       ?C0037?LED
  118:         L_num = 999;
  119:     }
0008DF 900040            MOV      DPTR,#L_num
0008E2 121A8A            LCALL    ?L?COM0057
  120:     if(R_num>999)
0008E5         ?C0037?LED:
  121:     {
0008E5 D3                SETB     C
0008E6 900043            MOV      DPTR,#R_num+01H
0008E9 E0                MOVX     A,@DPTR
0008EA 94E7              SUBB     A,#0E7H
0008EC 900042            MOV      DPTR,#R_num
0008EF E0                MOVX     A,@DPTR
0008F0 9403              SUBB     A,#03H
0008F2 4003              JC       ?C0038?LED
  122:         R_num = 999;
  123:     }
0008F4 121A8A            LCALL    ?L?COM0057
  124:     gLedBuf[0] = L_num/100%10;
0008F7         ?C0038?LED:
  125:     gLedBuf[1] = L_num/10%10;
0008F7 7142              ACALL    ?L?COM001D
0008F9 7D64              MOV      R5,#064H
0008FB 1201A8            LCALL    ?C?UIDIV
0008FE 11C5              ACALL    ?L?COM0006
000900 9000C5            MOV      DPTR,#gLedBuf
000903 ED                MOV      A,R5
000904 7141              ACALL    ?L?COM001C
000906 7D0A              MOV      R5,#0AH
000908 11AE              ACALL    ?L?COM0003
00090A 9000C7            MOV      DPTR,#gLedBuf+02H
00090D ED                MOV      A,R5
00090E F0                MOVX     @DPTR,A
  126:     gLedBuf[2] = L_num%10;
  127:     gLedBuf[3] = R_num/100;
00090F 900042            MOV      DPTR,#R_num
000912 7145              ACALL    ?L?COM001E
000914 7D64              MOV      R5,#064H
000916 1201A8            LCALL    ?C?UIDIV
000919 9000C8            MOV      DPTR,#gLedBuf+03H
00091C EF                MOV      A,R7
00091D F0                MOVX     @DPTR,A
  128:     if(gLedBuf[3] == 0)
00091E 7003              JNZ      ?C0039?LED
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 14


  129:     {
  130:         gLedBuf[3] = 12;
000920 740C              MOV      A,#0CH
000922 F0                MOVX     @DPTR,A
  131:     }
000923         ?C0039?LED:
  132:     gLedBuf[4] = R_num/10%10;
000923 900042            MOV      DPTR,#R_num
000926 11C0              ACALL    ?L?COM0005
000928 11C5              ACALL    ?L?COM0006
00092A AF05              MOV      R7,AR5
00092C 9000C9            MOV      DPTR,#gLedBuf+04H
00092F EF                MOV      A,R7
000930 F0                MOVX     @DPTR,A
  133:     if(gLedBuf[4] == 0)
000931 7003              JNZ      ?C0040?LED
  134:     {
  135:         gLedBuf[4] = 12;
000933 740C              MOV      A,#0CH
000935 F0                MOVX     @DPTR,A
  136:     }
000936         ?C0040?LED:
  137:     gLedBuf[5] = R_num%10;
000936 900042            MOV      DPTR,#R_num
000939 11C0              ACALL    ?L?COM0005
00093B 9000CA            MOV      DPTR,#gLedBuf+05H
00093E ED                MOV      A,R5
00093F F0                MOVX     @DPTR,A
  138:     gShowDot = DotPlace;
000940 9000CC            MOV      DPTR,#gShowDot
000943 EB                MOV      A,R3
000944 F0                MOVX     @DPTR,A
  139: }
000945 22                RET      
----- FUNCTION _led_ShowNumber1 (END) -------


----- FUNCTION app_brushCycle1s (BEGIN) -----
 FILE: 'App\app_brush.c'
  114: void app_brushCycle1s(void)
  115: {
  116:     switch (app_brushCard())
  117:     {
000946 1215AE            LCALL    app_brushCard
000949 EF                MOV      A,R7
00094A 24FE              ADD      A,#0FEH
00094C 7002              JNZ      $ + 4H
00094E 4133              AJMP     ?C0039?APP_BRUSH
000950 14                DEC      A
000951 7002              JNZ      $ + 4H
000953 21F4              AJMP     ?C0033?APP_BRUSH
000955 2402              ADD      A,#02H
000957 6002              JZ       $ + 4H
000959 611A              AJMP     ?C0023?APP_BRUSH
  118:         case MEM_CARD:
  119:             if(hwa_mifareReadBlock(gBuff,4))
00095B         ?C0024?APP_BRUSH:
  120:             {
00095B 7134              ACALL    ?L?COM0010
00095D 7D04              MOV      R5,#04H
00095F 7174              ACALL    _hwa_mifareReadBlock
000961 4002              JC       $ + 4H
000963 611A              AJMP     ?C0023?APP_BRUSH
  121:                 if(u8_FirstBrushCardDly)
  122:                 {
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 15


000965 9000C4            MOV      DPTR,#u8_FirstBrushCardDly
000968 E0                MOVX     A,@DPTR
000969 607B              JZ       ?C0026?APP_BRUSH
  123:                     if(gBuff[0]==0x01 && gBuff[1]==0x0A)
  124:                     {
00096B 9000AC            MOV      DPTR,#gBuff
00096E E0                MOVX     A,@DPTR
00096F 6401              XRL      A,#01H
000971 7032              JNZ      ?C0027?APP_BRUSH
000973 A3                INC      DPTR
000974 E0                MOVX     A,@DPTR
000975 B40A2D            CJNE     A,#0AH,?C0027?APP_BRUSH
  125:                         s_System.Money += 1000;
  126: 						if (s_System.Money > 20000)
000978 9000A6            MOV      DPTR,#s_System+012H
00097B E0                MOVX     A,@DPTR
00097C 24E8              ADD      A,#0E8H
00097E F0                MOVX     @DPTR,A
00097F 9000A5            MOV      DPTR,#s_System+011H
000982 E0                MOVX     A,@DPTR
000983 3403              ADDC     A,#03H
000985 F0                MOVX     @DPTR,A
  127: 						{
000986 D3                SETB     C
000987 A3                INC      DPTR
000988 121106            LCALL    ?L?COM0031
00098B 4004              JC       ?C0028?APP_BRUSH
  128: 							s_System.Money = 0;
  129: 						}
00098D E4                CLR      A
00098E F0                MOVX     @DPTR,A
00098F A3                INC      DPTR
000990 F0                MOVX     @DPTR,A
  130:                         s_System.Money -= s_System.Money%1000;
000991         ?C0028?APP_BRUSH:
  131:                     }
000991 9000A5            MOV      DPTR,#s_System+011H
000994 F1DF              ACALL    ?L?COM0032
000996 C3                CLR      C
000997 EB                MOV      A,R3
000998 9D                SUBB     A,R5
000999 FE                MOV      R6,A
00099A EA                MOV      A,R2
00099B 9C                SUBB     A,R4
00099C 9000A5            MOV      DPTR,#s_System+011H
00099F F0                MOVX     @DPTR,A
0009A0 A3                INC      DPTR
0009A1 CE                XCH      A,R6
0009A2 F0                MOVX     @DPTR,A
  132:                     else if(gBuff[0]==0xFA && gBuff[1]==0x01)
0009A3 8041              SJMP     ?C0026?APP_BRUSH
0009A5         ?C0027?APP_BRUSH:
  133:                     {
0009A5 9000AC            MOV      DPTR,#gBuff
0009A8 E0                MOVX     A,@DPTR
0009A9 64FA              XRL      A,#0FAH
0009AB 7039              JNZ      ?C0026?APP_BRUSH
0009AD A3                INC      DPTR
0009AE E0                MOVX     A,@DPTR
0009AF 6401              XRL      A,#01H
0009B1 7033              JNZ      ?C0026?APP_BRUSH
  134:                         if(s_System.Money<20000)
  135:                         {
0009B3 C3                CLR      C
0009B4 121103            LCALL    ?L?COM0030
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 16


0009B7 502D              JNC      ?C0026?APP_BRUSH
  136:                             s_System.Money += 100;
  137:                             if (s_System.Money % 1000 == 0 && s_System.Money/1000>0)
0009B9 A3                INC      DPTR
0009BA E0                MOVX     A,@DPTR
0009BB 2464              ADD      A,#064H
0009BD F0                MOVX     @DPTR,A
0009BE 9000A5            MOV      DPTR,#s_System+011H
0009C1 E0                MOVX     A,@DPTR
0009C2 3400              ADDC     A,#00H
0009C4 F0                MOVX     @DPTR,A
  138:                             {
0009C5 F1DF              ACALL    ?L?COM0032
0009C7 ED                MOV      A,R5
0009C8 4C                ORL      A,R4
0009C9 701B              JNZ      ?C0026?APP_BRUSH
0009CB 7C03              MOV      R4,#03H
0009CD 7DE8              MOV      R5,#0E8H
0009CF 121A9A            LCALL    ?L?COM005C
0009D2 D3                SETB     C
0009D3 EF                MOV      A,R7
0009D4 9400              SUBB     A,#00H
0009D6 EE                MOV      A,R6
0009D7 9400              SUBB     A,#00H
0009D9 400B              JC       ?C0026?APP_BRUSH
  139:                                 s_System.Money -= 1000;
  140:                             }
0009DB E0                MOVX     A,@DPTR
0009DC 2418              ADD      A,#018H
0009DE F0                MOVX     @DPTR,A
0009DF 9000A5            MOV      DPTR,#s_System+011H
0009E2 E0                MOVX     A,@DPTR
0009E3 34FC              ADDC     A,#0FCH
0009E5 F0                MOVX     @DPTR,A
  141:                         }
  142:                     }
  143:                 }
  144:                 led_ShowNumber1(s_System.Money/100, u8_BrushNum, 0);
0009E6         ?C0026?APP_BRUSH:
  145:                 u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
0009E6 F1D6              ACALL    ?L?COM003A
0009E8 7159              ACALL    ?L?COM000C
0009EA 716B              ACALL    ?L?COM003D
  146:                 buzzer_SoundNumber(1);
0009EC 7F01              MOV      R7,#01H
0009EE 713B              ACALL    _buzzer_SoundNumber
  147:                 b_SettingChange = TRUE;
0009F0 D207              SETB     b_SettingChange
  148:             }
  149:             break;
0009F2 611A              AJMP     ?C0023?APP_BRUSH
  150:             
  151:         case PWD_CARD:                                 //从初始卡中读取管理卡密码，并储存至E2
0009F4         ?C0033?APP_BRUSH:
  152:             if(hwa_mifareReadBlock(gBuff,4))       //读取管理卡密码
0009F4 7134              ACALL    ?L?COM0010
0009F6 7D04              MOV      R5,#04H
0009F8 7174              ACALL    _hwa_mifareReadBlock
0009FA 4002              JC       $ + 4H
0009FC 611A              AJMP     ?C0023?APP_BRUSH
  153:             {
  154:                 memcpy(&s_System, gBuff, 16);
0009FE 7894              MOV      R0,#LOW s_System
000A00 7C00              MOV      R4,#HIGH s_System
000A02 7D01              MOV      R5,#01H
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 17


000A04 7134              ACALL    ?L?COM0010
000A06 F1C6              ACALL    ?L?COM0045
  155: 
  156: 	            if (hwa_mifareReadBlock(gBuff, 5))			//读取管理卡和用户卡密码以及扇区
000A08 7134              ACALL    ?L?COM0010
000A0A 7D05              MOV      R5,#05H
000A0C 7174              ACALL    _hwa_mifareReadBlock
000A0E 4002              JC       $ + 4H
000A10 611A              AJMP     ?C0023?APP_BRUSH
  157: 	            {
  158: 	                if(gBuff[0] == 0x01)
000A12 9000AC            MOV      DPTR,#gBuff
000A15 E0                MOVX     A,@DPTR
000A16 B40108            CJNE     A,#01H,?C0036?APP_BRUSH
  159: 	                {
  160: 	                    s_System.RecoveryOldCard = 1;
000A19 9000A4            MOV      DPTR,#s_System+010H
000A1C 7401              MOV      A,#01H
000A1E F0                MOVX     @DPTR,A
  161: 	                }
000A1F 8005              SJMP     ?C0038?APP_BRUSH
000A21         ?C0036?APP_BRUSH:
  162: 	                else
  163: 	                {
  164: 	                    s_System.RecoveryOldCard = 0;
000A21 E4                CLR      A
000A22 9000A4            MOV      DPTR,#s_System+010H
000A25 F0                MOVX     @DPTR,A
  165: 	                }
  166: 	            }
  167: 	            else
  168: 	            {
  169: 	                break;
  170: 	            }
000A26         ?C0038?APP_BRUSH:
  171:                 app_configWrite(SYSTEM_SETTING_SECTOR);
000A26 E4                CLR      A
000A27 FF                MOV      R7,A
000A28 1210BD            LCALL    _app_configWrite
  172:                 buzzer_SoundNumber(1);
000A2B 7F01              MOV      R7,#01H
000A2D 713B              ACALL    _buzzer_SoundNumber
  173:                 b_FactorySystem = FALSE;
000A2F C208              CLR      b_FactorySystem
  174:             }
  175:             break;
000A31 611A              AJMP     ?C0023?APP_BRUSH
  176:             
  177:         case USER_CARD:
000A33         ?C0039?APP_BRUSH:
  178: //            pMoney->money = 1000;
  179: //            hwa_mifareWriteSector(gBuff, s_System.Sector);
  180: //            break;
  181:             if(hwa_mifareReadSector(gBuff, s_System.Sector))
000A33 7134              ACALL    ?L?COM0010
000A35 90009A            MOV      DPTR,#s_System+06H
000A38 E0                MOVX     A,@DPTR
000A39 FD                MOV      R5,A
000A3A 719F              ACALL    _hwa_mifareReadSector
000A3C 4002              JC       $ + 4H
000A3E 611A              AJMP     ?C0023?APP_BRUSH
  182:             {
  183:                 if(b_SettingChange == FALSE)
000A40 200727            JB       b_SettingChange,?C0041?APP_BRUSH
  184:                 {
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 18


  185:                     led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
000A43 AB08              MOV      R3,pMoney
000A45 AA09              MOV      R2,pMoney+01H
000A47 A90A              MOV      R1,pMoney+02H
000A49 120213            LCALL    ?C?ILDPTR
000A4C FB                MOV      R3,A
000A4D AAF0              MOV      R2,B
000A4F 7C00              MOV      R4,#00H
000A51 7D64              MOV      R5,#064H
000A53 F1E8              ACALL    ?L?COM0033
000A55 C006              PUSH     AR6
000A57 C007              PUSH     AR7
000A59 7C00              MOV      R4,#00H
000A5B 7D64              MOV      R5,#064H
000A5D 121A9A            LCALL    ?L?COM005C
000A60 D007              POP      AR7
000A62 D006              POP      AR6
000A64 7B08              MOV      R3,#08H
000A66 1157              ACALL    _led_ShowNumber
  186:                     u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
  187:                     buzzer_SoundNumber(1);
  188:                 }
000A68 6105              AJMP     ?C0065?APP_BRUSH
000A6A         ?C0041?APP_BRUSH:
  189:                 else
  190:                 {
  191:                     if ((pMoney->money+s_System.Money <= 20000
000A6A 121A01            LCALL    ?L?COM0015
000A6D 5009              JNC      ?C0045?APP_BRUSH
000A6F 121A49            LCALL    ?L?COM0037
000A72 12050B            LCALL    ?C?MEMCMP
000A75 EF                MOV      A,R7
000A76 700C              JNZ      ?C0044?APP_BRUSH
000A78         ?C0045?APP_BRUSH:
000A78 9000A5            MOV      DPTR,#s_System+011H
000A7B E0                MOVX     A,@DPTR
000A7C 7002              JNZ      ?C0060?APP_BRUSH
000A7E A3                INC      DPTR
000A7F E0                MOVX     A,@DPTR
000A80         ?C0060?APP_BRUSH:
000A80 6002              JZ       $ + 4H
000A82 610B              AJMP     ?C0043?APP_BRUSH
000A84         ?C0044?APP_BRUSH:
  192:                         && memcmp(LastCardId, gCard_UID, 5))
  193:                         || s_System.Money == 0)
  194:                     {
  195:                         if(s_System.Money == 0)
000A84 9000A5            MOV      DPTR,#s_System+011H
000A87 E0                MOVX     A,@DPTR
000A88 7002              JNZ      ?C0061?APP_BRUSH
000A8A A3                INC      DPTR
000A8B E0                MOVX     A,@DPTR
000A8C         ?C0061?APP_BRUSH:
000A8C 701B              JNZ      ?C0046?APP_BRUSH
  196:                         {
  197:                             pMoney->money = 0;
000A8E AB08              MOV      R3,pMoney
000A90 AA09              MOV      R2,pMoney+01H
000A92 A90A              MOV      R1,pMoney+02H
000A94 F5F0              MOV      B,A
000A96 120276            LCALL    ?C?ISTPTR
  198:                             if(hwa_mifareWriteSector(gBuff, s_System.Sector))
000A99 7134              ACALL    ?L?COM0010
000A9B 9170              ACALL    ?L?COM004F
000A9D 5071              JNC      ?C0066?APP_BRUSH
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 19


  199:                             {
  200:                                 buzzer_SoundNumber(1);
000A9F 7F01              MOV      R7,#01H
000AA1 713B              ACALL    _buzzer_SoundNumber
  201:                                 led_ShowNumber1(pMoney->money/100, u8_BrushNum, 0);
000AA3 714D              ACALL    ?L?COM000B
000AA5 716B              ACALL    ?L?COM003D
  202:                                 u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
  203:                                 break;
000AA7 8071              SJMP     ?C0023?APP_BRUSH
  204:                             }
000AA9         ?C0046?APP_BRUSH:
  205:                             else
  206:                             {
  207:                                 buzzer_SoundNumber(2);
  208:                             }
  209:                         }
  210:                         else
  211:                         {
  212:                             pMoney->money += s_System.Money;
000AA9 F1D6              ACALL    ?L?COM003A
000AAB AB08              MOV      R3,pMoney
000AAD AA09              MOV      R2,pMoney+01H
000AAF A90A              MOV      R1,pMoney+02H
000AB1 EE                MOV      A,R6
000AB2 8FF0              MOV      B,R7
000AB4 12023E            LCALL    ?C?IILDPTR
  213:                             if(hwa_mifareWriteSector(gBuff, s_System.Sector))
000AB7 7134              ACALL    ?L?COM0010
000AB9 9170              ACALL    ?L?COM004F
000ABB 5057              JNC      ?C0042?APP_BRUSH
  214:                             {
  215:                                 MoneySum += s_System.Money/100;
000ABD 900090            MOV      DPTR,#MoneySum
000AC0 E0                MOVX     A,@DPTR
000AC1 F8                MOV      R0,A
000AC2 A3                INC      DPTR
000AC3 E0                MOVX     A,@DPTR
000AC4 F9                MOV      R1,A
000AC5 A3                INC      DPTR
000AC6 E0                MOVX     A,@DPTR
000AC7 FA                MOV      R2,A
000AC8 A3                INC      DPTR
000AC9 E0                MOVX     A,@DPTR
000ACA FB                MOV      R3,A
000ACB C000              PUSH     AR0
000ACD 9000A5            MOV      DPTR,#s_System+011H
000AD0 7145              ACALL    ?L?COM001E
000AD2 7D64              MOV      R5,#064H
000AD4 1201A8            LCALL    ?C?UIDIV
000AD7 E4                CLR      A
000AD8 FC                MOV      R4,A
000AD9 FD                MOV      R5,A
000ADA D000              POP      AR0
000ADC EB                MOV      A,R3
000ADD 2F                ADD      A,R7
000ADE FF                MOV      R7,A
000ADF EA                MOV      A,R2
000AE0 3E                ADDC     A,R6
000AE1 FE                MOV      R6,A
000AE2 ED                MOV      A,R5
000AE3 39                ADDC     A,R1
000AE4 FD                MOV      R5,A
000AE5 EC                MOV      A,R4
000AE6 38                ADDC     A,R0
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 20


000AE7 FC                MOV      R4,A
000AE8 900090            MOV      DPTR,#MoneySum
000AEB 120379            LCALL    ?C?LSTXDATA
  216:                                 u8_BrushNum++;
000AEE 9000C3            MOV      DPTR,#u8_BrushNum+01H
000AF1 E0                MOVX     A,@DPTR
000AF2 04                INC      A
000AF3 F0                MOVX     @DPTR,A
000AF4 7006              JNZ      ?C0062?APP_BRUSH
000AF6 9000C2            MOV      DPTR,#u8_BrushNum
000AF9 E0                MOVX     A,@DPTR
000AFA 04                INC      A
000AFB F0                MOVX     @DPTR,A
000AFC         ?C0062?APP_BRUSH:
  217:                                 app_configWrite(MONEY_SECTOR);
000AFC 7F01              MOV      R7,#01H
000AFE 1210BD            LCALL    _app_configWrite
  218:                                 led_ShowNumber1(pMoney->money/100, u8_BrushNum, 0);
000B01 714D              ACALL    ?L?COM000B
000B03 11CC              ACALL    _led_ShowNumber1
  219:                                 u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
000B05         
000B05 716D              ACALL    ?L?COM003E
  220:                                 buzzer_SoundNumber(1);
000B07 7F01              MOV      R7,#01H
  221:                             }
  222:                         }
  223:                     }
000B09 8007              SJMP     ?C0067?APP_BRUSH
000B0B         ?C0043?APP_BRUSH:
  224:                     else if(pMoney->money+s_System.Money > 20000)
000B0B 121A01            LCALL    ?L?COM0015
000B0E 4004              JC       ?C0042?APP_BRUSH
  225:                     {
  226:                         buzzer_SoundNumber(2);
000B10         
000B10 7F02              MOV      R7,#02H
000B12         
000B12 713B              ACALL    _buzzer_SoundNumber
  227:                     }
  228:                 }
000B14         ?C0042?APP_BRUSH:
  229:                 memcpy(LastCardId, gCard_UID, 5);
000B14 121A49            LCALL    ?L?COM0037
000B17 1200F6            LCALL    ?C?COPY
  230:             }
  231:             break;
  232:             
  233:         default:
  234:             break;
  235:     }
000B1A         ?C0023?APP_BRUSH:
  236:     
  237:     if(u8_FirstBrushCardDly)
000B1A 9000C4            MOV      DPTR,#u8_FirstBrushCardDly
000B1D E0                MOVX     A,@DPTR
000B1E 6003              JZ       ?C0054?APP_BRUSH
  238:     {
  239:         u8_FirstBrushCardDly--;
000B20 14                DEC      A
000B21 F0                MOVX     @DPTR,A
  240:     }
000B22 22                RET      
000B23         ?C0054?APP_BRUSH:
  241:     else if(!b_FactorySystem)
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 21


000B23 20080C            JB       b_FactorySystem,?C0059?APP_BRUSH
  242:     {
  243:         if(b_SettingChange)
000B26 300706            JNB      b_SettingChange,?C0057?APP_BRUSH
  244:         {
  245:             led_ShowNumber1(s_System.Money/100, u8_BrushNum, 0);
000B29 F1D6              ACALL    ?L?COM003A
000B2B 7159              ACALL    ?L?COM000C
000B2D 01CC              AJMP     _led_ShowNumber1
  246:         }
000B2F         ?C0057?APP_BRUSH:
  247:         else
  248:         {
  249:             gLedBuf[0] = 12;
000B2F 121A20            LCALL    ?L?COM0025
  250:             gLedBuf[1] = 15;
  251:             gLedBuf[2] = 15;
  252:             gLedBuf[3] = 15;
  253:             gLedBuf[4] = 15;
  254:             gLedBuf[5] = 12;
  255:             gShowDot = 0;
  256:         }
  257:     }
  258: }
000B32         ?C0059?APP_BRUSH:
000B32 22                RET      
----- FUNCTION app_brushCycle1s (END) -------


----- FUNCTION ?L?COM000F (BEGIN) -----
000B33 F0                MOVX     @DPTR,A
000B34         ?L?COM0010:
000B34 7B01              MOV      R3,#01H
000B36 7A00              MOV      R2,#HIGH gBuff
000B38 79AC              MOV      R1,#LOW gBuff
000B3A 22                RET      
----- FUNCTION ?L?COM000F (END) -------


----- FUNCTION _buzzer_SoundNumber (BEGIN) -----
 FILE: 'Driver\buzzer.c'
   28: void buzzer_SoundNumber(UINT8 num)
   29: {
;---- Variable 'num' assigned to Register 'R7' ----
   30:     SoundNumberCount = num;
   30: }
000B3B 9000D1            MOV      DPTR,#SoundNumberCount
000B3E EF                MOV      A,R7
000B3F F0                MOVX     @DPTR,A
   30: 
000B40 22                RET      
----- FUNCTION _buzzer_SoundNumber (END) -------


----- FUNCTION ?L?COM001C (BEGIN) -----
000B41 F0                MOVX     @DPTR,A
000B42         ?L?COM001D:
000B42 900040            MOV      DPTR,#L_num
000B45         ?L?COM001E:
000B45 E0                MOVX     A,@DPTR
000B46 FE                MOV      R6,A
000B47 A3                INC      DPTR
000B48 E0                MOVX     A,@DPTR
000B49 FF                MOV      R7,A
000B4A 7C00              MOV      R4,#00H
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 22


000B4C 22                RET      
----- FUNCTION ?L?COM001C (END) -------


----- FUNCTION ?L?COM000B (BEGIN) -----
000B4D AB08              MOV      R3,pMoney
000B4F AA09              MOV      R2,pMoney+01H
000B51 A90A              MOV      R1,pMoney+02H
000B53 120213            LCALL    ?C?ILDPTR
000B56 FF                MOV      R7,A
000B57 AEF0              MOV      R6,B
000B59         ?L?COM000C:
000B59 7C00              MOV      R4,#00H
000B5B 7D64              MOV      R5,#064H
000B5D 1201A8            LCALL    ?C?UIDIV
000B60 9000C2            MOV      DPTR,#u8_BrushNum
000B63 E0                MOVX     A,@DPTR
000B64 FC                MOV      R4,A
000B65 A3                INC      DPTR
000B66 E0                MOVX     A,@DPTR
000B67 FD                MOV      R5,A
000B68 E4                CLR      A
000B69 FB                MOV      R3,A
000B6A 22                RET      
----- FUNCTION ?L?COM000B (END) -------


----- FUNCTION ?L?COM003D (BEGIN) -----
000B6B 11CC              ACALL    _led_ShowNumber1
000B6D         ?L?COM003E:
000B6D 9000C4            MOV      DPTR,#u8_FirstBrushCardDly
000B70 7403              MOV      A,#03H
000B72 F0                MOVX     @DPTR,A
000B73 22                RET      
----- FUNCTION ?L?COM003D (END) -------


----- FUNCTION _hwa_mifareReadBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   55: BOOL hwa_mifareReadBlock(UINT8 *buff, UINT8 block)
   56: {
000B74 900046            MOV      DPTR,#buff
000B77 B1E5              ACALL    ?L?COM0008
000B79 A3                INC      DPTR
000B7A ED                MOV      A,R5
000B7B F0                MOVX     @DPTR,A
   57: 	UINT8 u8_ReadErrCount;
   58: 	UINT8 u8_Result;
   59: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
000B7C E4                CLR      A
000B7D A3                INC      DPTR
000B7E F0                MOVX     @DPTR,A
000B7F         ?C0018?HWA_MIFARE:
   60: 	{
   61: 		u8_Result = Read_Block(buff, block);
000B7F 900046            MOV      DPTR,#buff
000B82 9168              ACALL    ?L?COM0002
000B84 F9                MOV      R1,A
000B85 A3                INC      DPTR
000B86 E0                MOVX     A,@DPTR
000B87 FD                MOV      R5,A
000B88 12178A            LCALL    _Read_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   62: 		if (u8_Result == FM1702_OK)
000B8B EF                MOV      A,R7
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 23


000B8C 7002              JNZ      ?C0021?HWA_MIFARE
   63: 		{
   64: 			return TRUE;
000B8E D3                SETB     C
000B8F 22                RET      
   65: 		}
000B90         ?C0021?HWA_MIFARE:
   66: 		else if (u8_Result == FM1702_NOTAGERR)
000B90 EF                MOV      A,R7
000B91 B40102            CJNE     A,#01H,?C0020?HWA_MIFARE
   67: 		{
   68: 			return FALSE;
000B94 C3                CLR      C
000B95 22                RET      
   69: 		}
   70: 	}
000B96         ?C0020?HWA_MIFARE:
000B96 90004A            MOV      DPTR,#u8_ReadErrCount
000B99 F1FD              ACALL    ?L?COM0059
000B9B 40E2              JC       ?C0018?HWA_MIFARE
000B9D         ?C0019?HWA_MIFARE:
   71: 	return FALSE;
000B9D C3                CLR      C
   72: }
000B9E 22                RET      
----- FUNCTION _hwa_mifareReadBlock (END) -------


----- FUNCTION _hwa_mifareReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  157: BOOL hwa_mifareReadSector(UINT8 *dat, UINT8 sector)
  158: {
000B9F 900040            MOV      DPTR,#dat
000BA2 B1E5              ACALL    ?L?COM0008
000BA4 A3                INC      DPTR
000BA5 ED                MOV      A,R5
000BA6 F0                MOVX     @DPTR,A
  159: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  160: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
000BA7 121A5A            LCALL    ?L?COM003C
  161: 
  162: 	if (dat != NULL && sector > 0 && sector < 16)
000BAA 900040            MOV      DPTR,#dat
000BAD 9168              ACALL    ?L?COM0002
000BAF 4A                ORL      A,R2
000BB0 4B                ORL      A,R3
000BB1 7002              JNZ      $ + 4H
000BB3 8163              AJMP     ?C0044?HWA_MIFARE
000BB5 A3                INC      DPTR
000BB6 E0                MOVX     A,@DPTR
000BB7 FF                MOV      R7,A
000BB8 D3                SETB     C
000BB9 9400              SUBB     A,#00H
000BBB 5002              JNC      $ + 4H
000BBD 8163              AJMP     ?C0044?HWA_MIFARE
000BBF EF                MOV      A,R7
000BC0 9410              SUBB     A,#010H
000BC2 4002              JC       $ + 4H
000BC4 8163              AJMP     ?C0044?HWA_MIFARE
  163: 	{
  164: 		if (hwa_mifareReadBlock((UINT8*)&s_NormalBuff, block) == FALSE)
000BC6 91D8              ACALL    ?L?COM0019
000BC8 A3                INC      DPTR
000BC9 E0                MOVX     A,@DPTR
000BCA FD                MOV      R5,A
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 24


000BCB 7174              ACALL    _hwa_mifareReadBlock
000BCD 4001              JC       ?C0045?HWA_MIFARE
  165: 		{
  166: 			return FALSE;
000BCF 22                RET      
  167: 		}
000BD0         ?C0045?HWA_MIFARE:
  168: 
  169: 		if (hwa_mifareReadBlock((UINT8*)&s_BackupBuff, block) == FALSE)
000BD0 B19F              ACALL    ?L?COM002E
000BD2 900044            MOV      DPTR,#block
000BD5 E0                MOVX     A,@DPTR
000BD6 FD                MOV      R5,A
000BD7 7174              ACALL    _hwa_mifareReadBlock
000BD9 4001              JC       ?C0047?HWA_MIFARE
  170: 		{
  171: 			return FALSE;
000BDB 22                RET      
  172: 		}
000BDC         ?C0047?HWA_MIFARE:
  173: 
  174: 		hwa_mifareCheckBlock();
000BDC B1A6              ACALL    hwa_mifareCheckBlock
  175: 
  176: 		if (NormalErrorFlag && BackupErrorFlag)				//正常块和备份块都校验错误
000BDE 300512            JNB      NormalErrorFlag,?C0048?HWA_MIFARE
000BE1 30040F            JNB      BackupErrorFlag,?C0048?HWA_MIFARE
  177: 		{
  178:             if(s_System.RecoveryOldCard)
000BE4 9000A4            MOV      DPTR,#s_System+010H
000BE7 E0                MOVX     A,@DPTR
000BE8 6007              JZ       ?C0049?HWA_MIFARE
  179:             {
  180:                 hwa_mifareRecoveryOldCard(sector);				//兼容旧卡
000BEA 900043            MOV      DPTR,#sector
000BED E0                MOVX     A,@DPTR
000BEE FF                MOV      R7,A
000BEF B10A              ACALL    _hwa_mifareRecoveryOldCard
  181:             }
000BF1         ?C0049?HWA_MIFARE:
  182: 			return FALSE;
000BF1 C3                CLR      C
000BF2 22                RET      
  183: 		}
000BF3         ?C0048?HWA_MIFARE:
  184: 		else if (BackupErrorFlag)							//备份块校验错误
000BF3 30040C            JNB      BackupErrorFlag,?C0051?HWA_MIFARE
  185: 		{
  186: 			if (hwa_mifareWriteBlock((UINT8*)&s_NormalBuff, blockBak) == FALSE)
000BF6 91D8              ACALL    ?L?COM0019
000BF8 900045            MOV      DPTR,#blockBak
000BFB E0                MOVX     A,@DPTR
000BFC FD                MOV      R5,A
000BFD 91DF              ACALL    _hwa_mifareWriteBlock
000BFF 4028              JC       ?C0050?HWA_MIFARE
  187: 			{
  188: 				return FALSE;
000C01 22                RET      
  189: 			}
  190: 		}
000C02         ?C0051?HWA_MIFARE:
  191: 		else if (NormalErrorFlag							//正常块校验错误
000C02 200518            JB       NormalErrorFlag,?C0055?HWA_MIFARE
000C05 900072            MOV      DPTR,#s_BackupBuff+02H
000C08 E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 25


000C09 FF                MOV      R7,A
000C0A 900082            MOV      DPTR,#s_NormalBuff+02H
000C0D E0                MOVX     A,@DPTR
000C0E B5070C            CJNE     A,AR7,?C0055?HWA_MIFARE
000C11 900073            MOV      DPTR,#s_BackupBuff+03H
000C14 E0                MOVX     A,@DPTR
000C15 FF                MOV      R7,A
000C16 900083            MOV      DPTR,#s_NormalBuff+03H
000C19 E0                MOVX     A,@DPTR
000C1A 6F                XRL      A,R7
000C1B 600C              JZ       ?C0050?HWA_MIFARE
000C1D         ?C0055?HWA_MIFARE:
  192: 			|| s_NormalBuff.crc[0] != s_BackupBuff.crc[0]	//正常块和备份块校验正确但数据不一样，用备份块替换正常块
  193: 			|| s_NormalBuff.crc[1] != s_BackupBuff.crc[1]
  194: 			)
  195: 		{
  196: 			if (hwa_mifareWriteBlock((UINT8*)&s_BackupBuff, block) == FALSE)
000C1D B19F              ACALL    ?L?COM002E
000C1F 900044            MOV      DPTR,#block
000C22 E0                MOVX     A,@DPTR
000C23 FD                MOV      R5,A
000C24 91DF              ACALL    _hwa_mifareWriteBlock
000C26 4001              JC       ?C0050?HWA_MIFARE
  197: 			{
  198: 				return FALSE;
000C28 22                RET      
  199: 			}
  200: 		}
000C29         ?C0050?HWA_MIFARE:
  201: 		if (BackupErrorFlag)
000C29 900040            MOV      DPTR,#dat
000C2C 9168              ACALL    ?L?COM0002
000C2E F8                MOV      R0,A
000C2F AC02              MOV      R4,AR2
000C31 AD03              MOV      R5,AR3
000C33 7B01              MOV      R3,#01H
000C35 300406            JNB      BackupErrorFlag,?C0057?HWA_MIFARE
  202: 		{
  203: 			memcpy(dat, (UINT8*)&s_NormalBuff, DATA_BLOCK_SIZE);
000C38 7A00              MOV      R2,#HIGH s_NormalBuff
000C3A 7980              MOV      R1,#LOW s_NormalBuff
  204: 		}
000C3C 8004              SJMP     ?C0073?HWA_MIFARE
000C3E         ?C0057?HWA_MIFARE:
  205: 		else
  206: 		{
  207: 			memcpy(dat, (UINT8*)&s_BackupBuff, DATA_BLOCK_SIZE);
000C3E 7A00              MOV      R2,#HIGH s_BackupBuff
000C40 7970              MOV      R1,#LOW s_BackupBuff
000C42         
000C42 F1C6              ACALL    ?L?COM0045
  208: 		}
000C44         ?C0058?HWA_MIFARE:
  209: 		if (*(UINT16*)dat > 50000)
000C44 900040            MOV      DPTR,#dat
000C47 9168              ACALL    ?L?COM0002
000C49 F9                MOV      R1,A
000C4A 120213            LCALL    ?C?ILDPTR
000C4D FF                MOV      R7,A
000C4E AEF0              MOV      R6,B
000C50 E4                CLR      A
000C51 FC                MOV      R4,A
000C52 FD                MOV      R5,A
000C53 7B50              MOV      R3,#050H
000C55 7AC3              MOV      R2,#0C3H
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 26


000C57 F9                MOV      R1,A
000C58 F8                MOV      R0,A
000C59 C3                CLR      C
000C5A 120363            LCALL    ?C?SLCMP
000C5D 5002              JNC      ?C0059?HWA_MIFARE
  210: 		{
  211: 			return FALSE;
000C5F C3                CLR      C
000C60 22                RET      
  212: 		}
000C61         ?C0059?HWA_MIFARE:
  213: 		return TRUE;
000C61 D3                SETB     C
000C62 22                RET      
  214: 	}
000C63         ?C0044?HWA_MIFARE:
  215: 	return FALSE;
000C63 C3                CLR      C
  216: }
000C64 22                RET      
----- FUNCTION _hwa_mifareReadSector (END) -------


----- FUNCTION ?L?COM0001 (BEGIN) -----
000C65 900048            MOV      DPTR,#dat
000C68         ?L?COM0002:
000C68 E0                MOVX     A,@DPTR
000C69 FB                MOV      R3,A
000C6A A3                INC      DPTR
000C6B E0                MOVX     A,@DPTR
000C6C FA                MOV      R2,A
000C6D A3                INC      DPTR
000C6E E0                MOVX     A,@DPTR
000C6F 22                RET      
----- FUNCTION ?L?COM0001 (END) -------


----- FUNCTION ?L?COM004F (BEGIN) -----
000C70 90009A            MOV      DPTR,#s_System+06H
000C73 E0                MOVX     A,@DPTR
000C74 FD                MOV      R5,A
----- FUNCTION _hwa_mifareWriteSector (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  218: BOOL hwa_mifareWriteSector(UINT8 *dat, UINT8 sector)
  219: {
000C75 900048            MOV      DPTR,#dat
000C78 B1E5              ACALL    ?L?COM0008
;---- Variable 'sector' assigned to Register 'R5' ----
  220: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  221: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
000C7A ED                MOV      A,R5
000C7B 121A5A            LCALL    ?L?COM003C
  222: 	UINT16 crc;
  223: 	if (dat != NULL && sector > 0 && sector < 16)
000C7E 9165              ACALL    ?L?COM0001
000C80 4A                ORL      A,R2
000C81 4B                ORL      A,R3
000C82 6050              JZ       ?C0060?HWA_MIFARE
000C84 ED                MOV      A,R5
000C85 D3                SETB     C
000C86 9400              SUBB     A,#00H
000C88 404A              JC       ?C0060?HWA_MIFARE
000C8A ED                MOV      A,R5
000C8B 9410              SUBB     A,#010H
000C8D 5045              JNC      ?C0060?HWA_MIFARE
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 27


  224: 	{
  225: 		crc = hwa_mifareCheckOut(dat, USE_DATA_BLOCK_LEN);
000C8F 900048            MOV      DPTR,#dat
000C92 A3                INC      DPTR
000C93 A3                INC      DPTR
000C94 E0                MOVX     A,@DPTR
000C95 F9                MOV      R1,A
;---- Variable 'crc' assigned to Register 'R4/R5' ----
000C96 F17E              ACALL    ?L?COM002A
  226: 		dat[USE_DATA_BLOCK_LEN] = (UINT8)(crc >> 8);
000C98 EC                MOV      A,R4
000C99 FF                MOV      R7,A
000C9A 9165              ACALL    ?L?COM0001
000C9C F9                MOV      R1,A
000C9D 900002            MOV      DPTR,#02H
000CA0 EF                MOV      A,R7
000CA1 120174            LCALL    ?C?CSTOPTR
  227: 		dat[USE_DATA_BLOCK_LEN + 1] = (UINT8)(crc & 0xFF);
000CA4 ED                MOV      A,R5
000CA5 900003            MOV      DPTR,#03H
000CA8 120174            LCALL    ?C?CSTOPTR
  228: 		memcpy((UINT8*)&s_NormalBuff, dat, 16);
000CAB 7880              MOV      R0,#LOW s_NormalBuff
000CAD 7C00              MOV      R4,#HIGH s_NormalBuff
000CAF 7D01              MOV      R5,#01H
000CB1 9165              ACALL    ?L?COM0001
000CB3 F9                MOV      R1,A
000CB4 F1C6              ACALL    ?L?COM0045
  229: 		hwa_mifareEncrypt((UINT8*)&s_NormalBuff);
000CB6 91D8              ACALL    ?L?COM0019
000CB8 B16D              ACALL    _hwa_mifareEncrypt
  230: 		if (hwa_mifareWriteBlock((UINT8*)&s_NormalBuff, block) == FALSE)
000CBA 91D8              ACALL    ?L?COM0019
000CBC 90004B            MOV      DPTR,#block
000CBF E0                MOVX     A,@DPTR
000CC0 FD                MOV      R5,A
000CC1 91DF              ACALL    _hwa_mifareWriteBlock
000CC3 4001              JC       ?C0061?HWA_MIFARE
  231: 		{
  232: 			return FALSE;
000CC5 22                RET      
  233: 		}
000CC6         ?C0061?HWA_MIFARE:
  234: 		if (hwa_mifareWriteBlock((UINT8*)&s_NormalBuff, blockBak) == FALSE)
000CC6 91D8              ACALL    ?L?COM0019
000CC8 90004C            MOV      DPTR,#blockBak
000CCB E0                MOVX     A,@DPTR
000CCC FD                MOV      R5,A
000CCD 91DF              ACALL    _hwa_mifareWriteBlock
000CCF 4001              JC       ?C0063?HWA_MIFARE
  235: 		{
  236: 			return FALSE;
000CD1 22                RET      
  237: 		}
000CD2         ?C0063?HWA_MIFARE:
  238: 		return TRUE;
000CD2 D3                SETB     C
000CD3 22                RET      
  239: 	}
000CD4         ?C0060?HWA_MIFARE:
  240: 	return FALSE;
000CD4 C3                CLR      C
  241: }
000CD5 22                RET      
----- FUNCTION _hwa_mifareWriteSector (END) -------
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 28




----- FUNCTION ?L?COM0018 (BEGIN) -----
000CD6 EF                MOV      A,R7
000CD7 F0                MOVX     @DPTR,A
000CD8         ?L?COM0019:
000CD8 7B01              MOV      R3,#01H
000CDA 7A00              MOV      R2,#HIGH s_NormalBuff
000CDC 7980              MOV      R1,#LOW s_NormalBuff
000CDE 22                RET      
----- FUNCTION ?L?COM0018 (END) -------


----- FUNCTION _hwa_mifareWriteBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   74: BOOL hwa_mifareWriteBlock(UINT8 *buff, UINT8 block)
   75: {
000CDF 90004D            MOV      DPTR,#buff
000CE2 B1E5              ACALL    ?L?COM0008
000CE4 A3                INC      DPTR
000CE5 ED                MOV      A,R5
000CE6 F0                MOVX     @DPTR,A
   76: 	UINT8 u8_ReadErrCount;
   77: 	UINT8 u8_Result;
   78: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
000CE7 E4                CLR      A
000CE8 A3                INC      DPTR
000CE9 F0                MOVX     @DPTR,A
000CEA         ?C0025?HWA_MIFARE:
   79: 	{
   80: 		u8_Result = Write_Block(buff, block);
000CEA 90004D            MOV      DPTR,#buff
000CED 9168              ACALL    ?L?COM0002
000CEF F9                MOV      R1,A
000CF0 A3                INC      DPTR
000CF1 E0                MOVX     A,@DPTR
000CF2 FD                MOV      R5,A
000CF3 121898            LCALL    _Write_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   81: 		if (u8_Result == FM1702_OK)
000CF6 EF                MOV      A,R7
000CF7 7002              JNZ      ?C0028?HWA_MIFARE
   82: 		{
   83: 			return TRUE;
000CF9 D3                SETB     C
000CFA 22                RET      
   84: 		}
000CFB         ?C0028?HWA_MIFARE:
   85: 		else if (u8_Result == FM1702_NOTAGERR)
000CFB EF                MOV      A,R7
000CFC B40102            CJNE     A,#01H,?C0027?HWA_MIFARE
   86: 		{
   87: 			return FALSE;
000CFF C3                CLR      C
000D00 22                RET      
   88: 		}
   89: 	}
000D01         ?C0027?HWA_MIFARE:
000D01 900051            MOV      DPTR,#u8_ReadErrCount
000D04 F1FD              ACALL    ?L?COM0059
000D06 40E2              JC       ?C0025?HWA_MIFARE
000D08         ?C0026?HWA_MIFARE:
   90: 	return FALSE;
000D08 C3                CLR      C
   91: }
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 29


000D09 22                RET      
----- FUNCTION _hwa_mifareWriteBlock (END) -------


----- FUNCTION _hwa_mifareRecoveryOldCard (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  130: static void hwa_mifareRecoveryOldCard(UINT8 sector)
  131: {
000D0A 900046            MOV      DPTR,#sector
000D0D 91D6              ACALL    ?L?COM0018
000D0F B16D              ACALL    _hwa_mifareEncrypt
  132: 	UINT8 money;
  133: 	hwa_mifareEncrypt((UINT8*)&s_NormalBuff);
  134: 	money = *(UINT8*)&s_NormalBuff;
000D11 900080            MOV      DPTR,#s_NormalBuff
000D14 E0                MOVX     A,@DPTR
000D15 900047            MOV      DPTR,#money
000D18 F0                MOVX     @DPTR,A
  135: 	if (money != 0xFF && money <= 200
000D19 F4                CPL      A
000D1A 601D              JZ       ?C0041?HWA_MIFARE
000D1C E0                MOVX     A,@DPTR
000D1D FF                MOV      R7,A
000D1E D3                SETB     C
000D1F 94C8              SUBB     A,#0C8H
000D21 5016              JNC      ?C0041?HWA_MIFARE
000D23 900082            MOV      DPTR,#s_NormalBuff+02H
000D26 E0                MOVX     A,@DPTR
000D27 7010              JNZ      ?C0041?HWA_MIFARE
000D29 A3                INC      DPTR
000D2A E0                MOVX     A,@DPTR
000D2B 700C              JNZ      ?C0041?HWA_MIFARE
  136: 		&& s_NormalBuff.crc[0] == 0
  137: 		&& s_NormalBuff.crc[1] == 0
  138: 		)
  139: 	{
  140: 		s_NormalBuff.money = (UINT16)money * 100;
000D2D F1EE              ACALL    ?L?COM0058
000D2F 900080            MOV      DPTR,#s_NormalBuff
000D32 EE                MOV      A,R6
000D33 F0                MOVX     @DPTR,A
000D34 A3                INC      DPTR
000D35 91D6              ACALL    ?L?COM0018
000D37 802C              SJMP     ?C0072?HWA_MIFARE
  141: 		hwa_mifareWriteSector((UINT8*)&s_NormalBuff, sector);
  142: 		return;
  143: 	}
000D39         ?C0041?HWA_MIFARE:
  144: 	hwa_mifareEncrypt((UINT8*)&s_BackupBuff);
000D39 B19F              ACALL    ?L?COM002E
000D3B B16D              ACALL    _hwa_mifareEncrypt
  145: 	money = *(UINT8*)&s_BackupBuff;
000D3D 900070            MOV      DPTR,#s_BackupBuff
000D40 E0                MOVX     A,@DPTR
000D41 900047            MOV      DPTR,#money
000D44 F0                MOVX     @DPTR,A
  146: 	if (money != 0xFF && money <= 200
000D45 F4                CPL      A
000D46 6024              JZ       ?C0042?HWA_MIFARE
000D48 E0                MOVX     A,@DPTR
000D49 FF                MOV      R7,A
000D4A D3                SETB     C
000D4B 94C8              SUBB     A,#0C8H
000D4D 501D              JNC      ?C0042?HWA_MIFARE
000D4F 900072            MOV      DPTR,#s_BackupBuff+02H
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 30


000D52 E0                MOVX     A,@DPTR
000D53 7017              JNZ      ?C0042?HWA_MIFARE
000D55 A3                INC      DPTR
000D56 E0                MOVX     A,@DPTR
000D57 7013              JNZ      ?C0042?HWA_MIFARE
  147: 		&& s_BackupBuff.crc[0] == 0
  148: 		&& s_BackupBuff.crc[1] == 0
  149: 		)
  150: 	{
  151: 		s_BackupBuff.money = (UINT16)money * 100;
000D59 F1EE              ACALL    ?L?COM0058
000D5B 900070            MOV      DPTR,#s_BackupBuff
000D5E EE                MOV      A,R6
000D5F F0                MOVX     @DPTR,A
000D60 A3                INC      DPTR
000D61 EF                MOV      A,R7
000D62 F0                MOVX     @DPTR,A
  152: 		hwa_mifareWriteSector((UINT8*)&s_BackupBuff, sector);
000D63 B19F              ACALL    ?L?COM002E
000D65         
000D65 900046            MOV      DPTR,#sector
000D68 E0                MOVX     A,@DPTR
000D69 FD                MOV      R5,A
000D6A 9175              ACALL    _hwa_mifareWriteSector
  153: 		return;
  154: 	}
  155: }
000D6C         ?C0042?HWA_MIFARE:
000D6C 22                RET      
----- FUNCTION _hwa_mifareRecoveryOldCard (END) -------


----- FUNCTION _hwa_mifareEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   29: void hwa_mifareEncrypt(UINT8 *pData)        //利用卡ID加密
   30: {
000D6D 90004D            MOV      DPTR,#pData
000D70 B1E5              ACALL    ?L?COM0008
   31: 	UINT8 i, j;
   32: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
000D72 E4                CLR      A
000D73 FE                MOV      R6,A
000D74         ?C0004?HWA_MIFARE:
   33: 	{
   34: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
000D74 7D04              MOV      R5,#04H
000D76         ?C0007?HWA_MIFARE:
   35: 		{
   36: 			pData[i] ^= gCard_UID[i % 5];
000D76 90004D            MOV      DPTR,#pData
000D79 9168              ACALL    ?L?COM0002
000D7B 1219E6            LCALL    ?L?COM0013
000D7E 6F                XRL      A,R7
000D7F 120162            LCALL    ?C?CSTPTR
   37: 			pData[i] = _cror_(pData[i], 1);
000D82 90004D            MOV      DPTR,#pData
000D85 9168              ACALL    ?L?COM0002
000D87 F9                MOV      R1,A
000D88 8E82              MOV      DPL,R6
000D8A F1D0              ACALL    ?L?COM0021
000D8C FF                MOV      R7,A
000D8D 7801              MOV      R0,#01H
000D8F 08                INC      R0
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 31


000D90 8001              SJMP     ?C0065?HWA_MIFARE
000D92         ?C0064?HWA_MIFARE:
000D92 03                RR       A
000D93         ?C0065?HWA_MIFARE:
000D93 D8FD              DJNZ     R0,?C0064?HWA_MIFARE
000D95 F1F5              ACALL    ?L?COM0052
   38: 		}
000D97 DDDD              DJNZ     R5,?C0007?HWA_MIFARE
   39: 	}
000D99         ?C0006?HWA_MIFARE:
000D99 0E                INC      R6
000D9A EE                MOV      A,R6
000D9B B404D6            CJNE     A,#04H,?C0004?HWA_MIFARE
   40: }
000D9E 22                RET      
----- FUNCTION _hwa_mifareEncrypt (END) -------


----- FUNCTION ?L?COM002E (BEGIN) -----
000D9F 7B01              MOV      R3,#01H
000DA1 7A00              MOV      R2,#HIGH s_BackupBuff
000DA3 7970              MOV      R1,#LOW s_BackupBuff
000DA5 22                RET      
----- FUNCTION ?L?COM002E (END) -------


----- FUNCTION hwa_mifareCheckBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  105: void hwa_mifareCheckBlock(void)
  106: {
  107: 	UINT16 crc, crcBak;
  108: 	hwa_mifareDecrypt((UINT8*)&s_NormalBuff);
000DA6 91D8              ACALL    ?L?COM0019
000DA8 F198              ACALL    _hwa_mifareDecrypt
  109: 	crc = hwa_mifareCheckOut((UINT8*)&s_NormalBuff, USE_DATA_BLOCK_LEN);
000DAA 91D8              ACALL    ?L?COM0019
;---- Variable 'crc' assigned to Register 'R4/R5' ----
000DAC F17E              ACALL    ?L?COM002A
  110: 	if (crc == (s_NormalBuff.crc[0] << 8 | s_NormalBuff.crc[1]))
000DAE 900082            MOV      DPTR,#s_NormalBuff+02H
000DB1 E0                MOVX     A,@DPTR
000DB2 FE                MOV      R6,A
000DB3 A3                INC      DPTR
000DB4 E0                MOVX     A,@DPTR
000DB5 FB                MOV      R3,A
000DB6 EB                MOV      A,R3
000DB7 B50508            CJNE     A,AR5,?C0036?HWA_MIFARE
000DBA EE                MOV      A,R6
000DBB B50404            CJNE     A,AR4,?C0036?HWA_MIFARE
  111: 	{
  112: 		NormalErrorFlag = FALSE;
000DBE C205              CLR      NormalErrorFlag
  113: 	}
000DC0 8002              SJMP     ?C0037?HWA_MIFARE
000DC2         ?C0036?HWA_MIFARE:
  114: 	else
  115: 	{
  116: 		NormalErrorFlag = TRUE;
000DC2 D205              SETB     NormalErrorFlag
  117: 	}
000DC4         ?C0037?HWA_MIFARE:
  118: 	hwa_mifareDecrypt((UINT8*)&s_BackupBuff);
000DC4 B19F              ACALL    ?L?COM002E
000DC6 F198              ACALL    _hwa_mifareDecrypt
  119: 	crcBak = hwa_mifareCheckOut((UINT8*)&s_BackupBuff, USE_DATA_BLOCK_LEN);
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 32


000DC8 B19F              ACALL    ?L?COM002E
;---- Variable 'crcBak' assigned to Register 'R4/R5' ----
000DCA F17E              ACALL    ?L?COM002A
  120: 	if (crcBak == (s_BackupBuff.crc[0] << 8 | s_BackupBuff.crc[1]))
000DCC 900072            MOV      DPTR,#s_BackupBuff+02H
000DCF E0                MOVX     A,@DPTR
000DD0 FE                MOV      R6,A
000DD1 A3                INC      DPTR
000DD2 E0                MOVX     A,@DPTR
000DD3 FB                MOV      R3,A
000DD4 EB                MOV      A,R3
000DD5 B50507            CJNE     A,AR5,?C0038?HWA_MIFARE
000DD8 EE                MOV      A,R6
000DD9 B50403            CJNE     A,AR4,?C0038?HWA_MIFARE
  121: 	{
  122: 		BackupErrorFlag = FALSE;
000DDC C204              CLR      BackupErrorFlag
  123: 	}
000DDE 22                RET      
000DDF         ?C0038?HWA_MIFARE:
  124: 	else
  125: 	{
  126: 		BackupErrorFlag = TRUE;
000DDF D204              SETB     BackupErrorFlag
  127: 	}
  128: }
000DE1 22                RET      
----- FUNCTION hwa_mifareCheckBlock (END) -------


----- FUNCTION ?L?COM0007 (BEGIN) -----
000DE2 900043            MOV      DPTR,#UID
000DE5         ?L?COM0008:
000DE5 EB                MOV      A,R3
000DE6 F0                MOVX     @DPTR,A
000DE7 A3                INC      DPTR
000DE8 EA                MOV      A,R2
000DE9 F0                MOVX     @DPTR,A
000DEA A3                INC      DPTR
000DEB E9                MOV      A,R1
000DEC F0                MOVX     @DPTR,A
000DED 22                RET      
----- FUNCTION ?L?COM0007 (END) -------


----- FUNCTION _hwa_mifareCheckOut (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   93: UINT16 hwa_mifareCheckOut(UINT8 *dat, UINT16 len)
   94: {
000DEE 90005F            MOV      DPTR,#dat
000DF1 B1E5              ACALL    ?L?COM0008
;---- Variable 'len' assigned to Register 'R4/R5' ----
   95: 	UINT16 Sum = 0;
   96: 	UINT8 i;
000DF3 E4                CLR      A
000DF4 121A68            LCALL    ?L?COM004B
000DF7         ?C0032?HWA_MIFARE:
000DF7 900064            MOV      DPTR,#i
000DFA E0                MOVX     A,@DPTR
000DFB C3                CLR      C
000DFC 9D                SUBB     A,R5
000DFD E4                CLR      A
000DFE 9C                SUBB     A,R4
000DFF 5024              JNC      ?C0033?HWA_MIFARE
   97: 	for (i = 0; i < len; i++)
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 33


   98: 	{
   99: 		Sum += dat[i];
000E01 90005F            MOV      DPTR,#dat
000E04 9168              ACALL    ?L?COM0002
000E06 F9                MOV      R1,A
000E07 900064            MOV      DPTR,#i
000E0A E0                MOVX     A,@DPTR
000E0B F582              MOV      DPL,A
000E0D F1D0              ACALL    ?L?COM0021
000E0F FF                MOV      R7,A
000E10 900063            MOV      DPTR,#Sum+01H
000E13 E0                MOVX     A,@DPTR
000E14 2F                ADD      A,R7
000E15 F0                MOVX     @DPTR,A
000E16 900062            MOV      DPTR,#Sum
000E19 E0                MOVX     A,@DPTR
000E1A 3400              ADDC     A,#00H
000E1C F0                MOVX     @DPTR,A
  100: 	}
000E1D 900064            MOV      DPTR,#i
000E20 E0                MOVX     A,@DPTR
000E21 04                INC      A
000E22 F0                MOVX     @DPTR,A
000E23 80D2              SJMP     ?C0032?HWA_MIFARE
000E25         ?C0033?HWA_MIFARE:
  101: 	Sum ^= 0xABCD;
000E25 900062            MOV      DPTR,#Sum
000E28 E0                MOVX     A,@DPTR
000E29 64AB              XRL      A,#0ABH
000E2B FE                MOV      R6,A
000E2C A3                INC      DPTR
000E2D E0                MOVX     A,@DPTR
000E2E 64CD              XRL      A,#0CDH
000E30 FF                MOV      R7,A
000E31 900062            MOV      DPTR,#Sum
000E34 EE                MOV      A,R6
000E35 F0                MOVX     @DPTR,A
000E36 A3                INC      DPTR
000E37 EF                MOV      A,R7
000E38 F0                MOVX     @DPTR,A
  102: 	return Sum;
  103: }
000E39 22                RET      
----- FUNCTION _hwa_mifareCheckOut (END) -------


----- FUNCTION _hwa_eepromReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   37: BOOL hwa_eepromReadSector(UINT8 *dat, UINT8 sector)
   38: {
000E3A 90004F            MOV      DPTR,#dat
000E3D B1E5              ACALL    ?L?COM0008
000E3F A3                INC      DPTR
000E40 ED                MOV      A,R5
000E41 F0                MOVX     @DPTR,A
   39: 	BOOL e2_error = FALSE, e2_bak_error = FALSE;
   40: 	UINT16 e2_addr, e2_bak_addr;
000E42 C202              CLR      e2_error
000E44 C203              CLR      e2_bak_error
   41: 	UINT16 e2_check_sum, e2_bak_check_sum;
   42: 	UINT16 Size, SectorSize;
   43: 
   44: 	if (sector >= c_u8_eepromSectorNum)
000E46 12154C            LCALL    ?L?COM004D
000E49 4001              JC       ?C0002?HWA_EEPROM
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 34


   45: 	{
   46: 		return FALSE;
000E4B 22                RET      
   47: 	}
000E4C         ?C0002?HWA_EEPROM:
   48: 	Size = c_s_eepromConfig[sector].UseSize;
000E4C 900052            MOV      DPTR,#sector
000E4F 121562            LCALL    ?L?COM0028
000E52 90005B            MOV      DPTR,#Size
000E55 12122B            LCALL    ?L?COM0009
000E58 900053            MOV      DPTR,#e2_addr
000E5B 1214E7            LCALL    ?L?COM005A
000E5E 121252            LCALL    ?L?COM000A
000E61 900055            MOV      DPTR,#e2_bak_addr
000E64 F0                MOVX     @DPTR,A
000E65 A3                INC      DPTR
000E66 CE                XCH      A,R6
000E67 F0                MOVX     @DPTR,A
   49: 	SectorSize = Size + 2;
   50: 
   51: 	e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
   52: 	e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
   53: 
   54: 	sys_eepromRead(e2_addr, e2_data, SectorSize);
000E68 121A6F            LCALL    ?L?COM004E
000E6B F177              ACALL    ?L?COM0017
000E6D 90005D            MOV      DPTR,#SectorSize
000E70 12121E            LCALL    ?L?COM000E
000E73 121296            LCALL    ?L?COM0011
000E76 6007              JZ       ?C0004?HWA_EEPROM
   55: 	if (c_s_eepromConfig[sector].Encrypt)
   56: 	{
   57: 		hwa_eepromDecrypt(e2_data, Size);
000E78 F177              ACALL    ?L?COM0017
000E7A F18F              ACALL    ?L?COM001B
000E7C 121503            LCALL    _hwa_eepromDecrypt
   58: 	}
000E7F         ?C0004?HWA_EEPROM:
   59: 	e2_check_sum = e2_data[Size] << 8 | e2_data[Size + 1];
000E7F F18F              ACALL    ?L?COM001B
000E81 2400              ADD      A,#LOW e2_data
000E83 F582              MOV      DPL,A
000E85 7400              MOV      A,#HIGH e2_data
000E87 3C                ADDC     A,R4
000E88 F583              MOV      DPH,A
000E8A E0                MOVX     A,@DPTR
000E8B FE                MOV      R6,A
000E8C 7401              MOV      A,#LOW e2_data+01H
000E8E 2D                ADD      A,R5
000E8F F582              MOV      DPL,A
000E91 7400              MOV      A,#HIGH e2_data+01H
000E93 121A92            LCALL    ?L?COM005B
000E96 900057            MOV      DPTR,#e2_check_sum
000E99 EE                MOV      A,R6
000E9A F0                MOVX     @DPTR,A
000E9B A3                INC      DPTR
000E9C EF                MOV      A,R7
000E9D F0                MOVX     @DPTR,A
   60: 
   61: 	sys_eepromRead(e2_bak_addr, e2_data_bak, SectorSize);
000E9E 121A3A            LCALL    ?L?COM0034
000EA1 90005D            MOV      DPTR,#SectorSize
000EA4 12121E            LCALL    ?L?COM000E
000EA7 121296            LCALL    ?L?COM0011
000EAA 6005              JZ       ?C0005?HWA_EEPROM
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 35


   62: 	if (c_s_eepromConfig[sector].Encrypt)
   63: 	{
   64: 		hwa_eepromDecrypt(e2_data_bak, Size);
000EAC F189              ACALL    ?L?COM001A
000EAE 121503            LCALL    _hwa_eepromDecrypt
   65: 	}
000EB1         ?C0005?HWA_EEPROM:
   66: 	e2_bak_check_sum = e2_data_bak[Size] << 8 | e2_data_bak[Size + 1];
000EB1 F18F              ACALL    ?L?COM001B
000EB3 2420              ADD      A,#LOW e2_data_bak
000EB5 F582              MOV      DPL,A
000EB7 7400              MOV      A,#HIGH e2_data_bak
000EB9 3C                ADDC     A,R4
000EBA F583              MOV      DPH,A
000EBC E0                MOVX     A,@DPTR
000EBD FE                MOV      R6,A
000EBE 7421              MOV      A,#LOW e2_data_bak+01H
000EC0 2D                ADD      A,R5
000EC1 F582              MOV      DPL,A
000EC3 7400              MOV      A,#HIGH e2_data_bak+01H
000EC5 121A92            LCALL    ?L?COM005B
000EC8 900059            MOV      DPTR,#e2_bak_check_sum
000ECB F172              ACALL    ?L?COM0016
000ECD A3                INC      DPTR
000ECE A3                INC      DPTR
000ECF E0                MOVX     A,@DPTR
000ED0 FD                MOV      R5,A
000ED1 B1EE              ACALL    _hwa_mifareCheckOut
000ED3 900057            MOV      DPTR,#e2_check_sum
000ED6 E0                MOVX     A,@DPTR
000ED7 6E                XRL      A,R6
000ED8 7003              JNZ      ?C0017?HWA_EEPROM
000EDA A3                INC      DPTR
000EDB E0                MOVX     A,@DPTR
000EDC 6F                XRL      A,R7
000EDD         ?C0017?HWA_EEPROM:
000EDD 6002              JZ       ?C0006?HWA_EEPROM
   67: 
   68: 	if (e2_check_sum != hwa_mifareCheckOut(e2_data, Size))
   69: 	{
   70: 		e2_error = TRUE;
000EDF D202              SETB     e2_error
   71: 	}
000EE1         ?C0006?HWA_EEPROM:
   72: 	if (e2_bak_check_sum != hwa_mifareCheckOut(e2_data_bak, Size))
000EE1 F189              ACALL    ?L?COM001A
000EE3 B1EE              ACALL    _hwa_mifareCheckOut
000EE5 900059            MOV      DPTR,#e2_bak_check_sum
000EE8 E0                MOVX     A,@DPTR
000EE9 6E                XRL      A,R6
000EEA 7003              JNZ      ?C0018?HWA_EEPROM
000EEC A3                INC      DPTR
000EED E0                MOVX     A,@DPTR
000EEE 6F                XRL      A,R7
000EEF         ?C0018?HWA_EEPROM:
000EEF 6002              JZ       ?C0007?HWA_EEPROM
   73: 	{
   74: 		e2_bak_error = TRUE;
000EF1 D203              SETB     e2_bak_error
   75: 	}
000EF3         ?C0007?HWA_EEPROM:
   76: 
   77: 	if (e2_error && e2_bak_error)    //~1~备份块和正常块都校验错误，返回错误
000EF3 300205            JNB      e2_error,?C0008?HWA_EEPROM
000EF6 300302            JNB      e2_bak_error,?C0008?HWA_EEPROM
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 36


   78: 	{
   79: 		return FALSE;
000EF9 C3                CLR      C
000EFA 22                RET      
   80: 	}
000EFB         ?C0008?HWA_EEPROM:
   81: 	else if (e2_error)                                 //~2~备份块校验错误，恢复正常块
000EFB 300219            JNB      e2_error,?C0010?HWA_EEPROM
   82: 	{
   83: 		memcpy(e2_data, e2_data_bak, SectorSize);
000EFE 90005D            MOV      DPTR,#SectorSize
000F01 121556            LCALL    ?L?COM0046
000F04 121A42            LCALL    ?L?COM0035
000F07 1200F6            LCALL    ?C?COPY
   84: 		sys_eepromEraseSector(e2_addr);
000F0A 900053            MOV      DPTR,#e2_addr
000F0D 1211CD            LCALL    ?L?COM002F
   85: 		sys_eepromWrite(e2_addr, e2_data, SectorSize);
000F10 121A6F            LCALL    ?L?COM004E
000F13 F177              ACALL    ?L?COM0017
   86: 	}
000F15 8039              SJMP     ?C0020?HWA_EEPROM
000F17         ?C0010?HWA_EEPROM:
   87: 	else if (e2_bak_error ||                          //~3~正常块校验错误，恢复备份块
000F17 20031A            JB       e2_bak_error,?C0013?HWA_EEPROM
000F1A 20023C            JB       e2_error,?C0009?HWA_EEPROM
000F1D 200339            JB       e2_bak_error,?C0009?HWA_EEPROM
000F20 900059            MOV      DPTR,#e2_bak_check_sum
000F23 E0                MOVX     A,@DPTR
000F24 FE                MOV      R6,A
000F25 A3                INC      DPTR
000F26 E0                MOVX     A,@DPTR
000F27 FF                MOV      R7,A
000F28 900057            MOV      DPTR,#e2_check_sum
000F2B E0                MOVX     A,@DPTR
000F2C 6E                XRL      A,R6
000F2D 7003              JNZ      ?C0019?HWA_EEPROM
000F2F A3                INC      DPTR
000F30 E0                MOVX     A,@DPTR
000F31 6F                XRL      A,R7
000F32         ?C0019?HWA_EEPROM:
000F32 6025              JZ       ?C0009?HWA_EEPROM
000F34         ?C0013?HWA_EEPROM:
   88: 		(e2_error == FALSE                                //~4~正常块、备份块都检验正确，但数据不同，则以
   89: 		&& e2_bak_error == FALSE                         //   最新写入的正常块覆盖备份块
   90: 		&& e2_check_sum != e2_bak_check_sum)
   91: 		)
   92: 	{
   93: 		memcpy(e2_data_bak, e2_data, SectorSize);
000F34 90005D            MOV      DPTR,#SectorSize
000F37 E0                MOVX     A,@DPTR
000F38 FE                MOV      R6,A
000F39 A3                INC      DPTR
000F3A E0                MOVX     A,@DPTR
000F3B FF                MOV      R7,A
000F3C 7820              MOV      R0,#LOW e2_data_bak
000F3E 7C00              MOV      R4,#HIGH e2_data_bak
000F40 7D01              MOV      R5,#01H
000F42 F177              ACALL    ?L?COM0017
000F44 1200F6            LCALL    ?C?COPY
   94: 		sys_eepromEraseSector(e2_bak_addr);
000F47 900055            MOV      DPTR,#e2_bak_addr
000F4A 1211CD            LCALL    ?L?COM002F
   95: 		sys_eepromWrite(e2_bak_addr, e2_data_bak, SectorSize);
000F4D 121A3A            LCALL    ?L?COM0034
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 37


000F50         
000F50 90005D            MOV      DPTR,#SectorSize
000F53 12121E            LCALL    ?L?COM000E
000F56 1211EB            LCALL    _sys_eepromWrite
   96: 	}
000F59         ?C0009?HWA_EEPROM:
   97: 	memcpy(dat, e2_data, Size);
000F59 90005B            MOV      DPTR,#Size
000F5C E0                MOVX     A,@DPTR
000F5D FE                MOV      R6,A
000F5E A3                INC      DPTR
000F5F E0                MOVX     A,@DPTR
000F60 FF                MOV      R7,A
000F61 90004F            MOV      DPTR,#dat
000F64 9168              ACALL    ?L?COM0002
000F66 F8                MOV      R0,A
000F67 AC02              MOV      R4,AR2
000F69 AD03              MOV      R5,AR3
000F6B F177              ACALL    ?L?COM0017
000F6D 1200F6            LCALL    ?C?COPY
   98: 	return TRUE;
000F70 D3                SETB     C
   99: }
000F71 22                RET      
----- FUNCTION _hwa_eepromReadSector (END) -------


----- FUNCTION ?L?COM0016 (BEGIN) -----
000F72 EE                MOV      A,R6
000F73 F0                MOVX     @DPTR,A
000F74 A3                INC      DPTR
000F75 EF                MOV      A,R7
000F76 F0                MOVX     @DPTR,A
000F77         ?L?COM0017:
000F77 7B01              MOV      R3,#01H
000F79 7A00              MOV      R2,#HIGH e2_data
000F7B 7900              MOV      R1,#LOW e2_data
000F7D 22                RET      
----- FUNCTION ?L?COM0016 (END) -------


----- FUNCTION ?L?COM002A (BEGIN) -----
000F7E 7D02              MOV      R5,#02H
000F80 7C00              MOV      R4,#00H
000F82 B1EE              ACALL    _hwa_mifareCheckOut
000F84 AD07              MOV      R5,AR7
000F86 AC06              MOV      R4,AR6
000F88 22                RET      
----- FUNCTION ?L?COM002A (END) -------


----- FUNCTION ?L?COM001A (BEGIN) -----
000F89 7B01              MOV      R3,#01H
000F8B 7A00              MOV      R2,#HIGH e2_data_bak
000F8D 7920              MOV      R1,#LOW e2_data_bak
000F8F         ?L?COM001B:
000F8F 90005B            MOV      DPTR,#Size
000F92 E0                MOVX     A,@DPTR
000F93 FC                MOV      R4,A
000F94 A3                INC      DPTR
000F95 E0                MOVX     A,@DPTR
000F96 FD                MOV      R5,A
000F97 22                RET      
----- FUNCTION ?L?COM001A (END) -------

LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 38



----- FUNCTION _hwa_mifareDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   42: void hwa_mifareDecrypt(UINT8 *pData)        //利用卡ID解密
   43: {
000F98 900046            MOV      DPTR,#pData
000F9B B1E5              ACALL    ?L?COM0008
   44: 	UINT8 i, j;
   45: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
000F9D E4                CLR      A
000F9E FE                MOV      R6,A
000F9F         ?C0011?HWA_MIFARE:
   46: 	{
   47: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
000F9F 7D04              MOV      R5,#04H
000FA1         ?C0014?HWA_MIFARE:
   48: 		{
   49: 			pData[i] = _crol_(pData[i], 1);
000FA1 900046            MOV      DPTR,#pData
000FA4 9168              ACALL    ?L?COM0002
000FA6 F9                MOV      R1,A
000FA7 8E82              MOV      DPL,R6
000FA9 F1D0              ACALL    ?L?COM0021
000FAB FF                MOV      R7,A
000FAC 7801              MOV      R0,#01H
000FAE 08                INC      R0
000FAF 8001              SJMP     ?C0067?HWA_MIFARE
000FB1         ?C0066?HWA_MIFARE:
000FB1 23                RL       A
000FB2         ?C0067?HWA_MIFARE:
000FB2 D8FD              DJNZ     R0,?C0066?HWA_MIFARE
000FB4 F1F5              ACALL    ?L?COM0052
   50: 			pData[i] ^= gCard_UID[i % 5];
000FB6 E9                MOV      A,R1
000FB7 1219E6            LCALL    ?L?COM0013
000FBA 6F                XRL      A,R7
000FBB 120162            LCALL    ?C?CSTPTR
   51: 		}
000FBE DDE1              DJNZ     R5,?C0014?HWA_MIFARE
   52: 	}
000FC0         ?C0013?HWA_MIFARE:
000FC0 0E                INC      R6
000FC1 EE                MOV      A,R6
000FC2 B404DA            CJNE     A,#04H,?C0011?HWA_MIFARE
   53: }
000FC5 22                RET      
----- FUNCTION _hwa_mifareDecrypt (END) -------


----- FUNCTION ?L?COM0045 (BEGIN) -----
000FC6 7E00              MOV      R6,#00H
000FC8 7F10              MOV      R7,#010H
000FCA 0200F6            LJMP     ?C?COPY
----- FUNCTION ?L?COM0045 (END) -------


----- FUNCTION ?L?COM001F (BEGIN) -----
000FCD F9                MOV      R1,A
000FCE         ?L?COM0020:
000FCE 8F82              MOV      DPL,R7
000FD0         ?L?COM0021:
000FD0 758300            MOV      DPH,#00H
000FD3 020135            LJMP     ?C?CLDOPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 39


----- FUNCTION ?L?COM001F (END) -------


----- FUNCTION ?L?COM003A (BEGIN) -----
000FD6 9000A5            MOV      DPTR,#s_System+011H
000FD9 E0                MOVX     A,@DPTR
000FDA FE                MOV      R6,A
000FDB A3                INC      DPTR
000FDC E0                MOVX     A,@DPTR
000FDD FF                MOV      R7,A
000FDE 22                RET      
----- FUNCTION ?L?COM003A (END) -------


----- FUNCTION ?L?COM0032 (BEGIN) -----
000FDF E0                MOVX     A,@DPTR
000FE0 FA                MOV      R2,A
000FE1 A3                INC      DPTR
000FE2 E0                MOVX     A,@DPTR
000FE3 FB                MOV      R3,A
000FE4 7C03              MOV      R4,#03H
000FE6 7DE8              MOV      R5,#0E8H
000FE8         ?L?COM0033:
000FE8 FF                MOV      R7,A
000FE9 AE02              MOV      R6,AR2
000FEB 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM0032 (END) -------


----- FUNCTION ?L?COM0058 (BEGIN) -----
000FEE FE                MOV      R6,A
000FEF FC                MOV      R4,A
000FF0 7D64              MOV      R5,#064H
000FF2 020196            LJMP     ?C?IMUL
----- FUNCTION ?L?COM0058 (END) -------


----- FUNCTION ?L?COM0052 (BEGIN) -----
000FF5 8E82              MOV      DPL,R6
000FF7 758300            MOV      DPH,#00H
000FFA 020174            LJMP     ?C?CSTOPTR
----- FUNCTION ?L?COM0052 (END) -------


----- FUNCTION ?L?COM0059 (BEGIN) -----
000FFD E0                MOVX     A,@DPTR
000FFE 04                INC      A
000FFF F0                MOVX     @DPTR,A
001000 E0                MOVX     A,@DPTR
001001 C3                CLR      C
001002 9403              SUBB     A,#03H
001004 22                RET      
----- FUNCTION ?L?COM0059 (END) -------


----- FUNCTION sys_tim0Init (BEGIN) -----
 FILE: 'System\sys_tim.c'
  101: void sys_tim0Init(void)
  102: {
  103: 	TMOD &= 0xF0;
  104: 	TH0 = (UINT8)(T1MS>>8);
001005 5389F0            ANL      TMOD,#0F0H
  105: 	TL0 = (UINT8)T1MS;
001008 758CF8            MOV      TH0,#0F8H
  106: 	ET0 = 1;
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 40


00100B 758ACD            MOV      TL0,#0CDH
  107: 	TR0 = 1;
00100E D2A9              SETB     ET0
  108: //	PT1 = 1;
001010 D28C              SETB     TR0
  109:     EA = 1;
001012 D2AF              SETB     EA
  110: }
001014 22                RET      
----- FUNCTION sys_tim0Init (END) -------


----- FUNCTION sys_taskInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   27: void sys_taskInit(void)
   28: {
   29:     WDT_CONTR = 0x33;
   30:     len_Init();
001015 75C133            MOV      WDT_CONTR,#033H
   31:     sys_gpioInit();
001018 B17A              ACALL    len_Init
   32:     buzzer_Init();
00101A 120009            LCALL    sys_gpioInit
   33:     sys_uartInit();
00101D 91EF              ACALL    buzzer_Init
   34:     sys_tim0Init();
00101F 9189              ACALL    sys_uartInit
   35:     app_configInit();
001021 1105              ACALL    sys_tim0Init
   36: 	app_Show();
001023 112B              ACALL    app_configInit
   37:     app_brushInit();
001025 12081F            LCALL    app_Show
   38: }
001028 0207F6            LJMP     app_brushInit
----- FUNCTION sys_taskInit (END) -------


----- FUNCTION app_configInit (BEGIN) -----
 FILE: 'App\app_config.c'
   47: void app_configInit(void)
   48: {
   49:     BOOL state = FALSE;
   50:     led_Switch(OFF);
00102B C200              CLR      state
   51:     hwa_eepromInit();
00102D C201              CLR      ?led_Switch?BIT
00102F 11B3              ACALL    led_Switch
   52:     if(app_configRead(SYSTEM_SETTING_SECTOR) == FALSE)
001031 120022            LCALL    hwa_eepromInit
   53:     {
001034 E4                CLR      A
001035 FF                MOV      R7,A
001036 11E1              ACALL    _app_configRead
001038 4022              JC       ?C0001?APP_CONFIG
   54:         memcpy(&s_System, &s_FactorySystem, sizeof(s_System));
   55:         b_FactorySystem = TRUE;
00103A 7894              MOV      R0,#LOW s_System
00103C 7C00              MOV      R4,#HIGH s_System
00103E 7D01              MOV      R5,#01H
001040 7BFF              MOV      R3,#0FFH
001042 7A00              MOV      R2,#HIGH s_FactorySystem
001044 790E              MOV      R1,#LOW s_FactorySystem
001046 7E00              MOV      R6,#00H
001048 7F13              MOV      R7,#013H
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 41


00104A 1200F6            LCALL    ?C?COPY
   56:         led_ShowNumber(8888,88,0xFF);
00104D D208              SETB     b_FactorySystem
   57:     }
00104F 7BFF              MOV      R3,#0FFH
001051 7D58              MOV      R5,#058H
001053 7FB8              MOV      R7,#0B8H
001055 7E22              MOV      R6,#022H
001057 120857            LCALL    _led_ShowNumber
   58:     else
00105A 803C              SJMP     ?C0002?APP_CONFIG
00105C         ?C0001?APP_CONFIG:
   59:     {
   60:         if(s_System.Sector > 16 || s_System.Sector < 1)                 //钱包分区不在1~16
00105C 90009A            MOV      DPTR,#s_System+06H
00105F E0                MOVX     A,@DPTR
001060 FF                MOV      R7,A
001061 D3                SETB     C
001062 9410              SUBB     A,#010H
001064 5006              JNC      ?C0004?APP_CONFIG
001066 EF                MOV      A,R7
001067 C3                CLR      C
001068 9401              SUBB     A,#01H
00106A 500B              JNC      ?C0003?APP_CONFIG
00106C         ?C0004?APP_CONFIG:
   61:         {
   62:             s_System.Sector = s_FactorySystem.Sector;
00106C 900014            MOV      DPTR,#s_FactorySystem+06H
00106F E4                CLR      A
001070 93                MOVC     A,@A+DPTR
001071 90009A            MOV      DPTR,#s_System+06H
001074 F0                MOVX     @DPTR,A
   63:             state = TRUE;
001075 D200              SETB     state
   64:         }
001077         ?C0003?APP_CONFIG:
   65:         if(s_System.Money > 20000)                                        //金额大于200
001077 D3                SETB     C
001078 3103              ACALL    ?L?COM0030
00107A 4013              JC       ?C0005?APP_CONFIG
   66:         {
   67:             s_System.Money = s_FactorySystem.Money;
00107C 90001F            MOV      DPTR,#s_FactorySystem+011H
00107F E4                CLR      A
001080 93                MOVC     A,@A+DPTR
001081 FF                MOV      R7,A
001082 7401              MOV      A,#01H
001084 93                MOVC     A,@A+DPTR
001085 9000A5            MOV      DPTR,#s_System+011H
001088 CF                XCH      A,R7
001089 F0                MOVX     @DPTR,A
00108A A3                INC      DPTR
00108B EF                MOV      A,R7
00108C F0                MOVX     @DPTR,A
   68:             state = TRUE;
00108D D200              SETB     state
   69:         }
00108F         ?C0005?APP_CONFIG:
   70:         if(state)
00108F 300006            JNB      state,?C0002?APP_CONFIG
   71:         {
   72: 			app_configWrite(SYSTEM_SETTING_SECTOR);
001092 E4                CLR      A
001093 FF                MOV      R7,A
001094 11BD              ACALL    _app_configWrite
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 42


   73:             b_FactorySystem = TRUE;
001096 D208              SETB     b_FactorySystem
   74:         }
   75:     }
001098         ?C0002?APP_CONFIG:
   76:     
   77:     if(app_configRead(MONEY_SECTOR) == FALSE)
001098 7F01              MOV      R7,#01H
00109A 11E1              ACALL    _app_configRead
00109C 4013              JC       ?C0007?APP_CONFIG
   78:     {
   79:         memset(&MoneySum, 0x00, sizeof(MoneySum));
00109E 7E00              MOV      R6,#00H
0010A0 7F04              MOV      R7,#04H
0010A2 7D00              MOV      R5,#00H
0010A4 7B01              MOV      R3,#01H
0010A6 7A00              MOV      R2,#HIGH MoneySum
0010A8 7990              MOV      R1,#LOW MoneySum
0010AA 12052F            LCALL    ?C?MEMSET
   80: 		app_configWrite(MONEY_SECTOR);
0010AD 7F01              MOV      R7,#01H
0010AF 11BD              ACALL    _app_configWrite
   81:     }
0010B1         ?C0007?APP_CONFIG:
   82:     led_Switch(ON);
0010B1 D201              SETB     ?led_Switch?BIT
;----                  JMP      led_Switch
----- FUNCTION app_configInit (END) -------


----- FUNCTION led_Switch (BEGIN) -----
 FILE: 'Driver\LED.c'
  152: void led_Switch(bit sw)
  153: {
  154:     ledsw = sw;
  155:     if(ledsw==0)
0010B3 A201              MOV      C,sw
0010B5 9209              MOV      ledsw,C
  156:     {
0010B7 200902            JB       ledsw,?C0044?LED
  157:     	LED_CS0 = 1;
  158:     	LED_CS1 = 1;
0010BA 917C              ACALL    ?L?COM003F
  159:     	LED_CS2 = 1;
  160:     	LED_CS3 = 1;
  161:     	LED_CS4 = 1;
  162:     	LED_CS5 = 1;
  163:     }
  164: }
0010BC         ?C0044?LED:
0010BC 22                RET      
----- FUNCTION led_Switch (END) -------


----- FUNCTION _app_configWrite (BEGIN) -----
 FILE: 'App\app_config.c'
   99: void app_configWrite(UINT8 Sector)
  100: {
0010BD 900040            MOV      DPTR,#Sector
0010C0 EF                MOV      A,R7
0010C1 F0                MOVX     @DPTR,A
  101:     led_Switch(OFF);
  102:     if(Sector == SYSTEM_SETTING_SECTOR)
0010C2 C201              CLR      ?led_Switch?BIT
0010C4 11B3              ACALL    led_Switch
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 43


  103:     {
0010C6 900040            MOV      DPTR,#Sector
0010C9 E0                MOVX     A,@DPTR
0010CA 7B01              MOV      R3,#01H
0010CC 7007              JNZ      ?C0012?APP_CONFIG
  104:         hwa_eepromWriteSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
  105:     }
0010CE 7A00              MOV      R2,#HIGH s_System
0010D0 7994              MOV      R1,#LOW s_System
0010D2 FD                MOV      R5,A
  106:     else
0010D3 8006              SJMP     ?C0017?APP_CONFIG
0010D5         ?C0012?APP_CONFIG:
  107:     {
  108:         hwa_eepromWriteSector((UINT8*)&MoneySum, MONEY_SECTOR);
0010D5 7A00              MOV      R2,#HIGH MoneySum
0010D7 7990              MOV      R1,#LOW MoneySum
0010D9 7D01              MOV      R5,#01H
0010DB         
0010DB 3126              ACALL    _hwa_eepromWriteSector
  109:     }
0010DD         ?C0013?APP_CONFIG:
  110:     led_Switch(ON);
0010DD D201              SETB     ?led_Switch?BIT
0010DF 80D2              SJMP     led_Switch
----- FUNCTION _app_configWrite (END) -------


----- FUNCTION _app_configRead (BEGIN) -----
 FILE: 'App\app_config.c'
   85: BOOL app_configRead(UINT8 Sector)
   86: {
;---- Variable 'Sector' assigned to Register 'R7' ----
   87:     BOOL state;
   88:     if(Sector == SYSTEM_SETTING_SECTOR)
0010E1 EF                MOV      A,R7
0010E2 7B01              MOV      R3,#01H
0010E4 7007              JNZ      ?C0009?APP_CONFIG
   89:     {
   90:         state = hwa_eepromReadSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
0010E6 7A00              MOV      R2,#HIGH s_System
0010E8 7994              MOV      R1,#LOW s_System
0010EA FD                MOV      R5,A
   91:     }
0010EB 8006              SJMP     ?C0016?APP_CONFIG
0010ED         ?C0009?APP_CONFIG:
   92:     else
   93:     {
   94:         state = hwa_eepromReadSector((UINT8*)&MoneySum, MONEY_SECTOR);
0010ED 7A00              MOV      R2,#HIGH MoneySum
0010EF 7990              MOV      R1,#LOW MoneySum
0010F1 7D01              MOV      R5,#01H
0010F3         
0010F3 120E3A            LCALL    _hwa_eepromReadSector
0010F6 9201              MOV      state,C
   95:     }
0010F8         ?C0010?APP_CONFIG:
   96:     return state;
0010F8 A201              MOV      C,state
   97: }
0010FA 22                RET      
----- FUNCTION _app_configRead (END) -------


----- FUNCTION app_confingHandler1s (BEGIN) -----
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 44


 FILE: 'App\app_config.c'
  113: void app_confingHandler1s(void)
  114: {
  115:     led_Switch(OFF);
  116: //    hwa_eepromReadSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
0010FB C201              CLR      ?led_Switch?BIT
0010FD 11B3              ACALL    led_Switch
  117: //    sys_uartSendData((UINT8*)&USER_Card_ID, 5);
  118: //    USER_Card_ID[0][0]++;
  119: //    hwa_eepromWriteSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
  120:     led_Switch(ON);
0010FF D201              SETB     ?led_Switch?BIT
001101 80B0              SJMP     led_Switch
----- FUNCTION app_confingHandler1s (END) -------


----- FUNCTION ?L?COM0030 (BEGIN) -----
001103 9000A6            MOV      DPTR,#s_System+012H
001106         ?L?COM0031:
001106 E0                MOVX     A,@DPTR
001107 9420              SUBB     A,#020H
001109 9000A5            MOV      DPTR,#s_System+011H
00110C E0                MOVX     A,@DPTR
00110D 944E              SUBB     A,#04EH
00110F 22                RET      
----- FUNCTION ?L?COM0030 (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: 'System\sys_task.c'
   77: void main(void)
   78: {
   79:     sys_taskInit();
   80:     buzzer_SoundNumber(1);
001110 1115              ACALL    sys_taskInit
   81:     while(1)
001112 7F01              MOV      R7,#01H
001114 120B3B            LCALL    _buzzer_SoundNumber
001117         ?C0010?SYS_TASK:
   82:     {
   83:         WDT_CONTR = 0x33;          //reset watch dog      SyttemClk is 11.0592M Over Time 568.8ms
   84:         if(taskCycle1sFlag == TRUE)
001117 75C133            MOV      WDT_CONTR,#033H
   85:         {
00111A 3006FA            JNB      taskCycle1sFlag,?C0010?SYS_TASK
   86:         	taskCycle1sFlag = FALSE;
   87:             app_confingHandler1s();
00111D C206              CLR      taskCycle1sFlag
   88:             app_brushCycle1s();
00111F 11FB              ACALL    app_confingHandler1s
   89:         }
001121 120946            LCALL    app_brushCycle1s
   90:     }
   91: }
001124 80F1              SJMP     ?C0010?SYS_TASK
----- FUNCTION main (END) -------


----- FUNCTION _hwa_eepromWriteSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
  101: BOOL hwa_eepromWriteSector(UINT8 *dat, UINT8 sector)
  102: {
001126 900041            MOV      DPTR,#dat
001129 120DE5            LCALL    ?L?COM0008
00112C A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 45


00112D ED                MOV      A,R5
00112E F0                MOVX     @DPTR,A
  103: 	UINT16 e2_addr, e2_bak_addr;
  104: 	UINT16 e2_check_sum;
  105: 
  106: 	UINT16 Size, SectorSize;
  107: 
  108: 	if (sector >= c_u8_eepromSectorNum)
00112F B14C              ACALL    ?L?COM004D
001131 4001              JC       ?C0014?HWA_EEPROM
  109: 	{
  110: 		return FALSE;
001133 22                RET      
  111: 	}
001134         ?C0014?HWA_EEPROM:
  112: 	Size = c_s_eepromConfig[sector].UseSize;
001134 900044            MOV      DPTR,#sector
001137 B162              ACALL    ?L?COM0028
001139 90004B            MOV      DPTR,#Size
00113C 512B              ACALL    ?L?COM0009
00113E 900045            MOV      DPTR,#e2_addr
001141 91E7              ACALL    ?L?COM005A
001143 5152              ACALL    ?L?COM000A
001145 900047            MOV      DPTR,#e2_bak_addr
001148 F0                MOVX     @DPTR,A
001149 A3                INC      DPTR
00114A CE                XCH      A,R6
00114B F0                MOVX     @DPTR,A
  113: 	SectorSize = Size + 2;
  114: 
  115: 	e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
  116: 	e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
  117: 	e2_check_sum = hwa_mifareCheckOut(dat, Size);
00114C 900041            MOV      DPTR,#dat
00114F 120C68            LCALL    ?L?COM0002
001152 F9                MOV      R1,A
001153 31C4              ACALL    ?L?COM0053
001155 120DEE            LCALL    _hwa_mifareCheckOut
001158 900049            MOV      DPTR,#e2_check_sum
00115B 120F72            LCALL    ?L?COM0016
00115E 900044            MOV      DPTR,#sector
001161 E0                MOVX     A,@DPTR
001162 FD                MOV      R5,A
001163 120E3A            LCALL    _hwa_eepromReadSector
  118: 
  119: 	hwa_eepromReadSector(e2_data, sector);                                  //  写入之前，如果有错误块，先恢复
  120: 
  121: 	memcpy(e2_data, dat, Size);
001166 90004B            MOV      DPTR,#Size
001169 B156              ACALL    ?L?COM0046
00116B 900041            MOV      DPTR,#dat
00116E 120C68            LCALL    ?L?COM0002
001171 F9                MOV      R1,A
001172 1200F6            LCALL    ?C?COPY
  122: 
  123: 	if (c_s_eepromConfig[sector].Encrypt)
001175 900044            MOV      DPTR,#sector
001178 519B              ACALL    ?L?COM0012
00117A 6007              JZ       ?C0016?HWA_EEPROM
  124: 	{
  125: 		hwa_eepromEncrypt(e2_data, Size);
00117C 120F77            LCALL    ?L?COM0017
00117F 31C4              ACALL    ?L?COM0053
001181 51C2              ACALL    _hwa_eepromEncrypt
  126: 	}
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 46


001183         ?C0016?HWA_EEPROM:
  127: 	e2_data[Size] = (UINT8)(e2_check_sum >> 8);
001183 900049            MOV      DPTR,#e2_check_sum
001186 E0                MOVX     A,@DPTR
001187 FC                MOV      R4,A
001188 A3                INC      DPTR
001189 E0                MOVX     A,@DPTR
00118A FD                MOV      R5,A
00118B EC                MOV      A,R4
00118C FF                MOV      R7,A
00118D A3                INC      DPTR
00118E E0                MOVX     A,@DPTR
00118F FA                MOV      R2,A
001190 A3                INC      DPTR
001191 E0                MOVX     A,@DPTR
001192 FB                MOV      R3,A
001193 2400              ADD      A,#LOW e2_data
001195 F582              MOV      DPL,A
001197 7400              MOV      A,#HIGH e2_data
001199 3A                ADDC     A,R2
00119A F583              MOV      DPH,A
00119C EF                MOV      A,R7
00119D F0                MOVX     @DPTR,A
  128: 	e2_data[Size + 1] = (UINT8)(e2_check_sum & 0xFF);
00119E 7401              MOV      A,#LOW e2_data+01H
0011A0 2B                ADD      A,R3
0011A1 F582              MOV      DPL,A
0011A3 7400              MOV      A,#HIGH e2_data+01H
0011A5 3A                ADDC     A,R2
0011A6 F583              MOV      DPH,A
0011A8 ED                MOV      A,R5
0011A9 F0                MOVX     @DPTR,A
  129: 	sys_eepromEraseSector(e2_addr);
0011AA 900045            MOV      DPTR,#e2_addr
0011AD 31CD              ACALL    ?L?COM002F
  130: 	sys_eepromWrite(e2_addr, e2_data, SectorSize);
0011AF 900045            MOV      DPTR,#e2_addr
0011B2 5110              ACALL    ?L?COM000D
0011B4 31EB              ACALL    _sys_eepromWrite
  131: 
  132: 	//    memcpy(e2_data_bak, e2_data, SectorSize);
  133: 	sys_eepromEraseSector(e2_bak_addr);
0011B6 900047            MOV      DPTR,#e2_bak_addr
0011B9 31CD              ACALL    ?L?COM002F
  134: 	sys_eepromWrite(e2_bak_addr, e2_data, SectorSize);
0011BB 900047            MOV      DPTR,#e2_bak_addr
0011BE 5110              ACALL    ?L?COM000D
0011C0 31EB              ACALL    _sys_eepromWrite
  135: 	return TRUE;
0011C2 D3                SETB     C
  136: }
0011C3 22                RET      
----- FUNCTION _hwa_eepromWriteSector (END) -------


----- FUNCTION ?L?COM0053 (BEGIN) -----
0011C4 90004B            MOV      DPTR,#Size
0011C7 E0                MOVX     A,@DPTR
0011C8 FC                MOV      R4,A
0011C9 A3                INC      DPTR
0011CA E0                MOVX     A,@DPTR
0011CB FD                MOV      R5,A
0011CC 22                RET      
----- FUNCTION ?L?COM0053 (END) -------

LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 47



----- FUNCTION ?L?COM002F (BEGIN) -----
0011CD E0                MOVX     A,@DPTR
0011CE FE                MOV      R6,A
0011CF A3                INC      DPTR
0011D0 E0                MOVX     A,@DPTR
0011D1 FF                MOV      R7,A
----- FUNCTION _sys_eepromEraseSector (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   72: void sys_eepromEraseSector(UINT16 addr)
   73: {
;---- Variable 'addr' assigned to Register 'R6/R7' ----
   74:     IAP_CONTR = ENABLE_IAP;         //使能IAP
   75:     IAP_CMD = CMD_ERASE;            //设置IAP命令
0011D2 75C780            MOV      IAP_CONTR,#080H
   76:     IAP_ADDRL = addr;               //设置IAP低地址
0011D5 75C503            MOV      IAP_CMD,#03H
   77:     IAP_ADDRH = addr >> 8;          //设置IAP高地址
0011D8 8FC4              MOV      IAP_ADDRL,R7
   78:     IAP_TRIG = 0x5a;                //写触发命令(0x5a)
0011DA EE                MOV      A,R6
0011DB 515B              ACALL    ?L?COM0048
   79:     IAP_TRIG = 0xa5;                //写触发命令(0xa5)
   80:     _nop_();                        //等待ISP/IAP/EEPROM操作完成
0011DD 00                NOP      
;----                  JMP      IapIdle
   81:     IapIdle();
----- FUNCTION _sys_eepromEraseSector (END) -------


----- FUNCTION IapIdle (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   24: void IapIdle(void)
   25: {
   26:     IAP_CONTR = 0;                  //关闭IAP功能
   27:     IAP_CMD = 0;                    //清除命令寄存器
0011DE E4                CLR      A
0011DF F5C7              MOV      IAP_CONTR,A
   28:     IAP_TRIG = 0;                   //清除触发寄存器
0011E1 F5C5              MOV      IAP_CMD,A
   29:     IAP_ADDRH = 0x80;               //将地址设置到非IAP区域
0011E3 F5C6              MOV      IAP_TRIG,A
   30:     IAP_ADDRL = 0;
0011E5 75C380            MOV      IAP_ADDRH,#080H
   31: }
0011E8 F5C4              MOV      IAP_ADDRL,A
   32: 
0011EA 22                RET      
----- FUNCTION IapIdle (END) -------


----- FUNCTION _sys_eepromWrite (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
  100: void sys_eepromWrite(UINT16 addr, UINT8 *Data, UINT16 num)
  101: {
;---- Variable 'Data' assigned to Register 'R1/R2/R3' ----
;---- Variable 'addr' assigned to Register 'R4/R5' ----
0011EB 51AD              ACALL    ?L?COM005D
  102:     IAP_CONTR = ENABLE_IAP;
  103:     IAP_CMD = CMD_PROGRAM;
0011ED 75C502            MOV      IAP_CMD,#02H
0011F0         ?C0006?SYS_EEPROM:
  104:     while(num--)
0011F0 51B5              ACALL    ?L?COM0041
0011F2 601A              JZ       ?C0007?SYS_EEPROM
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 48


  105:     {
  106:         IAP_ADDRL = addr;
0011F4 8DC4              MOV      IAP_ADDRL,R5
  107:         IAP_ADDRH = addr >> 8;
0011F6 EC                MOV      A,R4
0011F7 F5C3              MOV      IAP_ADDRH,A
  108:         IAP_DATA = *Data;
0011F9 12011C            LCALL    ?C?CLDPTR
0011FC F5C2              MOV      IAP_DATA,A
  109:         IAP_TRIG = 0x5a;
0011FE 515D              ACALL    ?L?COM0049
  110:         IAP_TRIG = 0xa5;
  111:         addr++;
001200 0D                INC      R5
001201 BD0001            CJNE     R5,#00H,?C0010?SYS_EEPROM
001204 0C                INC      R4
001205         ?C0010?SYS_EEPROM:
  112:         Data++;
001205 7401              MOV      A,#01H
001207 29                ADD      A,R1
001208 F9                MOV      R1,A
001209 E4                CLR      A
00120A 3A                ADDC     A,R2
00120B FA                MOV      R2,A
  113:     }
00120C 80E2              SJMP     ?C0006?SYS_EEPROM
00120E         ?C0007?SYS_EEPROM:
  114:     IapIdle();
00120E 80CE              SJMP     IapIdle
----- FUNCTION _sys_eepromWrite (END) -------


----- FUNCTION ?L?COM000D (BEGIN) -----
001210 E0                MOVX     A,@DPTR
001211 FE                MOV      R6,A
001212 A3                INC      DPTR
001213 E0                MOVX     A,@DPTR
001214 FF                MOV      R7,A
001215 7B01              MOV      R3,#01H
001217 7A00              MOV      R2,#HIGH e2_data
001219 7900              MOV      R1,#LOW e2_data
00121B 90004D            MOV      DPTR,#SectorSize
00121E         ?L?COM000E:
00121E E0                MOVX     A,@DPTR
00121F FD                MOV      R5,A
001220 A3                INC      DPTR
001221 E0                MOVX     A,@DPTR
001222 900064            MOV      DPTR,#?_sys_eepromWrite?BYTE+05H
001225 CD                XCH      A,R5
001226 F0                MOVX     @DPTR,A
001227 A3                INC      DPTR
001228 ED                MOV      A,R5
001229 F0                MOVX     @DPTR,A
00122A 22                RET      
----- FUNCTION ?L?COM000D (END) -------


----- FUNCTION ?L?COM0009 (BEGIN) -----
00122B EC                MOV      A,R4
00122C F0                MOVX     @DPTR,A
00122D A3                INC      DPTR
00122E ED                MOV      A,R5
00122F F0                MOVX     @DPTR,A
001230 2402              ADD      A,#02H
001232 FE                MOV      R6,A
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 49


001233 E4                CLR      A
001234 3C                ADDC     A,R4
001235 A3                INC      DPTR
001236 F0                MOVX     @DPTR,A
001237 A3                INC      DPTR
001238 CE                XCH      A,R6
001239 F0                MOVX     @DPTR,A
00123A EB                MOV      A,R3
00123B FF                MOV      R7,A
00123C 7E00              MOV      R6,#00H
00123E 900657            MOV      DPTR,#c_u16_eepromSectorSize
001241 E4                CLR      A
001242 93                MOVC     A,@A+DPTR
001243 FC                MOV      R4,A
001244 7401              MOV      A,#01H
001246 93                MOVC     A,@A+DPTR
001247 FD                MOV      R5,A
001248 120196            LCALL    ?C?IMUL
00124B AA06              MOV      R2,AR6
00124D AB07              MOV      R3,AR7
00124F 900659            MOV      DPTR,#c_u16_eepromSectorAddr
001252         ?L?COM000A:
001252 7401              MOV      A,#01H
001254 93                MOVC     A,@A+DPTR
001255 2B                ADD      A,R3
001256 FE                MOV      R6,A
001257 E4                CLR      A
001258 93                MOVC     A,@A+DPTR
001259 3A                ADDC     A,R2
00125A 22                RET      
----- FUNCTION ?L?COM0009 (END) -------


----- FUNCTION ?L?COM0048 (BEGIN) -----
00125B F5C3              MOV      IAP_ADDRH,A
00125D         ?L?COM0049:
00125D 75C65A            MOV      IAP_TRIG,#05AH
001260 75C6A5            MOV      IAP_TRIG,#0A5H
001263 22                RET      
----- FUNCTION ?L?COM0048 (END) -------


----- FUNCTION _sys_eepromRead (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   84: void sys_eepromRead(UINT16 addr, UINT8 *Data, UINT16 num)
   85: {
001264 900061            MOV      DPTR,#Data
001267 120DE5            LCALL    ?L?COM0008
;---- Variable 'addr' assigned to Register 'R4/R5' ----
00126A 51AD              ACALL    ?L?COM005D
   86:     IAP_CONTR = ENABLE_IAP;
   87:     IAP_CMD = CMD_READ;
00126C 75C501            MOV      IAP_CMD,#01H
00126F         ?C0003?SYS_EEPROM:
   88:     while(num--)
00126F 51B5              ACALL    ?L?COM0041
001271 6021              JZ       ?C0004?SYS_EEPROM
   89:     {
   90:         IAP_ADDRL = addr;
001273 8DC4              MOV      IAP_ADDRL,R5
   91:         IAP_ADDRH = addr >> 8;
001275 EC                MOV      A,R4
001276 515B              ACALL    ?L?COM0048
   92:         IAP_TRIG = 0x5a;
   93:         IAP_TRIG = 0xa5;
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 50


   94:         addr++;
001278 0D                INC      R5
001279 BD0001            CJNE     R5,#00H,?C0009?SYS_EEPROM
00127C 0C                INC      R4
00127D         ?C0009?SYS_EEPROM:
   95:         *Data++ = IAP_DATA;
00127D 900061            MOV      DPTR,#Data
001280 E0                MOVX     A,@DPTR
001281 FB                MOV      R3,A
001282 A3                INC      DPTR
001283 E4                CLR      A
001284 75F001            MOV      B,#01H
001287 1201FD            LCALL    ?C?ILDIX
00128A A9F0              MOV      R1,B
00128C FA                MOV      R2,A
00128D E5C2              MOV      A,IAP_DATA
00128F 120162            LCALL    ?C?CSTPTR
   96:     }
001292 80DB              SJMP     ?C0003?SYS_EEPROM
001294         ?C0004?SYS_EEPROM:
   97:     IapIdle();
001294 21DE              AJMP     IapIdle
----- FUNCTION _sys_eepromRead (END) -------


----- FUNCTION ?L?COM0011 (BEGIN) -----
001296 5164              ACALL    _sys_eepromRead
001298 900052            MOV      DPTR,#sector
00129B         ?L?COM0012:
00129B E0                MOVX     A,@DPTR
00129C 75F003            MOV      B,#03H
00129F A4                MUL      AB
0012A0 2453              ADD      A,#LOW c_s_eepromConfig+02H
0012A2 F582              MOV      DPL,A
0012A4 E5F0              MOV      A,B
0012A6 3406              ADDC     A,#HIGH c_s_eepromConfig+02H
0012A8 F583              MOV      DPH,A
0012AA E4                CLR      A
0012AB 93                MOVC     A,@A+DPTR
0012AC 22                RET      
----- FUNCTION ?L?COM0011 (END) -------


----- FUNCTION ?L?COM005D (BEGIN) -----
0012AD AD07              MOV      R5,AR7
0012AF AC06              MOV      R4,AR6
0012B1 75C780            MOV      IAP_CONTR,#080H
0012B4 22                RET      
----- FUNCTION ?L?COM005D (END) -------


----- FUNCTION ?L?COM0041 (BEGIN) -----
0012B5 900064            MOV      DPTR,#num
0012B8 74FF              MOV      A,#0FFH
0012BA F5F0              MOV      B,A
0012BC 1201FD            LCALL    ?C?ILDIX
0012BF 45F0              ORL      A,B
0012C1 22                RET      
----- FUNCTION ?L?COM0041 (END) -------


----- FUNCTION _hwa_eepromEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   37: void hwa_eepromEncrypt(UINT8 *dat, UINT16 size)        //加密
   38: {
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 51


0012C2 90004F            MOV      DPTR,#dat
0012C5 120DE5            LCALL    ?L?COM0008
;---- Variable 'i' assigned to Register 'R6/R7' ----
0012C8 91F9              ACALL    ?L?COM004C
0012CA         ?C0001?HWA_EEPROM_CFG:
0012CA D3                SETB     C
0012CB 900053            MOV      DPTR,#size+01H
0012CE E0                MOVX     A,@DPTR
0012CF 9F                SUBB     A,R7
0012D0 900052            MOV      DPTR,#size
0012D3 E0                MOVX     A,@DPTR
0012D4 9E                SUBB     A,R6
0012D5 401A              JC       ?C0004?HWA_EEPROM_CFG
   39: 	UINT16 i;
   40: 	UINT8 tmp;
   41: 	for (i = 0; i<size; i++)
   42: 	{
   43: 		tmp = dat[i];
0012D7 90004F            MOV      DPTR,#dat
0012DA 120C68            LCALL    ?L?COM0002
;---- Variable 'tmp' assigned to Register 'R5' ----
0012DD B133              ACALL    ?L?COM0042
   44: 		tmp ^= SecretKey;
   45: 		tmp = (tmp >> 1) | (tmp << 7);
0012DF C4                SWAP     A
0012E0 33                RLC      A
0012E1 33                RLC      A
0012E2 33                RLC      A
0012E3 5480              ANL      A,#080H
0012E5 FC                MOV      R4,A
0012E6 ED                MOV      A,R5
0012E7 C3                CLR      C
0012E8 13                RRC      A
0012E9 B13F              ACALL    ?L?COM0040
0012EB BF0001            CJNE     R7,#00H,?C0009?HWA_EEPROM_CFG
0012EE 0E                INC      R6
0012EF         ?C0009?HWA_EEPROM_CFG:
0012EF 80D9              SJMP     ?C0001?HWA_EEPROM_CFG
   46: 		tmp ^= SecretKey;
   47: 		dat[i] = tmp;
   48: 	}
   49: }
0012F1         ?C0004?HWA_EEPROM_CFG:
0012F1 22                RET      
----- FUNCTION _hwa_eepromEncrypt (END) -------


----- FUNCTION sys_tim0Isr (BEGIN) -----
 FILE: 'System\sys_task.c'
   40: void sys_tim0Isr(void) interrupt 1      //1ms interrupt task
0012F2 C0E0              PUSH     ACC
0012F4 C0F0              PUSH     B
0012F6 C083              PUSH     DPH
0012F8 C082              PUSH     DPL
0012FA C0D0              PUSH     PSW
0012FC 75D000            MOV      PSW,#00H
0012FF C000              PUSH     AR0
001301 C001              PUSH     AR1
001303 C002              PUSH     AR2
001305 C003              PUSH     AR3
001307 C004              PUSH     AR4
001309 C005              PUSH     AR5
00130B C006              PUSH     AR6
00130D C007              PUSH     AR7
   41: {
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 52


   42:     led_Handler1ms();
00130F 7177              ACALL    led_Handler1ms
   43: 	taskHandlerCnt10ms++;
001311 9000CF            MOV      DPTR,#taskHandlerCnt10ms
001314 E0                MOVX     A,@DPTR
001315 04                INC      A
001316 F0                MOVX     @DPTR,A
   44:     if(taskHandlerCnt10ms>=10)
001317 E0                MOVX     A,@DPTR
001318 C3                CLR      C
001319 940A              SUBB     A,#0AH
00131B 400B              JC       ?C0003?SYS_TASK
   45:     {
   46:         taskHandlerCnt10ms = 0;
00131D E4                CLR      A
00131E F0                MOVX     @DPTR,A
   47:         sys_taskHandler10ms();
00131F 12000A            LCALL    sys_taskHandler10ms
   48:         taskHandlerCnt100ms++;
001322 9000CD            MOV      DPTR,#taskHandlerCnt100ms
001325 E0                MOVX     A,@DPTR
001326 04                INC      A
001327 F0                MOVX     @DPTR,A
   49:     }
001328         ?C0003?SYS_TASK:
   50:     if(taskHandlerCnt100ms>=10)
001328 9000CD            MOV      DPTR,#taskHandlerCnt100ms
00132B E0                MOVX     A,@DPTR
00132C C3                CLR      C
00132D 940A              SUBB     A,#0AH
00132F 400A              JC       ?C0004?SYS_TASK
   51:     {
   52:         taskHandlerCnt100ms = 0;
001331 E4                CLR      A
001332 F0                MOVX     @DPTR,A
   53:         sys_taskHandler100ms();
001333 7166              ACALL    sys_taskHandler100ms
   54:         taskHandlerCnt1s++;
001335 9000CE            MOV      DPTR,#taskHandlerCnt1s
001338 E0                MOVX     A,@DPTR
001339 04                INC      A
00133A F0                MOVX     @DPTR,A
   55:     }
00133B         ?C0004?SYS_TASK:
   56:     if(taskHandlerCnt1s>=10)
00133B 9000CE            MOV      DPTR,#taskHandlerCnt1s
00133E E0                MOVX     A,@DPTR
00133F C3                CLR      C
001340 940A              SUBB     A,#0AH
001342 4007              JC       ?C0006?SYS_TASK
   57:     {
   58:         taskHandlerCnt1s = 0;
001344 E4                CLR      A
001345 F0                MOVX     @DPTR,A
   59:         sys_taskHandler1s();
001346 120021            LCALL    sys_taskHandler1s
   60:         taskCycle1sFlag = TRUE;
001349 D206              SETB     taskCycle1sFlag
   61:     }
   62: }
00134B         ?C0006?SYS_TASK:
00134B D007              POP      AR7
00134D D006              POP      AR6
00134F D005              POP      AR5
001351 D004              POP      AR4
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 53


001353 D003              POP      AR3
001355 D002              POP      AR2
001357 D001              POP      AR1
001359 D000              POP      AR0
00135B D0D0              POP      PSW
00135D D082              POP      DPL
00135F D083              POP      DPH
001361 D0F0              POP      B
001363 D0E0              POP      ACC
001365 32                RETI     
----- FUNCTION sys_tim0Isr (END) -------


----- FUNCTION sys_taskHandler100ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   68: void sys_taskHandler100ms(void)           //100ms interrupt task
;----                  JMP      buzzer_Handler100ms
   69: {
----- FUNCTION sys_taskHandler100ms (END) -------


----- FUNCTION buzzer_Handler100ms (BEGIN) -----
 FILE: 'Driver\buzzer.c'
   15: void buzzer_Handler100ms(void)
   16: {
   17:     if(Buzzer)
   18: 	{
001366 30B503            JNB      Buzzer,?C0002?BUZZER
   19: 		Buzzer = 0;
   20: 	}
001369 C2B5              CLR      Buzzer
   21: 	else if(SoundNumberCount)
00136B 22                RET      
00136C         ?C0002?BUZZER:
   22: 	{
00136C 9000D1            MOV      DPTR,#SoundNumberCount
00136F E0                MOVX     A,@DPTR
001370 6004              JZ       ?C0005?BUZZER
   23: 		Buzzer = 1;
   24: 		SoundNumberCount--;
001372 D2B5              SETB     Buzzer
   25: 	}
001374 14                DEC      A
001375 F0                MOVX     @DPTR,A
   26: }
   27: 
001376         ?C0005?BUZZER:
001376 22                RET      
----- FUNCTION buzzer_Handler100ms (END) -------


----- FUNCTION led_Handler1ms (BEGIN) -----
 FILE: 'Driver\LED.c'
   30: void led_Handler1ms(void)
   31: {
   32:     if(ledsw)
   33:     {
001377 200902            JB       ledsw,$ + 5H
00137A 817B              AJMP     ?C0033?LED
   34:     	if (gCurLed<5)
   35:     		gCurLed++;
00137C 9000CB            MOV      DPTR,#gCurLed
00137F E0                MOVX     A,@DPTR
001380 C3                CLR      C
001381 9405              SUBB     A,#05H
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 54


001383 5005              JNC      ?C0003?LED
   36:     	else
001385 E0                MOVX     A,@DPTR
001386 04                INC      A
001387 F0                MOVX     @DPTR,A
001388 8005              SJMP     ?C0004?LED
00138A         ?C0003?LED:
   37:     		gCurLed=0;
00138A E4                CLR      A
00138B 9000CB            MOV      DPTR,#gCurLed
00138E F0                MOVX     @DPTR,A
00138F         ?C0004?LED:
   38:     	LED_CS0 = 1;
00138F 917C              ACALL    ?L?COM003F
   39:     	LED_CS1 = 1;
   40:     	LED_CS2 = 1;
   41:     	LED_CS3 = 1;
   42:     	LED_CS4 = 1;
   43:     	LED_CS5 = 1;
   44:     	switch ( gLedBuf[gCurLed])		 //switch case 语句中 switch中的条件case都不满足就执行default
001391 9000CB            MOV      DPTR,#gCurLed
001394 E0                MOVX     A,@DPTR
001395 FF                MOV      R7,A
001396 24C5              ADD      A,#LOW gLedBuf
001398 F582              MOV      DPL,A
00139A E4                CLR      A
00139B 3400              ADDC     A,#HIGH gLedBuf
00139D F583              MOV      DPH,A
00139F E0                MOVX     A,@DPTR
0013A0 B41100            CJNE     A,#011H,?C0045?LED
0013A3         ?C0045?LED:
0013A3 4002              JC       $ + 4H
0013A5 8133              AJMP     ?C0023?LED
0013A7 9013AE            MOV      DPTR,#013AEH
0013AA F8                MOV      R0,A
0013AB 28                ADD      A,R0
0013AC 28                ADD      A,R0
0013AD 73                JMP      @A+DPTR
0013AE         ?C0046?LED:
0013AE 0213E1            LJMP     ?C0006?LED
0013B1 0213E6            LJMP     ?C0007?LED
0013B4 0213EB            LJMP     ?C0008?LED
0013B7 0213F0            LJMP     ?C0009?LED
0013BA 0213F5            LJMP     ?C0010?LED
0013BD 0213FA            LJMP     ?C0011?LED
0013C0 0213FF            LJMP     ?C0012?LED
0013C3 021404            LJMP     ?C0013?LED
0013C6 021409            LJMP     ?C0014?LED
0013C9 02140E            LJMP     ?C0015?LED
0013CC 021413            LJMP     ?C0016?LED
0013CF 021418            LJMP     ?C0017?LED
0013D2 02141D            LJMP     ?C0018?LED
0013D5 02141F            LJMP     ?C0019?LED
0013D8 021424            LJMP     ?C0020?LED
0013DB 021429            LJMP     ?C0021?LED
0013DE 02142E            LJMP     ?C0022?LED
   45:     	{
   46:     	    case 0:	P1 = 0xeb; break;//0X88
0013E1         ?C0006?LED:
0013E1 7590EB            MOV      P1,#0EBH
0013E4 8050              SJMP     ?C0005?LED
   47:     		case 1:	P1 = 0x88; break;//0XEB
0013E6         ?C0007?LED:
0013E6 759088            MOV      P1,#088H
0013E9 804B              SJMP     ?C0005?LED
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 55


   48:     		case 2:	P1 = 0xB3; break;//0X92
0013EB         ?C0008?LED:
0013EB 7590B3            MOV      P1,#0B3H
0013EE 8046              SJMP     ?C0005?LED
   49:     		case 3:	P1 = 0xba; break;//0XC2
0013F0         ?C0009?LED:
0013F0 7590BA            MOV      P1,#0BAH
0013F3 8041              SJMP     ?C0005?LED
   50:     		case 4:	P1 = 0xd8; break;//0XE1
0013F5         ?C0010?LED:
0013F5 7590D8            MOV      P1,#0D8H
0013F8 803C              SJMP     ?C0005?LED
   51:     		case 5:	P1 = 0x7a; break;//0XC4
0013FA         ?C0011?LED:
0013FA 75907A            MOV      P1,#07AH
0013FD 8037              SJMP     ?C0005?LED
   52:     		case 6:	P1 = 0x7b; break;//0X84
0013FF         ?C0012?LED:
0013FF 75907B            MOV      P1,#07BH
001402 8032              SJMP     ?C0005?LED
   53:     		case 7:	P1 = 0xa8; break;//0XEA
001404         ?C0013?LED:
001404 7590A8            MOV      P1,#0A8H
001407 802D              SJMP     ?C0005?LED
   54:     		case 8:	P1 = 0xfb; break;//0X80
001409         ?C0014?LED:
001409 7590FB            MOV      P1,#0FBH
00140C 8028              SJMP     ?C0005?LED
   55:     		case 9:	P1 = 0xfa; break;//0XC0
00140E         ?C0015?LED:
00140E 7590FA            MOV      P1,#0FAH
001411 8023              SJMP     ?C0005?LED
   56:     		case 10:P1 = 0xcb; break;//0XC0 U
001413         ?C0016?LED:
001413 7590CB            MOV      P1,#0CBH
001416 801E              SJMP     ?C0005?LED
   57:     		case 11:P1 = 0xbe; break;//3.
001418         ?C0017?LED:
001418 7590BE            MOV      P1,#0BEH
00141B 8019              SJMP     ?C0005?LED
   58:     		case 12:P1 = 0x00; break;//空
00141D         ?C0018?LED:
00141D 8014              SJMP     ?C0049?LED
   59:     		case 13:P1 = 0x7e; break;//5.
00141F         ?C0019?LED:
00141F 75907E            MOV      P1,#07EH
001422 8012              SJMP     ?C0005?LED
   60:             case 14:P1 = 0xf1;break;//P
001424         ?C0020?LED:
001424 7590F1            MOV      P1,#0F1H
001427 800D              SJMP     ?C0005?LED
   61:             case 15:P1 = 0x10;break;//-
001429         ?C0021?LED:
001429 759010            MOV      P1,#010H
00142C 8008              SJMP     ?C0005?LED
   62:             case 16:P1 = 0xf9;break;//A
00142E         ?C0022?LED:
00142E 7590F9            MOV      P1,#0F9H
001431 8003              SJMP     ?C0005?LED
   63:     		default:P1 = 0x00; break;
001433         ?C0023?LED:
001433         
001433 E4                CLR      A
001434 F590              MOV      P1,A
   64:     	}
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 56


001436         ?C0005?LED:
   65:         if(gShowDot & (1<<gCurLed))//show dot
001436 7401              MOV      A,#01H
001438 7E00              MOV      R6,#00H
00143A A807              MOV      R0,AR7
00143C 08                INC      R0
00143D 8005              SJMP     ?C0048?LED
00143F         ?C0047?LED:
00143F C3                CLR      C
001440 33                RLC      A
001441 CE                XCH      A,R6
001442 33                RLC      A
001443 CE                XCH      A,R6
001444         ?C0048?LED:
001444 D8F9              DJNZ     R0,?C0047?LED
001446 FF                MOV      R7,A
001447 9000CC            MOV      DPTR,#gShowDot
00144A E0                MOVX     A,@DPTR
00144B FD                MOV      R5,A
00144C EF                MOV      A,R7
00144D 5D                ANL      A,R5
00144E 6003              JZ       ?C0024?LED
   66:         {
   67:      		P1 |= 0X04;
001450 439004            ORL      P1,#04H
   68:         }
001453         ?C0024?LED:
   69:     	switch (gCurLed)
001453 9000CB            MOV      DPTR,#gCurLed
001456 E0                MOVX     A,@DPTR
001457 14                DEC      A
001458 6013              JZ       ?C0027?LED
00145A 14                DEC      A
00145B 6013              JZ       ?C0028?LED
00145D 14                DEC      A
00145E 6013              JZ       ?C0029?LED
001460 14                DEC      A
001461 6013              JZ       ?C0030?LED
001463 14                DEC      A
001464 6013              JZ       ?C0031?LED
001466 2405              ADD      A,#05H
001468 7011              JNZ      ?C0033?LED
   70:     	{
   71:     		case 0:
00146A         ?C0026?LED:
   72:     			LED_CS0 = 0;
00146A C2A6              CLR      LED_CS0
   73:     			break;
00146C 22                RET      
   74:     		case 1:
00146D         ?C0027?LED:
   75:     			LED_CS1 = 0;
00146D C2A7              CLR      LED_CS1
   76:     			break;
00146F 22                RET      
   77:     		case 2:
001470         ?C0028?LED:
   78:     			LED_CS2 = 0;
001470 C2A0              CLR      LED_CS2
   79:     			break;
001472 22                RET      
   80:     		case 3:
001473         ?C0029?LED:
   81:     			LED_CS3 = 0;
001473 C2CD              CLR      LED_CS3
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 57


   82:     			break;
001475 22                RET      
   83:     		case 4:
001476         ?C0030?LED:
   84:     			LED_CS4 = 0;
001476 C2CC              CLR      LED_CS4
   85:     			break;
001478 22                RET      
   86:     		case 5:
001479         ?C0031?LED:
   87:     			LED_CS5 = 0;
001479 C2B6              CLR      LED_CS5
   88:     			break;
   89:     		default:
   90:     			break;
   91:     	}
   92:     }
   93: }
00147B         ?C0033?LED:
00147B 22                RET      
----- FUNCTION led_Handler1ms (END) -------


----- FUNCTION ?L?COM003F (BEGIN) -----
00147C D2A6              SETB     LED_CS0
00147E D2A7              SETB     LED_CS1
001480 D2A0              SETB     LED_CS2
001482 D2CD              SETB     LED_CS3
001484 D2CC              SETB     LED_CS4
001486 D2B6              SETB     LED_CS5
001488 22                RET      
----- FUNCTION ?L?COM003F (END) -------


----- FUNCTION sys_uartInit (BEGIN) -----
 FILE: 'System\sys_uart.c'
   13: void sys_uartInit(void)
   14: {
   15:     ACC = P_SW1;
   16:     ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
001489 E5A2              MOV      A,P_SW1
   17:     P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
00148B 543F              ANL      A,#03FH
   18:     SCON = 0x50;                //8位可变波特率
00148D F5A2              MOV      P_SW1,A
   19:     T2L = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
00148F 759850            MOV      SCON,#050H
   20:     T2H = (65536 - (FOSC/4/BAUD))>>8;
001492 75D7E0            MOV      T2L,#0E0H
   21:     AUXR |= 0x14;                //T2为1T模式, 并启动定时器2
001495 75D6FE            MOV      T2H,#0FEH
   22:     AUXR |= 0x01;               //选择定时器2为串口1的波特率发生器
001498 438E14            ORL      AUXR,#014H
   23:     ES = 1;                     //使能串口1中断
00149B 438E01            ORL      AUXR,#01H
   24:     EA = 1;
00149E D2AC              SETB     ES
   25: }
0014A0 D2AF              SETB     EA
   26: 
0014A2 22                RET      
----- FUNCTION sys_uartInit (END) -------


----- FUNCTION sys_uartInterrupt (BEGIN) -----
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 58


 FILE: 'System\sys_uart.c'
   27: void sys_uartInterrupt() interrupt 4
0014A3 C0E0              PUSH     ACC
0014A5 C0F0              PUSH     B
0014A7 C083              PUSH     DPH
0014A9 C082              PUSH     DPL
0014AB C0D0              PUSH     PSW
0014AD 75D000            MOV      PSW,#00H
0014B0 C000              PUSH     AR0
0014B2 C001              PUSH     AR1
0014B4 C002              PUSH     AR2
0014B6 C003              PUSH     AR3
0014B8 C004              PUSH     AR4
0014BA C005              PUSH     AR5
0014BC C006              PUSH     AR6
0014BE C007              PUSH     AR7
   28: {
   29:     if(RI)
0014C0 309804            JNB      RI,?C0002?SYS_UART
   30:     {
   31:         RI = 0;
0014C3 C298              CLR      RI
   32:         sys_uartRxHandler();
0014C5 B193              ACALL    sys_uartRxHandler
   33:     }
0014C7         ?C0002?SYS_UART:
   34:     if(TI)
0014C7 309902            JNB      TI,?C0004?SYS_UART
   35:     {
   36:         TI = 0;
0014CA C299              CLR      TI
   37:     }
   38: }
0014CC         ?C0004?SYS_UART:
0014CC D007              POP      AR7
0014CE D006              POP      AR6
0014D0 D005              POP      AR5
0014D2 D004              POP      AR4
0014D4 D003              POP      AR3
0014D6 D002              POP      AR2
0014D8 D001              POP      AR1
0014DA D000              POP      AR0
0014DC D0D0              POP      PSW
0014DE D082              POP      DPL
0014E0 D083              POP      DPH
0014E2 D0F0              POP      B
0014E4 D0E0              POP      ACC
0014E6 32                RETI     
----- FUNCTION sys_uartInterrupt (END) -------


----- FUNCTION ?L?COM005A (BEGIN) -----
0014E7 F0                MOVX     @DPTR,A
0014E8 A3                INC      DPTR
0014E9 CE                XCH      A,R6
0014EA F0                MOVX     @DPTR,A
0014EB 90065B            MOV      DPTR,#c_u16_eepromSectorBakAddr
0014EE 22                RET      
----- FUNCTION ?L?COM005A (END) -------


----- FUNCTION buzzer_Init (BEGIN) -----
 FILE: 'Driver\buzzer.c'
    8: void buzzer_Init(void)
    9: {
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 59


   10:     P3M1 &= ~0x20;      //推挽输出
   11:     P3M0 |= 0x20;
0014EF 53B1DF            ANL      P3M1,#0DFH
   12:     P3 &= ~0x20;
0014F2 43B220            ORL      P3M0,#020H
   13: }
0014F5 53B0DF            ANL      P3,#0DFH
   14: 
0014F8 22                RET      
----- FUNCTION buzzer_Init (END) -------


----- FUNCTION ?L?COM004C (BEGIN) -----
0014F9 A3                INC      DPTR
0014FA EC                MOV      A,R4
0014FB F0                MOVX     @DPTR,A
0014FC A3                INC      DPTR
0014FD ED                MOV      A,R5
0014FE F0                MOVX     @DPTR,A
0014FF E4                CLR      A
001500 FF                MOV      R7,A
001501 FE                MOV      R6,A
001502 22                RET      
----- FUNCTION ?L?COM004C (END) -------


----- FUNCTION _hwa_eepromDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   51: void hwa_eepromDecrypt(UINT8 *dat, UINT16 size)        //解密
   52: {
001503 90005F            MOV      DPTR,#dat
001506 120DE5            LCALL    ?L?COM0008
;---- Variable 'i' assigned to Register 'R6/R7' ----
001509 91F9              ACALL    ?L?COM004C
00150B         ?C0005?HWA_EEPROM_CFG:
00150B D3                SETB     C
00150C 900063            MOV      DPTR,#size+01H
00150F E0                MOVX     A,@DPTR
001510 9F                SUBB     A,R7
001511 900062            MOV      DPTR,#size
001514 E0                MOVX     A,@DPTR
001515 9E                SUBB     A,R6
001516 401A              JC       ?C0008?HWA_EEPROM_CFG
   53: 	UINT16 i;
   54: 	UINT8 tmp;
   55: 	for (i = 0; i<size; i++)
   56: 	{
   57: 		tmp = dat[i];
001518 90005F            MOV      DPTR,#dat
00151B 120C68            LCALL    ?L?COM0002
;---- Variable 'tmp' assigned to Register 'R5' ----
00151E B133              ACALL    ?L?COM0042
   58: 		tmp ^= SecretKey;
   59: 		tmp = (tmp << 1) | (tmp >> 7);
001520 25E0              ADD      A,ACC
001522 FC                MOV      R4,A
001523 ED                MOV      A,R5
001524 C4                SWAP     A
001525 13                RRC      A
001526 13                RRC      A
001527 13                RRC      A
001528 5401              ANL      A,#01H
00152A B13F              ACALL    ?L?COM0040
00152C BF0001            CJNE     R7,#00H,?C0010?HWA_EEPROM_CFG
00152F 0E                INC      R6
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 60


001530         ?C0010?HWA_EEPROM_CFG:
001530 80D9              SJMP     ?C0005?HWA_EEPROM_CFG
   60: 		tmp ^= SecretKey;
   61: 		dat[i] = tmp;
   62: 	}
   63: }
001532         ?C0008?HWA_EEPROM_CFG:
001532 22                RET      
----- FUNCTION _hwa_eepromDecrypt (END) -------


----- FUNCTION ?L?COM0042 (BEGIN) -----
001533 F9                MOV      R1,A
001534 8F82              MOV      DPL,R7
001536 8E83              MOV      DPH,R6
001538 120135            LCALL    ?C?CLDOPTR
00153B 64A5              XRL      A,#0A5H
00153D FD                MOV      R5,A
00153E 22                RET      
----- FUNCTION ?L?COM0042 (END) -------


----- FUNCTION ?L?COM0040 (BEGIN) -----
00153F 4C                ORL      A,R4
001540 64A5              XRL      A,#0A5H
001542 FD                MOV      R5,A
001543 8F82              MOV      DPL,R7
001545 8E83              MOV      DPH,R6
001547 120174            LCALL    ?C?CSTOPTR
00154A 0F                INC      R7
00154B 22                RET      
----- FUNCTION ?L?COM0040 (END) -------


----- FUNCTION ?L?COM004D (BEGIN) -----
00154C 900650            MOV      DPTR,#c_u8_eepromSectorNum
00154F E4                CLR      A
001550 93                MOVC     A,@A+DPTR
001551 FF                MOV      R7,A
001552 ED                MOV      A,R5
001553 C3                CLR      C
001554 9F                SUBB     A,R7
001555 22                RET      
----- FUNCTION ?L?COM004D (END) -------


----- FUNCTION ?L?COM0046 (BEGIN) -----
001556 E0                MOVX     A,@DPTR
001557 FE                MOV      R6,A
001558 A3                INC      DPTR
001559 E0                MOVX     A,@DPTR
00155A FF                MOV      R7,A
00155B 7800              MOV      R0,#LOW e2_data
00155D 7C00              MOV      R4,#HIGH e2_data
00155F 7D01              MOV      R5,#01H
001561 22                RET      
----- FUNCTION ?L?COM0046 (END) -------


----- FUNCTION ?L?COM0028 (BEGIN) -----
001562 E0                MOVX     A,@DPTR
001563 FB                MOV      R3,A
001564 75F003            MOV      B,#03H
001567 A4                MUL      AB
001568 2451              ADD      A,#LOW c_s_eepromConfig
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 61


00156A F582              MOV      DPL,A
00156C E5F0              MOV      A,B
00156E 3406              ADDC     A,#HIGH c_s_eepromConfig
001570 F583              MOV      DPH,A
001572 E4                CLR      A
001573 93                MOVC     A,@A+DPTR
001574 FC                MOV      R4,A
001575 7401              MOV      A,#01H
001577 93                MOVC     A,@A+DPTR
001578 FD                MOV      R5,A
001579 22                RET      
----- FUNCTION ?L?COM0028 (END) -------


----- FUNCTION len_Init (BEGIN) -----
 FILE: 'Driver\LED.c'
   17: void len_Init(void)
   18: {
   19:     P1M1 &= ~0xFF;      //推挽输出
   20:     P1M0 |= 0xFF;
00157A 759100            MOV      P1M1,#00H
   21:     P2M1 &= ~0xC1;      //推挽输出
00157D 7592FF            MOV      P1M0,#0FFH
   22:     P2M0 |= 0xC1;
001580 53953E            ANL      P2M1,#03EH
   23:     P5M1 &= ~0x30;      //推挽输出
001583 4396C1            ORL      P2M0,#0C1H
   24:     P5M0 |= 0x30;
001586 53C9CF            ANL      P5M1,#0CFH
   25:     P3M1 &= ~0x40;      //推挽输出
001589 43CA30            ORL      P5M0,#030H
   26:     P3M0 |= 0x40;
00158C 53B1BF            ANL      P3M1,#0BFH
   27: }
00158F 43B240            ORL      P3M0,#040H
   28: 
001592 22                RET      
----- FUNCTION len_Init (END) -------


----- FUNCTION sys_uartRxHandler (BEGIN) -----
 FILE: 'System\sys_uart.c'
   41: void sys_uartRxHandler(void)
   42: {
   43:     if(SBUF == 0x7F)        //0x7F auto download     boud 2400 0x7F at boud 9600 is 0xF8
   44:     {
001593 E599              MOV      A,SBUF
001595 B47F10            CJNE     A,#07FH,?C0005?SYS_UART
   45:         RxNum++;
   46:         if(RxNum >= 40)
001598 9000D0            MOV      DPTR,#RxNum
00159B E0                MOVX     A,@DPTR
00159C 04                INC      A
00159D F0                MOVX     @DPTR,A
   47:         {
00159E E0                MOVX     A,@DPTR
00159F C3                CLR      C
0015A0 9428              SUBB     A,#028H
0015A2 4009              JC       ?C0008?SYS_UART
   48:             IAP_CONTR = 0x60;
   49:         }
0015A4 75C760            MOV      IAP_CONTR,#060H
   50:     }
   51:     else
0015A7 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 62


0015A8         ?C0005?SYS_UART:
   52:     {
   53:         RxNum = 0;
0015A8 E4                CLR      A
0015A9 9000D0            MOV      DPTR,#RxNum
0015AC F0                MOVX     @DPTR,A
   54:     }
   55: }
0015AD         ?C0008?SYS_UART:
0015AD 22                RET      
----- FUNCTION sys_uartRxHandler (END) -------


----- FUNCTION app_brushCard (BEGIN) -----
 FILE: 'App\app_brush.c'
   58: UINT8 app_brushCard(void)
   59: {
   60: 	UINT8 Sector;
   61: 	UINT8 CardIndex;
   62:     UINT8 i;
   63: 	for (CardIndex = MEM_CARD; CardIndex <= PWD_CARD; CardIndex++)
0015AE 900041            MOV      DPTR,#CardIndex
0015B1 7401              MOV      A,#01H
0015B3 F0                MOVX     @DPTR,A
0015B4         ?C0005?APP_BRUSH:
   64: 	{
   65: 		if (b_FactorySystem)
0015B4 300806            JNB      b_FactorySystem,?C0008?APP_BRUSH
   66: 		{
   67: 			CardIndex = PWD_CARD;
0015B7 900041            MOV      DPTR,#CardIndex
0015BA 7403              MOV      A,#03H
0015BC F0                MOVX     @DPTR,A
   68: 		}
0015BD         ?C0008?APP_BRUSH:
   69: 		if (CardIndex == MEM_CARD)
0015BD 900041            MOV      DPTR,#CardIndex
0015C0 E0                MOVX     A,@DPTR
0015C1 B40108            CJNE     A,#01H,?C0009?APP_BRUSH
   70: 		{
   71: 			Load_Key(&s_System.MGM_Card);
0015C4 7B01              MOV      R3,#01H
0015C6 7A00              MOV      R2,#HIGH s_System
0015C8 7994              MOV      R1,#LOW s_System
   72: 		}
0015CA 801C              SJMP     ?C0064?APP_BRUSH
0015CC         ?C0009?APP_BRUSH:
   73: 		else if (CardIndex == USER_CARD)
0015CC 900041            MOV      DPTR,#CardIndex
0015CF E0                MOVX     A,@DPTR
0015D0 B40208            CJNE     A,#02H,?C0011?APP_BRUSH
   74: 		{
   75: 			Load_Key(&s_System.USER_Card);
0015D3 7B01              MOV      R3,#01H
0015D5 7A00              MOV      R2,#HIGH s_System+0AH
0015D7 799E              MOV      R1,#LOW s_System+0AH
0015D9         
   76: 		}
0015D9 800D              SJMP     ?C0064?APP_BRUSH
0015DB         ?C0011?APP_BRUSH:
   77: 		else if (CardIndex == PWD_CARD)
0015DB 900041            MOV      DPTR,#CardIndex
0015DE E0                MOVX     A,@DPTR
0015DF B40309            CJNE     A,#03H,?C0010?APP_BRUSH
   78: 		{
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 63


   79: 			Load_Key(PWD_Card);
0015E2 7BFF              MOV      R3,#0FFH
0015E4 7A00              MOV      R2,#HIGH PWD_Card
0015E6 7903              MOV      R1,#LOW PWD_Card
0015E8         
0015E8 12196C            LCALL    _Load_Key
   80: 		}
0015EB         ?C0010?APP_BRUSH:
   81: 		MIF_Halt();
0015EB D155              ACALL    MIF_Halt
   82: 		if (Request(RF_CMD_REQUEST_STD) != FM1702_OK)
0015ED 7F26              MOV      R7,#026H
0015EF 121802            LCALL    _Request
0015F2 EF                MOV      A,R7
0015F3 704F              JNZ      ?C0007?APP_BRUSH
   83: 		{
   84: 			continue;
   85: 		}
0015F5         ?C0014?APP_BRUSH:
   86:         for(i=0; i<2; i++)
0015F5 E4                CLR      A
0015F6 900042            MOV      DPTR,#i
0015F9 F0                MOVX     @DPTR,A
0015FA         ?C0015?APP_BRUSH:
   87:         {
   88:             if (AntiColl() == FM1702_OK && SelectCard() == FM1702_OK)
0015FA 120727            LCALL    AntiColl
0015FD EF                MOV      A,R7
0015FE 7038              JNZ      ?C0017?APP_BRUSH
001600 F11E              ACALL    SelectCard
001602 EF                MOV      A,R7
001603 7033              JNZ      ?C0017?APP_BRUSH
   89:             {
   90:                 if (CardIndex == USER_CARD)     //用户卡验证钱所在扇区
001605 900041            MOV      DPTR,#CardIndex
001608 E0                MOVX     A,@DPTR
001609 B4020A            CJNE     A,#02H,?C0019?APP_BRUSH
   91:                 {
   92:                     Sector = s_System.Sector;
00160C 90009A            MOV      DPTR,#s_System+06H
00160F E0                MOVX     A,@DPTR
001610 900040            MOV      DPTR,#Sector
001613 F0                MOVX     @DPTR,A
   93:                 }
001614 8006              SJMP     ?C0020?APP_BRUSH
001616         ?C0019?APP_BRUSH:
   94:                 else                            //管理和密码卡验证1扇区
   95:                 {
   96:                     Sector = 1;
001616 900040            MOV      DPTR,#Sector
001619 7401              MOV      A,#01H
00161B F0                MOVX     @DPTR,A
   97:                 }
00161C         ?C0020?APP_BRUSH:
   98:                 if (Authentication(gCard_UID, Sector, 0x60) == FM1702_OK)
00161C 7B01              MOV      R3,#01H
00161E 7A00              MOV      R2,#HIGH gCard_UID
001620 79A7              MOV      R1,#LOW gCard_UID
001622 900040            MOV      DPTR,#Sector
001625 E0                MOVX     A,@DPTR
001626 FD                MOV      R5,A
001627 900047            MOV      DPTR,#?_Authentication?BYTE+04H
00162A 7460              MOV      A,#060H
00162C F0                MOVX     @DPTR,A
00162D D189              ACALL    _Authentication
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 64


00162F EF                MOV      A,R7
001630 7006              JNZ      ?C0017?APP_BRUSH
   99:                 {
  100:                     return CardIndex;
001632 900041            MOV      DPTR,#CardIndex
001635 E0                MOVX     A,@DPTR
001636 FF                MOV      R7,A
001637 22                RET      
  101:                 }
  102:             }
  103:         }
001638         ?C0017?APP_BRUSH:
001638 900042            MOV      DPTR,#i
00163B E0                MOVX     A,@DPTR
00163C 04                INC      A
00163D F0                MOVX     @DPTR,A
00163E E0                MOVX     A,@DPTR
00163F C3                CLR      C
001640 9402              SUBB     A,#02H
001642 40B6              JC       ?C0015?APP_BRUSH
  104: 	}
001644         ?C0007?APP_BRUSH:
001644 900041            MOV      DPTR,#CardIndex
001647 E0                MOVX     A,@DPTR
001648 04                INC      A
001649 F0                MOVX     @DPTR,A
00164A E0                MOVX     A,@DPTR
00164B D3                SETB     C
00164C 9403              SUBB     A,#03H
00164E 5002              JNC      $ + 4H
001650 A1B4              AJMP     ?C0005?APP_BRUSH
001652         ?C0006?APP_BRUSH:
  105: 	return NONE_CARD;
001652 7F00              MOV      R7,#00H
  106: }
001654 22                RET      
----- FUNCTION app_brushCard (END) -------


----- FUNCTION MIF_Halt (BEGIN) -----
 FILE: 'Driver\mifare.c'
  610: uchar MIF_Halt(void)
  611: {
  612: 	uchar	temp;
  613: 	//选择TX1、TX2的发射天线阻抗
  614: 	SPIWriteOne(CwConductance_Reg,0x3f);
001655 F1F0              ACALL    ?L?COM0022
001657 7450              MOV      A,#050H
001659 F0                MOVX     @DPTR,A
  615: 	//选择数据校验种类和模式
  616: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  617: 	*gBuff = RF_CMD_HALT;
  618: 	*(gBuff + 1) = 0x00;
00165A E4                CLR      A
00165B A3                INC      DPTR
00165C 120B33            LCALL    ?L?COM000F
00165F 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
001662 7402              MOV      A,#02H
001664 F0                MOVX     @DPTR,A
001665 7F1A              MOV      R7,#01AH
001667 120795            LCALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  619: 	temp = Command_Send(Transmit, gBuff, 2);//发送FIFO缓存地址
  620: 	if(temp == TRUE)
00166A EF                MOV      A,R7
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 65


00166B B40103            CJNE     A,#01H,?C0133?MIFARE
  621: 		return FM1702_OK;
00166E 7F00              MOV      R7,#00H
001670 22                RET      
001671         ?C0133?MIFARE:
  622: 	else
  623: 	{
  624: 		temp = SPIReadOne(ErrorFlag_Reg);
001671 D182              ACALL    ?L?COM002B
001673 30E103            JNB      ACC.1,?C0136?MIFARE
  625: 		if((temp & 0x02) == 0x02)
  626: 		{
  627: 			return(FM1702_PARITYERR);
001676 7F05              MOV      R7,#05H
001678 22                RET      
  628: 		}
001679         ?C0136?MIFARE:
  629: 
  630: 		if((temp & 0x04) == 0x04)
001679 EF                MOV      A,R7
00167A 7F01              MOV      R7,#01H
00167C 30E202            JNB      ACC.2,?C0137?MIFARE
  631: 		{
  632: 			return(FM1702_FRAMINGERR);
00167F 7F14              MOV      R7,#014H
  633: 		}
001681         ?C0137?MIFARE:
  634: 		return(FM1702_NOTAGERR);
  635: 	}
  636: }
001681 22                RET      
----- FUNCTION MIF_Halt (END) -------


----- FUNCTION ?L?COM002B (BEGIN) -----
001682 7F0A              MOV      R7,#0AH
001684 1206F7            LCALL    _SPIReadOne
001687 EF                MOV      A,R7
001688 22                RET      
----- FUNCTION ?L?COM002B (END) -------


----- FUNCTION _Authentication (BEGIN) -----
 FILE: 'Driver\mifare.c'
  472: uchar Authentication(uchar *UID, uchar SecNR, uchar mode)
  473: {
001689 120DE2            LCALL    ?L?COM0007
;---- Variable 'SecNR' assigned to Register 'R4' ----
00168C AC05              MOV      R4,AR5
  474: 	uchar i;
  475: 	uchar temp, temp1;
  476: 
  477: 	if(SecNR >= 16)
00168E EC                MOV      A,R4
00168F C3                CLR      C
001690 9410              SUBB     A,#010H
001692 4004              JC       ?C0094?MIFARE
  478: 		SecNR = SecNR % 16;
001694 EC                MOV      A,R4
001695 540F              ANL      A,#0FH
001697 FC                MOV      R4,A
001698         ?C0094?MIFARE:
  479: 	
  480: 	//选择数据校验种类和模式
  481: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 66


001698 F1D2              ACALL    ?L?COM0054
  482: 	gBuff[0] = mode;
00169A 900047            MOV      DPTR,#mode
00169D E0                MOVX     A,@DPTR
00169E 9000AC            MOV      DPTR,#gBuff
0016A1 F0                MOVX     @DPTR,A
  483: 	gBuff[1] = SecNR * 4 + 3;
0016A2 EC                MOV      A,R4
0016A3 25E0              ADD      A,ACC
0016A5 25E0              ADD      A,ACC
0016A7 2403              ADD      A,#03H
0016A9 A3                INC      DPTR
0016AA F0                MOVX     @DPTR,A
  484: 	for(i = 0; i < 4; i++)
;---- Variable 'i' assigned to Register 'R7' ----
0016AB E4                CLR      A
0016AC FF                MOV      R7,A
0016AD         ?C0095?MIFARE:
  485: 	{
  486: 		gBuff[2 + i] = UID[i];
0016AD 900043            MOV      DPTR,#UID
0016B0 120C68            LCALL    ?L?COM0002
0016B3 120FCD            LCALL    ?L?COM001F
0016B6 F1D9              ACALL    ?L?COM002C
0016B8 B404F2            CJNE     A,#04H,?C0095?MIFARE
0016BB         ?C0096?MIFARE:
  487: 	}
  488: 
  489: 	temp = Command_Send(Authent1, gBuff,6 );
0016BB 120B34            LCALL    ?L?COM0010
0016BE 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
0016C1 7406              MOV      A,#06H
0016C3 F0                MOVX     @DPTR,A
0016C4 7F0C              MOV      R7,#0CH
0016C6 120795            LCALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  490: 	if(temp==0)
0016C9 EF                MOV      A,R7
0016CA 7003              JNZ      ?C0098?MIFARE
  491: 	{
  492: 		return 0x99;
0016CC 7F99              MOV      R7,#099H
0016CE 22                RET      
  493: 	}
0016CF         ?C0098?MIFARE:
  494: 
  495: 	temp = SPIReadOne(ErrorFlag_Reg);   
0016CF D182              ACALL    ?L?COM002B
0016D1 30E103            JNB      ACC.1,?C0100?MIFARE
0016D4 7F05              MOV      R7,#05H
0016D6 22                RET      
0016D7         ?C0100?MIFARE:
  496: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  497: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
0016D7 EF                MOV      A,R7
0016D8 30E203            JNB      ACC.2,?C0101?MIFARE
0016DB 7F14              MOV      R7,#014H
0016DD 22                RET      
0016DE         ?C0101?MIFARE:
  498: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
0016DE EF                MOV      A,R7
0016DF 30E303            JNB      ACC.3,?C0102?MIFARE
0016E2 7F02              MOV      R7,#02H
0016E4 22                RET      
0016E5         ?C0102?MIFARE:
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 67


  499: 	temp = Command_Send(Authent2, gBuff,0 );	
0016E5 120B34            LCALL    ?L?COM0010
0016E8 E4                CLR      A
0016E9 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
0016EC F0                MOVX     @DPTR,A
0016ED 7F14              MOV      R7,#014H
0016EF 120795            LCALL    _Command_Send
  500: 	if(temp ==0)
0016F2 EF                MOV      A,R7
0016F3 7003              JNZ      ?C0103?MIFARE
  501: 	{
  502: 		return 0x88;
0016F5 7F88              MOV      R7,#088H
0016F7 22                RET      
  503: 	}
0016F8         ?C0103?MIFARE:
  504: 
  505: 	temp = SPIReadOne(ErrorFlag_Reg);
0016F8 D182              ACALL    ?L?COM002B
0016FA 30E103            JNB      ACC.1,?C0104?MIFARE
0016FD 7F05              MOV      R7,#05H
0016FF 22                RET      
001700         ?C0104?MIFARE:
  506: //	Show(temp,0);
  507: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  508: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
001700 EF                MOV      A,R7
001701 30E203            JNB      ACC.2,?C0105?MIFARE
001704 7F14              MOV      R7,#014H
001706 22                RET      
001707         ?C0105?MIFARE:
  509: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
001707 EF                MOV      A,R7
001708 30E303            JNB      ACC.3,?C0106?MIFARE
00170B 7F02              MOV      R7,#02H
00170D 22                RET      
00170E         ?C0106?MIFARE:
  510: 	temp1 = SPIReadOne(Control_Reg);
00170E 7F09              MOV      R7,#09H
001710 1206F7            LCALL    _SPIReadOne
;---- Variable 'temp1' assigned to Register 'R7' ----
  511: 	temp1 = temp1 & 0x08;	
001713 EF                MOV      A,R7
001714 5408              ANL      A,#08H
  512: 	if(temp1 == 0x08)
001716 7F04              MOV      R7,#04H
001718 B40802            CJNE     A,#08H,?C0107?MIFARE
  513: 	{
  514: 		return FM1702_OK;
00171B 7F00              MOV      R7,#00H
  515: 	}
00171D         ?C0107?MIFARE:
  516: 
  517: 	return FM1702_AUTHERR;
  518: }
00171D 22                RET      
----- FUNCTION _Authentication (END) -------


----- FUNCTION SelectCard (BEGIN) -----
 FILE: 'Driver\mifare.c'
  335: uchar SelectCard(void)
  336: {
  337: 	
  338: 	uchar	temp, i;
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 68


  339: 	
  340: 	//选择TX1、TX2的发射天线阻抗
  341: 	SPIWriteOne(CwConductance_Reg,0x3f);
00171E F1E9              ACALL    ?L?COM0055
  342: 	//选择数据校验种类和模式
  343: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
001720 7D0F              MOV      R5,#0FH
001722 F1F9              ACALL    ?L?COM0023
001724 7493              MOV      A,#093H
001726 F0                MOVX     @DPTR,A
  344: 
  345: 	gBuff[0] = RF_CMD_SELECT;
  346: 	gBuff[1] = 0x70;
001727 A3                INC      DPTR
001728 7470              MOV      A,#070H
00172A F0                MOVX     @DPTR,A
  347: 	for(i = 0; i < 5; i++)
;---- Variable 'i' assigned to Register 'R7' ----
00172B E4                CLR      A
00172C FF                MOV      R7,A
00172D         ?C0077?MIFARE:
  348: 	{
  349: 		gBuff[i + 2] = gCard_UID[i];
00172D 74A7              MOV      A,#LOW gCard_UID
00172F 2F                ADD      A,R7
001730 1219F8            LCALL    ?L?COM0014
001733 F1D9              ACALL    ?L?COM002C
001735 B405F5            CJNE     A,#05H,?C0077?MIFARE
001738         ?C0078?MIFARE:
  350: 	}
  351: 	temp = Command_Send(Transceive, gBuff,7 );
001738 120B34            LCALL    ?L?COM0010
00173B 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
00173E 7407              MOV      A,#07H
;---- Variable 'temp' assigned to Register 'R7' ----
001740 F182              ACALL    ?L?COM0027
001742 7003              JNZ      ?C0080?MIFARE
  352: 	if(temp==0 )
  353: 	{
  354: 		return(FM1702_NOTAGERR);
001744 7F01              MOV      R7,#01H
001746 22                RET      
  355: 	}
001747         ?C0080?MIFARE:
  356: 	else
  357: 	{
  358: 		temp = SPIReadOne(ErrorFlag_Reg);
001747 D182              ACALL    ?L?COM002B
001749 30E103            JNB      ACC.1,?C0083?MIFARE
00174C 7F05              MOV      R7,#05H
00174E 22                RET      
00174F         ?C0083?MIFARE:
  359: 		if((temp & 0x02) == 0x02) return(FM1702_PARITYERR);
  360: 		if((temp & 0x04) == 0x04) return(FM1702_FRAMINGERR);
00174F EF                MOV      A,R7
001750 30E203            JNB      ACC.2,?C0084?MIFARE
001753 7F14              MOV      R7,#014H
001755 22                RET      
001756         ?C0084?MIFARE:
  361: 		if((temp & 0x08) == 0x08) return(FM1702_CRCERR);
001756 EF                MOV      A,R7
001757 30E303            JNB      ACC.3,?C0085?MIFARE
00175A 7F02              MOV      R7,#02H
00175C 22                RET      
00175D         ?C0085?MIFARE:
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 69


  362: 		temp = SPIReadOne(FIFOLength_Reg);
00175D 7F04              MOV      R7,#04H
00175F 1206F7            LCALL    _SPIReadOne
  363: 		if(temp != 1) return(FM1702_BYTECOUNTERR);
001762 EF                MOV      A,R7
001763 6401              XRL      A,#01H
001765 6003              JZ       ?C0086?MIFARE
001767 7F0C              MOV      R7,#0CH
001769 22                RET      
00176A         ?C0086?MIFARE:
  364: //		SPIRead(FIFO_Reg,gBuff,temp);	//从FIFO中读取应答信息
  365: 		gBuff[0] = SPIReadOne(FIFO_Reg);
00176A 7F02              MOV      R7,#02H
00176C 1206F7            LCALL    _SPIReadOne
00176F 9000AC            MOV      DPTR,#gBuff
001772 EF                MOV      A,R7
001773 F0                MOVX     @DPTR,A
  366: 		if(gBuff[0]==0x08) 	  	// 判断应答信号是否正确 
001774 BF0803            CJNE     R7,#08H,?C0087?MIFARE
  367: 			return(FM1702_OK);
001777 7F00              MOV      R7,#00H
001779 22                RET      
00177A         ?C0087?MIFARE:
  368: 		else
  369: 			return(FM1702_SELERR);
00177A 7F16              MOV      R7,#016H
  370: 	}
  371: }
00177C 22                RET      
----- FUNCTION SelectCard (END) -------


----- FUNCTION ?L?COM0026 (BEGIN) -----
00177D 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
001780 7402              MOV      A,#02H
001782         ?L?COM0027:
001782 F0                MOVX     @DPTR,A
001783 7F1E              MOV      R7,#01EH
001785 120795            LCALL    _Command_Send
001788 EF                MOV      A,R7
001789 22                RET      
----- FUNCTION ?L?COM0026 (END) -------


----- FUNCTION _Read_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  532: uchar Read_Block(uchar *buff,uchar index)
  533: {
00178A 90004B            MOV      DPTR,#buff
00178D 120DE5            LCALL    ?L?COM0008
;---- Variable 'index' assigned to Register 'R4' ----
001790 AC05              MOV      R4,AR5
  534:     uchar ucCmdLine[2],ucResult;
  535:     SPIWriteOne(ChannelRedundancy_Reg,0x0F);
001792 F1D2              ACALL    ?L?COM0054
  536:     ucCmdLine[0] = RF_CMD_READ;
001794 A3                INC      DPTR
001795 7430              MOV      A,#030H
001797 F0                MOVX     @DPTR,A
  537:     ucCmdLine[1] = index;
001798 A3                INC      DPTR
001799 EC                MOV      A,R4
00179A F0                MOVX     @DPTR,A
  538:     ucResult = Command_Send(Transceive,ucCmdLine,2);
00179B 7B01              MOV      R3,#01H
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 70


00179D 7A00              MOV      R2,#HIGH ucCmdLine
00179F 794E              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
0017A1 F17D              ACALL    ?L?COM0026
0017A3 7003              JNZ      ?C0108?MIFARE
  539:     if(ucResult == FALSE)
  540:         return FM1702_NOTAGERR;   //无卡
0017A5 7F01              MOV      R7,#01H
0017A7 22                RET      
0017A8         ?C0108?MIFARE:
  541:     ucResult = SPIReadOne(ErrorFlag_Reg);
0017A8 D182              ACALL    ?L?COM002B
0017AA 30E103            JNB      ACC.1,?C0110?MIFARE
0017AD 7F05              MOV      R7,#05H
0017AF 22                RET      
0017B0         ?C0110?MIFARE:
  542: 	if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
  543: 	if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
0017B0 EF                MOV      A,R7
0017B1 30E203            JNB      ACC.2,?C0111?MIFARE
0017B4 7F14              MOV      R7,#014H
0017B6 22                RET      
0017B7         ?C0111?MIFARE:
  544: 	if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
0017B7 EF                MOV      A,R7
0017B8 30E303            JNB      ACC.3,?C0112?MIFARE
0017BB 7F02              MOV      R7,#02H
0017BD 22                RET      
0017BE         ?C0112?MIFARE:
  545:     ucResult = Read_FIFO(buff);
0017BE 90004B            MOV      DPTR,#buff
0017C1 120C68            LCALL    ?L?COM0002
0017C4 F9                MOV      R1,A
0017C5 121863            LCALL    _Read_FIFO
  546:     if(ucResult!=0x10)
0017C8 EF                MOV      A,R7
0017C9 6410              XRL      A,#010H
0017CB 7F00              MOV      R7,#00H
0017CD 6002              JZ       ?C0113?MIFARE
  547:         return FM1702_BYTECOUNTERR;
0017CF 7F0C              MOV      R7,#0CH
0017D1         ?C0113?MIFARE:
  548:     else
  549:         return FM1702_OK;
  550: }
0017D1 22                RET      
----- FUNCTION _Read_Block (END) -------


----- FUNCTION ?L?COM0054 (BEGIN) -----
0017D2 7D0F              MOV      R5,#0FH
0017D4 7F22              MOV      R7,#022H
0017D6 0206C2            LJMP     _SPIWriteOne
----- FUNCTION ?L?COM0054 (END) -------


----- FUNCTION ?L?COM002C (BEGIN) -----
0017D9 FE                MOV      R6,A
0017DA 74AE              MOV      A,#LOW gBuff+02H
0017DC 2F                ADD      A,R7
0017DD F582              MOV      DPL,A
0017DF E4                CLR      A
0017E0 3400              ADDC     A,#HIGH gBuff+02H
0017E2         ?L?COM002D:
0017E2 F583              MOV      DPH,A
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 71


0017E4 EE                MOV      A,R6
0017E5 F0                MOVX     @DPTR,A
0017E6 0F                INC      R7
0017E7 EF                MOV      A,R7
0017E8 22                RET      
----- FUNCTION ?L?COM002C (END) -------


----- FUNCTION ?L?COM0055 (BEGIN) -----
0017E9 7D3F              MOV      R5,#03FH
0017EB 7F12              MOV      R7,#012H
0017ED 0206C2            LJMP     _SPIWriteOne
----- FUNCTION ?L?COM0055 (END) -------


----- FUNCTION ?L?COM0022 (BEGIN) -----
0017F0 7D3F              MOV      R5,#03FH
0017F2 7F12              MOV      R7,#012H
0017F4 1206C2            LCALL    _SPIWriteOne
0017F7 7D03              MOV      R5,#03H
0017F9         ?L?COM0023:
0017F9 7F22              MOV      R7,#022H
0017FB         ?L?COM0024:
0017FB 1206C2            LCALL    _SPIWriteOne
0017FE 9000AC            MOV      DPTR,#gBuff
001801 22                RET      
----- FUNCTION ?L?COM0022 (END) -------


----- FUNCTION _Request (BEGIN) -----
 FILE: 'Driver\mifare.c'
  152: uchar Request(uchar mode)
  153: {
;---- Variable 'mode' assigned to Register 'R4' ----
001802 AC07              MOV      R4,AR7
  154: 	
  155: 	uchar temp;
  156: 	
  157: 	//选择TX1、TX2的发射天线阻抗
  158: 	SPIWriteOne(CwConductance_Reg,0x3f);
001804 1217E9            LCALL    ?L?COM0055
  159: 	//选择数据校验种类和模式
  160: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
001807 7D03              MOV      R5,#03H
001809 7F22              MOV      R7,#022H
00180B 1206C2            LCALL    _SPIWriteOne
  161: 	//调整面向bit的格式
  162: 	SPIWriteOne(BitFraming_Reg,0x07);
00180E 7D07              MOV      R5,#07H
001810 7F0F              MOV      R7,#0FH
001812 1217FB            LCALL    ?L?COM0024
001815 EC                MOV      A,R4
001816 F0                MOVX     @DPTR,A
  163: 	gBuff[0] = mode;		//Request模式选择 
  164: 	temp = SPIReadOne(Control_Reg);
001817 7F09              MOV      R7,#09H
001819 1206F7            LCALL    _SPIReadOne
;---- Variable 'temp' assigned to Register 'R7' ----
  165: 	temp = temp & (0xf7);	
00181C EF                MOV      A,R7
00181D 54F7              ANL      A,#0F7H
  166: 	SPIWriteOne(Control_Reg,temp);			//Control reset value is 00
00181F FD                MOV      R5,A
001820 7F09              MOV      R7,#09H
001822 1206C2            LCALL    _SPIWriteOne
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 72


  167: 	temp = Command_Send(Transceive, gBuff,1 );   //发送接收命令 
001825 120B34            LCALL    ?L?COM0010
001828 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
00182B 7401              MOV      A,#01H
00182D 121782            LCALL    ?L?COM0027
001830 7003              JNZ      ?C0030?MIFARE
  168: 	if(temp==0 )
  169: 	{
  170: 		return FM1702_NOTAGERR;
001832 7F01              MOV      R7,#01H
001834 22                RET      
  171: 	}
001835         ?C0030?MIFARE:
  172: 
  173: 	temp=Read_FIFO(gBuff);		//从FIFO中读取应答信息到gBuff中 
001835 120B34            LCALL    ?L?COM0010
001838 1163              ACALL    _Read_FIFO
  174: 	// 判断应答信号是否正确 
  175: 	// 2  	Mifare Pro 卡
  176: 	//4 		Mifare One 卡
  177: 	if((gBuff[0] == 0x04) & (gBuff[1] == 0x0) &(temp == 2))
00183A 9000AD            MOV      DPTR,#gBuff+01H
00183D E0                MOVX     A,@DPTR
00183E 7E00              MOV      R6,#00H
001840 7002              JNZ      ?C0033?MIFARE
001842 7E01              MOV      R6,#01H
001844         ?C0033?MIFARE:
001844         ?C0034?MIFARE:
001844 9000AC            MOV      DPTR,#gBuff
001847 E0                MOVX     A,@DPTR
001848 7D00              MOV      R5,#00H
00184A B40402            CJNE     A,#04H,?C0035?MIFARE
00184D 7D01              MOV      R5,#01H
00184F         ?C0035?MIFARE:
00184F         ?C0036?MIFARE:
00184F ED                MOV      A,R5
001850 5E                ANL      A,R6
001851 FE                MOV      R6,A
001852 EF                MOV      A,R7
001853 7F00              MOV      R7,#00H
001855 B40202            CJNE     A,#02H,?C0037?MIFARE
001858 7F01              MOV      R7,#01H
00185A         ?C0037?MIFARE:
00185A         ?C0038?MIFARE:
00185A EF                MOV      A,R7
00185B 5E                ANL      A,R6
00185C 7F15              MOV      R7,#015H
00185E 6002              JZ       ?C0032?MIFARE
  178: 	{
  179: 			return FM1702_OK;
001860 7F00              MOV      R7,#00H
  180: 	}
001862         ?C0032?MIFARE:
  181: 	return FM1702_REQERR;
  182: }
001862 22                RET      
----- FUNCTION _Request (END) -------


----- FUNCTION _Read_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  228: uchar Read_FIFO(uchar *buff)
  229: {
001863 900067            MOV      DPTR,#buff
001866 120DE5            LCALL    ?L?COM0008
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 73


  230: 	uchar	ucResult,i;
  231: 	ucResult = SPIReadOne(FIFOLength_Reg);
;---- Variable 'ucResult' assigned to Register 'R5' ----
001869 1207E3            LCALL    ?L?COM0043
00186C 6005              JZ       ?C0050?MIFARE
00186E D3                SETB     C
00186F 9410              SUBB     A,#010H
001871 4003              JC       ?C0049?MIFARE
001873         ?C0050?MIFARE:
  232: 	if(ucResult == 0 || ucResult>16)
  233: 		return 0;
001873 7F00              MOV      R7,#00H
001875 22                RET      
001876         ?C0049?MIFARE:
  234: 	for(i=0;i<ucResult;i++)
;---- Variable 'i' assigned to Register 'R4' ----
001876 E4                CLR      A
001877 FC                MOV      R4,A
001878         ?C0052?MIFARE:
001878 EC                MOV      A,R4
001879 C3                CLR      C
00187A 9D                SUBB     A,R5
00187B 5018              JNC      ?C0053?MIFARE
  235: 	{
  236: 		buff[i] = SPIReadOne(FIFO_Reg);
00187D 7F02              MOV      R7,#02H
00187F 1206F7            LCALL    _SPIReadOne
001882 900067            MOV      DPTR,#buff
001885 120C68            LCALL    ?L?COM0002
001888 F9                MOV      R1,A
001889 8C82              MOV      DPL,R4
00188B 758300            MOV      DPH,#00H
00188E EF                MOV      A,R7
00188F 120174            LCALL    ?C?CSTOPTR
  237: 	}
001892 0C                INC      R4
001893 80E3              SJMP     ?C0052?MIFARE
001895         ?C0053?MIFARE:
  238: 
  239: 	return ucResult;
001895 AF05              MOV      R7,AR5
  240: }
001897 22                RET      
----- FUNCTION _Read_FIFO (END) -------


----- FUNCTION _Write_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  566: uchar Write_Block(uchar *buff,uchar index)
  567: {
001898 900052            MOV      DPTR,#buff
00189B 120DE5            LCALL    ?L?COM0008
;---- Variable 'index' assigned to Register 'R4' ----
00189E AC05              MOV      R4,AR5
  568:     uchar ucCmdLine[2],ucResult,ucData[16];
  569:     SPIWriteOne(ChannelRedundancy_Reg,0x07);   /* Note: this line is for 1702, different from RC500*/
0018A0 7D07              MOV      R5,#07H
0018A2 7F22              MOV      R7,#022H
0018A4 1206C2            LCALL    _SPIWriteOne
  570:     ucCmdLine[0] = RF_CMD_WRITE;
0018A7 A3                INC      DPTR
0018A8 74A0              MOV      A,#0A0H
0018AA F0                MOVX     @DPTR,A
  571:     ucCmdLine[1] = index;
0018AB A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 74


0018AC EC                MOV      A,R4
0018AD F0                MOVX     @DPTR,A
  572:     ucResult = Command_Send(Transceive,ucCmdLine,2);
0018AE 7B01              MOV      R3,#01H
0018B0 7A00              MOV      R2,#HIGH ucCmdLine
0018B2 7955              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
0018B4 12177D            LCALL    ?L?COM0026
0018B7 7003              JNZ      ?C0115?MIFARE
  573:     if(ucResult == FALSE)
  574:         return FM1702_NOTAGERR;
0018B9 7F01              MOV      R7,#01H
0018BB 22                RET      
0018BC         ?C0115?MIFARE:
  575:     ucResult = Read_FIFO(ucData);
0018BC 7B01              MOV      R3,#01H
0018BE 7A00              MOV      R2,#HIGH ucData
0018C0 7957              MOV      R1,#LOW ucData
0018C2 1163              ACALL    _Read_FIFO
  576:     if(ucResult == 0)
0018C4 EF                MOV      A,R7
0018C5 7003              JNZ      ?C0117?MIFARE
  577:         return FM1702_BYTECOUNTERR;
0018C7 7F0C              MOV      R7,#0CH
0018C9 22                RET      
0018CA         ?C0117?MIFARE:
  578:     switch(ucData[0])
0018CA 900057            MOV      DPTR,#ucData
0018CD E0                MOVX     A,@DPTR
0018CE 14                DEC      A
0018CF 6015              JZ       ?C0122?MIFARE
0018D1 24FD              ADD      A,#0FDH
0018D3 600E              JZ       ?C0120?MIFARE
0018D5 14                DEC      A
0018D6 6011              JZ       ?C0123?MIFARE
0018D8 24FB              ADD      A,#0FBH
0018DA 6013              JZ       ?C0118?MIFARE
0018DC 240A              ADD      A,#0AH
0018DE 700C              JNZ      ?C0124?MIFARE
  579:     {
  580: 	    case 0x00:	return(FM1702_NOTAUTHERR);	
0018E0         ?C0119?MIFARE:
0018E0 7F0A              MOV      R7,#0AH
0018E2 22                RET      
  581: 	    case 0x04:	return(FM1702_EMPTY);
0018E3         ?C0120?MIFARE:
0018E3 7F03              MOV      R7,#03H
0018E5 22                RET      
  582: 	    case 0x0a:	break;                   //正常
  583: 	    case 0x01:	return(FM1702_CRCERR);
0018E6         ?C0122?MIFARE:
0018E6 7F02              MOV      R7,#02H
0018E8 22                RET      
  584: 	    case 0x05:	return(FM1702_PARITYERR); 
0018E9         ?C0123?MIFARE:
0018E9 7F05              MOV      R7,#05H
0018EB 22                RET      
  585: 	    default:	return(FM1702_WRITEERR);
0018EC         ?C0124?MIFARE:
0018EC 7F0F              MOV      R7,#0FH
0018EE 22                RET      
  586:     }
0018EF         ?C0118?MIFARE:
  587:     ucResult = Command_Send(Transceive,buff,16);
0018EF 900052            MOV      DPTR,#buff
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 75


0018F2 120C68            LCALL    ?L?COM0002
0018F5 F9                MOV      R1,A
0018F6 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
0018F9 7410              MOV      A,#010H
0018FB 121782            LCALL    ?L?COM0027
0018FE B40103            CJNE     A,#01H,?C0125?MIFARE
  588:     if(ucResult == TRUE)
  589:         return FM1702_OK;
001901 7F00              MOV      R7,#00H
001903 22                RET      
001904         ?C0125?MIFARE:
  590:     else
  591:     {
  592:         ucResult = SPIReadOne(ErrorFlag_Reg);
001904 121682            LCALL    ?L?COM002B
001907 30E103            JNB      ACC.1,?C0127?MIFARE
00190A 7F05              MOV      R7,#05H
00190C 22                RET      
00190D         ?C0127?MIFARE:
  593: 	    if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
  594: 	    else if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
00190D EF                MOV      A,R7
00190E 30E203            JNB      ACC.2,?C0129?MIFARE
001911 7F14              MOV      R7,#014H
001913 22                RET      
001914         ?C0129?MIFARE:
  595: 	    else if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
001914 EF                MOV      A,R7
001915 7F0F              MOV      R7,#0FH
001917 30E302            JNB      ACC.3,?C0131?MIFARE
00191A 7F02              MOV      R7,#02H
00191C         ?C0131?MIFARE:
  596:         else return FM1702_WRITEERR;
  597:     }
  598: }
00191C 22                RET      
----- FUNCTION _Write_Block (END) -------


----- FUNCTION Clear_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  190: uchar Clear_FIFO(void)
  191: {
  192:     uchar ucResult,i;
  193:     ucResult = SPIReadOne(Control_Reg);
00191D 7F09              MOV      R7,#09H
;---- Variable 'ucResult' assigned to Register 'R4' ----
00191F 1207DD            LCALL    ?L?COM0039
001922 4401              ORL      A,#01H
001924 FC                MOV      R4,A
  194:     ucResult |=0x01;
  195:     SPIWriteOne(Control_Reg,ucResult);
001925 FD                MOV      R5,A
001926 7F09              MOV      R7,#09H
001928 1206C2            LCALL    _SPIWriteOne
  196:     for(i=0;i<0xA0;i++)
;---- Variable 'i' assigned to Register 'R5' ----
00192B E4                CLR      A
00192C FD                MOV      R5,A
00192D         ?C0039?MIFARE:
  197:     {
  198:         ucResult = SPIReadOne(FIFOLength_Reg);
00192D 7F04              MOV      R7,#04H
00192F 1207DD            LCALL    ?L?COM0039
001932 7003              JNZ      ?C0041?MIFARE
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 76


  199:         if(ucResult == 0)
  200:             return TRUE;
001934 7F01              MOV      R7,#01H
001936 22                RET      
  201:     }
001937         ?C0041?MIFARE:
001937 0D                INC      R5
001938 ED                MOV      A,R5
001939 B4A0F1            CJNE     A,#0A0H,?C0039?MIFARE
00193C         ?C0040?MIFARE:
  202:     return FALSE;
00193C 7F00              MOV      R7,#00H
  203: }
00193E 22                RET      
----- FUNCTION Clear_FIFO (END) -------


----- FUNCTION _Write_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  212: void Write_FIFO(uchar *buff,uchar count)
  213: {
00193F 90006C            MOV      DPTR,#buff
001942 120DE5            LCALL    ?L?COM0008
001945 A3                INC      DPTR
001946 ED                MOV      A,R5
001947 F0                MOVX     @DPTR,A
  214: 	uchar i;
  215: 	if(count == 0)
001948 6021              JZ       ?C0045?MIFARE
00194A         ?C0044?MIFARE:
  216:         return;
  217: 	for(i=0;i<count;i++)
;---- Variable 'i' assigned to Register 'R4' ----
00194A E4                CLR      A
00194B FC                MOV      R4,A
00194C         ?C0046?MIFARE:
00194C 90006F            MOV      DPTR,#count
00194F E0                MOVX     A,@DPTR
001950 FF                MOV      R7,A
001951 EC                MOV      A,R4
001952 C3                CLR      C
001953 9F                SUBB     A,R7
001954 5015              JNC      ?C0045?MIFARE
  218: 		SPIWriteOne(FIFO_Reg,buff[i]);
001956 90006C            MOV      DPTR,#buff
001959 120C68            LCALL    ?L?COM0002
00195C F9                MOV      R1,A
00195D 8C82              MOV      DPL,R4
00195F 120FD0            LCALL    ?L?COM0021
001962 FD                MOV      R5,A
001963 7F02              MOV      R7,#02H
001965 1206C2            LCALL    _SPIWriteOne
001968 0C                INC      R4
001969 80E1              SJMP     ?C0046?MIFARE
  219: //		SPIWrite(FIFO_Reg,buff,count);
  220: }
00196B         ?C0045?MIFARE:
00196B 22                RET      
----- FUNCTION _Write_FIFO (END) -------


----- FUNCTION _Load_Key (BEGIN) -----
 FILE: 'Driver\mifare.c'
  406: uchar Load_Key(uchar *ramadr)
  407: {
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 77


00196C 120DE2            LCALL    ?L?COM0007
  408: 	uchar acktemp,temp[1],i;
  409: 	uchar ucBuff[12];
  410: 	for (i=0;i<6;i++)
;---- Variable 'i' assigned to Register 'R7' ----
00196F E4                CLR      A
001970 FF                MOV      R7,A
001971         ?C0089?MIFARE:
  411: 	{
  412: 		temp[0]=ramadr[i];
001971 900043            MOV      DPTR,#ramadr
001974 120C68            LCALL    ?L?COM0002
001977 120FCD            LCALL    ?L?COM001F
00197A 900047            MOV      DPTR,#temp
00197D F0                MOVX     @DPTR,A
00197E FD                MOV      R5,A
  413: 		ucBuff[2*i]=(((ramadr[i]&0xf0)>>4)|((~ramadr[i])&0xf0));
00197F 54F0              ANL      A,#0F0H
001981 C4                SWAP     A
001982 540F              ANL      A,#0FH
001984 FE                MOV      R6,A
001985 120FCE            LCALL    ?L?COM0020
001988 F4                CPL      A
001989 31DE              ACALL    ?L?COM0056
00198B 2448              ADD      A,#LOW ucBuff
00198D F582              MOV      DPL,A
00198F E4                CLR      A
001990 3400              ADDC     A,#HIGH ucBuff
001992 F583              MOV      DPH,A
001994 EE                MOV      A,R6
001995 F0                MOVX     @DPTR,A
  414: 		ucBuff[2*i+1]=((temp[0]&0xf)|(~(temp[0]&0xf)<<4));
001996 ED                MOV      A,R5
001997 540F              ANL      A,#0FH
001999 FE                MOV      R6,A
00199A F4                CPL      A
00199B FD                MOV      R5,A
00199C C4                SWAP     A
00199D 31DE              ACALL    ?L?COM0056
00199F 2449              ADD      A,#LOW ucBuff+01H
0019A1 F582              MOV      DPL,A
0019A3 E4                CLR      A
0019A4 3400              ADDC     A,#HIGH ucBuff+01H
0019A6 1217E2            LCALL    ?L?COM002D
0019A9 B406C5            CJNE     A,#06H,?C0089?MIFARE
0019AC         ?C0090?MIFARE:
  415: 	}
  416: 	acktemp=Command_Send(LOAD_KEY, ucBuff, 12);
0019AC 7B01              MOV      R3,#01H
0019AE 7A00              MOV      R2,#HIGH ucBuff
0019B0 7948              MOV      R1,#LOW ucBuff
0019B2 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
0019B5 740C              MOV      A,#0CH
0019B7 F0                MOVX     @DPTR,A
0019B8 7F19              MOV      R7,#019H
0019BA 120795            LCALL    _Command_Send
0019BD 900046            MOV      DPTR,#acktemp
0019C0 EF                MOV      A,R7
0019C1 F0                MOVX     @DPTR,A
  417: 	temp[0] = SPIReadOne(SecondaryStatus_Reg);
0019C2 7F05              MOV      R7,#05H
0019C4 1206F7            LCALL    _SPIReadOne
0019C7 A3                INC      DPTR
0019C8 EF                MOV      A,R7
0019C9 F0                MOVX     @DPTR,A
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 78


  418: 	if (temp[0]&0x40)
0019CA 30E607            JNB      ACC.6,?C0092?MIFARE
  419: 	{
  420: 		temp[0]=0x0;
0019CD E4                CLR      A
0019CE 1206BE            LCALL    ?L?COM003B
  421: 		SPIWriteOne(Command_Reg,temp[0]);
  422: 		return(0);
0019D1 7F00              MOV      R7,#00H
0019D3 22                RET      
  423: 	}
0019D4         ?C0092?MIFARE:
  424: 	temp[0]=0x0;
0019D4 E4                CLR      A
0019D5 900047            MOV      DPTR,#temp
0019D8 1206BE            LCALL    ?L?COM003B
  425: 	SPIWriteOne(Command_Reg,temp[0]);
  426: 	return(1);
0019DB 7F01              MOV      R7,#01H
  427: }
0019DD 22                RET      
----- FUNCTION _Load_Key (END) -------


----- FUNCTION ?L?COM0056 (BEGIN) -----
0019DE 54F0              ANL      A,#0F0H
0019E0 4E                ORL      A,R6
0019E1 FE                MOV      R6,A
0019E2 EF                MOV      A,R7
0019E3 25E0              ADD      A,ACC
0019E5 22                RET      
----- FUNCTION ?L?COM0056 (END) -------


----- FUNCTION ?L?COM0013 (BEGIN) -----
0019E6 2E                ADD      A,R6
0019E7 F9                MOV      R1,A
0019E8 E4                CLR      A
0019E9 3A                ADDC     A,R2
0019EA FA                MOV      R2,A
0019EB 12011C            LCALL    ?C?CLDPTR
0019EE FF                MOV      R7,A
0019EF EE                MOV      A,R6
0019F0 75F005            MOV      B,#05H
0019F3 84                DIV      AB
0019F4 74A7              MOV      A,#LOW gCard_UID
0019F6 25F0              ADD      A,B
0019F8         ?L?COM0014:
0019F8 F582              MOV      DPL,A
0019FA E4                CLR      A
0019FB 3400              ADDC     A,#HIGH gCard_UID
0019FD F583              MOV      DPH,A
0019FF E0                MOVX     A,@DPTR
001A00 22                RET      
----- FUNCTION ?L?COM0013 (END) -------


----- FUNCTION ?L?COM0015 (BEGIN) -----
001A01 AB08              MOV      R3,pMoney
001A03 AA09              MOV      R2,pMoney+01H
001A05 A90A              MOV      R1,pMoney+02H
001A07 120213            LCALL    ?C?ILDPTR
001A0A FF                MOV      R7,A
001A0B 9000A6            MOV      DPTR,#s_System+012H
001A0E E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 79


001A0F 2F                ADD      A,R7
001A10 FF                MOV      R7,A
001A11 9000A5            MOV      DPTR,#s_System+011H
001A14 E0                MOVX     A,@DPTR
001A15 35F0              ADDC     A,B
001A17 FE                MOV      R6,A
001A18 D3                SETB     C
001A19 EF                MOV      A,R7
001A1A 9420              SUBB     A,#020H
001A1C EE                MOV      A,R6
001A1D 944E              SUBB     A,#04EH
001A1F 22                RET      
----- FUNCTION ?L?COM0015 (END) -------


----- FUNCTION ?L?COM0025 (BEGIN) -----
001A20 9000C5            MOV      DPTR,#gLedBuf
001A23 740C              MOV      A,#0CH
001A25 F0                MOVX     @DPTR,A
001A26 A3                INC      DPTR
001A27 740F              MOV      A,#0FH
001A29 F0                MOVX     @DPTR,A
001A2A A3                INC      DPTR
001A2B F0                MOVX     @DPTR,A
001A2C A3                INC      DPTR
001A2D F0                MOVX     @DPTR,A
001A2E A3                INC      DPTR
001A2F F0                MOVX     @DPTR,A
001A30 A3                INC      DPTR
001A31 740C              MOV      A,#0CH
001A33 F0                MOVX     @DPTR,A
001A34 E4                CLR      A
001A35 9000CC            MOV      DPTR,#gShowDot
001A38 F0                MOVX     @DPTR,A
001A39 22                RET      
----- FUNCTION ?L?COM0025 (END) -------


----- FUNCTION ?L?COM0034 (BEGIN) -----
001A3A 900055            MOV      DPTR,#e2_bak_addr
001A3D E0                MOVX     A,@DPTR
001A3E FE                MOV      R6,A
001A3F A3                INC      DPTR
001A40 E0                MOVX     A,@DPTR
001A41 FF                MOV      R7,A
001A42         ?L?COM0035:
001A42 7B01              MOV      R3,#01H
001A44 7A00              MOV      R2,#HIGH e2_data_bak
001A46 7920              MOV      R1,#LOW e2_data_bak
001A48 22                RET      
----- FUNCTION ?L?COM0034 (END) -------


----- FUNCTION ?L?COM0037 (BEGIN) -----
001A49 78BD              MOV      R0,#LOW LastCardId
001A4B 7C00              MOV      R4,#HIGH LastCardId
001A4D 7D01              MOV      R5,#01H
001A4F 7B01              MOV      R3,#01H
001A51 7A00              MOV      R2,#HIGH gCard_UID
001A53 79A7              MOV      R1,#LOW gCard_UID
001A55 7E00              MOV      R6,#00H
001A57 7F05              MOV      R7,#05H
001A59 22                RET      
----- FUNCTION ?L?COM0037 (END) -------

LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 80



----- FUNCTION ?L?COM003C (BEGIN) -----
001A5A 25E0              ADD      A,ACC
001A5C 25E0              ADD      A,ACC
001A5E FE                MOV      R6,A
001A5F 04                INC      A
001A60 A3                INC      DPTR
001A61 F0                MOVX     @DPTR,A
001A62 EE                MOV      A,R6
001A63 2402              ADD      A,#02H
001A65 A3                INC      DPTR
001A66 F0                MOVX     @DPTR,A
001A67 22                RET      
----- FUNCTION ?L?COM003C (END) -------


----- FUNCTION ?L?COM004B (BEGIN) -----
001A68 A3                INC      DPTR
001A69 F0                MOVX     @DPTR,A
001A6A A3                INC      DPTR
001A6B F0                MOVX     @DPTR,A
001A6C A3                INC      DPTR
001A6D F0                MOVX     @DPTR,A
001A6E 22                RET      
----- FUNCTION ?L?COM004B (END) -------


----- FUNCTION ?L?COM004E (BEGIN) -----
001A6F 900053            MOV      DPTR,#e2_addr
001A72 E0                MOVX     A,@DPTR
001A73 FE                MOV      R6,A
001A74 A3                INC      DPTR
001A75 E0                MOVX     A,@DPTR
001A76 FF                MOV      R7,A
001A77 22                RET      
----- FUNCTION ?L?COM004E (END) -------


----- FUNCTION ?L?COM0050 (BEGIN) -----
001A78 900040            MOV      DPTR,#L_num
001A7B EE                MOV      A,R6
001A7C F0                MOVX     @DPTR,A
001A7D A3                INC      DPTR
001A7E EF                MOV      A,R7
001A7F F0                MOVX     @DPTR,A
001A80 22                RET      
----- FUNCTION ?L?COM0050 (END) -------


----- FUNCTION ?L?COM0051 (BEGIN) -----
001A81 75F00A            MOV      B,#0AH
001A84 84                DIV      AB
001A85 A3                INC      DPTR
001A86 E5F0              MOV      A,B
001A88 F0                MOVX     @DPTR,A
001A89 22                RET      
----- FUNCTION ?L?COM0051 (END) -------


----- FUNCTION ?L?COM0057 (BEGIN) -----
001A8A 7403              MOV      A,#03H
001A8C F0                MOVX     @DPTR,A
001A8D A3                INC      DPTR
001A8E 74E7              MOV      A,#0E7H
001A90 F0                MOVX     @DPTR,A
LX51 LINKER/LOCATER V4.66.1.0                                                         12/01/2015  20:04:53  PAGE 81


001A91 22                RET      
----- FUNCTION ?L?COM0057 (END) -------


----- FUNCTION ?L?COM005B (BEGIN) -----
001A92 3C                ADDC     A,R4
001A93 F583              MOV      DPH,A
001A95 E0                MOVX     A,@DPTR
001A96 FD                MOV      R5,A
001A97 ED                MOV      A,R5
001A98 FF                MOV      R7,A
001A99 22                RET      
----- FUNCTION ?L?COM005B (END) -------


----- FUNCTION ?L?COM005C (BEGIN) -----
001A9A AF03              MOV      R7,AR3
001A9C AE02              MOV      R6,AR2
001A9E 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM005C (END) -------


