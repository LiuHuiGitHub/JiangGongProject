LX51 LINKER/LOCATER V4.66.1.0                                                           11/29/2015  09:45:01  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  .\Debug\PP01_01 (SYS_DELAY)


----- FUNCTION sys_gpioInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   23: void sys_gpioInit(void)
   24: {
   25: }
   26: 
000009 22                RET      
----- FUNCTION sys_gpioInit (END) -------


----- FUNCTION sys_taskHandler10ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   66: void sys_taskHandler10ms(void)            //10ms interrupt task
   67: {
   68: }
   69: 
00000A 22                RET      
----- FUNCTION sys_taskHandler10ms (END) -------


00000B 021010            LJMP     01010H
----- FUNCTION app_brushInit (BEGIN) -----
 FILE: 'App\app_brush.c'
   31: void app_brushInit(void)
   32: {
   33: 	Init_FM1702();
   34: }
000020 816E              AJMP     Init_FM1702
----- FUNCTION app_brushInit (END) -------


----- FUNCTION sys_taskHandler1s (BEGIN) -----
 FILE: 'System\sys_task.c'
   75: void sys_taskHandler1s(void)              //1s interrupt task
   76: {
   77: }
   78: 
000022 22                RET      
----- FUNCTION sys_taskHandler1s (END) -------


000023 0216A6            LJMP     016A6H
----- FUNCTION _sys_delayus (BEGIN) -----
 FILE: 'System\sys_delay.c'
    5: void sys_delayus(UINT16 xus)
    6: {
;---- Variable 'xus' assigned to Register 'R6/R7' ----
    7:     while(xus--);
000463         ?C0001?SYS_DELAY:
    8: }
000463 EF                MOV      A,R7
000464 1F                DEC      R7
000465 AC06              MOV      R4,AR6
000467 7001              JNZ      ?C0012?SYS_DELAY
000469 1E                DEC      R6
00046A         ?C0012?SYS_DELAY:
00046A 4C                ORL      A,R4
00046B 70F6              JNZ      ?C0001?SYS_DELAY
    9: 
00046D 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 2


----- FUNCTION _sys_delayus (END) -------


----- FUNCTION Init_FM1702 (BEGIN) -----
 FILE: 'Driver\mifare.c'
  104: void Init_FM1702(void)
  105: {
  106: 	uchar temp;
  107: 	uint i;
  108: 	RC500SCK = 0;
00046E C2A1              CLR      RC500SCK
  109: 	RC500SO = 1;
000470 D2A2              SETB     RC500SO
  110: 	RC500SI = 1;
000472 D2A4              SETB     RC500SI
  111: 	RC500RST = 1;	// FM1702复位 
000474 D2A5              SETB     RC500RST
  112: 	sys_delayms(2);
000476 7F02              MOV      R7,#02H
000478 7E00              MOV      R6,#00H
00047A 120807            LCALL    _sys_delayms
  113: 	RC500RST = 0;	
00047D C2A5              CLR      RC500RST
  114: 	//进入复位阶段，需要512个FM1702SL的时钟周期，约38us
  115: 	sys_delayus(100); 
00047F 7F64              MOV      R7,#064H
000481 7E00              MOV      R6,#00H
000483 9163              ACALL    _sys_delayus
000485         ?C0024?MIFARE:
  116: 	//进入初始化阶段，需要128个时钟周期，约10us
  117: 	do{ 		// 等待Command = 0,FM1702复位成功
  118: 		temp = SPIReadOne(Command_Reg);	 //(Command_Reg<<1)|0x80 = 0x82
;---- Variable 'temp' assigned to Register 'R4' ----
000485 F189              ACALL    ?L?COM002F
000487 70FC              JNZ      ?C0024?MIFARE
  119: 	}while(temp!=0);
  120: ///////////////////////////////////////////////////////////////////////////////////
  121: 	SPIWriteOne(Page_Reg,0x80);	//初始化SPI接口
000489 7D80              MOV      R5,#080H
00048B FF                MOV      R7,A
00048C 91C8              ACALL    _SPIWriteOne
  122: 	for(i = 0; i < 0x1fff; i++) // 延时
;---- Variable 'i' assigned to Register 'R2/R3' ----
00048E E4                CLR      A
00048F FB                MOV      R3,A
000490 FA                MOV      R2,A
000491         ?C0025?MIFARE:
  123: 	{
  124: 		temp = SPIReadOne(Command_Reg);
000491 F189              ACALL    ?L?COM002F
000493 7006              JNZ      ?C0027?MIFARE
  125: 		if(temp == 0x00)	//SPI初始化成功
  126: 		{
  127: 			SPIWriteOne(Page_Reg,0);//可以使用SPI接口
000495 FD                MOV      R5,A
000496 FF                MOV      R7,A
000497 91C8              ACALL    _SPIWriteOne
  128: 			break;
000499 800B              SJMP     ?C0026?MIFARE
  129: 		}
  130: 	}
00049B         ?C0027?MIFARE:
00049B 0B                INC      R3
00049C BB0001            CJNE     R3,#00H,?C0138?MIFARE
00049F 0A                INC      R2
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 3


0004A0         ?C0138?MIFARE:
0004A0 BA1FEE            CJNE     R2,#01FH,?C0025?MIFARE
0004A3 BBFFEB            CJNE     R3,#0FFH,?C0025?MIFARE
0004A6         ?C0026?MIFARE:
  131: ////////////////////////////////////////////////////////////////////////////////////
  132: 	SPIWriteOne(InterruptEn_Reg,0x7F);	//  禁止所有中断请求（最高位置0）
0004A6 7D7F              MOV      R5,#07FH
0004A8 7F06              MOV      R7,#06H
0004AA 91C8              ACALL    _SPIWriteOne
  133: 	SPIWriteOne(InterruptRq_Reg,0x7F);	// 禁止所有中断请求标识置0（最高位置0）
0004AC 7D7F              MOV      R5,#07FH
0004AE 7F07              MOV      R7,#07H
0004B0 91C8              ACALL    _SPIWriteOne
  134: 	
  135: 	//设置调制器的输入源为内部编码器, 并且设置TX1和TX2
  136: 	SPIWriteOne(TxControl_Reg,0x5B); 		// 发送控制寄存器 
0004B2 7D5B              MOV      R5,#05BH
0004B4 7F11              MOV      R7,#011H
0004B6 91C8              ACALL    _SPIWriteOne
  137: 	SPIWriteOne(RxControl2_Reg,0x01);
0004B8 7D01              MOV      R5,#01H
0004BA 7F1E              MOV      R7,#01EH
0004BC 91C8              ACALL    _SPIWriteOne
  138: 	SPIWriteOne(RxWait_Reg,5);
0004BE 7D05              MOV      R5,#05H
0004C0 7F21              MOV      R7,#021H
0004C2 8004              SJMP     _SPIWriteOne
----- FUNCTION Init_FM1702 (END) -------


----- FUNCTION ?L?COM0031 (BEGIN) -----
0004C4 F0                MOVX     @DPTR,A
0004C5 FD                MOV      R5,A
0004C6 7F01              MOV      R7,#01H
----- FUNCTION _SPIWriteOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   65: void SPIWriteOne(uchar SpiAddress,uchar wData)
   66: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
;---- Variable 'wData' assigned to Register 'R5' ----
   67: 	uchar i;
   68: 	SpiAddress = SpiAddress<<1;
0004C8 EF                MOV      A,R7
0004C9 25E0              ADD      A,ACC
   69: 	SpiAddress = SpiAddress & 0x7E;
0004CB 547E              ANL      A,#07EH
0004CD FF                MOV      R7,A
   70: 
   71: 	//传输地址 从高位到低位传输
   72: 	RC500CS = 0;
0004CE C2A3              CLR      RC500CS
   73: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
0004D0 E4                CLR      A
0004D1 FE                MOV      R6,A
0004D2         ?C0011?MIFARE:
   74: 	{
   75: 		if(SpiAddress&0x80)
0004D2 EF                MOV      A,R7
0004D3 30E704            JNB      ACC.7,?C0014?MIFARE
   76: 			RC500SO = 1;
0004D6 D2A2              SETB     RC500SO
0004D8 8002              SJMP     ?C0015?MIFARE
0004DA         ?C0014?MIFARE:
   77: 		else
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 4


   78: 			RC500SO = 0;
0004DA C2A2              CLR      RC500SO
0004DC         ?C0015?MIFARE:
   79: 		RC500SCK = 1;
0004DC F1F8              ACALL    ?L?COM003C
0004DE B408F1            CJNE     A,#08H,?C0011?MIFARE
0004E1         ?C0012?MIFARE:
   80: 		SpiAddress = SpiAddress<<1;
   81: 		RC500SCK = 0;
   82: 	}
   83: 	//传输数据，从高位开始
   84: 	for (i=0;i<8;i++)
0004E1 E4                CLR      A
0004E2 FE                MOV      R6,A
0004E3         ?C0016?MIFARE:
   85: 	{
   86: 		if(wData & 0x80)
0004E3 ED                MOV      A,R5
0004E4 30E704            JNB      ACC.7,?C0019?MIFARE
   87: 			RC500SO = 1;
0004E7 D2A2              SETB     RC500SO
0004E9 8002              SJMP     ?C0020?MIFARE
0004EB         ?C0019?MIFARE:
   88: 		else
   89: 			RC500SO = 0;
0004EB C2A2              CLR      RC500SO
0004ED         ?C0020?MIFARE:
   90: 		RC500SCK = 1;
0004ED D2A1              SETB     RC500SCK
   91: 		wData = wData<<1;
0004EF ED                MOV      A,R5
0004F0 25E0              ADD      A,ACC
0004F2 FD                MOV      R5,A
   92: 		RC500SCK = 0;
0004F3 C2A1              CLR      RC500SCK
   93: 	}
0004F5 0E                INC      R6
0004F6 EE                MOV      A,R6
0004F7 B408E9            CJNE     A,#08H,?C0016?MIFARE
0004FA         ?C0017?MIFARE:
   94: 	RC500CS = 1;
0004FA D2A3              SETB     RC500CS
   95: }
0004FC 22                RET      
----- FUNCTION _SPIWriteOne (END) -------


----- FUNCTION _SPIReadOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   24: uchar SPIReadOne(uchar SpiAddress)
   25: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
   26: 	uchar i,rdata; 
   27: 	//地址字节最高位置1，表示为读数据，最低位固定为0，中间6位为地址
   28: 	SpiAddress = SpiAddress<<1;
0004FD EF                MOV      A,R7
0004FE 25E0              ADD      A,ACC
   29: 	SpiAddress = SpiAddress | 0x80;
000500 4480              ORL      A,#080H
000502 FF                MOV      R7,A
   30: 	//传输地址 从高位到低位传输
   31: 	RC500CS = 0;
000503 C2A3              CLR      RC500CS
   32: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 5


000505 E4                CLR      A
000506 FE                MOV      R6,A
000507         ?C0001?MIFARE:
   33: 	{
   34: 		if(SpiAddress&0x80)
000507 EF                MOV      A,R7
000508 30E704            JNB      ACC.7,?C0004?MIFARE
   35: 			RC500SO = 1;
00050B D2A2              SETB     RC500SO
00050D 8002              SJMP     ?C0005?MIFARE
00050F         ?C0004?MIFARE:
   36: 		else
   37: 			RC500SO = 0;
00050F C2A2              CLR      RC500SO
000511         ?C0005?MIFARE:
   38: 		RC500SCK = 1;
000511 F1F8              ACALL    ?L?COM003C
000513 B408F1            CJNE     A,#08H,?C0001?MIFARE
000516         ?C0002?MIFARE:
   39: 		SpiAddress = SpiAddress<<1;
   40: 		RC500SCK = 0;
   41: 	}
   42: 	
   43: 	//接收数据
   44: 	rdata = 0;
;---- Variable 'rdata' assigned to Register 'R7' ----
000516 E4                CLR      A
000517 FF                MOV      R7,A
   45: 	for (i=0;i<8;i++)
000518 FE                MOV      R6,A
000519         ?C0006?MIFARE:
   46: 	{
   47: 		RC500SCK = 1;
000519 D2A1              SETB     RC500SCK
   48: 		rdata = rdata<<1;
00051B EF                MOV      A,R7
00051C 25E0              ADD      A,ACC
00051E FF                MOV      R7,A
   49: 		if (RC500SI)
00051F 30A401            JNB      RC500SI,?C0009?MIFARE
   50: 			rdata+= 1;
000522 0F                INC      R7
000523         ?C0009?MIFARE:
   51: 		RC500SCK = 0;
000523 C2A1              CLR      RC500SCK
   52: 	}
000525 0E                INC      R6
000526 EE                MOV      A,R6
000527 B408EF            CJNE     A,#08H,?C0006?MIFARE
00052A         ?C0007?MIFARE:
   53: 	RC500CS=1;
00052A D2A3              SETB     RC500CS
   54: 	return (rdata);
   55: }
00052C 22                RET      
----- FUNCTION _SPIReadOne (END) -------


----- FUNCTION AntiColl (BEGIN) -----
 FILE: 'Driver\mifare.c'
  278: uchar AntiColl(void)
  279: {
  280: 	
  281: 	uchar	temp,i;
  282: 
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 6


  283: 	//选择TX1、TX2的发射天线阻抗
  284: 	SPIWriteOne(CwConductance_Reg,0x3f);
00052D F15A              ACALL    ?L?COM001B
00052F 7493              MOV      A,#093H
000531 F0                MOVX     @DPTR,A
  285: 	//选择数据校验种类和模式
  286: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  287: 	
  288: 	gBuff[0] = RF_CMD_ANTICOL;
  289: 	gBuff[1] = 0x20;
000532 A3                INC      DPTR
000533 7420              MOV      A,#020H
000535 D191              ACALL    ?L?COM000B
000537 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
00053A 7402              MOV      A,#02H
00053C F0                MOVX     @DPTR,A
00053D 7F1E              MOV      R7,#01EH
00053F B195              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R5' ----
000541 AD07              MOV      R5,AR7
  290: 	temp = Command_Send(Transceive,gBuff,2);
  291: 	if (temp==0)
000543 ED                MOV      A,R5
000544 7003              JNZ      ?C0062?MIFARE
  292: 	{
  293: 		return(FM1702_NOTAGERR);
000546 7F01              MOV      R7,#01H
000548 22                RET      
  294: 	}
000549         ?C0062?MIFARE:
  295: 
  296: 	temp = SPIReadOne(FIFOLength_Reg);
000549 F191              ACALL    ?L?COM0034
00054B 7003              JNZ      ?C0064?MIFARE
  297: 	if (temp == 0)
  298: 	{
  299: 		return FM1702_BYTECOUNTERR;
00054D 7F0C              MOV      R7,#0CH
00054F 22                RET      
  300: 	}
000550         ?C0064?MIFARE:
  301: 
  302: 	for(i=0;i<temp;i++)
;---- Variable 'i' assigned to Register 'R4' ----
000550 E4                CLR      A
000551 FC                MOV      R4,A
000552         ?C0065?MIFARE:
000552 EC                MOV      A,R4
000553 C3                CLR      C
000554 9D                SUBB     A,R5
000555 500B              JNC      ?C0066?MIFARE
  303: 	{
  304: 		gBuff[i] = SPIReadOne(FIFO_Reg);
000557 7F02              MOV      R7,#02H
000559 91FD              ACALL    _SPIReadOne
00055B F199              ACALL    ?L?COM002D
00055D EF                MOV      A,R7
00055E F0                MOVX     @DPTR,A
  305: 	}
00055F 0C                INC      R4
000560 80F0              SJMP     ?C0065?MIFARE
000562         ?C0066?MIFARE:
  306: 	temp = SPIReadOne(ErrorFlag_Reg);	// 判断接数据是否有冲突位
000562 7F0A              MOV      R7,#0AH
000564 F193              ACALL    ?L?COM0035
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 7


000566 5401              ANL      A,#01H
000568 FD                MOV      R5,A
  307: 	temp = temp & 0x01;
  308: 	if (temp == 0x00)
000569 7027              JNZ      ?C0068?MIFARE
  309: 	{
  310: 		for (i=0;i<5;i++)
00056B FC                MOV      R4,A
00056C         ?C0069?MIFARE:
  311: 			temp^=gBuff[i];
00056C F199              ACALL    ?L?COM002D
00056E E0                MOVX     A,@DPTR
00056F 6D                XRL      A,R5
000570 FD                MOV      R5,A
000571 0C                INC      R4
000572 EC                MOV      A,R4
000573 B405F6            CJNE     A,#05H,?C0069?MIFARE
000576         ?C0070?MIFARE:
  312: 		if (temp)
000576 ED                MOV      A,R5
000577 6003              JZ       ?C0072?MIFARE
  313: 			return(FM1702_SERNRERR);
000579 7F08              MOV      R7,#08H
00057B 22                RET      
00057C         ?C0072?MIFARE:
  314:         for (i=0;i<5;i++)
00057C E4                CLR      A
00057D FC                MOV      R4,A
00057E         ?C0073?MIFARE:
  315:         {
  316:             gCard_UID[i]=gBuff[i];
00057E F199              ACALL    ?L?COM002D
000580 E0                MOVX     A,@DPTR
000581 FF                MOV      R7,A
000582 74A6              MOV      A,#LOW gCard_UID
000584 2C                ADD      A,R4
000585 1211EF            LCALL    ?L?COM0011
000588 EF                MOV      A,R7
000589 F0                MOVX     @DPTR,A
  317:         }
00058A 0C                INC      R4
00058B EC                MOV      A,R4
00058C B405EF            CJNE     A,#05H,?C0073?MIFARE
00058F         ?C0074?MIFARE:
  318: 		return(FM1702_OK);
00058F 7F00              MOV      R7,#00H
000591 22                RET      
  319: 	}
000592         ?C0068?MIFARE:
  320: 	else //有冲突位
  321: 		return FM1702_SERNRERR;
000592 7F08              MOV      R7,#08H
  322: }
000594 22                RET      
----- FUNCTION AntiColl (END) -------


----- FUNCTION _Command_Send (BEGIN) -----
 FILE: 'Driver\mifare.c'
  251: uchar Command_Send(uchar Comm_Set,uchar *buff, uchar count)
  252: {
000595 900067            MOV      DPTR,#Comm_Set
000598 EF                MOV      A,R7
000599 F0                MOVX     @DPTR,A
;---- Variable 'buff' assigned to Register 'R1/R2/R3' ----
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 8


  253:     uchar ucResult1,ucResult2,i;
  254:     SPIWriteOne(Command_Reg,0x00);
00059A E4                CLR      A
00059B FD                MOV      R5,A
00059C 7F01              MOV      R7,#01H
00059E 91C8              ACALL    _SPIWriteOne
  255:     if(Clear_FIFO()==FALSE)
0005A0 F16A              ACALL    Clear_FIFO
0005A2 EF                MOV      A,R7
0005A3 7002              JNZ      ?C0055?MIFARE
  256:         return FALSE;
0005A5 FF                MOV      R7,A
0005A6 22                RET      
0005A7         ?C0055?MIFARE:
  257:     Write_FIFO(buff,count);
0005A7 90006B            MOV      DPTR,#count
0005AA E0                MOVX     A,@DPTR
0005AB FD                MOV      R5,A
0005AC 12154B            LCALL    _Write_FIFO
  258: 	SPIWriteOne(Command_Reg,Comm_Set);
0005AF 900067            MOV      DPTR,#Comm_Set
0005B2 E0                MOVX     A,@DPTR
0005B3 FD                MOV      R5,A
0005B4 7F01              MOV      R7,#01H
0005B6 91C8              ACALL    _SPIWriteOne
  259: 	for (i=0;i<0xA0;i++)
;---- Variable 'i' assigned to Register 'R5' ----
0005B8 E4                CLR      A
0005B9 FD                MOV      R5,A
0005BA         ?C0057?MIFARE:
  260: 	{
  261:         ucResult1 = SPIReadOne(Command_Reg);
0005BA 7F01              MOV      R7,#01H
0005BC 91FD              ACALL    _SPIReadOne
;---- Variable 'ucResult1' assigned to Register 'R4' ----
0005BE AC07              MOV      R4,AR7
  262:         ucResult2 = SPIReadOne(InterruptRq_Reg) & 0x80;
0005C0 7F07              MOV      R7,#07H
0005C2 91FD              ACALL    _SPIReadOne
0005C4 EF                MOV      A,R7
0005C5 5480              ANL      A,#080H
0005C7 FF                MOV      R7,A
;---- Variable 'ucResult2' assigned to Register 'R7' ----
  263:         if(ucResult1 == 0 || ucResult2 ==0x80)
0005C8 EC                MOV      A,R4
0005C9 6004              JZ       ?C0061?MIFARE
0005CB EF                MOV      A,R7
0005CC B48003            CJNE     A,#080H,?C0059?MIFARE
0005CF         ?C0061?MIFARE:
  264:             return TRUE;
0005CF 7F01              MOV      R7,#01H
0005D1 22                RET      
  265: 	}
0005D2         ?C0059?MIFARE:
0005D2 0D                INC      R5
0005D3 ED                MOV      A,R5
0005D4 B4A0E3            CJNE     A,#0A0H,?C0057?MIFARE
0005D7         ?C0058?MIFARE:
  266: 	return FALSE;
0005D7 7F00              MOV      R7,#00H
  267: }
0005D9 22                RET      
----- FUNCTION _Command_Send (END) -------


LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 9


----- FUNCTION _Request (BEGIN) -----
 FILE: 'Driver\mifare.c'
  152: uchar Request(uchar mode)
  153: {
;---- Variable 'mode' assigned to Register 'R4' ----
0005DA AC07              MOV      R4,AR7
  154: 	
  155: 	uchar temp;
  156: 	
  157: 	//选择TX1、TX2的发射天线阻抗
  158: 	SPIWriteOne(CwConductance_Reg,0x3f);
0005DC F1E1              ACALL    ?L?COM0049
  159: 	//选择数据校验种类和模式
  160: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
0005DE 7D03              MOV      R5,#03H
0005E0 7F22              MOV      R7,#022H
0005E2 91C8              ACALL    _SPIWriteOne
  161: 	//调整面向bit的格式
  162: 	SPIWriteOne(BitFraming_Reg,0x07);
0005E4 7D07              MOV      R5,#07H
0005E6 7F0F              MOV      R7,#0FH
0005E8 F164              ACALL    ?L?COM001D
0005EA EC                MOV      A,R4
0005EB F0                MOVX     @DPTR,A
  163: 	gBuff[0] = mode;		//Request模式选择 
  164: 	temp = SPIReadOne(Control_Reg);
0005EC 7F09              MOV      R7,#09H
0005EE 91FD              ACALL    _SPIReadOne
;---- Variable 'temp' assigned to Register 'R7' ----
  165: 	temp = temp & (0xf7);	
0005F0 EF                MOV      A,R7
0005F1 54F7              ANL      A,#0F7H
  166: 	SPIWriteOne(Control_Reg,temp);			//Control reset value is 00
0005F3 FD                MOV      R5,A
0005F4 7F09              MOV      R7,#09H
0005F6 91C8              ACALL    _SPIWriteOne
  167: 	temp = Command_Send(Transceive, gBuff,1 );   //发送接收命令 
0005F8 D192              ACALL    ?L?COM000C
0005FA 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
0005FD 7401              MOV      A,#01H
0005FF F1A9              ACALL    ?L?COM0021
000601 7003              JNZ      ?C0030?MIFARE
  168: 	if(temp==0 )
  169: 	{
  170: 		return FM1702_NOTAGERR;
000603 7F01              MOV      R7,#01H
000605 22                RET      
  171: 	}
000606         ?C0030?MIFARE:
  172: 
  173: 	temp=Read_FIFO(gBuff);		//从FIFO中读取应答信息到gBuff中 
000606 D192              ACALL    ?L?COM000C
000608 F1B0              ACALL    _Read_FIFO
  174: 	// 判断应答信号是否正确 
  175: 	// 2  	Mifare Pro 卡
  176: 	//4 		Mifare One 卡
  177: 	if((gBuff[0] == 0x04) & (gBuff[1] == 0x0) &(temp == 2))
00060A 9000AC            MOV      DPTR,#gBuff+01H
00060D E0                MOVX     A,@DPTR
00060E 7E00              MOV      R6,#00H
000610 7002              JNZ      ?C0033?MIFARE
000612 7E01              MOV      R6,#01H
000614         ?C0033?MIFARE:
000614         ?C0034?MIFARE:
000614 9000AB            MOV      DPTR,#gBuff
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 10


000617 E0                MOVX     A,@DPTR
000618 7D00              MOV      R5,#00H
00061A B40402            CJNE     A,#04H,?C0035?MIFARE
00061D 7D01              MOV      R5,#01H
00061F         ?C0035?MIFARE:
00061F         ?C0036?MIFARE:
00061F ED                MOV      A,R5
000620 5E                ANL      A,R6
000621 FE                MOV      R6,A
000622 EF                MOV      A,R7
000623 7F00              MOV      R7,#00H
000625 B40202            CJNE     A,#02H,?C0037?MIFARE
000628 7F01              MOV      R7,#01H
00062A         ?C0037?MIFARE:
00062A         ?C0038?MIFARE:
00062A EF                MOV      A,R7
00062B 5E                ANL      A,R6
00062C 7F15              MOV      R7,#015H
00062E 6002              JZ       ?C0032?MIFARE
  178: 	{
  179: 			return FM1702_OK;
000630 7F00              MOV      R7,#00H
  180: 	}
000632         ?C0032?MIFARE:
  181: 	return FM1702_REQERR;
  182: }
000632 22                RET      
----- FUNCTION _Request (END) -------


----- FUNCTION SelectCard (BEGIN) -----
 FILE: 'Driver\mifare.c'
  335: uchar SelectCard(void)
  336: {
  337: 	
  338: 	uchar	temp, i;
  339: 	
  340: 	//选择TX1、TX2的发射天线阻抗
  341: 	SPIWriteOne(CwConductance_Reg,0x3f);
000633 F1E1              ACALL    ?L?COM0049
  342: 	//选择数据校验种类和模式
  343: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
000635 7D0F              MOV      R5,#0FH
000637 F162              ACALL    ?L?COM001C
000639 7493              MOV      A,#093H
00063B F0                MOVX     @DPTR,A
  344: 
  345: 	gBuff[0] = RF_CMD_SELECT;
  346: 	gBuff[1] = 0x70;
00063C A3                INC      DPTR
00063D 7470              MOV      A,#070H
00063F F0                MOVX     @DPTR,A
  347: 	for(i = 0; i < 5; i++)
;---- Variable 'i' assigned to Register 'R7' ----
000640 E4                CLR      A
000641 FF                MOV      R7,A
000642         ?C0077?MIFARE:
  348: 	{
  349: 		gBuff[i + 2] = gCard_UID[i];
000642 74A6              MOV      A,#LOW gCard_UID
000644 2F                ADD      A,R7
000645 1211EF            LCALL    ?L?COM0011
000648 E0                MOVX     A,@DPTR
000649 120FF0            LCALL    ?L?COM0025
00064C B405F3            CJNE     A,#05H,?C0077?MIFARE
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 11


00064F         ?C0078?MIFARE:
  350: 	}
  351: 	temp = Command_Send(Transceive, gBuff,7 );
00064F D192              ACALL    ?L?COM000C
000651 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
000654 7407              MOV      A,#07H
;---- Variable 'temp' assigned to Register 'R7' ----
000656 F1A9              ACALL    ?L?COM0021
000658 7003              JNZ      ?C0080?MIFARE
  352: 	if(temp==0 )
  353: 	{
  354: 		return(FM1702_NOTAGERR);
00065A 7F01              MOV      R7,#01H
00065C 22                RET      
  355: 	}
00065D         ?C0080?MIFARE:
  356: 	else
  357: 	{
  358: 		temp = SPIReadOne(ErrorFlag_Reg);
00065D F154              ACALL    ?L?COM0024
00065F 30E103            JNB      ACC.1,?C0083?MIFARE
000662 7F05              MOV      R7,#05H
000664 22                RET      
000665         ?C0083?MIFARE:
  359: 		if((temp & 0x02) == 0x02) return(FM1702_PARITYERR);
  360: 		if((temp & 0x04) == 0x04) return(FM1702_FRAMINGERR);
000665 EF                MOV      A,R7
000666 30E203            JNB      ACC.2,?C0084?MIFARE
000669 7F14              MOV      R7,#014H
00066B 22                RET      
00066C         ?C0084?MIFARE:
  361: 		if((temp & 0x08) == 0x08) return(FM1702_CRCERR);
00066C EF                MOV      A,R7
00066D 30E303            JNB      ACC.3,?C0085?MIFARE
000670 7F02              MOV      R7,#02H
000672 22                RET      
000673         ?C0085?MIFARE:
  362: 		temp = SPIReadOne(FIFOLength_Reg);
000673 7F04              MOV      R7,#04H
000675 91FD              ACALL    _SPIReadOne
  363: 		if(temp != 1) return(FM1702_BYTECOUNTERR);
000677 EF                MOV      A,R7
000678 6401              XRL      A,#01H
00067A 6003              JZ       ?C0086?MIFARE
00067C 7F0C              MOV      R7,#0CH
00067E 22                RET      
00067F         ?C0086?MIFARE:
  364: //		SPIRead(FIFO_Reg,gBuff,temp);	//从FIFO中读取应答信息
  365: 		gBuff[0] = SPIReadOne(FIFO_Reg);
00067F 7F02              MOV      R7,#02H
000681 91FD              ACALL    _SPIReadOne
000683 9000AB            MOV      DPTR,#gBuff
000686 EF                MOV      A,R7
000687 F0                MOVX     @DPTR,A
  366: 		if(gBuff[0]==0x08) 	  	// 判断应答信号是否正确 
000688 BF0803            CJNE     R7,#08H,?C0087?MIFARE
  367: 			return(FM1702_OK);
00068B 7F00              MOV      R7,#00H
00068D 22                RET      
00068E         ?C0087?MIFARE:
  368: 		else
  369: 			return(FM1702_SELERR);
00068E 7F16              MOV      R7,#016H
  370: 	}
  371: }
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 12


000690 22                RET      
----- FUNCTION SelectCard (END) -------


----- FUNCTION ?L?COM000B (BEGIN) -----
000691 F0                MOVX     @DPTR,A
000692         ?L?COM000C:
000692 7B01              MOV      R3,#01H
000694 7A00              MOV      R2,#HIGH gBuff
000696 79AB              MOV      R1,#LOW gBuff
000698 22                RET      
----- FUNCTION ?L?COM000B (END) -------


----- FUNCTION _Authentication (BEGIN) -----
 FILE: 'Driver\mifare.c'
  472: uchar Authentication(uchar *UID, uchar SecNR, uchar mode)
  473: {
000699 120EE8            LCALL    ?L?COM0003
;---- Variable 'SecNR' assigned to Register 'R4' ----
00069C AC05              MOV      R4,AR5
  474: 	uchar i;
  475: 	uchar temp, temp1;
  476: 
  477: 	if(SecNR >= 16)
00069E EC                MOV      A,R4
00069F C3                CLR      C
0006A0 9410              SUBB     A,#010H
0006A2 4004              JC       ?C0094?MIFARE
  478: 		SecNR = SecNR % 16;
0006A4 EC                MOV      A,R4
0006A5 540F              ANL      A,#0FH
0006A7 FC                MOV      R4,A
0006A8         ?C0094?MIFARE:
  479: 	
  480: 	//选择数据校验种类和模式
  481: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
0006A8 F1E7              ACALL    ?L?COM0048
  482: 	gBuff[0] = mode;
0006AA 900047            MOV      DPTR,#mode
0006AD E0                MOVX     A,@DPTR
0006AE 9000AB            MOV      DPTR,#gBuff
0006B1 F0                MOVX     @DPTR,A
  483: 	gBuff[1] = SecNR * 4 + 3;
0006B2 EC                MOV      A,R4
0006B3 25E0              ADD      A,ACC
0006B5 25E0              ADD      A,ACC
0006B7 2403              ADD      A,#03H
0006B9 A3                INC      DPTR
0006BA F0                MOVX     @DPTR,A
  484: 	for(i = 0; i < 4; i++)
;---- Variable 'i' assigned to Register 'R7' ----
0006BB E4                CLR      A
0006BC FF                MOV      R7,A
0006BD         ?C0095?MIFARE:
  485: 	{
  486: 		gBuff[2 + i] = UID[i];
0006BD 900043            MOV      DPTR,#UID
0006C0 F1F0              ACALL    ?L?COM0002
0006C2 121477            LCALL    ?L?COM0018
0006C5 120FF0            LCALL    ?L?COM0025
0006C8 B404F2            CJNE     A,#04H,?C0095?MIFARE
0006CB         ?C0096?MIFARE:
  487: 	}
  488: 
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 13


  489: 	temp = Command_Send(Authent1, gBuff,6 );
0006CB D192              ACALL    ?L?COM000C
0006CD 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
0006D0 7406              MOV      A,#06H
0006D2 F0                MOVX     @DPTR,A
0006D3 7F0C              MOV      R7,#0CH
0006D5 B195              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  490: 	if(temp==0)
0006D7 EF                MOV      A,R7
0006D8 7003              JNZ      ?C0098?MIFARE
  491: 	{
  492: 		return 0x99;
0006DA 7F99              MOV      R7,#099H
0006DC 22                RET      
  493: 	}
0006DD         ?C0098?MIFARE:
  494: 
  495: 	temp = SPIReadOne(ErrorFlag_Reg);   
0006DD F154              ACALL    ?L?COM0024
0006DF 30E103            JNB      ACC.1,?C0100?MIFARE
0006E2 7F05              MOV      R7,#05H
0006E4 22                RET      
0006E5         ?C0100?MIFARE:
  496: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  497: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
0006E5 EF                MOV      A,R7
0006E6 30E203            JNB      ACC.2,?C0101?MIFARE
0006E9 7F14              MOV      R7,#014H
0006EB 22                RET      
0006EC         ?C0101?MIFARE:
  498: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
0006EC EF                MOV      A,R7
0006ED 30E303            JNB      ACC.3,?C0102?MIFARE
0006F0 7F02              MOV      R7,#02H
0006F2 22                RET      
0006F3         ?C0102?MIFARE:
  499: 	temp = Command_Send(Authent2, gBuff,0 );	
0006F3 D192              ACALL    ?L?COM000C
0006F5 E4                CLR      A
0006F6 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
0006F9 F0                MOVX     @DPTR,A
0006FA 7F14              MOV      R7,#014H
0006FC B195              ACALL    _Command_Send
  500: 	if(temp ==0)
0006FE EF                MOV      A,R7
0006FF 7003              JNZ      ?C0103?MIFARE
  501: 	{
  502: 		return 0x88;
000701 7F88              MOV      R7,#088H
000703 22                RET      
  503: 	}
000704         ?C0103?MIFARE:
  504: 
  505: 	temp = SPIReadOne(ErrorFlag_Reg);
000704 F154              ACALL    ?L?COM0024
000706 30E103            JNB      ACC.1,?C0104?MIFARE
000709 7F05              MOV      R7,#05H
00070B 22                RET      
00070C         ?C0104?MIFARE:
  506: //	Show(temp,0);
  507: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  508: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
00070C EF                MOV      A,R7
00070D 30E203            JNB      ACC.2,?C0105?MIFARE
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 14


000710 7F14              MOV      R7,#014H
000712 22                RET      
000713         ?C0105?MIFARE:
  509: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
000713 EF                MOV      A,R7
000714 30E303            JNB      ACC.3,?C0106?MIFARE
000717 7F02              MOV      R7,#02H
000719 22                RET      
00071A         ?C0106?MIFARE:
  510: 	temp1 = SPIReadOne(Control_Reg);
00071A 7F09              MOV      R7,#09H
00071C 91FD              ACALL    _SPIReadOne
;---- Variable 'temp1' assigned to Register 'R7' ----
  511: 	temp1 = temp1 & 0x08;	
00071E EF                MOV      A,R7
00071F 5408              ANL      A,#08H
  512: 	if(temp1 == 0x08)
000721 7F04              MOV      R7,#04H
000723 B40802            CJNE     A,#08H,?C0107?MIFARE
  513: 	{
  514: 		return FM1702_OK;
000726 7F00              MOV      R7,#00H
  515: 	}
000728         ?C0107?MIFARE:
  516: 
  517: 	return FM1702_AUTHERR;
  518: }
000728 22                RET      
----- FUNCTION _Authentication (END) -------


----- FUNCTION MIF_Halt (BEGIN) -----
 FILE: 'Driver\mifare.c'
  610: uchar MIF_Halt(void)
  611: {
  612: 	uchar	temp;
  613: 	//选择TX1、TX2的发射天线阻抗
  614: 	SPIWriteOne(CwConductance_Reg,0x3f);
000729 F15A              ACALL    ?L?COM001B
00072B 7450              MOV      A,#050H
00072D F0                MOVX     @DPTR,A
  615: 	//选择数据校验种类和模式
  616: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  617: 	*gBuff = RF_CMD_HALT;
  618: 	*(gBuff + 1) = 0x00;
00072E E4                CLR      A
00072F A3                INC      DPTR
000730 D191              ACALL    ?L?COM000B
000732 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
000735 7402              MOV      A,#02H
000737 F0                MOVX     @DPTR,A
000738 7F1A              MOV      R7,#01AH
00073A B195              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  619: 	temp = Command_Send(Transmit, gBuff, 2);//发送FIFO缓存地址
  620: 	if(temp == TRUE)
00073C EF                MOV      A,R7
00073D B40103            CJNE     A,#01H,?C0133?MIFARE
  621: 		return FM1702_OK;
000740 7F00              MOV      R7,#00H
000742 22                RET      
000743         ?C0133?MIFARE:
  622: 	else
  623: 	{
  624: 		temp = SPIReadOne(ErrorFlag_Reg);
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 15


000743 F154              ACALL    ?L?COM0024
000745 30E103            JNB      ACC.1,?C0136?MIFARE
  625: 		if((temp & 0x02) == 0x02)
  626: 		{
  627: 			return(FM1702_PARITYERR);
000748 7F05              MOV      R7,#05H
00074A 22                RET      
  628: 		}
00074B         ?C0136?MIFARE:
  629: 
  630: 		if((temp & 0x04) == 0x04)
00074B EF                MOV      A,R7
00074C 7F01              MOV      R7,#01H
00074E 30E202            JNB      ACC.2,?C0137?MIFARE
  631: 		{
  632: 			return(FM1702_FRAMINGERR);
000751 7F14              MOV      R7,#014H
  633: 		}
000753         ?C0137?MIFARE:
  634: 		return(FM1702_NOTAGERR);
  635: 	}
  636: }
000753 22                RET      
----- FUNCTION MIF_Halt (END) -------


----- FUNCTION ?L?COM0024 (BEGIN) -----
000754 7F0A              MOV      R7,#0AH
000756 91FD              ACALL    _SPIReadOne
000758 EF                MOV      A,R7
000759 22                RET      
----- FUNCTION ?L?COM0024 (END) -------


----- FUNCTION ?L?COM001B (BEGIN) -----
00075A 7D3F              MOV      R5,#03FH
00075C 7F12              MOV      R7,#012H
00075E 91C8              ACALL    _SPIWriteOne
000760 7D03              MOV      R5,#03H
000762         ?L?COM001C:
000762 7F22              MOV      R7,#022H
000764         ?L?COM001D:
000764 91C8              ACALL    _SPIWriteOne
000766 9000AB            MOV      DPTR,#gBuff
000769 22                RET      
----- FUNCTION ?L?COM001B (END) -------


----- FUNCTION Clear_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  190: uchar Clear_FIFO(void)
  191: {
  192:     uchar ucResult,i;
  193:     ucResult = SPIReadOne(Control_Reg);
00076A 7F09              MOV      R7,#09H
;---- Variable 'ucResult' assigned to Register 'R4' ----
00076C F18B              ACALL    ?L?COM0030
00076E 4401              ORL      A,#01H
000770 FC                MOV      R4,A
  194:     ucResult |=0x01;
  195:     SPIWriteOne(Control_Reg,ucResult);
000771 FD                MOV      R5,A
000772 7F09              MOV      R7,#09H
000774 91C8              ACALL    _SPIWriteOne
  196:     for(i=0;i<0xA0;i++)
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 16


;---- Variable 'i' assigned to Register 'R5' ----
000776 E4                CLR      A
000777 FD                MOV      R5,A
000778         ?C0039?MIFARE:
  197:     {
  198:         ucResult = SPIReadOne(FIFOLength_Reg);
000778 7F04              MOV      R7,#04H
00077A F18B              ACALL    ?L?COM0030
00077C 7003              JNZ      ?C0041?MIFARE
  199:         if(ucResult == 0)
  200:             return TRUE;
00077E 7F01              MOV      R7,#01H
000780 22                RET      
  201:     }
000781         ?C0041?MIFARE:
000781 0D                INC      R5
000782 ED                MOV      A,R5
000783 B4A0F2            CJNE     A,#0A0H,?C0039?MIFARE
000786         ?C0040?MIFARE:
  202:     return FALSE;
000786 7F00              MOV      R7,#00H
  203: }
000788 22                RET      
----- FUNCTION Clear_FIFO (END) -------


----- FUNCTION ?L?COM002F (BEGIN) -----
000789 7F01              MOV      R7,#01H
00078B         ?L?COM0030:
00078B 91FD              ACALL    _SPIReadOne
00078D AC07              MOV      R4,AR7
00078F EC                MOV      A,R4
000790 22                RET      
----- FUNCTION ?L?COM002F (END) -------


----- FUNCTION ?L?COM0034 (BEGIN) -----
000791 7F04              MOV      R7,#04H
000793         ?L?COM0035:
000793 91FD              ACALL    _SPIReadOne
000795 AD07              MOV      R5,AR7
000797 ED                MOV      A,R5
000798 22                RET      
----- FUNCTION ?L?COM0034 (END) -------


----- FUNCTION ?L?COM002D (BEGIN) -----
000799 74AB              MOV      A,#LOW gBuff
00079B 2C                ADD      A,R4
00079C F582              MOV      DPL,A
00079E E4                CLR      A
00079F 3400              ADDC     A,#HIGH gBuff
0007A1 F583              MOV      DPH,A
0007A3 22                RET      
----- FUNCTION ?L?COM002D (END) -------


----- FUNCTION ?L?COM0020 (BEGIN) -----
0007A4 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
0007A7 7402              MOV      A,#02H
0007A9         ?L?COM0021:
0007A9 F0                MOVX     @DPTR,A
0007AA 7F1E              MOV      R7,#01EH
0007AC B195              ACALL    _Command_Send
0007AE EF                MOV      A,R7
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 17


0007AF 22                RET      
----- FUNCTION ?L?COM0020 (END) -------


----- FUNCTION _Read_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  228: uchar Read_FIFO(uchar *buff)
  229: {
0007B0 900067            MOV      DPTR,#buff
0007B3 120EEB            LCALL    ?L?COM0004
  230: 	uchar	ucResult,i;
  231: 	ucResult = SPIReadOne(FIFOLength_Reg);
;---- Variable 'ucResult' assigned to Register 'R5' ----
0007B6 F191              ACALL    ?L?COM0034
0007B8 6005              JZ       ?C0050?MIFARE
0007BA D3                SETB     C
0007BB 9410              SUBB     A,#010H
0007BD 4003              JC       ?C0049?MIFARE
0007BF         ?C0050?MIFARE:
  232: 	if(ucResult == 0 || ucResult>16)
  233: 		return 0;
0007BF 7F00              MOV      R7,#00H
0007C1 22                RET      
0007C2         ?C0049?MIFARE:
  234: 	for(i=0;i<ucResult;i++)
;---- Variable 'i' assigned to Register 'R4' ----
0007C2 E4                CLR      A
0007C3 FC                MOV      R4,A
0007C4         ?C0052?MIFARE:
0007C4 EC                MOV      A,R4
0007C5 C3                CLR      C
0007C6 9D                SUBB     A,R5
0007C7 5015              JNC      ?C0053?MIFARE
  235: 	{
  236: 		buff[i] = SPIReadOne(FIFO_Reg);
0007C9 7F02              MOV      R7,#02H
0007CB 91FD              ACALL    _SPIReadOne
0007CD 900067            MOV      DPTR,#buff
0007D0 F1F0              ACALL    ?L?COM0002
0007D2 F9                MOV      R1,A
0007D3 8C82              MOV      DPL,R4
0007D5 758300            MOV      DPH,#00H
0007D8 EF                MOV      A,R7
0007D9 3174              ACALL    ?C?CSTOPTR
  237: 	}
0007DB 0C                INC      R4
0007DC 80E6              SJMP     ?C0052?MIFARE
0007DE         ?C0053?MIFARE:
  238: 
  239: 	return ucResult;
0007DE AF05              MOV      R7,AR5
  240: }
0007E0 22                RET      
----- FUNCTION _Read_FIFO (END) -------


----- FUNCTION ?L?COM0049 (BEGIN) -----
0007E1 7D3F              MOV      R5,#03FH
0007E3 7F12              MOV      R7,#012H
0007E5 81C8              AJMP     _SPIWriteOne
----- FUNCTION ?L?COM0049 (END) -------


----- FUNCTION ?L?COM0048 (BEGIN) -----
0007E7 7D0F              MOV      R5,#0FH
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 18


0007E9 7F22              MOV      R7,#022H
0007EB 81C8              AJMP     _SPIWriteOne
----- FUNCTION ?L?COM0048 (END) -------


----- FUNCTION ?L?COM0001 (BEGIN) -----
0007ED 900048            MOV      DPTR,#dat
0007F0         ?L?COM0002:
0007F0 E0                MOVX     A,@DPTR
0007F1 FB                MOV      R3,A
0007F2 A3                INC      DPTR
0007F3 E0                MOVX     A,@DPTR
0007F4 FA                MOV      R2,A
0007F5 A3                INC      DPTR
0007F6 E0                MOVX     A,@DPTR
0007F7 22                RET      
----- FUNCTION ?L?COM0001 (END) -------


----- FUNCTION ?L?COM003C (BEGIN) -----
0007F8 D2A1              SETB     RC500SCK
0007FA EF                MOV      A,R7
0007FB 25E0              ADD      A,ACC
0007FD FF                MOV      R7,A
0007FE C2A1              CLR      RC500SCK
000800 0E                INC      R6
000801 EE                MOV      A,R6
000802 22                RET      
----- FUNCTION ?L?COM003C (END) -------


----- FUNCTION ?L?COM0039 (BEGIN) -----
000803 7FF4              MOV      R7,#0F4H
000805 7E01              MOV      R6,#01H
----- FUNCTION _sys_delayms (BEGIN) -----
 FILE: 'System\sys_delay.c'
   10: void sys_delayms(UINT16 xms)
   11: {   
;---- Variable 'xms' assigned to Register 'R6/R7' ----
   12:     UINT8 i, j;
000807         ?C0004?SYS_DELAY:
   13: 	while(xms--)
000807 EF                MOV      A,R7
000808 1F                DEC      R7
000809 AC06              MOV      R4,AR6
00080B 7001              JNZ      ?C0013?SYS_DELAY
00080D 1E                DEC      R6
00080E         ?C0013?SYS_DELAY:
00080E 4C                ORL      A,R4
00080F 600D              JZ       ?C0011?SYS_DELAY
   14:     {
   15:     	WDT_CONTR |= 0x35;
000811 43C135            ORL      WDT_CONTR,#035H
   16:         i = 22;
;---- Variable 'i' assigned to Register 'R5' ----
000814 7D16              MOV      R5,#016H
   17:         j = 128;
;---- Variable 'j' assigned to Register 'R4' ----
000816 7C80              MOV      R4,#080H
   18:         do
   19:         {
000818         ?C0009?SYS_DELAY:
   20:             while (--j);
000818 DCFE              DJNZ     R4,?C0009?SYS_DELAY
00081A         ?C0010?SYS_DELAY:
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 19


   21:         } while (--i);
00081A         ?C0006?SYS_DELAY:
00081A DDFC              DJNZ     R5,?C0009?SYS_DELAY
   22:     }
00081C 80E9              SJMP     ?C0004?SYS_DELAY
   22: }
00081E         ?C0011?SYS_DELAY:
00081E 22                RET      
----- FUNCTION _sys_delayms (END) -------


----- FUNCTION app_Show (BEGIN) -----
 FILE: 'App\app_brush.c'
   18: void app_Show(void)
   19: {
   20:     sys_delayms(500);
   21:     led_ShowNumber(s_System.Money/100, s_System.Money%100, 1<<3);
00081F 1103              ACALL    ?L?COM0039
   22:     gLedBuf[0] = 12;
000821 F1DD              ACALL    ?L?COM0047
000823 51B9              ACALL    ?L?COM000E
000825 C006              PUSH     AR6
000827 C007              PUSH     AR7
000829 5199              ACALL    ?L?COM002A
00082B 1201A8            LCALL    ?C?UIDIV
00082E D007              POP      AR7
000830 D006              POP      AR6
000832 7B08              MOV      R3,#08H
000834 5129              ACALL    _led_ShowNumber
   23:     gLedBuf[1] = 12;
000836 1217F7            LCALL    ?L?COM003E
   24:     gLedBuf[2] = 12;
   25:     sys_delayms(500);
000839 1103              ACALL    ?L?COM0039
   26:     led_ShowNumber(MoneySum/100/100, MoneySum/100%100, 0);
00083B F182              ACALL    ?L?COM000F
00083D 120299            LCALL    ?C?ULDIV
000840 C006              PUSH     AR6
000842 C007              PUSH     AR7
000844 F182              ACALL    ?L?COM000F
000846 120299            LCALL    ?C?ULDIV
000849 AF03              MOV      R7,AR3
00084B AD07              MOV      R5,AR7
00084D D007              POP      AR7
00084F D006              POP      AR6
000851 E4                CLR      A
000852 FB                MOV      R3,A
000853 5129              ACALL    _led_ShowNumber
   27:     sys_delayms(500);
000855 1103              ACALL    ?L?COM0039
;----                  JMP      Led_ShowZero
   28:     Led_ShowZero();
----- FUNCTION app_Show (END) -------


----- FUNCTION Led_ShowZero (BEGIN) -----
 FILE: 'Driver\LED.c'
  114: void Led_ShowZero(void)
  115: {
  116:     gLedBuf[0] = 12;
  117:     gLedBuf[1] = 12;
000857 1217F7            LCALL    ?L?COM003E
  118:     gLedBuf[2] = 12;
  119:     gLedBuf[3] = 12;
00085A A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 20


00085B F0                MOVX     @DPTR,A
  120:     gLedBuf[4] = 12;
00085C A3                INC      DPTR
00085D F0                MOVX     @DPTR,A
  121:     gLedBuf[5] = 0;
00085E E4                CLR      A
00085F A3                INC      DPTR
000860 F0                MOVX     @DPTR,A
  122:     gShowDot = 0;
000861 9000C2            MOV      DPTR,#gShowDot
000864 F0                MOVX     @DPTR,A
  123: }
000865 22                RET      
----- FUNCTION Led_ShowZero (END) -------


----- FUNCTION app_brushCycle1s (BEGIN) -----
 FILE: 'App\app_brush.c'
  106: void app_brushCycle1s(void)
  107: {
  108:     switch (app_brushCard())
  109:     {
000866 1215FD            LCALL    app_brushCard
000869 EF                MOV      A,R7
00086A 24FE              ADD      A,#0FEH
00086C 7002              JNZ      $ + 4H
00086E 215A              AJMP     ?C0034?APP_BRUSH
000870 14                DEC      A
000871 7002              JNZ      $ + 4H
000873 2117              AJMP     ?C0032?APP_BRUSH
000875 2402              ADD      A,#02H
000877 6002              JZ       $ + 4H
000879 411B              AJMP     ?C0022?APP_BRUSH
  110:         case MEM_CARD:
  111:             if(hwa_mifareReadBlock(gBuff,4))
00087B         ?C0023?APP_BRUSH:
  112:             {
00087B 120692            LCALL    ?L?COM000C
00087E 7D04              MOV      R5,#04H
000880 F1A0              ACALL    _hwa_mifareReadBlock
000882 4002              JC       $ + 4H
000884 411B              AJMP     ?C0022?APP_BRUSH
  113:                 if(u8_FirstBrushCardDly)
  114:                 {
000886 9000CB            MOV      DPTR,#u8_FirstBrushCardDly
000889 E0                MOVX     A,@DPTR
00088A 6066              JZ       ?C0025?APP_BRUSH
  115:                     if(gBuff[0]==0x01 && gBuff[1]==0x0A)
  116:                     {
00088C 9000AB            MOV      DPTR,#gBuff
00088F E0                MOVX     A,@DPTR
000890 FF                MOV      R7,A
000891 B40128            CJNE     A,#01H,?C0026?APP_BRUSH
000894 A3                INC      DPTR
000895 E0                MOVX     A,@DPTR
000896 B40A23            CJNE     A,#0AH,?C0026?APP_BRUSH
  117:                         s_System.Money += 10;
  118: 						if (s_System.Money > 500)
000899 9000A5            MOV      DPTR,#s_System+011H
00089C E0                MOVX     A,@DPTR
00089D 240A              ADD      A,#0AH
00089F F0                MOVX     @DPTR,A
0008A0 9000A4            MOV      DPTR,#s_System+010H
0008A3 E0                MOVX     A,@DPTR
0008A4 3400              ADDC     A,#00H
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 21


0008A6 F0                MOVX     @DPTR,A
  119: 						{
0008A7 D3                SETB     C
0008A8 A3                INC      DPTR
0008A9 E0                MOVX     A,@DPTR
0008AA 94F4              SUBB     A,#0F4H
0008AC 9000A4            MOV      DPTR,#s_System+010H
0008AF E0                MOVX     A,@DPTR
0008B0 9401              SUBB     A,#01H
0008B2 403A              JC       ?C0028?APP_BRUSH
  120: 							s_System.Money = 10;
  121: 						}
0008B4 E4                CLR      A
0008B5 F0                MOVX     @DPTR,A
0008B6 A3                INC      DPTR
0008B7 740A              MOV      A,#0AH
0008B9 F0                MOVX     @DPTR,A
  122:                     }
  123:                     else if(gBuff[0]==0xFA && gBuff[1]==0x01)
0008BA 8032              SJMP     ?C0028?APP_BRUSH
0008BC         ?C0026?APP_BRUSH:
  124:                     {
0008BC EF                MOV      A,R7
0008BD B4FA2E            CJNE     A,#0FAH,?C0028?APP_BRUSH
0008C0 9000AC            MOV      DPTR,#gBuff+01H
0008C3 E0                MOVX     A,@DPTR
0008C4 B40127            CJNE     A,#01H,?C0028?APP_BRUSH
  125: 						if(s_System.Money > 10)
  126: 						{
0008C7 D3                SETB     C
0008C8 9000A5            MOV      DPTR,#s_System+011H
0008CB E0                MOVX     A,@DPTR
0008CC 940A              SUBB     A,#0AH
0008CE 9000A4            MOV      DPTR,#s_System+010H
0008D1 E0                MOVX     A,@DPTR
0008D2 9400              SUBB     A,#00H
0008D4 400E              JC       ?C0030?APP_BRUSH
  127:                         	s_System.Money -= 10;
  128: 						}
0008D6 A3                INC      DPTR
0008D7 E0                MOVX     A,@DPTR
0008D8 24F6              ADD      A,#0F6H
0008DA F0                MOVX     @DPTR,A
0008DB 9000A4            MOV      DPTR,#s_System+010H
0008DE E0                MOVX     A,@DPTR
0008DF 34FF              ADDC     A,#0FFH
0008E1 F0                MOVX     @DPTR,A
  129:                         else
0008E2 800A              SJMP     ?C0028?APP_BRUSH
0008E4         ?C0030?APP_BRUSH:
  130:                         {
  131:                             s_System.Money = 500;
0008E4 9000A4            MOV      DPTR,#s_System+010H
0008E7 7401              MOV      A,#01H
0008E9 F0                MOVX     @DPTR,A
0008EA A3                INC      DPTR
0008EB 74F4              MOV      A,#0F4H
0008ED F0                MOVX     @DPTR,A
  132:                         }
  133:                     }
0008EE         ?C0028?APP_BRUSH:
  134:                     app_configWrite(SYSTEM_SETTING_SECTOR);
0008EE E4                CLR      A
0008EF FF                MOV      R7,A
0008F0 51C3              ACALL    _app_configWrite
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 22


  135:                 }
0008F2         ?C0025?APP_BRUSH:
  136:                 u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
0008F2 9000CB            MOV      DPTR,#u8_FirstBrushCardDly
0008F5 7403              MOV      A,#03H
0008F7 F0                MOVX     @DPTR,A
  137:                 buzzer_SoundNumber(1);
0008F8 7F01              MOV      R7,#01H
0008FA 719F              ACALL    _buzzer_SoundNumber
  138:                 led_ShowNumber(s_System.Money/100, s_System.Money%100, 1<<3);
0008FC F1DD              ACALL    ?L?COM0047
0008FE 51B9              ACALL    ?L?COM000E
000900 C006              PUSH     AR6
000902 C007              PUSH     AR7
000904 5199              ACALL    ?L?COM002A
000906 1201A8            LCALL    ?C?UIDIV
000909 D007              POP      AR7
00090B D006              POP      AR6
00090D 7B08              MOV      R3,#08H
00090F 5129              ACALL    _led_ShowNumber
  139:                 sys_delayms(1000);
000911 7FE8              MOV      R7,#0E8H
000913 7E03              MOV      R6,#03H
  140:             }
  141:             break;
000915 4113              AJMP     ?C0048?APP_BRUSH
  142:             
  143:         case PWD_CARD:                                 //从初始卡中读取管理卡密码，并储存至E2
000917         ?C0032?APP_BRUSH:
  144:             if(hwa_mifareReadBlock(gBuff,4))       //读取管理卡密码
000917 120692            LCALL    ?L?COM000C
00091A 7D04              MOV      R5,#04H
00091C F1A0              ACALL    _hwa_mifareReadBlock
00091E 4002              JC       $ + 4H
000920 411B              AJMP     ?C0022?APP_BRUSH
  145:             {
  146:                 memcpy(&s_System, gBuff, 16);
000922 7894              MOV      R0,#LOW s_System
000924 7C00              MOV      R4,#HIGH s_System
000926 7D01              MOV      R5,#01H
000928 120692            LCALL    ?L?COM000C
00092B 1214F8            LCALL    ?L?COM0037
  147:                 app_configWrite(SYSTEM_SETTING_SECTOR);
00092E E4                CLR      A
00092F FF                MOV      R7,A
000930 51C3              ACALL    _app_configWrite
  148:                 Led_ShowZero();
000932 1157              ACALL    Led_ShowZero
  149:                 gLedBuf[0] = s_System.Sector/10;
000934 90009A            MOV      DPTR,#s_System+06H
000937 E0                MOVX     A,@DPTR
000938 FF                MOV      R7,A
000939 75F00A            MOV      B,#0AH
00093C 84                DIV      AB
00093D 9000BB            MOV      DPTR,#gLedBuf
000940 51A2              ACALL    ?L?COM0022
  150:                 gLedBuf[1] = s_System.Sector%10;
  151:                 gLedBuf[4] = s_System.PulseWidth/10;
000942 90009B            MOV      DPTR,#s_System+07H
000945 E0                MOVX     A,@DPTR
000946 FF                MOV      R7,A
000947 75F00A            MOV      B,#0AH
00094A 84                DIV      AB
00094B 9000BF            MOV      DPTR,#gLedBuf+04H
00094E 51A2              ACALL    ?L?COM0022
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 23


  152:                 gLedBuf[5] = s_System.PulseWidth%10;
  153:                 sys_delayms(1000);
000950 7FE8              MOV      R7,#0E8H
000952 7E03              MOV      R6,#03H
000954 1107              ACALL    _sys_delayms
  154:                 b_FactorySystem = FALSE;
000956 C207              CLR      b_FactorySystem
  155:             }
  156:             break;
000958 411B              AJMP     ?C0022?APP_BRUSH
  157:             
  158:         case USER_CARD:
00095A         ?C0034?APP_BRUSH:
  159: //                memset(gBuff, 0x00, sizeof(gBuff));
  160: //                pMoney->money = 20000;										//充钱
  161: //                if (hwa_mifareWriteSector(gBuff, s_System.Sector))
  162: //                {
  163: //                    drv_buzzerNumber(1);
  164: //                }
  165: //                break;
  166:             if(hwa_mifareReadSector(gBuff, s_System.Sector))
00095A 120692            LCALL    ?L?COM000C
00095D 90009A            MOV      DPTR,#s_System+06H
000960 E0                MOVX     A,@DPTR
000961 FD                MOV      R5,A
000962 12126E            LCALL    _hwa_mifareReadSector
000965 4002              JC       $ + 4H
000967 411B              AJMP     ?C0022?APP_BRUSH
  167:             {
  168:                 if (pMoney->money >= s_System.Money)//确保余额充足
000969 AB08              MOV      R3,pMoney
00096B AA09              MOV      R2,pMoney+01H
00096D A90A              MOV      R1,pMoney+02H
00096F 120213            LCALL    ?C?ILDPTR
000972 FF                MOV      R7,A
000973 AEF0              MOV      R6,B
000975 9000A4            MOV      DPTR,#s_System+010H
000978 121537            LCALL    ?L?COM0046
00097B 9E                SUBB     A,R6
00097C 4002              JC       $ + 4H
00097E 4117              AJMP     ?C0036?APP_BRUSH
  169:                 {
  170:                     pMoney->money -= s_System.Money;
000980 C3                CLR      C
000981 EF                MOV      A,R7
000982 9D                SUBB     A,R5
000983 FF                MOV      R7,A
000984 EE                MOV      A,R6
000985 9C                SUBB     A,R4
000986 8FF0              MOV      B,R7
000988 12023E            LCALL    ?C?ISTPTR
  171:                     if(hwa_mifareWriteSector(gBuff, s_System.Sector))
00098B 120692            LCALL    ?L?COM000C
00098E 90009A            MOV      DPTR,#s_System+06H
000991 E0                MOVX     A,@DPTR
000992 FD                MOV      R5,A
000993 12139F            LCALL    _hwa_mifareWriteSector
000996 4002              JC       $ + 4H
000998 411B              AJMP     ?C0022?APP_BRUSH
  172:                     {
  173:                     	led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
00099A 51AD              ACALL    ?L?COM000D
00099C C006              PUSH     AR6
00099E C007              PUSH     AR7
0009A0 5199              ACALL    ?L?COM002A
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 24


0009A2 1201A8            LCALL    ?C?UIDIV
0009A5 D007              POP      AR7
0009A7 D006              POP      AR6
0009A9 7B08              MOV      R3,#08H
0009AB 5129              ACALL    _led_ShowNumber
  174:                         MoneySum += s_System.Money;
0009AD 900090            MOV      DPTR,#MoneySum
0009B0 E0                MOVX     A,@DPTR
0009B1 F8                MOV      R0,A
0009B2 A3                INC      DPTR
0009B3 E0                MOVX     A,@DPTR
0009B4 F9                MOV      R1,A
0009B5 A3                INC      DPTR
0009B6 E0                MOVX     A,@DPTR
0009B7 FA                MOV      R2,A
0009B8 A3                INC      DPTR
0009B9 E0                MOVX     A,@DPTR
0009BA FB                MOV      R3,A
0009BB 9000A4            MOV      DPTR,#s_System+010H
0009BE E0                MOVX     A,@DPTR
0009BF FE                MOV      R6,A
0009C0 A3                INC      DPTR
0009C1 E0                MOVX     A,@DPTR
0009C2 FF                MOV      R7,A
0009C3 E4                CLR      A
0009C4 FC                MOV      R4,A
0009C5 FD                MOV      R5,A
0009C6 EB                MOV      A,R3
0009C7 2F                ADD      A,R7
0009C8 FF                MOV      R7,A
0009C9 EA                MOV      A,R2
0009CA 3E                ADDC     A,R6
0009CB FE                MOV      R6,A
0009CC ED                MOV      A,R5
0009CD 39                ADDC     A,R1
0009CE FD                MOV      R5,A
0009CF EC                MOV      A,R4
0009D0 38                ADDC     A,R0
0009D1 FC                MOV      R4,A
0009D2 900090            MOV      DPTR,#MoneySum
0009D5 120341            LCALL    ?C?LSTXDATA
  175:     					app_configWrite(MONEY_SECTOR);
0009D8 7F01              MOV      R7,#01H
0009DA 51C3              ACALL    _app_configWrite
  176:                         
  177:                         if(s_System.Money != 100)
0009DC 9000A4            MOV      DPTR,#s_System+010H
0009DF E0                MOVX     A,@DPTR
0009E0 7004              JNZ      ?C0045?APP_BRUSH
0009E2 A3                INC      DPTR
0009E3 E0                MOVX     A,@DPTR
0009E4 6464              XRL      A,#064H
0009E6         ?C0045?APP_BRUSH:
0009E6 90009B            MOV      DPTR,#s_System+07H
0009E9 6006              JZ       ?C0038?APP_BRUSH
  178:                         {
  179:                             app_pulseSendPulse(s_System.PulseWidth, 9);     //充电站->1,洗衣机->9
0009EB E0                MOVX     A,@DPTR
0009EC FF                MOV      R7,A
0009ED 7D09              MOV      R5,#09H
  180:                         }
0009EF 8004              SJMP     ?C0049?APP_BRUSH
0009F1         ?C0038?APP_BRUSH:
  181:                         else
  182:                         {
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 25


  183:                             app_pulseSendPulse(s_System.PulseWidth, 1);
0009F1 E0                MOVX     A,@DPTR
0009F2 FF                MOV      R7,A
0009F3 7D01              MOV      R5,#01H
0009F5         
0009F5 12170E            LCALL    _app_pulseSendPulse
  184:                         }
0009F8         ?C0039?APP_BRUSH:
  185:                         buzzer_SoundNumber(1);
0009F8 7F01              MOV      R7,#01H
0009FA 719F              ACALL    _buzzer_SoundNumber
  186:                         led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
0009FC 51AD              ACALL    ?L?COM000D
0009FE C006              PUSH     AR6
000A00 C007              PUSH     AR7
000A02 5199              ACALL    ?L?COM002A
000A04 1201A8            LCALL    ?C?UIDIV
000A07 D007              POP      AR7
000A09 D006              POP      AR6
000A0B 7B08              MOV      R3,#08H
000A0D 5129              ACALL    _led_ShowNumber
  187:                         sys_delayms(3000);
000A0F 7FB8              MOV      R7,#0B8H
000A11 7E0B              MOV      R6,#0BH
000A13         
000A13 1107              ACALL    _sys_delayms
  188:                         break;
000A15 8004              SJMP     ?C0022?APP_BRUSH
  189:                     }
  190:                 }
000A17         ?C0036?APP_BRUSH:
  191:                 else
  192:                 {
  193:                     buzzer_SoundNumber(3);
000A17 7F03              MOV      R7,#03H
000A19 719F              ACALL    _buzzer_SoundNumber
  194:                 }
  195:             }
  196:             break;
  197:             
  198:         default:
  199:             break;
  200:     }
000A1B         ?C0022?APP_BRUSH:
  201:     
  202:     if(u8_FirstBrushCardDly)
000A1B 9000CB            MOV      DPTR,#u8_FirstBrushCardDly
000A1E E0                MOVX     A,@DPTR
000A1F 6002              JZ       ?C0042?APP_BRUSH
  203:     {
  204:         u8_FirstBrushCardDly--;
000A21 14                DEC      A
000A22 F0                MOVX     @DPTR,A
  205:     }
000A23         ?C0042?APP_BRUSH:
  206:     if(!b_FactorySystem)
000A23 200702            JB       b_FactorySystem,?C0044?APP_BRUSH
  207:     {
  208:         Led_ShowZero();
000A26 1157              ACALL    Led_ShowZero
  209:     }
  210: }
000A28         ?C0044?APP_BRUSH:
000A28 22                RET      
----- FUNCTION app_brushCycle1s (END) -------
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 26




----- FUNCTION _led_ShowNumber (BEGIN) -----
 FILE: 'Driver\LED.c'
   95: void led_ShowNumber(UINT16 L_num, UINT8 R_num, UINT8 DotPlace)
   96: {
000A29 900040            MOV      DPTR,#L_num
000A2C EE                MOV      A,R6
000A2D F0                MOVX     @DPTR,A
000A2E A3                INC      DPTR
000A2F EF                MOV      A,R7
000A30 F0                MOVX     @DPTR,A
;---- Variable 'R_num' assigned to Register 'R2' ----
000A31 AA05              MOV      R2,AR5
;---- Variable 'DotPlace' assigned to Register 'R3' ----
   97:     if(L_num>9999)
   98:     {
000A33 D3                SETB     C
000A34 E0                MOVX     A,@DPTR
000A35 940F              SUBB     A,#0FH
000A37 900040            MOV      DPTR,#L_num
000A3A E0                MOVX     A,@DPTR
000A3B 9427              SUBB     A,#027H
000A3D 4007              JC       ?C0034?LED
   99:         L_num = 9999;
  100:     }
000A3F 7427              MOV      A,#027H
000A41 F0                MOVX     @DPTR,A
000A42 A3                INC      DPTR
000A43 740F              MOV      A,#0FH
000A45 F0                MOVX     @DPTR,A
  101:     if(R_num>99)
000A46         ?C0034?LED:
  102:     {
000A46 EA                MOV      A,R2
000A47 D3                SETB     C
000A48 9463              SUBB     A,#063H
000A4A 4002              JC       ?C0035?LED
  103:         R_num = 99;
  104:     }
000A4C 7A63              MOV      R2,#063H
  105:     gLedBuf[0] = L_num/1000;
000A4E         ?C0035?LED:
  106:     gLedBuf[1] = L_num/100%10;
000A4E 71A5              ACALL    ?L?COM0043
000A50 7C03              MOV      R4,#03H
000A52 7DE8              MOV      R5,#0E8H
000A54 1201A8            LCALL    ?C?UIDIV
000A57 9000BB            MOV      DPTR,#gLedBuf
000A5A EF                MOV      A,R7
000A5B F0                MOVX     @DPTR,A
  107:     gLedBuf[2] = L_num/10%10;
000A5C 71A5              ACALL    ?L?COM0043
000A5E 7C00              MOV      R4,#00H
000A60 7D64              MOV      R5,#064H
000A62 1201A8            LCALL    ?C?UIDIV
000A65 5192              ACALL    ?L?COM001F
000A67 9000BC            MOV      DPTR,#gLedBuf+01H
000A6A 5188              ACALL    ?L?COM001E
000A6C 5192              ACALL    ?L?COM001F
000A6E 9000BD            MOV      DPTR,#gLedBuf+02H
000A71 5188              ACALL    ?L?COM001E
000A73 9000BE            MOV      DPTR,#gLedBuf+03H
000A76 ED                MOV      A,R5
000A77 F0                MOVX     @DPTR,A
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 27


  108:     gLedBuf[3] = L_num%10;
  109:     gLedBuf[4] = R_num/10%10;
000A78 EA                MOV      A,R2
000A79 75F00A            MOV      B,#0AH
000A7C 84                DIV      AB
000A7D 51A4              ACALL    ?L?COM0023
  110:     gLedBuf[5] = R_num%10;
000A7F EA                MOV      A,R2
000A80 51A4              ACALL    ?L?COM0023
  111:     gShowDot = DotPlace;
000A82 9000C2            MOV      DPTR,#gShowDot
000A85 EB                MOV      A,R3
000A86 F0                MOVX     @DPTR,A
  112: }
000A87 22                RET      
----- FUNCTION _led_ShowNumber (END) -------


----- FUNCTION ?L?COM001E (BEGIN) -----
000A88 ED                MOV      A,R5
000A89 F0                MOVX     @DPTR,A
000A8A 900040            MOV      DPTR,#L_num
000A8D E0                MOVX     A,@DPTR
000A8E FE                MOV      R6,A
000A8F A3                INC      DPTR
000A90 E0                MOVX     A,@DPTR
000A91 FF                MOV      R7,A
000A92         ?L?COM001F:
000A92 7C00              MOV      R4,#00H
000A94 7D0A              MOV      R5,#0AH
000A96 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM001E (END) -------


----- FUNCTION ?L?COM002A (BEGIN) -----
000A99 7C00              MOV      R4,#00H
000A9B 7D64              MOV      R5,#064H
000A9D AF03              MOV      R7,AR3
000A9F AE02              MOV      R6,AR2
000AA1 22                RET      
----- FUNCTION ?L?COM002A (END) -------


----- FUNCTION ?L?COM0022 (BEGIN) -----
000AA2 F0                MOVX     @DPTR,A
000AA3 EF                MOV      A,R7
000AA4         ?L?COM0023:
000AA4 75F00A            MOV      B,#0AH
000AA7 84                DIV      AB
000AA8 A3                INC      DPTR
000AA9 E5F0              MOV      A,B
000AAB F0                MOVX     @DPTR,A
000AAC 22                RET      
----- FUNCTION ?L?COM0022 (END) -------


----- FUNCTION ?L?COM000D (BEGIN) -----
000AAD AB08              MOV      R3,pMoney
000AAF AA09              MOV      R2,pMoney+01H
000AB1 A90A              MOV      R1,pMoney+02H
000AB3 120213            LCALL    ?C?ILDPTR
000AB6 FB                MOV      R3,A
000AB7 AAF0              MOV      R2,B
000AB9         ?L?COM000E:
000AB9 7C00              MOV      R4,#00H
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 28


000ABB 7D64              MOV      R5,#064H
000ABD FF                MOV      R7,A
000ABE AE02              MOV      R6,AR2
000AC0 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM000D (END) -------


----- FUNCTION _app_configWrite (BEGIN) -----
 FILE: 'App\app_config.c'
  101: void app_configWrite(UINT8 Sector)
  102: {
000AC3 900040            MOV      DPTR,#Sector
000AC6 EF                MOV      A,R7
000AC7 F0                MOVX     @DPTR,A
  103:     led_Switch(OFF);
  104:     if(Sector == SYSTEM_SETTING_SECTOR)
000AC8 C201              CLR      ?led_Switch?BIT
000ACA 51E5              ACALL    led_Switch
  105:     {
000ACC 900040            MOV      DPTR,#Sector
000ACF E0                MOVX     A,@DPTR
000AD0 7B01              MOV      R3,#01H
000AD2 7007              JNZ      ?C0013?APP_CONFIG
  106:         hwa_eepromWriteSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
  107:     }
000AD4 7A00              MOV      R2,#HIGH s_System
000AD6 7994              MOV      R1,#LOW s_System
000AD8 FD                MOV      R5,A
  108:     else
000AD9 8006              SJMP     ?C0018?APP_CONFIG
000ADB         ?C0013?APP_CONFIG:
  109:     {
  110:         hwa_eepromWriteSector((UINT8*)&MoneySum, MONEY_SECTOR);
000ADB 7A00              MOV      R2,#HIGH MoneySum
000ADD 7990              MOV      R1,#LOW MoneySum
000ADF 7D01              MOV      R5,#01H
000AE1         
000AE1 B10C              ACALL    _hwa_eepromWriteSector
  111:     }
000AE3         ?C0014?APP_CONFIG:
  112:     led_Switch(ON);
000AE3 D201              SETB     ?led_Switch?BIT
;----                  JMP      led_Switch
----- FUNCTION _app_configWrite (END) -------


----- FUNCTION led_Switch (BEGIN) -----
 FILE: 'Driver\LED.c'
  125: void led_Switch(bit sw)
  126: {
  127:     ledsw = sw;
  128:     if(ledsw==0)
000AE5 A201              MOV      C,sw
000AE7 9208              MOV      ledsw,C
  129:     {
000AE9 200805            JB       ledsw,?C0039?LED
  130:     	LED_CS0 = 1;
  131:     	LED_CS1 = 1;
000AEC 121540            LCALL    ?L?COM003D
  132:     	LED_CS2 = 1;
  133:     	LED_CS3 = 1;
  134:     	LED_CS4 = 1;
  135:     	LED_CS5 = 1;
000AEF D2B6              SETB     LED_CS5
  136:     }
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 29


  137: }
000AF1         ?C0039?LED:
000AF1 22                RET      
----- FUNCTION led_Switch (END) -------


----- FUNCTION app_configInit (BEGIN) -----
 FILE: 'App\app_config.c'
   44: void app_configInit(void)
   45: {
   46:     BOOL state = FALSE;
   47:     led_Switch(OFF);
000AF2 C200              CLR      state
   48:     hwa_eepromInit();
000AF4 C201              CLR      ?led_Switch?BIT
000AF6 51E5              ACALL    led_Switch
   49:     if(app_configRead(SYSTEM_SETTING_SECTOR) == FALSE)
000AF8 121717            LCALL    hwa_eepromInit
   50:     {
000AFB E4                CLR      A
000AFC FF                MOV      R7,A
000AFD 71AE              ACALL    _app_configRead
000AFF 4021              JC       ?C0001?APP_CONFIG
   51:         memcpy(&s_System, &s_FactorySystem, sizeof(s_System));
   52:         b_FactorySystem = TRUE;
000B01 7894              MOV      R0,#LOW s_System
000B03 7C00              MOV      R4,#HIGH s_System
000B05 7D01              MOV      R5,#01H
000B07 7BFF              MOV      R3,#0FFH
000B09 7A00              MOV      R2,#HIGH s_FactorySystem
000B0B 790E              MOV      R1,#LOW s_FactorySystem
000B0D 7E00              MOV      R6,#00H
000B0F 7F12              MOV      R7,#012H
000B11 1200F6            LCALL    ?C?COPY
   53:         led_ShowNumber(8888,88,0xFF);
000B14 D207              SETB     b_FactorySystem
   54:     }
000B16 7BFF              MOV      R3,#0FFH
000B18 7D58              MOV      R5,#058H
000B1A 7FB8              MOV      R7,#0B8H
000B1C 7E22              MOV      R6,#022H
000B1E 5129              ACALL    _led_ShowNumber
   55:     else
000B20 8060              SJMP     ?C0002?APP_CONFIG
000B22         ?C0001?APP_CONFIG:
   56:     {
   57:         if(s_System.Sector > 16 || s_System.Sector < 1)                 //钱包分区不在1~16
000B22 90009A            MOV      DPTR,#s_System+06H
000B25 E0                MOVX     A,@DPTR
000B26 FF                MOV      R7,A
000B27 D3                SETB     C
000B28 9410              SUBB     A,#010H
000B2A 5006              JNC      ?C0004?APP_CONFIG
000B2C EF                MOV      A,R7
000B2D C3                CLR      C
000B2E 9401              SUBB     A,#01H
000B30 500B              JNC      ?C0003?APP_CONFIG
000B32         ?C0004?APP_CONFIG:
   58:         {
   59:             s_System.Sector = s_FactorySystem.Sector;
000B32 900014            MOV      DPTR,#s_FactorySystem+06H
000B35 E4                CLR      A
000B36 93                MOVC     A,@A+DPTR
000B37 90009A            MOV      DPTR,#s_System+06H
000B3A F0                MOVX     @DPTR,A
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 30


   60:             state = TRUE;
000B3B D200              SETB     state
   61:         }
000B3D         ?C0003?APP_CONFIG:
   62:         if(s_System.PulseWidth<10 && s_System.PulseWidth>60)
000B3D 90009B            MOV      DPTR,#s_System+07H
000B40 E0                MOVX     A,@DPTR
000B41 FF                MOV      R7,A
000B42 C3                CLR      C
000B43 940A              SUBB     A,#0AH
000B45 5010              JNC      ?C0005?APP_CONFIG
000B47 EF                MOV      A,R7
000B48 943C              SUBB     A,#03CH
000B4A 400B              JC       ?C0005?APP_CONFIG
   63:         {
   64:             s_System.PulseWidth = s_FactorySystem.PulseWidth;
000B4C 900015            MOV      DPTR,#s_FactorySystem+07H
000B4F E4                CLR      A
000B50 93                MOVC     A,@A+DPTR
000B51 90009B            MOV      DPTR,#s_System+07H
000B54 F0                MOVX     @DPTR,A
   65:             state = TRUE;
000B55 D200              SETB     state
   66:         }
000B57         ?C0005?APP_CONFIG:
   67:         if(s_System.Money > 200)                                        //金额整数部分大于10
000B57 D3                SETB     C
000B58 9000A5            MOV      DPTR,#s_System+011H
000B5B E0                MOVX     A,@DPTR
000B5C 94C8              SUBB     A,#0C8H
000B5E 9000A4            MOV      DPTR,#s_System+010H
000B61 E0                MOVX     A,@DPTR
000B62 9400              SUBB     A,#00H
000B64 4013              JC       ?C0006?APP_CONFIG
   68:         {
   69:             s_System.Money = s_FactorySystem.Money;
000B66 90001E            MOV      DPTR,#s_FactorySystem+010H
000B69 E4                CLR      A
000B6A 93                MOVC     A,@A+DPTR
000B6B FF                MOV      R7,A
000B6C 7401              MOV      A,#01H
000B6E 93                MOVC     A,@A+DPTR
000B6F 9000A4            MOV      DPTR,#s_System+010H
000B72 CF                XCH      A,R7
000B73 F0                MOVX     @DPTR,A
000B74 A3                INC      DPTR
000B75 EF                MOV      A,R7
000B76 F0                MOVX     @DPTR,A
   70:             state = TRUE;
000B77 D200              SETB     state
   71:         }
000B79         ?C0006?APP_CONFIG:
   72:         if(state)
000B79 300006            JNB      state,?C0002?APP_CONFIG
   73:         {
   74: 			app_configWrite(SYSTEM_SETTING_SECTOR);
000B7C E4                CLR      A
000B7D FF                MOV      R7,A
000B7E 51C3              ACALL    _app_configWrite
   75:             b_FactorySystem = TRUE;
000B80 D207              SETB     b_FactorySystem
   76:         }
   77:     }
000B82         ?C0002?APP_CONFIG:
   78:     
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 31


   79:     if(app_configRead(MONEY_SECTOR) == FALSE)
000B82 7F01              MOV      R7,#01H
000B84 71AE              ACALL    _app_configRead
000B86 4013              JC       ?C0008?APP_CONFIG
   80:     {
   81:         memset(&MoneySum, 0x00, sizeof(MoneySum));
000B88 7E00              MOV      R6,#00H
000B8A 7F04              MOV      R7,#04H
000B8C 7D00              MOV      R5,#00H
000B8E 7B01              MOV      R3,#01H
000B90 7A00              MOV      R2,#HIGH MoneySum
000B92 7990              MOV      R1,#LOW MoneySum
000B94 12034D            LCALL    ?C?MEMSET
   82: 		app_configWrite(MONEY_SECTOR);
000B97 7F01              MOV      R7,#01H
000B99 51C3              ACALL    _app_configWrite
   83:     }
000B9B         ?C0008?APP_CONFIG:
   84:     led_Switch(ON);
000B9B D201              SETB     ?led_Switch?BIT
000B9D 41E5              AJMP     led_Switch
----- FUNCTION app_configInit (END) -------


----- FUNCTION _buzzer_SoundNumber (BEGIN) -----
 FILE: 'Driver\buzzer.c'
   28: void buzzer_SoundNumber(UINT8 num)
   29: {
;---- Variable 'num' assigned to Register 'R7' ----
   30:     SoundNumberCount = num;
   30: }
000B9F 9000CD            MOV      DPTR,#SoundNumberCount
000BA2 EF                MOV      A,R7
000BA3 F0                MOVX     @DPTR,A
   30: 
000BA4 22                RET      
----- FUNCTION _buzzer_SoundNumber (END) -------


----- FUNCTION ?L?COM0043 (BEGIN) -----
000BA5 900040            MOV      DPTR,#L_num
000BA8 E0                MOVX     A,@DPTR
000BA9 FE                MOV      R6,A
000BAA A3                INC      DPTR
000BAB E0                MOVX     A,@DPTR
000BAC FF                MOV      R7,A
000BAD 22                RET      
----- FUNCTION ?L?COM0043 (END) -------


----- FUNCTION _app_configRead (BEGIN) -----
 FILE: 'App\app_config.c'
   87: BOOL app_configRead(UINT8 Sector)
   88: {
;---- Variable 'Sector' assigned to Register 'R7' ----
   89:     BOOL state;
   90:     if(Sector == SYSTEM_SETTING_SECTOR)
000BAE EF                MOV      A,R7
000BAF 7B01              MOV      R3,#01H
000BB1 7007              JNZ      ?C0010?APP_CONFIG
   91:     {
   92:         state = hwa_eepromReadSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
000BB3 7A00              MOV      R2,#HIGH s_System
000BB5 7994              MOV      R1,#LOW s_System
000BB7 FD                MOV      R5,A
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 32


   93:     }
000BB8 8006              SJMP     ?C0017?APP_CONFIG
000BBA         ?C0010?APP_CONFIG:
   94:     else
   95:     {
   96:         state = hwa_eepromReadSector((UINT8*)&MoneySum, MONEY_SECTOR);
000BBA 7A00              MOV      R2,#HIGH MoneySum
000BBC 7990              MOV      R1,#LOW MoneySum
000BBE 7D01              MOV      R5,#01H
000BC0         
000BC0 71C7              ACALL    _hwa_eepromReadSector
000BC2 9201              MOV      state,C
   97:     }
000BC4         ?C0011?APP_CONFIG:
   98:     return state;
000BC4 A201              MOV      C,state
   99: }
000BC6 22                RET      
----- FUNCTION _app_configRead (END) -------


----- FUNCTION _hwa_eepromReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   37: BOOL hwa_eepromReadSector(UINT8 *dat, UINT8 sector)
   38: {
000BC7 90004F            MOV      DPTR,#dat
000BCA D1EB              ACALL    ?L?COM0004
000BCC A3                INC      DPTR
000BCD ED                MOV      A,R5
000BCE F0                MOVX     @DPTR,A
   39: 	BOOL e2_error = FALSE, e2_bak_error = FALSE;
   40: 	UINT16 e2_addr, e2_bak_addr;
000BCF C202              CLR      e2_error
000BD1 C203              CLR      e2_bak_error
   41: 	UINT16 e2_check_sum, e2_bak_check_sum;
   42: 	UINT16 Size, SectorSize;
   43: 
   44: 	if (sector >= c_u8_eepromSectorNum)
000BD3 121802            LCALL    ?L?COM0041
000BD6 4001              JC       ?C0002?HWA_EEPROM
   45: 	{
   46: 		return FALSE;
000BD8 22                RET      
   47: 	}
000BD9         ?C0002?HWA_EEPROM:
   48: 	Size = c_s_eepromConfig[sector].UseSize;
000BD9 900052            MOV      DPTR,#sector
000BDC 1217D8            LCALL    ?L?COM0029
000BDF FC                MOV      R4,A
000BE0 7401              MOV      A,#01H
000BE2 93                MOVC     A,@A+DPTR
000BE3 FD                MOV      R5,A
000BE4 90005B            MOV      DPTR,#Size
000BE7 D10E              ACALL    ?L?COM0005
000BE9 900053            MOV      DPTR,#e2_addr
000BEC F1CD              ACALL    ?L?COM004D
000BEE D135              ACALL    ?L?COM0006
000BF0 900055            MOV      DPTR,#e2_bak_addr
000BF3 F0                MOVX     @DPTR,A
000BF4 A3                INC      DPTR
000BF5 CE                XCH      A,R6
000BF6 F0                MOVX     @DPTR,A
   49: 	SectorSize = Size + 2;
   50: 
   51: 	e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 33


   52: 	e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
   53: 
   54: 	sys_eepromRead(e2_addr, e2_data, SectorSize);
000BF7 F138              ACALL    ?L?COM0042
000BF9 91F6              ACALL    ?L?COM0013
000BFB 90005D            MOV      DPTR,#SectorSize
000BFE B1BC              ACALL    ?L?COM0008
000C00 D14D              ACALL    ?L?COM0009
000C02 6006              JZ       ?C0004?HWA_EEPROM
   55: 	if (c_s_eepromConfig[sector].Encrypt)
   56: 	{
   57: 		hwa_eepromDecrypt(e2_data, Size);
000C04 91F6              ACALL    ?L?COM0013
000C06 B103              ACALL    ?L?COM0017
000C08 D1F4              ACALL    _hwa_eepromDecrypt
   58: 	}
000C0A         ?C0004?HWA_EEPROM:
   59: 	e2_check_sum = e2_data[Size] << 8 | e2_data[Size + 1];
000C0A B103              ACALL    ?L?COM0017
000C0C 2400              ADD      A,#LOW e2_data
000C0E F582              MOV      DPL,A
000C10 7400              MOV      A,#HIGH e2_data
000C12 3C                ADDC     A,R4
000C13 F583              MOV      DPH,A
000C15 E0                MOVX     A,@DPTR
000C16 FE                MOV      R6,A
000C17 7401              MOV      A,#LOW e2_data+01H
000C19 2D                ADD      A,R5
000C1A F582              MOV      DPL,A
000C1C 7400              MOV      A,#HIGH e2_data+01H
000C1E F127              ACALL    ?L?COM004E
000C20 900057            MOV      DPTR,#e2_check_sum
000C23 EE                MOV      A,R6
000C24 F0                MOVX     @DPTR,A
000C25 A3                INC      DPTR
000C26 EF                MOV      A,R7
000C27 F0                MOVX     @DPTR,A
   60: 
   61: 	sys_eepromRead(e2_bak_addr, e2_data_bak, SectorSize);
000C28 D13E              ACALL    ?L?COM002B
000C2A 90005D            MOV      DPTR,#SectorSize
000C2D B1BC              ACALL    ?L?COM0008
000C2F D14D              ACALL    ?L?COM0009
000C31 6004              JZ       ?C0005?HWA_EEPROM
   62: 	if (c_s_eepromConfig[sector].Encrypt)
   63: 	{
   64: 		hwa_eepromDecrypt(e2_data_bak, Size);
000C33 91FD              ACALL    ?L?COM0016
000C35 D1F4              ACALL    _hwa_eepromDecrypt
   65: 	}
000C37         ?C0005?HWA_EEPROM:
   66: 	e2_bak_check_sum = e2_data_bak[Size] << 8 | e2_data_bak[Size + 1];
000C37 B103              ACALL    ?L?COM0017
000C39 2420              ADD      A,#LOW e2_data_bak
000C3B F582              MOV      DPL,A
000C3D 7400              MOV      A,#HIGH e2_data_bak
000C3F 3C                ADDC     A,R4
000C40 F583              MOV      DPH,A
000C42 E0                MOVX     A,@DPTR
000C43 FE                MOV      R6,A
000C44 7421              MOV      A,#LOW e2_data_bak+01H
000C46 2D                ADD      A,R5
000C47 F582              MOV      DPL,A
000C49 7400              MOV      A,#HIGH e2_data_bak+01H
000C4B F127              ACALL    ?L?COM004E
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 34


000C4D 900059            MOV      DPTR,#e2_bak_check_sum
000C50 91F1              ACALL    ?L?COM0012
000C52 A3                INC      DPTR
000C53 A3                INC      DPTR
000C54 E0                MOVX     A,@DPTR
000C55 FD                MOV      R5,A
000C56 D197              ACALL    _hwa_mifareCheckOut
000C58 900057            MOV      DPTR,#e2_check_sum
000C5B E0                MOVX     A,@DPTR
000C5C 6E                XRL      A,R6
000C5D 7003              JNZ      ?C0017?HWA_EEPROM
000C5F A3                INC      DPTR
000C60 E0                MOVX     A,@DPTR
000C61 6F                XRL      A,R7
000C62         ?C0017?HWA_EEPROM:
000C62 6002              JZ       ?C0006?HWA_EEPROM
   67: 
   68: 	if (e2_check_sum != hwa_mifareCheckOut(e2_data, Size))
   69: 	{
   70: 		e2_error = TRUE;
000C64 D202              SETB     e2_error
   71: 	}
000C66         ?C0006?HWA_EEPROM:
   72: 	if (e2_bak_check_sum != hwa_mifareCheckOut(e2_data_bak, Size))
000C66 91FD              ACALL    ?L?COM0016
000C68 D197              ACALL    _hwa_mifareCheckOut
000C6A 900059            MOV      DPTR,#e2_bak_check_sum
000C6D E0                MOVX     A,@DPTR
000C6E 6E                XRL      A,R6
000C6F 7003              JNZ      ?C0018?HWA_EEPROM
000C71 A3                INC      DPTR
000C72 E0                MOVX     A,@DPTR
000C73 6F                XRL      A,R7
000C74         ?C0018?HWA_EEPROM:
000C74 6002              JZ       ?C0007?HWA_EEPROM
   73: 	{
   74: 		e2_bak_error = TRUE;
000C76 D203              SETB     e2_bak_error
   75: 	}
000C78         ?C0007?HWA_EEPROM:
   76: 
   77: 	if (e2_error && e2_bak_error)    //~1~备份块和正常块都校验错误，返回错误
000C78 300205            JNB      e2_error,?C0008?HWA_EEPROM
000C7B 300302            JNB      e2_bak_error,?C0008?HWA_EEPROM
   78: 	{
   79: 		return FALSE;
000C7E C3                CLR      C
000C7F 22                RET      
   80: 	}
000C80         ?C0008?HWA_EEPROM:
   81: 	else if (e2_error)                                 //~2~备份块校验错误，恢复正常块
000C80 300216            JNB      e2_error,?C0010?HWA_EEPROM
   82: 	{
   83: 		memcpy(e2_data, e2_data_bak, SectorSize);
000C83 90005D            MOV      DPTR,#SectorSize
000C86 1217EB            LCALL    ?L?COM0038
000C89 D146              ACALL    ?L?COM002C
000C8B 1200F6            LCALL    ?C?COPY
   84: 		sys_eepromEraseSector(e2_addr);
000C8E 900053            MOV      DPTR,#e2_addr
000C91 B1C9              ACALL    ?L?COM0028
   85: 		sys_eepromWrite(e2_addr, e2_data, SectorSize);
000C93 F138              ACALL    ?L?COM0042
000C95 91F6              ACALL    ?L?COM0013
   86: 	}
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 35


000C97 8037              SJMP     ?C0020?HWA_EEPROM
000C99         ?C0010?HWA_EEPROM:
   87: 	else if (e2_bak_error ||                          //~3~正常块校验错误，恢复备份块
000C99 20031A            JB       e2_bak_error,?C0013?HWA_EEPROM
000C9C 200238            JB       e2_error,?C0009?HWA_EEPROM
000C9F 200335            JB       e2_bak_error,?C0009?HWA_EEPROM
000CA2 900059            MOV      DPTR,#e2_bak_check_sum
000CA5 E0                MOVX     A,@DPTR
000CA6 FE                MOV      R6,A
000CA7 A3                INC      DPTR
000CA8 E0                MOVX     A,@DPTR
000CA9 FF                MOV      R7,A
000CAA 900057            MOV      DPTR,#e2_check_sum
000CAD E0                MOVX     A,@DPTR
000CAE 6E                XRL      A,R6
000CAF 7003              JNZ      ?C0019?HWA_EEPROM
000CB1 A3                INC      DPTR
000CB2 E0                MOVX     A,@DPTR
000CB3 6F                XRL      A,R7
000CB4         ?C0019?HWA_EEPROM:
000CB4 6021              JZ       ?C0009?HWA_EEPROM
000CB6         ?C0013?HWA_EEPROM:
   88: 		(e2_error == FALSE                                //~4~正常块、备份块都检验正确，但数据不同，则以
   89: 		&& e2_bak_error == FALSE                         //   最新写入的正常块覆盖备份块
   90: 		&& e2_check_sum != e2_bak_check_sum)
   91: 		)
   92: 	{
   93: 		memcpy(e2_data_bak, e2_data, SectorSize);
000CB6 90005D            MOV      DPTR,#SectorSize
000CB9 E0                MOVX     A,@DPTR
000CBA FE                MOV      R6,A
000CBB A3                INC      DPTR
000CBC E0                MOVX     A,@DPTR
000CBD FF                MOV      R7,A
000CBE 7820              MOV      R0,#LOW e2_data_bak
000CC0 7C00              MOV      R4,#HIGH e2_data_bak
000CC2 7D01              MOV      R5,#01H
000CC4 91F6              ACALL    ?L?COM0013
000CC6 1200F6            LCALL    ?C?COPY
   94: 		sys_eepromEraseSector(e2_bak_addr);
000CC9 900055            MOV      DPTR,#e2_bak_addr
000CCC B1C9              ACALL    ?L?COM0028
   95: 		sys_eepromWrite(e2_bak_addr, e2_data_bak, SectorSize);
000CCE D13E              ACALL    ?L?COM002B
000CD0         
000CD0 90005D            MOV      DPTR,#SectorSize
000CD3 B1BC              ACALL    ?L?COM0008
000CD5 B1E7              ACALL    _sys_eepromWrite
   96: 	}
000CD7         ?C0009?HWA_EEPROM:
   97: 	memcpy(dat, e2_data, Size);
000CD7 90005B            MOV      DPTR,#Size
000CDA E0                MOVX     A,@DPTR
000CDB FE                MOV      R6,A
000CDC A3                INC      DPTR
000CDD E0                MOVX     A,@DPTR
000CDE FF                MOV      R7,A
000CDF 90004F            MOV      DPTR,#dat
000CE2 1207F0            LCALL    ?L?COM0002
000CE5 F8                MOV      R0,A
000CE6 AC02              MOV      R4,AR2
000CE8 AD03              MOV      R5,AR3
000CEA 91F6              ACALL    ?L?COM0013
000CEC 1200F6            LCALL    ?C?COPY
   98: 	return TRUE;
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 36


000CEF D3                SETB     C
   99: }
000CF0 22                RET      
----- FUNCTION _hwa_eepromReadSector (END) -------


----- FUNCTION ?L?COM0012 (BEGIN) -----
000CF1 EE                MOV      A,R6
000CF2 F0                MOVX     @DPTR,A
000CF3 A3                INC      DPTR
000CF4 EF                MOV      A,R7
000CF5 F0                MOVX     @DPTR,A
000CF6         ?L?COM0013:
000CF6 7B01              MOV      R3,#01H
000CF8 7A00              MOV      R2,#HIGH e2_data
000CFA 7900              MOV      R1,#LOW e2_data
000CFC 22                RET      
----- FUNCTION ?L?COM0012 (END) -------


----- FUNCTION ?L?COM0016 (BEGIN) -----
000CFD 7B01              MOV      R3,#01H
000CFF 7A00              MOV      R2,#HIGH e2_data_bak
000D01 7920              MOV      R1,#LOW e2_data_bak
000D03         ?L?COM0017:
000D03 90005B            MOV      DPTR,#Size
000D06 E0                MOVX     A,@DPTR
000D07 FC                MOV      R4,A
000D08 A3                INC      DPTR
000D09 E0                MOVX     A,@DPTR
000D0A FD                MOV      R5,A
000D0B 22                RET      
----- FUNCTION ?L?COM0016 (END) -------


----- FUNCTION _hwa_eepromWriteSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
  101: BOOL hwa_eepromWriteSector(UINT8 *dat, UINT8 sector)
  102: {
000D0C 900041            MOV      DPTR,#dat
000D0F D1EB              ACALL    ?L?COM0004
000D11 A3                INC      DPTR
000D12 ED                MOV      A,R5
000D13 F0                MOVX     @DPTR,A
  103: 	UINT16 e2_addr, e2_bak_addr;
  104: 	UINT16 e2_check_sum;
  105: 
  106: 	UINT16 Size, SectorSize;
  107: 
  108: 	if (sector >= c_u8_eepromSectorNum)
000D14 121802            LCALL    ?L?COM0041
000D17 4001              JC       ?C0014?HWA_EEPROM
  109: 	{
  110: 		return FALSE;
000D19 22                RET      
  111: 	}
000D1A         ?C0014?HWA_EEPROM:
  112: 	Size = c_s_eepromConfig[sector].UseSize;
000D1A 900044            MOV      DPTR,#sector
000D1D 1217D8            LCALL    ?L?COM0029
000D20 FC                MOV      R4,A
000D21 7401              MOV      A,#01H
000D23 93                MOVC     A,@A+DPTR
000D24 FD                MOV      R5,A
000D25 90004B            MOV      DPTR,#Size
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 37


000D28 D10E              ACALL    ?L?COM0005
000D2A 900045            MOV      DPTR,#e2_addr
000D2D F1CD              ACALL    ?L?COM004D
000D2F D135              ACALL    ?L?COM0006
000D31 900047            MOV      DPTR,#e2_bak_addr
000D34 F0                MOVX     @DPTR,A
000D35 A3                INC      DPTR
000D36 CE                XCH      A,R6
000D37 F0                MOVX     @DPTR,A
  113: 	SectorSize = Size + 2;
  114: 
  115: 	e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
  116: 	e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
  117: 	e2_check_sum = hwa_mifareCheckOut(dat, Size);
000D38 900041            MOV      DPTR,#dat
000D3B 1207F0            LCALL    ?L?COM0002
000D3E F9                MOV      R1,A
000D3F F141              ACALL    ?L?COM0045
000D41 D197              ACALL    _hwa_mifareCheckOut
000D43 900049            MOV      DPTR,#e2_check_sum
000D46 91F1              ACALL    ?L?COM0012
000D48 900044            MOV      DPTR,#sector
000D4B E0                MOVX     A,@DPTR
000D4C FD                MOV      R5,A
000D4D 71C7              ACALL    _hwa_eepromReadSector
  118: 
  119: 	hwa_eepromReadSector(e2_data, sector);                                  //  写入之前，如果有错误块，先恢复
  120: 
  121: 	memcpy(e2_data, dat, Size);
000D4F 90004B            MOV      DPTR,#Size
000D52 1217EB            LCALL    ?L?COM0038
000D55 900041            MOV      DPTR,#dat
000D58 1207F0            LCALL    ?L?COM0002
000D5B F9                MOV      R1,A
000D5C 1200F6            LCALL    ?C?COPY
  122: 
  123: 	if (c_s_eepromConfig[sector].Encrypt)
000D5F 900044            MOV      DPTR,#sector
000D62 D152              ACALL    ?L?COM000A
000D64 6007              JZ       ?C0016?HWA_EEPROM
  124: 	{
  125: 		hwa_eepromEncrypt(e2_data, Size);
000D66 91F6              ACALL    ?L?COM0013
000D68 F141              ACALL    ?L?COM0045
000D6A 121718            LCALL    _hwa_eepromEncrypt
  126: 	}
000D6D         ?C0016?HWA_EEPROM:
  127: 	e2_data[Size] = (UINT8)(e2_check_sum >> 8);
000D6D 900049            MOV      DPTR,#e2_check_sum
000D70 E0                MOVX     A,@DPTR
000D71 FC                MOV      R4,A
000D72 A3                INC      DPTR
000D73 E0                MOVX     A,@DPTR
000D74 FD                MOV      R5,A
000D75 EC                MOV      A,R4
000D76 FF                MOV      R7,A
000D77 A3                INC      DPTR
000D78 E0                MOVX     A,@DPTR
000D79 FA                MOV      R2,A
000D7A A3                INC      DPTR
000D7B E0                MOVX     A,@DPTR
000D7C FB                MOV      R3,A
000D7D 2400              ADD      A,#LOW e2_data
000D7F F582              MOV      DPL,A
000D81 7400              MOV      A,#HIGH e2_data
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 38


000D83 3A                ADDC     A,R2
000D84 F583              MOV      DPH,A
000D86 EF                MOV      A,R7
000D87 F0                MOVX     @DPTR,A
  128: 	e2_data[Size + 1] = (UINT8)(e2_check_sum & 0xFF);
000D88 7401              MOV      A,#LOW e2_data+01H
000D8A 2B                ADD      A,R3
000D8B F582              MOV      DPL,A
000D8D 7400              MOV      A,#HIGH e2_data+01H
000D8F 3A                ADDC     A,R2
000D90 F583              MOV      DPH,A
000D92 ED                MOV      A,R5
000D93 F0                MOVX     @DPTR,A
  129: 	sys_eepromEraseSector(e2_addr);
000D94 900045            MOV      DPTR,#e2_addr
000D97 B1C9              ACALL    ?L?COM0028
  130: 	sys_eepromWrite(e2_addr, e2_data, SectorSize);
000D99 900045            MOV      DPTR,#e2_addr
000D9C B1AE              ACALL    ?L?COM0007
000D9E B1E7              ACALL    _sys_eepromWrite
  131: 
  132: 	//    memcpy(e2_data_bak, e2_data, SectorSize);
  133: 	sys_eepromEraseSector(e2_bak_addr);
000DA0 900047            MOV      DPTR,#e2_bak_addr
000DA3 B1C9              ACALL    ?L?COM0028
  134: 	sys_eepromWrite(e2_bak_addr, e2_data, SectorSize);
000DA5 900047            MOV      DPTR,#e2_bak_addr
000DA8 B1AE              ACALL    ?L?COM0007
000DAA B1E7              ACALL    _sys_eepromWrite
  135: 	return TRUE;
000DAC D3                SETB     C
  136: }
000DAD 22                RET      
----- FUNCTION _hwa_eepromWriteSector (END) -------


----- FUNCTION ?L?COM0007 (BEGIN) -----
000DAE E0                MOVX     A,@DPTR
000DAF FE                MOV      R6,A
000DB0 A3                INC      DPTR
000DB1 E0                MOVX     A,@DPTR
000DB2 FF                MOV      R7,A
000DB3 7B01              MOV      R3,#01H
000DB5 7A00              MOV      R2,#HIGH e2_data
000DB7 7900              MOV      R1,#LOW e2_data
000DB9 90004D            MOV      DPTR,#SectorSize
000DBC         ?L?COM0008:
000DBC E0                MOVX     A,@DPTR
000DBD FD                MOV      R5,A
000DBE A3                INC      DPTR
000DBF E0                MOVX     A,@DPTR
000DC0 900064            MOV      DPTR,#?_sys_eepromWrite?BYTE+05H
000DC3 CD                XCH      A,R5
000DC4 F0                MOVX     @DPTR,A
000DC5 A3                INC      DPTR
000DC6 ED                MOV      A,R5
000DC7 F0                MOVX     @DPTR,A
000DC8 22                RET      
----- FUNCTION ?L?COM0007 (END) -------


----- FUNCTION ?L?COM0028 (BEGIN) -----
000DC9 E0                MOVX     A,@DPTR
000DCA FE                MOV      R6,A
000DCB A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 39


000DCC E0                MOVX     A,@DPTR
000DCD FF                MOV      R7,A
----- FUNCTION _sys_eepromEraseSector (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   72: void sys_eepromEraseSector(UINT16 addr)
   73: {
;---- Variable 'addr' assigned to Register 'R6/R7' ----
   74:     IAP_CONTR = ENABLE_IAP;         //使能IAP
   75:     IAP_CMD = CMD_ERASE;            //设置IAP命令
000DCE 75C780            MOV      IAP_CONTR,#080H
   76:     IAP_ADDRL = addr;               //设置IAP低地址
000DD1 75C503            MOV      IAP_CMD,#03H
   77:     IAP_ADDRH = addr >> 8;          //设置IAP高地址
000DD4 8FC4              MOV      IAP_ADDRL,R7
   78:     IAP_TRIG = 0x5a;                //写触发命令(0x5a)
000DD6 EE                MOV      A,R6
000DD7 F12F              ACALL    ?L?COM003A
   79:     IAP_TRIG = 0xa5;                //写触发命令(0xa5)
   80:     _nop_();                        //等待ISP/IAP/EEPROM操作完成
000DD9 00                NOP      
;----                  JMP      IapIdle
   81:     IapIdle();
----- FUNCTION _sys_eepromEraseSector (END) -------


----- FUNCTION IapIdle (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   24: void IapIdle(void)
   25: {
   26:     IAP_CONTR = 0;                  //关闭IAP功能
   27:     IAP_CMD = 0;                    //清除命令寄存器
000DDA E4                CLR      A
000DDB F5C7              MOV      IAP_CONTR,A
   28:     IAP_TRIG = 0;                   //清除触发寄存器
000DDD F5C5              MOV      IAP_CMD,A
   29:     IAP_ADDRH = 0x80;               //将地址设置到非IAP区域
000DDF F5C6              MOV      IAP_TRIG,A
   30:     IAP_ADDRL = 0;
000DE1 75C380            MOV      IAP_ADDRH,#080H
   31: }
000DE4 F5C4              MOV      IAP_ADDRL,A
   32: 
000DE6 22                RET      
----- FUNCTION IapIdle (END) -------


----- FUNCTION _sys_eepromWrite (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
  100: void sys_eepromWrite(UINT16 addr, UINT8 *Data, UINT16 num)
  101: {
;---- Variable 'Data' assigned to Register 'R1/R2/R3' ----
;---- Variable 'addr' assigned to Register 'R4/R5' ----
000DE7 F1D5              ACALL    ?L?COM004F
  102:     IAP_CONTR = ENABLE_IAP;
  103:     IAP_CMD = CMD_PROGRAM;
000DE9 75C502            MOV      IAP_CMD,#02H
000DEC         ?C0006?SYS_EEPROM:
  104:     while(num--)
000DEC F1E6              ACALL    ?L?COM003F
000DEE 45F0              ORL      A,B
000DF0 601A              JZ       ?C0007?SYS_EEPROM
  105:     {
  106:         IAP_ADDRL = addr;
000DF2 8DC4              MOV      IAP_ADDRL,R5
  107:         IAP_ADDRH = addr >> 8;
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 40


000DF4 EC                MOV      A,R4
000DF5 F5C3              MOV      IAP_ADDRH,A
  108:         IAP_DATA = *Data;
000DF7 12011C            LCALL    ?C?CLDPTR
000DFA F5C2              MOV      IAP_DATA,A
  109:         IAP_TRIG = 0x5a;
000DFC F131              ACALL    ?L?COM003B
  110:         IAP_TRIG = 0xa5;
  111:         addr++;
000DFE 0D                INC      R5
000DFF BD0001            CJNE     R5,#00H,?C0010?SYS_EEPROM
000E02 0C                INC      R4
000E03         ?C0010?SYS_EEPROM:
  112:         Data++;
000E03 7401              MOV      A,#01H
000E05 29                ADD      A,R1
000E06 F9                MOV      R1,A
000E07 E4                CLR      A
000E08 3A                ADDC     A,R2
000E09 FA                MOV      R2,A
  113:     }
000E0A 80E0              SJMP     ?C0006?SYS_EEPROM
000E0C         ?C0007?SYS_EEPROM:
  114:     IapIdle();
000E0C 80CC              SJMP     IapIdle
----- FUNCTION _sys_eepromWrite (END) -------


----- FUNCTION ?L?COM0005 (BEGIN) -----
000E0E EC                MOV      A,R4
000E0F F0                MOVX     @DPTR,A
000E10 A3                INC      DPTR
000E11 ED                MOV      A,R5
000E12 F0                MOVX     @DPTR,A
000E13 2402              ADD      A,#02H
000E15 FE                MOV      R6,A
000E16 E4                CLR      A
000E17 3C                ADDC     A,R4
000E18 A3                INC      DPTR
000E19 F0                MOVX     @DPTR,A
000E1A A3                INC      DPTR
000E1B CE                XCH      A,R6
000E1C F0                MOVX     @DPTR,A
000E1D EB                MOV      A,R3
000E1E FF                MOV      R7,A
000E1F 7E00              MOV      R6,#00H
000E21 90045D            MOV      DPTR,#c_u16_eepromSectorSize
000E24 E4                CLR      A
000E25 93                MOVC     A,@A+DPTR
000E26 FC                MOV      R4,A
000E27 7401              MOV      A,#01H
000E29 93                MOVC     A,@A+DPTR
000E2A FD                MOV      R5,A
000E2B 120196            LCALL    ?C?IMUL
000E2E AA06              MOV      R2,AR6
000E30 AB07              MOV      R3,AR7
000E32 90045F            MOV      DPTR,#c_u16_eepromSectorAddr
000E35         ?L?COM0006:
000E35 7401              MOV      A,#01H
000E37 93                MOVC     A,@A+DPTR
000E38 2B                ADD      A,R3
000E39 FE                MOV      R6,A
000E3A E4                CLR      A
000E3B 93                MOVC     A,@A+DPTR
000E3C 3A                ADDC     A,R2
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 41


000E3D 22                RET      
----- FUNCTION ?L?COM0005 (END) -------


----- FUNCTION ?L?COM002B (BEGIN) -----
000E3E 900055            MOV      DPTR,#e2_bak_addr
000E41 E0                MOVX     A,@DPTR
000E42 FE                MOV      R6,A
000E43 A3                INC      DPTR
000E44 E0                MOVX     A,@DPTR
000E45 FF                MOV      R7,A
000E46         ?L?COM002C:
000E46 7B01              MOV      R3,#01H
000E48 7A00              MOV      R2,#HIGH e2_data_bak
000E4A 7920              MOV      R1,#LOW e2_data_bak
000E4C 22                RET      
----- FUNCTION ?L?COM002B (END) -------


----- FUNCTION ?L?COM0009 (BEGIN) -----
000E4D D164              ACALL    _sys_eepromRead
000E4F 900052            MOV      DPTR,#sector
000E52         ?L?COM000A:
000E52 E0                MOVX     A,@DPTR
000E53 75F003            MOV      B,#03H
000E56 A4                MUL      AB
000E57 2459              ADD      A,#LOW c_s_eepromConfig+02H
000E59 F582              MOV      DPL,A
000E5B E5F0              MOV      A,B
000E5D 3404              ADDC     A,#HIGH c_s_eepromConfig+02H
000E5F F583              MOV      DPH,A
000E61 E4                CLR      A
000E62 93                MOVC     A,@A+DPTR
000E63 22                RET      
----- FUNCTION ?L?COM0009 (END) -------


----- FUNCTION _sys_eepromRead (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   84: void sys_eepromRead(UINT16 addr, UINT8 *Data, UINT16 num)
   85: {
000E64 900061            MOV      DPTR,#Data
000E67 D1EB              ACALL    ?L?COM0004
;---- Variable 'addr' assigned to Register 'R4/R5' ----
000E69 F1D5              ACALL    ?L?COM004F
   86:     IAP_CONTR = ENABLE_IAP;
   87:     IAP_CMD = CMD_READ;
000E6B 75C501            MOV      IAP_CMD,#01H
000E6E         ?C0003?SYS_EEPROM:
   88:     while(num--)
000E6E F1E6              ACALL    ?L?COM003F
000E70 45F0              ORL      A,B
000E72 6021              JZ       ?C0004?SYS_EEPROM
   89:     {
   90:         IAP_ADDRL = addr;
000E74 8DC4              MOV      IAP_ADDRL,R5
   91:         IAP_ADDRH = addr >> 8;
000E76 EC                MOV      A,R4
000E77 F12F              ACALL    ?L?COM003A
   92:         IAP_TRIG = 0x5a;
   93:         IAP_TRIG = 0xa5;
   94:         addr++;
000E79 0D                INC      R5
000E7A BD0001            CJNE     R5,#00H,?C0009?SYS_EEPROM
000E7D 0C                INC      R4
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 42


000E7E         ?C0009?SYS_EEPROM:
   95:         *Data++ = IAP_DATA;
000E7E 900061            MOV      DPTR,#Data
000E81 E0                MOVX     A,@DPTR
000E82 FB                MOV      R3,A
000E83 A3                INC      DPTR
000E84 E4                CLR      A
000E85 75F001            MOV      B,#01H
000E88 1201FD            LCALL    ?C?ILDIX
000E8B A9F0              MOV      R1,B
000E8D FA                MOV      R2,A
000E8E E5C2              MOV      A,IAP_DATA
000E90 120162            LCALL    ?C?CSTPTR
   96:     }
000E93 80D9              SJMP     ?C0003?SYS_EEPROM
000E95         ?C0004?SYS_EEPROM:
   97:     IapIdle();
000E95 A1DA              AJMP     IapIdle
----- FUNCTION _sys_eepromRead (END) -------


----- FUNCTION _hwa_mifareCheckOut (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   91: UINT16 hwa_mifareCheckOut(UINT8 *dat, UINT16 len)
   92: {
000E97 90005F            MOV      DPTR,#dat
000E9A D1EB              ACALL    ?L?COM0004
;---- Variable 'len' assigned to Register 'R4/R5' ----
   93: 	UINT16 Sum = 0;
   94: 	UINT8 i;
000E9C E4                CLR      A
000E9D A3                INC      DPTR
000E9E F0                MOVX     @DPTR,A
000E9F A3                INC      DPTR
000EA0 F0                MOVX     @DPTR,A
   95: 	for (i = 0; i < len; i++)
000EA1 A3                INC      DPTR
000EA2 F0                MOVX     @DPTR,A
000EA3         ?C0032?HWA_MIFARE:
000EA3 900064            MOV      DPTR,#i
000EA6 E0                MOVX     A,@DPTR
000EA7 C3                CLR      C
000EA8 9D                SUBB     A,R5
000EA9 E4                CLR      A
000EAA 9C                SUBB     A,R4
000EAB 5026              JNC      ?C0033?HWA_MIFARE
   96: 	{
   97: 		Sum += dat[i];
000EAD 90005F            MOV      DPTR,#dat
000EB0 1207F0            LCALL    ?L?COM0002
000EB3 F9                MOV      R1,A
000EB4 900064            MOV      DPTR,#i
000EB7 E0                MOVX     A,@DPTR
000EB8 F582              MOV      DPL,A
000EBA 12147A            LCALL    ?L?COM001A
000EBD FF                MOV      R7,A
000EBE 900063            MOV      DPTR,#Sum+01H
000EC1 E0                MOVX     A,@DPTR
000EC2 2F                ADD      A,R7
000EC3 F0                MOVX     @DPTR,A
000EC4 900062            MOV      DPTR,#Sum
000EC7 E0                MOVX     A,@DPTR
000EC8 3400              ADDC     A,#00H
000ECA F0                MOVX     @DPTR,A
   98: 	}
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 43


000ECB 900064            MOV      DPTR,#i
000ECE E0                MOVX     A,@DPTR
000ECF 04                INC      A
000ED0 F0                MOVX     @DPTR,A
000ED1 80D0              SJMP     ?C0032?HWA_MIFARE
000ED3         ?C0033?HWA_MIFARE:
   99: 	Sum ^= 0xABCD;
000ED3 900062            MOV      DPTR,#Sum
000ED6 E0                MOVX     A,@DPTR
000ED7 64AB              XRL      A,#0ABH
000ED9 FE                MOV      R6,A
000EDA A3                INC      DPTR
000EDB E0                MOVX     A,@DPTR
000EDC 64CD              XRL      A,#0CDH
000EDE FF                MOV      R7,A
000EDF 900062            MOV      DPTR,#Sum
000EE2 EE                MOV      A,R6
000EE3 F0                MOVX     @DPTR,A
000EE4 A3                INC      DPTR
000EE5 EF                MOV      A,R7
000EE6 F0                MOVX     @DPTR,A
  100: 	return Sum;
  101: }
000EE7 22                RET      
----- FUNCTION _hwa_mifareCheckOut (END) -------


----- FUNCTION ?L?COM0003 (BEGIN) -----
000EE8 900043            MOV      DPTR,#UID
000EEB         ?L?COM0004:
000EEB EB                MOV      A,R3
000EEC F0                MOVX     @DPTR,A
000EED A3                INC      DPTR
000EEE EA                MOV      A,R2
000EEF F0                MOVX     @DPTR,A
000EF0 A3                INC      DPTR
000EF1 E9                MOV      A,R1
000EF2 F0                MOVX     @DPTR,A
000EF3 22                RET      
----- FUNCTION ?L?COM0003 (END) -------


----- FUNCTION _hwa_eepromDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   51: void hwa_eepromDecrypt(UINT8 *dat, UINT16 size)        //解密
   52: {
000EF4 90005F            MOV      DPTR,#dat
000EF7 D1EB              ACALL    ?L?COM0004
;---- Variable 'i' assigned to Register 'R6/R7' ----
000EF9 121749            LCALL    ?L?COM0040
000EFC         ?C0005?HWA_EEPROM_CFG:
000EFC D3                SETB     C
000EFD 900063            MOV      DPTR,#size+01H
000F00 E0                MOVX     A,@DPTR
000F01 9F                SUBB     A,R7
000F02 900062            MOV      DPTR,#size
000F05 E0                MOVX     A,@DPTR
000F06 9E                SUBB     A,R6
000F07 401D              JC       ?C0008?HWA_EEPROM_CFG
   53: 	UINT16 i;
   54: 	UINT8 tmp;
   55: 	for (i = 0; i<size; i++)
   56: 	{
   57: 		tmp = dat[i];
000F09 90005F            MOV      DPTR,#dat
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 44


000F0C 1207F0            LCALL    ?L?COM0002
;---- Variable 'tmp' assigned to Register 'R5' ----
000F0F 12175E            LCALL    ?L?COM0033
   58: 		tmp ^= SecretKey;
   59: 		tmp = (tmp << 1) | (tmp >> 7);
000F12 25E0              ADD      A,ACC
000F14 FC                MOV      R4,A
000F15 ED                MOV      A,R5
000F16 C4                SWAP     A
000F17 13                RRC      A
000F18 13                RRC      A
000F19 13                RRC      A
000F1A 5401              ANL      A,#01H
000F1C 121753            LCALL    ?L?COM0036
   60: 		tmp ^= SecretKey;
   61: 		dat[i] = tmp;
   62: 	}
000F1F 0F                INC      R7
000F20 BF0001            CJNE     R7,#00H,?C0010?HWA_EEPROM_CFG
000F23 0E                INC      R6
000F24         ?C0010?HWA_EEPROM_CFG:
000F24 80D6              SJMP     ?C0005?HWA_EEPROM_CFG
   63: }
000F26         ?C0008?HWA_EEPROM_CFG:
000F26 22                RET      
----- FUNCTION _hwa_eepromDecrypt (END) -------


----- FUNCTION ?L?COM004E (BEGIN) -----
000F27 3C                ADDC     A,R4
000F28 F583              MOV      DPH,A
000F2A E0                MOVX     A,@DPTR
000F2B FD                MOV      R5,A
000F2C ED                MOV      A,R5
000F2D FF                MOV      R7,A
000F2E 22                RET      
----- FUNCTION ?L?COM004E (END) -------


----- FUNCTION ?L?COM003A (BEGIN) -----
000F2F F5C3              MOV      IAP_ADDRH,A
000F31         ?L?COM003B:
000F31 75C65A            MOV      IAP_TRIG,#05AH
000F34 75C6A5            MOV      IAP_TRIG,#0A5H
000F37 22                RET      
----- FUNCTION ?L?COM003A (END) -------


----- FUNCTION ?L?COM0042 (BEGIN) -----
000F38 900053            MOV      DPTR,#e2_addr
000F3B E0                MOVX     A,@DPTR
000F3C FE                MOV      R6,A
000F3D A3                INC      DPTR
000F3E E0                MOVX     A,@DPTR
000F3F FF                MOV      R7,A
000F40 22                RET      
----- FUNCTION ?L?COM0042 (END) -------


----- FUNCTION ?L?COM0045 (BEGIN) -----
000F41 90004B            MOV      DPTR,#Size
000F44 E0                MOVX     A,@DPTR
000F45 FC                MOV      R4,A
000F46 A3                INC      DPTR
000F47 E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 45


000F48 FD                MOV      R5,A
000F49 22                RET      
----- FUNCTION ?L?COM0045 (END) -------


----- FUNCTION sys_taskInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   27: void sys_taskInit(void)
   28: {
   29:     WDT_CONTR = 0x33;
   30:     app_pulseInit();
000F4A 75C133            MOV      WDT_CONTR,#033H
   31:     len_Init();
000F4D 121705            LCALL    app_pulseInit
   32:     sys_gpioInit();
000F50 121774            LCALL    len_Init
   33:     buzzer_Init();
000F53 120009            LCALL    sys_gpioInit
   34:     sys_uartInit();
000F56 12176A            LCALL    buzzer_Init
   35:     sys_tim0Init();
000F59 121515            LCALL    sys_uartInit
   36: 	app_Show();
000F5C 121000            LCALL    sys_tim0Init
   37:     app_configInit();
000F5F 111F              ACALL    app_Show
   38:     app_brushInit();
000F61 51F2              ACALL    app_configInit
   39: }
000F63 020020            LJMP     app_brushInit
----- FUNCTION sys_taskInit (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: 'System\sys_task.c'
   79: void main(void)
   80: {
   81:     sys_taskInit();
   82:     buzzer_SoundNumber(1);
000F66 F14A              ACALL    sys_taskInit
   83:     while(1)
000F68 7F01              MOV      R7,#01H
000F6A 719F              ACALL    _buzzer_SoundNumber
000F6C         ?C0010?SYS_TASK:
   84:     {
   85:         WDT_CONTR = 0x33;          //reset watch dog      SyttemClk is 11.0592M Over Time 568.8ms
   86:         if(taskCycle1sFlag == TRUE)
000F6C 75C133            MOV      WDT_CONTR,#033H
   87:         {
000F6F 3006FA            JNB      taskCycle1sFlag,?C0010?SYS_TASK
   88:         	taskCycle1sFlag = FALSE;
   89:             app_confingHandler1s();
000F72 C206              CLR      taskCycle1sFlag
   90:             app_brushCycle1s();
000F74 F17A              ACALL    app_confingHandler1s
   91:         }
000F76 1166              ACALL    app_brushCycle1s
   92:     }
   93: }
000F78 80F2              SJMP     ?C0010?SYS_TASK
----- FUNCTION main (END) -------


----- FUNCTION app_confingHandler1s (BEGIN) -----
 FILE: 'App\app_config.c'
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 46


  115: void app_confingHandler1s(void)
  116: {
  117:     led_Switch(OFF);
  118: //    hwa_eepromReadSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
000F7A C201              CLR      ?led_Switch?BIT
000F7C 51E5              ACALL    led_Switch
  119: //    sys_uartSendData((UINT8*)&USER_Card_ID, 5);
  120: //    USER_Card_ID[0][0]++;
  121: //    hwa_eepromWriteSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
  122:     led_Switch(ON);
000F7E D201              SETB     ?led_Switch?BIT
000F80 41E5              AJMP     led_Switch
----- FUNCTION app_confingHandler1s (END) -------


----- FUNCTION ?L?COM000F (BEGIN) -----
000F82 E4                CLR      A
000F83 7B64              MOV      R3,#064H
000F85 FA                MOV      R2,A
000F86 F9                MOV      R1,A
000F87 F8                MOV      R0,A
000F88 900090            MOV      DPTR,#MoneySum
000F8B E0                MOVX     A,@DPTR
000F8C FC                MOV      R4,A
000F8D A3                INC      DPTR
000F8E E0                MOVX     A,@DPTR
000F8F FD                MOV      R5,A
000F90 A3                INC      DPTR
000F91 E0                MOVX     A,@DPTR
000F92 FE                MOV      R6,A
000F93 A3                INC      DPTR
000F94 E0                MOVX     A,@DPTR
000F95 FF                MOV      R7,A
000F96 120299            LCALL    ?C?ULDIV
000F99 E4                CLR      A
000F9A 7B64              MOV      R3,#064H
000F9C FA                MOV      R2,A
000F9D F9                MOV      R1,A
000F9E F8                MOV      R0,A
000F9F 22                RET      
----- FUNCTION ?L?COM000F (END) -------


----- FUNCTION _hwa_mifareReadBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   53: BOOL hwa_mifareReadBlock(UINT8 *buff, UINT8 block)
   54: {
000FA0 900046            MOV      DPTR,#buff
000FA3 D1EB              ACALL    ?L?COM0004
000FA5 A3                INC      DPTR
000FA6 ED                MOV      A,R5
000FA7 F0                MOVX     @DPTR,A
   55: 	UINT8 u8_ReadErrCount;
   56: 	UINT8 u8_Result;
   57: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
000FA8 E4                CLR      A
000FA9 A3                INC      DPTR
000FAA F0                MOVX     @DPTR,A
000FAB         ?C0018?HWA_MIFARE:
   58: 	{
   59: 		u8_Result = Read_Block(buff, block);
000FAB 900046            MOV      DPTR,#buff
000FAE 1207F0            LCALL    ?L?COM0002
000FB1 F9                MOV      R1,A
000FB2 A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 47


000FB3 E0                MOVX     A,@DPTR
000FB4 FD                MOV      R5,A
000FB5 12178D            LCALL    _Read_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   60: 		if (u8_Result == FM1702_OK)
000FB8 EF                MOV      A,R7
000FB9 7002              JNZ      ?C0021?HWA_MIFARE
   61: 		{
   62: 			return TRUE;
000FBB D3                SETB     C
000FBC 22                RET      
   63: 		}
000FBD         ?C0021?HWA_MIFARE:
   64: 		else if (u8_Result == FM1702_NOTAGERR)
000FBD EF                MOV      A,R7
000FBE B40102            CJNE     A,#01H,?C0020?HWA_MIFARE
   65: 		{
   66: 			return FALSE;
000FC1 C3                CLR      C
000FC2 22                RET      
   67: 		}
   68: 	}
000FC3         ?C0020?HWA_MIFARE:
000FC3 90004A            MOV      DPTR,#u8_ReadErrCount
000FC6 12152F            LCALL    ?L?COM004C
000FC9 40E0              JC       ?C0018?HWA_MIFARE
000FCB         ?C0019?HWA_MIFARE:
   69: 	return FALSE;
000FCB C3                CLR      C
   70: }
000FCC 22                RET      
----- FUNCTION _hwa_mifareReadBlock (END) -------


----- FUNCTION ?L?COM004D (BEGIN) -----
000FCD F0                MOVX     @DPTR,A
000FCE A3                INC      DPTR
000FCF CE                XCH      A,R6
000FD0 F0                MOVX     @DPTR,A
000FD1 900461            MOV      DPTR,#c_u16_eepromSectorBakAddr
000FD4 22                RET      
----- FUNCTION ?L?COM004D (END) -------


----- FUNCTION ?L?COM004F (BEGIN) -----
000FD5 AD07              MOV      R5,AR7
000FD7 AC06              MOV      R4,AR6
000FD9 75C780            MOV      IAP_CONTR,#080H
000FDC 22                RET      
----- FUNCTION ?L?COM004F (END) -------


----- FUNCTION ?L?COM0047 (BEGIN) -----
000FDD 9000A4            MOV      DPTR,#s_System+010H
000FE0 E0                MOVX     A,@DPTR
000FE1 FA                MOV      R2,A
000FE2 A3                INC      DPTR
000FE3 E0                MOVX     A,@DPTR
000FE4 FB                MOV      R3,A
000FE5 22                RET      
----- FUNCTION ?L?COM0047 (END) -------


----- FUNCTION ?L?COM003F (BEGIN) -----
000FE6 900064            MOV      DPTR,#num
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 48


000FE9 74FF              MOV      A,#0FFH
000FEB F5F0              MOV      B,A
000FED 0201FD            LJMP     ?C?ILDIX
----- FUNCTION ?L?COM003F (END) -------


----- FUNCTION ?L?COM0025 (BEGIN) -----
000FF0 FE                MOV      R6,A
000FF1 74AD              MOV      A,#LOW gBuff+02H
000FF3 2F                ADD      A,R7
000FF4 F582              MOV      DPL,A
000FF6 E4                CLR      A
000FF7 3400              ADDC     A,#HIGH gBuff+02H
000FF9         ?L?COM0026:
000FF9 F583              MOV      DPH,A
000FFB EE                MOV      A,R6
000FFC F0                MOVX     @DPTR,A
000FFD 0F                INC      R7
000FFE EF                MOV      A,R7
000FFF 22                RET      
----- FUNCTION ?L?COM0025 (END) -------


----- FUNCTION sys_tim0Init (BEGIN) -----
 FILE: 'System\sys_tim.c'
  101: void sys_tim0Init(void)
  102: {
  103: 	TMOD &= 0xF0;
  104: 	TH0 = (UINT8)(T1MS>>8);
001000 5389F0            ANL      TMOD,#0F0H
  105: 	TL0 = (UINT8)T1MS;
001003 758CF8            MOV      TH0,#0F8H
  106: 	ET0 = 1;
001006 758ACD            MOV      TL0,#0CDH
  107: 	TR0 = 1;
001009 D2A9              SETB     ET0
  108: //	PT1 = 1;
00100B D28C              SETB     TR0
  109:     EA = 1;
00100D D2AF              SETB     EA
  110: }
00100F 22                RET      
----- FUNCTION sys_tim0Init (END) -------


----- FUNCTION sys_tim0Isr (BEGIN) -----
 FILE: 'System\sys_task.c'
   41: void sys_tim0Isr(void) interrupt 1      //1ms interrupt task
001010 C0E0              PUSH     ACC
001012 C0F0              PUSH     B
001014 C083              PUSH     DPH
001016 C082              PUSH     DPL
001018 C0D0              PUSH     PSW
00101A 75D000            MOV      PSW,#00H
00101D C000              PUSH     AR0
00101F C001              PUSH     AR1
001021 C002              PUSH     AR2
001023 C003              PUSH     AR3
001025 C004              PUSH     AR4
001027 C005              PUSH     AR5
001029 C006              PUSH     AR6
00102B C007              PUSH     AR7
   42: {
   43:     led_Handler1ms();
00102D 11D6              ACALL    led_Handler1ms
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 49


   44:     app_pulseHandler1ms();
00102F 1197              ACALL    app_pulseHandler1ms
   45: 	taskHandlerCnt10ms++;
001031 9000C9            MOV      DPTR,#taskHandlerCnt10ms
001034 E0                MOVX     A,@DPTR
001035 04                INC      A
001036 F0                MOVX     @DPTR,A
   46:     if(taskHandlerCnt10ms>=10)
001037 E0                MOVX     A,@DPTR
001038 C3                CLR      C
001039 940A              SUBB     A,#0AH
00103B 400B              JC       ?C0003?SYS_TASK
   47:     {
   48:         taskHandlerCnt10ms = 0;
00103D E4                CLR      A
00103E F0                MOVX     @DPTR,A
   49:         sys_taskHandler10ms();
00103F 12000A            LCALL    sys_taskHandler10ms
   50:         taskHandlerCnt100ms++;
001042 9000C7            MOV      DPTR,#taskHandlerCnt100ms
001045 E0                MOVX     A,@DPTR
001046 04                INC      A
001047 F0                MOVX     @DPTR,A
   51:     }
001048         ?C0003?SYS_TASK:
   52:     if(taskHandlerCnt100ms>=10)
001048 9000C7            MOV      DPTR,#taskHandlerCnt100ms
00104B E0                MOVX     A,@DPTR
00104C C3                CLR      C
00104D 940A              SUBB     A,#0AH
00104F 400A              JC       ?C0004?SYS_TASK
   53:     {
   54:         taskHandlerCnt100ms = 0;
001051 E4                CLR      A
001052 F0                MOVX     @DPTR,A
   55:         sys_taskHandler100ms();
001053 1186              ACALL    sys_taskHandler100ms
   56:         taskHandlerCnt1s++;
001055 9000C8            MOV      DPTR,#taskHandlerCnt1s
001058 E0                MOVX     A,@DPTR
001059 04                INC      A
00105A F0                MOVX     @DPTR,A
   57:     }
00105B         ?C0004?SYS_TASK:
   58:     if(taskHandlerCnt1s>=10)
00105B 9000C8            MOV      DPTR,#taskHandlerCnt1s
00105E E0                MOVX     A,@DPTR
00105F C3                CLR      C
001060 940A              SUBB     A,#0AH
001062 4007              JC       ?C0006?SYS_TASK
   59:     {
   60:         taskHandlerCnt1s = 0;
001064 E4                CLR      A
001065 F0                MOVX     @DPTR,A
   61:         sys_taskHandler1s();
001066 120022            LCALL    sys_taskHandler1s
   62:         taskCycle1sFlag = TRUE;
001069 D206              SETB     taskCycle1sFlag
   63:     }
   64: }
00106B         ?C0006?SYS_TASK:
00106B D007              POP      AR7
00106D D006              POP      AR6
00106F D005              POP      AR5
001071 D004              POP      AR4
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 50


001073 D003              POP      AR3
001075 D002              POP      AR2
001077 D001              POP      AR1
001079 D000              POP      AR0
00107B D0D0              POP      PSW
00107D D082              POP      DPL
00107F D083              POP      DPH
001081 D0F0              POP      B
001083 D0E0              POP      ACC
001085 32                RETI     
----- FUNCTION sys_tim0Isr (END) -------


----- FUNCTION sys_taskHandler100ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   70: void sys_taskHandler100ms(void)           //100ms interrupt task
;----                  JMP      buzzer_Handler100ms
   71: {
----- FUNCTION sys_taskHandler100ms (END) -------


----- FUNCTION buzzer_Handler100ms (BEGIN) -----
 FILE: 'Driver\buzzer.c'
   15: void buzzer_Handler100ms(void)
   16: {
   17:     if(Buzzer)
   18: 	{
001086 30B503            JNB      Buzzer,?C0002?BUZZER
   19: 		Buzzer = 0;
   20: 	}
001089 C2B5              CLR      Buzzer
   21: 	else if(SoundNumberCount)
00108B 22                RET      
00108C         ?C0002?BUZZER:
   22: 	{
00108C 9000CD            MOV      DPTR,#SoundNumberCount
00108F E0                MOVX     A,@DPTR
001090 6004              JZ       ?C0005?BUZZER
   23: 		Buzzer = 1;
   24: 		SoundNumberCount--;
001092 D2B5              SETB     Buzzer
   25: 	}
001094 14                DEC      A
001095 F0                MOVX     @DPTR,A
   26: }
   27: 
001096         ?C0005?BUZZER:
001096 22                RET      
----- FUNCTION buzzer_Handler100ms (END) -------


----- FUNCTION app_pulseHandler1ms (BEGIN) -----
 FILE: 'App\app_pulse.c'
   19: void app_pulseHandler1ms(void)
   20: {
   21:     if(u8_pulse)
   22:     {
001097 9000C4            MOV      DPTR,#u8_pulse
00109A E0                MOVX     A,@DPTR
00109B 6038              JZ       ?C0007?APP_PULSE
   23:         u16_count++;
   24:         if(u16_count<=u8_width)
00109D 9000C6            MOV      DPTR,#u16_count+01H
0010A0 E0                MOVX     A,@DPTR
0010A1 04                INC      A
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 51


0010A2 F0                MOVX     @DPTR,A
0010A3 7006              JNZ      ?C0009?APP_PULSE
0010A5 9000C5            MOV      DPTR,#u16_count
0010A8 E0                MOVX     A,@DPTR
0010A9 04                INC      A
0010AA F0                MOVX     @DPTR,A
0010AB         ?C0009?APP_PULSE:
   25:         {
0010AB 9000C3            MOV      DPTR,#u8_width
0010AE E0                MOVX     A,@DPTR
0010AF FF                MOV      R7,A
0010B0 9000C5            MOV      DPTR,#u16_count
0010B3 B137              ACALL    ?L?COM0046
0010B5 9400              SUBB     A,#00H
0010B7 5003              JNC      ?C0003?APP_PULSE
   26:             pulse = 0;
   27:         }
0010B9 C2B7              CLR      pulse
   28:         else if(u16_count<=PULSE_Interval)
0010BB 22                RET      
0010BC         ?C0003?APP_PULSE:
   29:         {
0010BC D3                SETB     C
0010BD ED                MOV      A,R5
0010BE 942C              SUBB     A,#02CH
0010C0 EC                MOV      A,R4
0010C1 9401              SUBB     A,#01H
0010C3 5003              JNC      ?C0005?APP_PULSE
   30:             pulse = 1;
   31:         }
0010C5 D2B7              SETB     pulse
   32:         else
0010C7 22                RET      
0010C8         ?C0005?APP_PULSE:
   33:         {
   34:             u16_count = 0;
0010C8 E4                CLR      A
0010C9 9000C5            MOV      DPTR,#u16_count
0010CC F0                MOVX     @DPTR,A
0010CD A3                INC      DPTR
0010CE F0                MOVX     @DPTR,A
   35:             u8_pulse--;
0010CF 9000C4            MOV      DPTR,#u8_pulse
0010D2 E0                MOVX     A,@DPTR
0010D3 14                DEC      A
0010D4 F0                MOVX     @DPTR,A
   36:         }
   37:     }
   38: }
0010D5         ?C0007?APP_PULSE:
0010D5 22                RET      
----- FUNCTION app_pulseHandler1ms (END) -------


----- FUNCTION led_Handler1ms (BEGIN) -----
 FILE: 'Driver\LED.c'
   30: void led_Handler1ms(void)
   31: {
   32:     if(ledsw)
   33:     {
0010D6 200802            JB       ledsw,$ + 5H
0010D9 21DC              AJMP     ?C0033?LED
   34:     	if (gCurLed<5)
   35:     		gCurLed++;
0010DB 9000C1            MOV      DPTR,#gCurLed
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 52


0010DE E0                MOVX     A,@DPTR
0010DF C3                CLR      C
0010E0 9405              SUBB     A,#05H
0010E2 5005              JNC      ?C0003?LED
   36:     	else
0010E4 E0                MOVX     A,@DPTR
0010E5 04                INC      A
0010E6 F0                MOVX     @DPTR,A
0010E7 8005              SJMP     ?C0004?LED
0010E9         ?C0003?LED:
   37:     		gCurLed=0;
0010E9 E4                CLR      A
0010EA 9000C1            MOV      DPTR,#gCurLed
0010ED F0                MOVX     @DPTR,A
0010EE         ?C0004?LED:
   38:     	LED_CS0 = 1;
0010EE B140              ACALL    ?L?COM003D
   39:     	LED_CS1 = 1;
   40:     	LED_CS2 = 1;
   41:     	LED_CS3 = 1;
   42:     	LED_CS4 = 1;
   43:     	LED_CS5 = 1;
0010F0 D2B6              SETB     LED_CS5
   44:     	switch ( gLedBuf[gCurLed])		 //switch case 语句中 switch中的条件case都不满足就执行default
0010F2 9000C1            MOV      DPTR,#gCurLed
0010F5 E0                MOVX     A,@DPTR
0010F6 FF                MOV      R7,A
0010F7 24BB              ADD      A,#LOW gLedBuf
0010F9 F582              MOV      DPL,A
0010FB E4                CLR      A
0010FC 3400              ADDC     A,#HIGH gLedBuf
0010FE F583              MOV      DPH,A
001100 E0                MOVX     A,@DPTR
001101 B41100            CJNE     A,#011H,?C0040?LED
001104         ?C0040?LED:
001104 4002              JC       $ + 4H
001106 2194              AJMP     ?C0023?LED
001108 90110F            MOV      DPTR,#0110FH
00110B F8                MOV      R0,A
00110C 28                ADD      A,R0
00110D 28                ADD      A,R0
00110E 73                JMP      @A+DPTR
00110F         ?C0041?LED:
00110F 021142            LJMP     ?C0006?LED
001112 021147            LJMP     ?C0007?LED
001115 02114C            LJMP     ?C0008?LED
001118 021151            LJMP     ?C0009?LED
00111B 021156            LJMP     ?C0010?LED
00111E 02115B            LJMP     ?C0011?LED
001121 021160            LJMP     ?C0012?LED
001124 021165            LJMP     ?C0013?LED
001127 02116A            LJMP     ?C0014?LED
00112A 02116F            LJMP     ?C0015?LED
00112D 021174            LJMP     ?C0016?LED
001130 021179            LJMP     ?C0017?LED
001133 02117E            LJMP     ?C0018?LED
001136 021180            LJMP     ?C0019?LED
001139 021185            LJMP     ?C0020?LED
00113C 02118A            LJMP     ?C0021?LED
00113F 02118F            LJMP     ?C0022?LED
   45:     	{
   46:     	    case 0:	P1 = 0xeb; break;//0X88
001142         ?C0006?LED:
001142 7590EB            MOV      P1,#0EBH
001145 8050              SJMP     ?C0005?LED
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 53


   47:     		case 1:	P1 = 0x88; break;//0XEB
001147         ?C0007?LED:
001147 759088            MOV      P1,#088H
00114A 804B              SJMP     ?C0005?LED
   48:     		case 2:	P1 = 0xB3; break;//0X92
00114C         ?C0008?LED:
00114C 7590B3            MOV      P1,#0B3H
00114F 8046              SJMP     ?C0005?LED
   49:     		case 3:	P1 = 0xba; break;//0XC2
001151         ?C0009?LED:
001151 7590BA            MOV      P1,#0BAH
001154 8041              SJMP     ?C0005?LED
   50:     		case 4:	P1 = 0xd8; break;//0XE1
001156         ?C0010?LED:
001156 7590D8            MOV      P1,#0D8H
001159 803C              SJMP     ?C0005?LED
   51:     		case 5:	P1 = 0x7a; break;//0XC4
00115B         ?C0011?LED:
00115B 75907A            MOV      P1,#07AH
00115E 8037              SJMP     ?C0005?LED
   52:     		case 6:	P1 = 0x7b; break;//0X84
001160         ?C0012?LED:
001160 75907B            MOV      P1,#07BH
001163 8032              SJMP     ?C0005?LED
   53:     		case 7:	P1 = 0xa8; break;//0XEA
001165         ?C0013?LED:
001165 7590A8            MOV      P1,#0A8H
001168 802D              SJMP     ?C0005?LED
   54:     		case 8:	P1 = 0xfb; break;//0X80
00116A         ?C0014?LED:
00116A 7590FB            MOV      P1,#0FBH
00116D 8028              SJMP     ?C0005?LED
   55:     		case 9:	P1 = 0xfa; break;//0XC0
00116F         ?C0015?LED:
00116F 7590FA            MOV      P1,#0FAH
001172 8023              SJMP     ?C0005?LED
   56:     		case 10:P1 = 0xcb; break;//0XC0 U
001174         ?C0016?LED:
001174 7590CB            MOV      P1,#0CBH
001177 801E              SJMP     ?C0005?LED
   57:     		case 11:P1 = 0xbe; break;//3.
001179         ?C0017?LED:
001179 7590BE            MOV      P1,#0BEH
00117C 8019              SJMP     ?C0005?LED
   58:     		case 12:P1 = 0x00; break;//空
00117E         ?C0018?LED:
00117E 8014              SJMP     ?C0044?LED
   59:     		case 13:P1 = 0x7e; break;//5.
001180         ?C0019?LED:
001180 75907E            MOV      P1,#07EH
001183 8012              SJMP     ?C0005?LED
   60:             case 14:P1 = 0xf1;break;//P
001185         ?C0020?LED:
001185 7590F1            MOV      P1,#0F1H
001188 800D              SJMP     ?C0005?LED
   61:             case 15:P1 = 0x10;break;//-
00118A         ?C0021?LED:
00118A 759010            MOV      P1,#010H
00118D 8008              SJMP     ?C0005?LED
   62:             case 16:P1 = 0xf9;break;//-
00118F         ?C0022?LED:
00118F 7590F9            MOV      P1,#0F9H
001192 8003              SJMP     ?C0005?LED
   63:     		default:P1 = 0x00; break;
001194         ?C0023?LED:
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 54


001194         
001194 E4                CLR      A
001195 F590              MOV      P1,A
   64:     	}
001197         ?C0005?LED:
   65:         if(gShowDot & (1<<gCurLed))//show dot
001197 7401              MOV      A,#01H
001199 7E00              MOV      R6,#00H
00119B A807              MOV      R0,AR7
00119D 08                INC      R0
00119E 8005              SJMP     ?C0043?LED
0011A0         ?C0042?LED:
0011A0 C3                CLR      C
0011A1 33                RLC      A
0011A2 CE                XCH      A,R6
0011A3 33                RLC      A
0011A4 CE                XCH      A,R6
0011A5         ?C0043?LED:
0011A5 D8F9              DJNZ     R0,?C0042?LED
0011A7 FF                MOV      R7,A
0011A8 9000C2            MOV      DPTR,#gShowDot
0011AB E0                MOVX     A,@DPTR
0011AC FD                MOV      R5,A
0011AD EF                MOV      A,R7
0011AE 5D                ANL      A,R5
0011AF 6003              JZ       ?C0024?LED
   66:         {
   67:      		P1 |= 0X04;
0011B1 439004            ORL      P1,#04H
   68:         }
0011B4         ?C0024?LED:
   69:     	switch (gCurLed)
0011B4 9000C1            MOV      DPTR,#gCurLed
0011B7 E0                MOVX     A,@DPTR
0011B8 14                DEC      A
0011B9 6013              JZ       ?C0027?LED
0011BB 14                DEC      A
0011BC 6013              JZ       ?C0028?LED
0011BE 14                DEC      A
0011BF 6013              JZ       ?C0029?LED
0011C1 14                DEC      A
0011C2 6013              JZ       ?C0030?LED
0011C4 14                DEC      A
0011C5 6013              JZ       ?C0031?LED
0011C7 2405              ADD      A,#05H
0011C9 7011              JNZ      ?C0033?LED
   70:     	{
   71:     		case 0:
0011CB         ?C0026?LED:
   72:     			LED_CS0 = 0;
0011CB C2A6              CLR      LED_CS0
   73:     			break;
0011CD 22                RET      
   74:     		case 1:
0011CE         ?C0027?LED:
   75:     			LED_CS1 = 0;
0011CE C2A7              CLR      LED_CS1
   76:     			break;
0011D0 22                RET      
   77:     		case 2:
0011D1         ?C0028?LED:
   78:     			LED_CS2 = 0;
0011D1 C2A0              CLR      LED_CS2
   79:     			break;
0011D3 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 55


   80:     		case 3:
0011D4         ?C0029?LED:
   81:     			LED_CS3 = 0;
0011D4 C2CD              CLR      LED_CS3
   82:     			break;
0011D6 22                RET      
   83:     		case 4:
0011D7         ?C0030?LED:
   84:     			LED_CS4 = 0;
0011D7 C2CC              CLR      LED_CS4
   85:     			break;
0011D9 22                RET      
   86:     		case 5:
0011DA         ?C0031?LED:
   87:     			LED_CS5 = 0;
0011DA C2B6              CLR      LED_CS5
   88:     			break;
   89:     		default:
   90:     			break;
   91:     	}
   92:     }
   93: }
0011DC         ?C0033?LED:
0011DC 22                RET      
----- FUNCTION led_Handler1ms (END) -------


----- FUNCTION ?L?COM0010 (BEGIN) -----
0011DD 2E                ADD      A,R6
0011DE F9                MOV      R1,A
0011DF E4                CLR      A
0011E0 3A                ADDC     A,R2
0011E1 FA                MOV      R2,A
0011E2 12011C            LCALL    ?C?CLDPTR
0011E5 FF                MOV      R7,A
0011E6 EE                MOV      A,R6
0011E7 75F005            MOV      B,#05H
0011EA 84                DIV      AB
0011EB 74A6              MOV      A,#LOW gCard_UID
0011ED 25F0              ADD      A,B
0011EF         ?L?COM0011:
0011EF F582              MOV      DPL,A
0011F1 E4                CLR      A
0011F2 3400              ADDC     A,#HIGH gCard_UID
0011F4 F583              MOV      DPH,A
0011F6 22                RET      
----- FUNCTION ?L?COM0010 (END) -------


----- FUNCTION _hwa_mifareDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   40: void hwa_mifareDecrypt(UINT8 *pData)        //利用卡ID解密
   41: {
0011F7 900046            MOV      DPTR,#pData
0011FA 120EEB            LCALL    ?L?COM0004
   42: 	UINT8 i, j;
   43: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
0011FD E4                CLR      A
0011FE FE                MOV      R6,A
0011FF         ?C0011?HWA_MIFARE:
   44: 	{
   45: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
0011FF 7D04              MOV      R5,#04H
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 56


001201         ?C0014?HWA_MIFARE:
   46: 		{
   47: 			pData[i] = _crol_(pData[i], 1);
001201 900046            MOV      DPTR,#pData
001204 1207F0            LCALL    ?L?COM0002
001207 F9                MOV      R1,A
001208 8E82              MOV      DPL,R6
00120A 917A              ACALL    ?L?COM001A
00120C FF                MOV      R7,A
00120D 7801              MOV      R0,#01H
00120F 08                INC      R0
001210 8001              SJMP     ?C0066?HWA_MIFARE
001212         ?C0065?HWA_MIFARE:
001212 23                RL       A
001213         ?C0066?HWA_MIFARE:
001213 D8FD              DJNZ     R0,?C0065?HWA_MIFARE
001215 91FF              ACALL    ?L?COM0044
   48: 			pData[i] ^= gCard_UID[i % 5];
001217 E9                MOV      A,R1
001218 31DD              ACALL    ?L?COM0010
00121A E0                MOVX     A,@DPTR
00121B 6F                XRL      A,R7
00121C 120162            LCALL    ?C?CSTPTR
   49: 		}
00121F DDE0              DJNZ     R5,?C0014?HWA_MIFARE
   50: 	}
001221         ?C0013?HWA_MIFARE:
001221 0E                INC      R6
001222 EE                MOV      A,R6
001223 B404D9            CJNE     A,#04H,?C0011?HWA_MIFARE
   51: }
001226 22                RET      
----- FUNCTION _hwa_mifareDecrypt (END) -------


----- FUNCTION hwa_mifareCheckBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  103: void hwa_mifareCheckBlock(void)
  104: {
  105: 	UINT16 crc, crcBak;
  106: 	hwa_mifareDecrypt((UINT8*)&s_NormalBuff);
001227 7135              ACALL    ?L?COM0015
001229 31F7              ACALL    _hwa_mifareDecrypt
  107: 	crc = hwa_mifareCheckOut((UINT8*)&s_NormalBuff, USE_DATA_BLOCK_LEN);
00122B 7135              ACALL    ?L?COM0015
;---- Variable 'crc' assigned to Register 'R4/R5' ----
00122D 9166              ACALL    ?L?COM002E
00122F AC06              MOV      R4,AR6
  108: 	if (crc == (s_NormalBuff.crc[0] << 8 | s_NormalBuff.crc[1]))
001231 900082            MOV      DPTR,#s_NormalBuff+02H
001234 E0                MOVX     A,@DPTR
001235 FE                MOV      R6,A
001236 A3                INC      DPTR
001237 E0                MOVX     A,@DPTR
001238 FB                MOV      R3,A
001239 EB                MOV      A,R3
00123A B50508            CJNE     A,AR5,?C0036?HWA_MIFARE
00123D EE                MOV      A,R6
00123E B50404            CJNE     A,AR4,?C0036?HWA_MIFARE
  109: 	{
  110: 		NormalErrorFlag = FALSE;
001241 C205              CLR      NormalErrorFlag
  111: 	}
001243 8002              SJMP     ?C0037?HWA_MIFARE
001245         ?C0036?HWA_MIFARE:
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 57


  112: 	else
  113: 	{
  114: 		NormalErrorFlag = TRUE;
001245 D205              SETB     NormalErrorFlag
  115: 	}
001247         ?C0037?HWA_MIFARE:
  116: 	hwa_mifareDecrypt((UINT8*)&s_BackupBuff);
001247 5167              ACALL    ?L?COM0027
001249 31F7              ACALL    _hwa_mifareDecrypt
  117: 	crcBak = hwa_mifareCheckOut((UINT8*)&s_BackupBuff, USE_DATA_BLOCK_LEN);
00124B 5167              ACALL    ?L?COM0027
;---- Variable 'crcBak' assigned to Register 'R4/R5' ----
00124D 9166              ACALL    ?L?COM002E
00124F AC06              MOV      R4,AR6
  118: 	if (crcBak == (s_BackupBuff.crc[0] << 8 | s_BackupBuff.crc[1]))
001251 900072            MOV      DPTR,#s_BackupBuff+02H
001254 E0                MOVX     A,@DPTR
001255 FE                MOV      R6,A
001256 A3                INC      DPTR
001257 E0                MOVX     A,@DPTR
001258 FB                MOV      R3,A
001259 EB                MOV      A,R3
00125A B50507            CJNE     A,AR5,?C0038?HWA_MIFARE
00125D EE                MOV      A,R6
00125E B50403            CJNE     A,AR4,?C0038?HWA_MIFARE
  119: 	{
  120: 		BackupErrorFlag = FALSE;
001261 C204              CLR      BackupErrorFlag
  121: 	}
001263 22                RET      
001264         ?C0038?HWA_MIFARE:
  122: 	else
  123: 	{
  124: 		BackupErrorFlag = TRUE;
001264 D204              SETB     BackupErrorFlag
  125: 	}
  126: }
001266 22                RET      
----- FUNCTION hwa_mifareCheckBlock (END) -------


----- FUNCTION ?L?COM0027 (BEGIN) -----
001267 7B01              MOV      R3,#01H
001269 7A00              MOV      R2,#HIGH s_BackupBuff
00126B 7970              MOV      R1,#LOW s_BackupBuff
00126D 22                RET      
----- FUNCTION ?L?COM0027 (END) -------


----- FUNCTION _hwa_mifareReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  155: BOOL hwa_mifareReadSector(UINT8 *dat, UINT8 sector)
  156: {
00126E 900040            MOV      DPTR,#dat
001271 120EEB            LCALL    ?L?COM0004
001274 A3                INC      DPTR
001275 ED                MOV      A,R5
001276 F0                MOVX     @DPTR,A
  157: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  158: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
001277 B107              ACALL    ?L?COM0032
  159: 
  160: 	if (dat != NULL && sector > 0 && sector < 16)
001279 900040            MOV      DPTR,#dat
00127C 1207F0            LCALL    ?L?COM0002
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 58


00127F 4A                ORL      A,R2
001280 4B                ORL      A,R3
001281 7002              JNZ      $ + 4H
001283 6131              AJMP     ?C0044?HWA_MIFARE
001285 A3                INC      DPTR
001286 E0                MOVX     A,@DPTR
001287 FF                MOV      R7,A
001288 D3                SETB     C
001289 9400              SUBB     A,#00H
00128B 5002              JNC      $ + 4H
00128D 6131              AJMP     ?C0044?HWA_MIFARE
00128F EF                MOV      A,R7
001290 9410              SUBB     A,#010H
001292 4002              JC       $ + 4H
001294 6131              AJMP     ?C0044?HWA_MIFARE
  161: 	{
  162: 		if (hwa_mifareReadBlock((UINT8*)&s_NormalBuff, block) == FALSE)
001296 7135              ACALL    ?L?COM0015
001298 A3                INC      DPTR
001299 E0                MOVX     A,@DPTR
00129A FD                MOV      R5,A
00129B 120FA0            LCALL    _hwa_mifareReadBlock
00129E 4001              JC       ?C0045?HWA_MIFARE
  163: 		{
  164: 			return FALSE;
0012A0 22                RET      
  165: 		}
0012A1         ?C0045?HWA_MIFARE:
  166: 
  167: 		if (hwa_mifareReadBlock((UINT8*)&s_BackupBuff, block) == FALSE)
0012A1 5167              ACALL    ?L?COM0027
0012A3 900044            MOV      DPTR,#block
0012A6 E0                MOVX     A,@DPTR
0012A7 FD                MOV      R5,A
0012A8 120FA0            LCALL    _hwa_mifareReadBlock
0012AB 4001              JC       ?C0047?HWA_MIFARE
  168: 		{
  169: 			return FALSE;
0012AD 22                RET      
  170: 		}
0012AE         ?C0047?HWA_MIFARE:
  171: 
  172: 		hwa_mifareCheckBlock();
0012AE 5127              ACALL    hwa_mifareCheckBlock
  173: 
  174: 		if (NormalErrorFlag && BackupErrorFlag)				//正常块和备份块都校验错误
0012B0 30050C            JNB      NormalErrorFlag,?C0048?HWA_MIFARE
0012B3 300409            JNB      BackupErrorFlag,?C0048?HWA_MIFARE
  175: 		{
  176: 			hwa_mifareRecoveryOldCard(sector);				//兼容旧卡
0012B6 900043            MOV      DPTR,#sector
0012B9 E0                MOVX     A,@DPTR
0012BA FF                MOV      R7,A
0012BB 713C              ACALL    _hwa_mifareRecoveryOldCard
  177: 			return FALSE;
0012BD C3                CLR      C
0012BE 22                RET      
  178: 		}
0012BF         ?C0048?HWA_MIFARE:
  179: 		else if (BackupErrorFlag)							//备份块校验错误
0012BF 30040C            JNB      BackupErrorFlag,?C0050?HWA_MIFARE
  180: 		{
  181: 			if (hwa_mifareWriteBlock((UINT8*)&s_NormalBuff, blockBak) == FALSE)
0012C2 7135              ACALL    ?L?COM0015
0012C4 900045            MOV      DPTR,#blockBak
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 59


0012C7 E0                MOVX     A,@DPTR
0012C8 FD                MOV      R5,A
0012C9 9105              ACALL    _hwa_mifareWriteBlock
0012CB 4028              JC       ?C0049?HWA_MIFARE
  182: 			{
  183: 				return FALSE;
0012CD 22                RET      
  184: 			}
  185: 		}
0012CE         ?C0050?HWA_MIFARE:
  186: 		else if (NormalErrorFlag							//正常块校验错误
0012CE 200518            JB       NormalErrorFlag,?C0054?HWA_MIFARE
0012D1 900072            MOV      DPTR,#s_BackupBuff+02H
0012D4 E0                MOVX     A,@DPTR
0012D5 FF                MOV      R7,A
0012D6 900082            MOV      DPTR,#s_NormalBuff+02H
0012D9 E0                MOVX     A,@DPTR
0012DA B5070C            CJNE     A,AR7,?C0054?HWA_MIFARE
0012DD 900073            MOV      DPTR,#s_BackupBuff+03H
0012E0 E0                MOVX     A,@DPTR
0012E1 FF                MOV      R7,A
0012E2 900083            MOV      DPTR,#s_NormalBuff+03H
0012E5 E0                MOVX     A,@DPTR
0012E6 6F                XRL      A,R7
0012E7 600C              JZ       ?C0049?HWA_MIFARE
0012E9         ?C0054?HWA_MIFARE:
  187: 			|| s_NormalBuff.crc[0] != s_BackupBuff.crc[0]	//正常块和备份块校验正确但数据不一样，用备份块替换正常块
  188: 			|| s_NormalBuff.crc[1] != s_BackupBuff.crc[1]
  189: 			)
  190: 		{
  191: 			if (hwa_mifareWriteBlock((UINT8*)&s_BackupBuff, block) == FALSE)
0012E9 5167              ACALL    ?L?COM0027
0012EB 900044            MOV      DPTR,#block
0012EE E0                MOVX     A,@DPTR
0012EF FD                MOV      R5,A
0012F0 9105              ACALL    _hwa_mifareWriteBlock
0012F2 4001              JC       ?C0049?HWA_MIFARE
  192: 			{
  193: 				return FALSE;
0012F4 22                RET      
  194: 			}
  195: 		}
0012F5         ?C0049?HWA_MIFARE:
  196: 		if (BackupErrorFlag)
0012F5 900040            MOV      DPTR,#dat
0012F8 1207F0            LCALL    ?L?COM0002
0012FB F8                MOV      R0,A
0012FC AC02              MOV      R4,AR2
0012FE AD03              MOV      R5,AR3
001300 7B01              MOV      R3,#01H
001302 300406            JNB      BackupErrorFlag,?C0056?HWA_MIFARE
  197: 		{
  198: 			memcpy(dat, (UINT8*)&s_NormalBuff, DATA_BLOCK_SIZE);
001305 7A00              MOV      R2,#HIGH s_NormalBuff
001307 7980              MOV      R1,#LOW s_NormalBuff
  199: 		}
001309 8004              SJMP     ?C0072?HWA_MIFARE
00130B         ?C0056?HWA_MIFARE:
  200: 		else
  201: 		{
  202: 			memcpy(dat, (UINT8*)&s_BackupBuff, DATA_BLOCK_SIZE);
00130B 7A00              MOV      R2,#HIGH s_BackupBuff
00130D 7970              MOV      R1,#LOW s_BackupBuff
00130F         
00130F 91F8              ACALL    ?L?COM0037
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 60


  203: 		}
001311         ?C0057?HWA_MIFARE:
  204: 		if (*(UINT16*)dat > 50000)
001311 900040            MOV      DPTR,#dat
001314 1207F0            LCALL    ?L?COM0002
001317 F9                MOV      R1,A
001318 120213            LCALL    ?C?ILDPTR
00131B FF                MOV      R7,A
00131C AEF0              MOV      R6,B
00131E E4                CLR      A
00131F FC                MOV      R4,A
001320 FD                MOV      R5,A
001321 7B50              MOV      R3,#050H
001323 7AC3              MOV      R2,#0C3H
001325 F9                MOV      R1,A
001326 F8                MOV      R0,A
001327 C3                CLR      C
001328 12032B            LCALL    ?C?SLCMP
00132B 5002              JNC      ?C0058?HWA_MIFARE
  205: 		{
  206: 			return FALSE;
00132D C3                CLR      C
00132E 22                RET      
  207: 		}
00132F         ?C0058?HWA_MIFARE:
  208: 		return TRUE;
00132F D3                SETB     C
001330 22                RET      
  209: 	}
001331         ?C0044?HWA_MIFARE:
  210: 	return FALSE;
001331 C3                CLR      C
  211: }
001332 22                RET      
----- FUNCTION _hwa_mifareReadSector (END) -------


----- FUNCTION ?L?COM0014 (BEGIN) -----
001333 EF                MOV      A,R7
001334 F0                MOVX     @DPTR,A
001335         ?L?COM0015:
001335 7B01              MOV      R3,#01H
001337 7A00              MOV      R2,#HIGH s_NormalBuff
001339 7980              MOV      R1,#LOW s_NormalBuff
00133B 22                RET      
----- FUNCTION ?L?COM0014 (END) -------


----- FUNCTION _hwa_mifareRecoveryOldCard (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  128: static void hwa_mifareRecoveryOldCard(UINT8 sector)
  129: {
00133C 900046            MOV      DPTR,#sector
00133F 7133              ACALL    ?L?COM0014
001341 9131              ACALL    _hwa_mifareEncrypt
  130: 	UINT8 money;
  131: 	hwa_mifareEncrypt((UINT8*)&s_NormalBuff);
  132: 	money = *(UINT8*)&s_NormalBuff;
001343 900080            MOV      DPTR,#s_NormalBuff
001346 E0                MOVX     A,@DPTR
001347 900047            MOV      DPTR,#money
00134A F0                MOVX     @DPTR,A
  133: 	if (money != 0xFF && money <= 200
00134B F4                CPL      A
00134C 601D              JZ       ?C0041?HWA_MIFARE
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 61


00134E E0                MOVX     A,@DPTR
00134F FF                MOV      R7,A
001350 D3                SETB     C
001351 94C8              SUBB     A,#0C8H
001353 5016              JNC      ?C0041?HWA_MIFARE
001355 900082            MOV      DPTR,#s_NormalBuff+02H
001358 E0                MOVX     A,@DPTR
001359 7010              JNZ      ?C0041?HWA_MIFARE
00135B A3                INC      DPTR
00135C E0                MOVX     A,@DPTR
00135D 700C              JNZ      ?C0041?HWA_MIFARE
  134: 		&& s_NormalBuff.crc[0] == 0
  135: 		&& s_NormalBuff.crc[1] == 0
  136: 		)
  137: 	{
  138: 		s_NormalBuff.money = (UINT16)money * 100;
00135F 9170              ACALL    ?L?COM004B
001361 900080            MOV      DPTR,#s_NormalBuff
001364 EE                MOV      A,R6
001365 F0                MOVX     @DPTR,A
001366 A3                INC      DPTR
001367 7133              ACALL    ?L?COM0014
001369 802C              SJMP     ?C0071?HWA_MIFARE
  139: 		hwa_mifareWriteSector((UINT8*)&s_NormalBuff, sector);
  140: 		return;
  141: 	}
00136B         ?C0041?HWA_MIFARE:
  142: 	hwa_mifareEncrypt((UINT8*)&s_BackupBuff);
00136B 5167              ACALL    ?L?COM0027
00136D 9131              ACALL    _hwa_mifareEncrypt
  143: 	money = *(UINT8*)&s_BackupBuff;
00136F 900070            MOV      DPTR,#s_BackupBuff
001372 E0                MOVX     A,@DPTR
001373 900047            MOV      DPTR,#money
001376 F0                MOVX     @DPTR,A
  144: 	if (money != 0xFF && money <= 200
001377 F4                CPL      A
001378 6024              JZ       ?C0042?HWA_MIFARE
00137A E0                MOVX     A,@DPTR
00137B FF                MOV      R7,A
00137C D3                SETB     C
00137D 94C8              SUBB     A,#0C8H
00137F 501D              JNC      ?C0042?HWA_MIFARE
001381 900072            MOV      DPTR,#s_BackupBuff+02H
001384 E0                MOVX     A,@DPTR
001385 7017              JNZ      ?C0042?HWA_MIFARE
001387 A3                INC      DPTR
001388 E0                MOVX     A,@DPTR
001389 7013              JNZ      ?C0042?HWA_MIFARE
  145: 		&& s_BackupBuff.crc[0] == 0
  146: 		&& s_BackupBuff.crc[1] == 0
  147: 		)
  148: 	{
  149: 		s_BackupBuff.money = (UINT16)money * 100;
00138B 9170              ACALL    ?L?COM004B
00138D 900070            MOV      DPTR,#s_BackupBuff
001390 EE                MOV      A,R6
001391 F0                MOVX     @DPTR,A
001392 A3                INC      DPTR
001393 EF                MOV      A,R7
001394 F0                MOVX     @DPTR,A
  150: 		hwa_mifareWriteSector((UINT8*)&s_BackupBuff, sector);
001395 5167              ACALL    ?L?COM0027
001397         
001397 900046            MOV      DPTR,#sector
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 62


00139A E0                MOVX     A,@DPTR
00139B FD                MOV      R5,A
00139C 719F              ACALL    _hwa_mifareWriteSector
  151: 		return;
  152: 	}
  153: }
00139E         ?C0042?HWA_MIFARE:
00139E 22                RET      
----- FUNCTION _hwa_mifareRecoveryOldCard (END) -------


----- FUNCTION _hwa_mifareWriteSector (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  213: BOOL hwa_mifareWriteSector(UINT8 *dat, UINT8 sector)
  214: {
00139F 900048            MOV      DPTR,#dat
0013A2 120EEB            LCALL    ?L?COM0004
;---- Variable 'sector' assigned to Register 'R5' ----
  215: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  216: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
0013A5 ED                MOV      A,R5
0013A6 B107              ACALL    ?L?COM0032
  217: 	UINT16 crc;
  218: 	if (dat != NULL && sector > 0 && sector < 16)
0013A8 1207ED            LCALL    ?L?COM0001
0013AB 4A                ORL      A,R2
0013AC 4B                ORL      A,R3
0013AD 6054              JZ       ?C0059?HWA_MIFARE
0013AF ED                MOV      A,R5
0013B0 D3                SETB     C
0013B1 9400              SUBB     A,#00H
0013B3 404E              JC       ?C0059?HWA_MIFARE
0013B5 ED                MOV      A,R5
0013B6 9410              SUBB     A,#010H
0013B8 5049              JNC      ?C0059?HWA_MIFARE
  219: 	{
  220: 		crc = hwa_mifareCheckOut(dat, USE_DATA_BLOCK_LEN);
0013BA 900048            MOV      DPTR,#dat
0013BD A3                INC      DPTR
0013BE A3                INC      DPTR
0013BF E0                MOVX     A,@DPTR
0013C0 F9                MOV      R1,A
;---- Variable 'crc' assigned to Register 'R4/R5' ----
0013C1 9166              ACALL    ?L?COM002E
0013C3 AC06              MOV      R4,AR6
  221: 		dat[USE_DATA_BLOCK_LEN] = (UINT8)(crc >> 8);
0013C5 EC                MOV      A,R4
0013C6 FF                MOV      R7,A
0013C7 1207ED            LCALL    ?L?COM0001
0013CA F9                MOV      R1,A
0013CB 900002            MOV      DPTR,#02H
0013CE EF                MOV      A,R7
0013CF 120174            LCALL    ?C?CSTOPTR
  222: 		dat[USE_DATA_BLOCK_LEN + 1] = (UINT8)(crc & 0xFF);
0013D2 ED                MOV      A,R5
0013D3 900003            MOV      DPTR,#03H
0013D6 120174            LCALL    ?C?CSTOPTR
  223: 		memcpy((UINT8*)&s_NormalBuff, dat, 16);
0013D9 7880              MOV      R0,#LOW s_NormalBuff
0013DB 7C00              MOV      R4,#HIGH s_NormalBuff
0013DD 7D01              MOV      R5,#01H
0013DF 1207ED            LCALL    ?L?COM0001
0013E2 F9                MOV      R1,A
0013E3 91F8              ACALL    ?L?COM0037
  224: 		hwa_mifareEncrypt((UINT8*)&s_NormalBuff);
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 63


0013E5 7135              ACALL    ?L?COM0015
0013E7 9131              ACALL    _hwa_mifareEncrypt
  225: 		if (hwa_mifareWriteBlock((UINT8*)&s_NormalBuff, block) == FALSE)
0013E9 7135              ACALL    ?L?COM0015
0013EB 90004B            MOV      DPTR,#block
0013EE E0                MOVX     A,@DPTR
0013EF FD                MOV      R5,A
0013F0 9105              ACALL    _hwa_mifareWriteBlock
0013F2 4001              JC       ?C0060?HWA_MIFARE
  226: 		{
  227: 			return FALSE;
0013F4 22                RET      
  228: 		}
0013F5         ?C0060?HWA_MIFARE:
  229: 		if (hwa_mifareWriteBlock((UINT8*)&s_NormalBuff, blockBak) == FALSE)
0013F5 7135              ACALL    ?L?COM0015
0013F7 90004C            MOV      DPTR,#blockBak
0013FA E0                MOVX     A,@DPTR
0013FB FD                MOV      R5,A
0013FC 9105              ACALL    _hwa_mifareWriteBlock
0013FE 4001              JC       ?C0062?HWA_MIFARE
  230: 		{
  231: 			return FALSE;
001400 22                RET      
  232: 		}
001401         ?C0062?HWA_MIFARE:
  233: 		return TRUE;
001401 D3                SETB     C
001402 22                RET      
  234: 	}
001403         ?C0059?HWA_MIFARE:
  235: 	return FALSE;
001403 C3                CLR      C
  236: }
001404 22                RET      
----- FUNCTION _hwa_mifareWriteSector (END) -------


----- FUNCTION _hwa_mifareWriteBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   72: BOOL hwa_mifareWriteBlock(UINT8 *buff, UINT8 block)
   73: {
001405 90004D            MOV      DPTR,#buff
001408 120EEB            LCALL    ?L?COM0004
00140B A3                INC      DPTR
00140C ED                MOV      A,R5
00140D F0                MOVX     @DPTR,A
   74: 	UINT8 u8_ReadErrCount;
   75: 	UINT8 u8_Result;
   76: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
00140E E4                CLR      A
00140F A3                INC      DPTR
001410 F0                MOVX     @DPTR,A
001411         ?C0025?HWA_MIFARE:
   77: 	{
   78: 		u8_Result = Write_Block(buff, block);
001411 90004D            MOV      DPTR,#buff
001414 1207F0            LCALL    ?L?COM0002
001417 F9                MOV      R1,A
001418 A3                INC      DPTR
001419 E0                MOVX     A,@DPTR
00141A FD                MOV      R5,A
00141B B177              ACALL    _Write_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   79: 		if (u8_Result == FM1702_OK)
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 64


00141D EF                MOV      A,R7
00141E 7002              JNZ      ?C0028?HWA_MIFARE
   80: 		{
   81: 			return TRUE;
001420 D3                SETB     C
001421 22                RET      
   82: 		}
001422         ?C0028?HWA_MIFARE:
   83: 		else if (u8_Result == FM1702_NOTAGERR)
001422 EF                MOV      A,R7
001423 B40102            CJNE     A,#01H,?C0027?HWA_MIFARE
   84: 		{
   85: 			return FALSE;
001426 C3                CLR      C
001427 22                RET      
   86: 		}
   87: 	}
001428         ?C0027?HWA_MIFARE:
001428 900051            MOV      DPTR,#u8_ReadErrCount
00142B B12F              ACALL    ?L?COM004C
00142D 40E2              JC       ?C0025?HWA_MIFARE
00142F         ?C0026?HWA_MIFARE:
   88: 	return FALSE;
00142F C3                CLR      C
   89: }
001430 22                RET      
----- FUNCTION _hwa_mifareWriteBlock (END) -------


----- FUNCTION _hwa_mifareEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   27: void hwa_mifareEncrypt(UINT8 *pData)        //利用卡ID加密
   28: {
001431 90004D            MOV      DPTR,#pData
001434 120EEB            LCALL    ?L?COM0004
   29: 	UINT8 i, j;
   30: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
001437 E4                CLR      A
001438 FE                MOV      R6,A
001439         ?C0004?HWA_MIFARE:
   31: 	{
   32: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
001439 7D04              MOV      R5,#04H
00143B         ?C0007?HWA_MIFARE:
   33: 		{
   34: 			pData[i] ^= gCard_UID[i % 5];
00143B 90004D            MOV      DPTR,#pData
00143E 1207F0            LCALL    ?L?COM0002
001441 31DD              ACALL    ?L?COM0010
001443 E0                MOVX     A,@DPTR
001444 6F                XRL      A,R7
001445 120162            LCALL    ?C?CSTPTR
   35: 			pData[i] = _cror_(pData[i], 1);
001448 90004D            MOV      DPTR,#pData
00144B 1207F0            LCALL    ?L?COM0002
00144E F9                MOV      R1,A
00144F 8E82              MOV      DPL,R6
001451 917A              ACALL    ?L?COM001A
001453 FF                MOV      R7,A
001454 7801              MOV      R0,#01H
001456 08                INC      R0
001457 8001              SJMP     ?C0064?HWA_MIFARE
001459         ?C0063?HWA_MIFARE:
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 65


001459 03                RR       A
00145A         ?C0064?HWA_MIFARE:
00145A D8FD              DJNZ     R0,?C0063?HWA_MIFARE
00145C 91FF              ACALL    ?L?COM0044
   36: 		}
00145E DDDB              DJNZ     R5,?C0007?HWA_MIFARE
   37: 	}
001460         ?C0006?HWA_MIFARE:
001460 0E                INC      R6
001461 EE                MOV      A,R6
001462 B404D4            CJNE     A,#04H,?C0004?HWA_MIFARE
   38: }
001465 22                RET      
----- FUNCTION _hwa_mifareEncrypt (END) -------


----- FUNCTION ?L?COM002E (BEGIN) -----
001466 7D02              MOV      R5,#02H
001468 7C00              MOV      R4,#00H
00146A 120E97            LCALL    _hwa_mifareCheckOut
00146D AD07              MOV      R5,AR7
00146F 22                RET      
----- FUNCTION ?L?COM002E (END) -------


----- FUNCTION ?L?COM004B (BEGIN) -----
001470 FE                MOV      R6,A
001471 FC                MOV      R4,A
001472 7D64              MOV      R5,#064H
001474 020196            LJMP     ?C?IMUL
----- FUNCTION ?L?COM004B (END) -------


----- FUNCTION ?L?COM0018 (BEGIN) -----
001477 F9                MOV      R1,A
001478         ?L?COM0019:
001478 8F82              MOV      DPL,R7
00147A         ?L?COM001A:
00147A 758300            MOV      DPH,#00H
00147D 020135            LJMP     ?C?CLDOPTR
----- FUNCTION ?L?COM0018 (END) -------


----- FUNCTION _Load_Key (BEGIN) -----
 FILE: 'Driver\mifare.c'
  406: uchar Load_Key(uchar *ramadr)
  407: {
001480 120EE8            LCALL    ?L?COM0003
  408: 	uchar acktemp,temp[1],i;
  409: 	uchar ucBuff[12];
  410: 	for (i=0;i<6;i++)
;---- Variable 'i' assigned to Register 'R7' ----
001483 E4                CLR      A
001484 FF                MOV      R7,A
001485         ?C0089?MIFARE:
  411: 	{
  412: 		temp[0]=ramadr[i];
001485 900043            MOV      DPTR,#ramadr
001488 1207F0            LCALL    ?L?COM0002
00148B 9177              ACALL    ?L?COM0018
00148D 900047            MOV      DPTR,#temp
001490 F0                MOVX     @DPTR,A
001491 FD                MOV      R5,A
  413: 		ucBuff[2*i]=(((ramadr[i]&0xf0)>>4)|((~ramadr[i])&0xf0));
001492 54F0              ANL      A,#0F0H
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 66


001494 C4                SWAP     A
001495 540F              ANL      A,#0FH
001497 FE                MOV      R6,A
001498 9178              ACALL    ?L?COM0019
00149A F4                CPL      A
00149B 91F0              ACALL    ?L?COM004A
00149D 2448              ADD      A,#LOW ucBuff
00149F F582              MOV      DPL,A
0014A1 E4                CLR      A
0014A2 3400              ADDC     A,#HIGH ucBuff
0014A4 F583              MOV      DPH,A
0014A6 EE                MOV      A,R6
0014A7 F0                MOVX     @DPTR,A
  414: 		ucBuff[2*i+1]=((temp[0]&0xf)|(~(temp[0]&0xf)<<4));
0014A8 ED                MOV      A,R5
0014A9 540F              ANL      A,#0FH
0014AB FE                MOV      R6,A
0014AC F4                CPL      A
0014AD FD                MOV      R5,A
0014AE C4                SWAP     A
0014AF 91F0              ACALL    ?L?COM004A
0014B1 2449              ADD      A,#LOW ucBuff+01H
0014B3 F582              MOV      DPL,A
0014B5 E4                CLR      A
0014B6 3400              ADDC     A,#HIGH ucBuff+01H
0014B8 120FF9            LCALL    ?L?COM0026
0014BB B406C7            CJNE     A,#06H,?C0089?MIFARE
0014BE         ?C0090?MIFARE:
  415: 	}
  416: 	acktemp=Command_Send(LOAD_KEY, ucBuff, 12);
0014BE 7B01              MOV      R3,#01H
0014C0 7A00              MOV      R2,#HIGH ucBuff
0014C2 7948              MOV      R1,#LOW ucBuff
0014C4 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
0014C7 740C              MOV      A,#0CH
0014C9 F0                MOVX     @DPTR,A
0014CA 7F19              MOV      R7,#019H
0014CC 120595            LCALL    _Command_Send
0014CF 900046            MOV      DPTR,#acktemp
0014D2 EF                MOV      A,R7
0014D3 F0                MOVX     @DPTR,A
  417: 	temp[0] = SPIReadOne(SecondaryStatus_Reg);
0014D4 7F05              MOV      R7,#05H
0014D6 1204FD            LCALL    _SPIReadOne
0014D9 A3                INC      DPTR
0014DA EF                MOV      A,R7
0014DB F0                MOVX     @DPTR,A
  418: 	if (temp[0]&0x40)
0014DC 30E607            JNB      ACC.6,?C0092?MIFARE
  419: 	{
  420: 		temp[0]=0x0;
0014DF E4                CLR      A
0014E0 1204C4            LCALL    ?L?COM0031
  421: 		SPIWriteOne(Command_Reg,temp[0]);
  422: 		return(0);
0014E3 7F00              MOV      R7,#00H
0014E5 22                RET      
  423: 	}
0014E6         ?C0092?MIFARE:
  424: 	temp[0]=0x0;
0014E6 E4                CLR      A
0014E7 900047            MOV      DPTR,#temp
0014EA 1204C4            LCALL    ?L?COM0031
  425: 	SPIWriteOne(Command_Reg,temp[0]);
  426: 	return(1);
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 67


0014ED 7F01              MOV      R7,#01H
  427: }
0014EF 22                RET      
----- FUNCTION _Load_Key (END) -------


----- FUNCTION ?L?COM004A (BEGIN) -----
0014F0 54F0              ANL      A,#0F0H
0014F2 4E                ORL      A,R6
0014F3 FE                MOV      R6,A
0014F4 EF                MOV      A,R7
0014F5 25E0              ADD      A,ACC
0014F7 22                RET      
----- FUNCTION ?L?COM004A (END) -------


----- FUNCTION ?L?COM0037 (BEGIN) -----
0014F8 7E00              MOV      R6,#00H
0014FA 7F10              MOV      R7,#010H
0014FC 0200F6            LJMP     ?C?COPY
----- FUNCTION ?L?COM0037 (END) -------


----- FUNCTION ?L?COM0044 (BEGIN) -----
0014FF 8E82              MOV      DPL,R6
001501 758300            MOV      DPH,#00H
001504 020174            LJMP     ?C?CSTOPTR
----- FUNCTION ?L?COM0044 (END) -------


----- FUNCTION ?L?COM0032 (BEGIN) -----
001507 25E0              ADD      A,ACC
001509 25E0              ADD      A,ACC
00150B FE                MOV      R6,A
00150C 04                INC      A
00150D A3                INC      DPTR
00150E F0                MOVX     @DPTR,A
00150F EE                MOV      A,R6
001510 2402              ADD      A,#02H
001512 A3                INC      DPTR
001513 F0                MOVX     @DPTR,A
001514 22                RET      
----- FUNCTION ?L?COM0032 (END) -------


----- FUNCTION sys_uartInit (BEGIN) -----
 FILE: 'System\sys_uart.c'
   13: void sys_uartInit(void)
   14: {
   15:     ACC = P_SW1;
   16:     ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
001515 E5A2              MOV      A,P_SW1
   17:     P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
001517 543F              ANL      A,#03FH
   18:     SCON = 0x50;                //8位可变波特率
001519 F5A2              MOV      P_SW1,A
   19:     T2L = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
00151B 759850            MOV      SCON,#050H
   20:     T2H = (65536 - (FOSC/4/BAUD))>>8;
00151E 75D7E0            MOV      T2L,#0E0H
   21:     AUXR |= 0x14;                //T2为1T模式, 并启动定时器2
001521 75D6FE            MOV      T2H,#0FEH
   22:     AUXR |= 0x01;               //选择定时器2为串口1的波特率发生器
001524 438E14            ORL      AUXR,#014H
   23:     ES = 1;                     //使能串口1中断
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 68


001527 438E01            ORL      AUXR,#01H
   24:     EA = 1;
00152A D2AC              SETB     ES
   25: }
00152C D2AF              SETB     EA
   26: 
00152E 22                RET      
----- FUNCTION sys_uartInit (END) -------


----- FUNCTION ?L?COM004C (BEGIN) -----
00152F E0                MOVX     A,@DPTR
001530 04                INC      A
001531 F0                MOVX     @DPTR,A
001532 E0                MOVX     A,@DPTR
001533 C3                CLR      C
001534 9403              SUBB     A,#03H
001536 22                RET      
----- FUNCTION ?L?COM004C (END) -------


----- FUNCTION ?L?COM0046 (BEGIN) -----
001537 E0                MOVX     A,@DPTR
001538 FC                MOV      R4,A
001539 A3                INC      DPTR
00153A E0                MOVX     A,@DPTR
00153B FD                MOV      R5,A
00153C D3                SETB     C
00153D 9F                SUBB     A,R7
00153E EC                MOV      A,R4
00153F 22                RET      
----- FUNCTION ?L?COM0046 (END) -------


----- FUNCTION ?L?COM003D (BEGIN) -----
001540 D2A6              SETB     LED_CS0
001542 D2A7              SETB     LED_CS1
001544 D2A0              SETB     LED_CS2
001546 D2CD              SETB     LED_CS3
001548 D2CC              SETB     LED_CS4
00154A 22                RET      
----- FUNCTION ?L?COM003D (END) -------


----- FUNCTION _Write_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  212: void Write_FIFO(uchar *buff,uchar count)
  213: {
00154B 90006C            MOV      DPTR,#buff
00154E 120EEB            LCALL    ?L?COM0004
001551 A3                INC      DPTR
001552 ED                MOV      A,R5
001553 F0                MOVX     @DPTR,A
  214: 	uchar i;
  215: 	if(count == 0)
001554 6020              JZ       ?C0045?MIFARE
001556         ?C0044?MIFARE:
  216:         return;
  217: 	for(i=0;i<count;i++)
;---- Variable 'i' assigned to Register 'R4' ----
001556 E4                CLR      A
001557 FC                MOV      R4,A
001558         ?C0046?MIFARE:
001558 90006F            MOV      DPTR,#count
00155B E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 69


00155C FF                MOV      R7,A
00155D EC                MOV      A,R4
00155E C3                CLR      C
00155F 9F                SUBB     A,R7
001560 5014              JNC      ?C0045?MIFARE
  218: 		SPIWriteOne(FIFO_Reg,buff[i]);
001562 90006C            MOV      DPTR,#buff
001565 1207F0            LCALL    ?L?COM0002
001568 F9                MOV      R1,A
001569 8C82              MOV      DPL,R4
00156B 917A              ACALL    ?L?COM001A
00156D FD                MOV      R5,A
00156E 7F02              MOV      R7,#02H
001570 1204C8            LCALL    _SPIWriteOne
001573 0C                INC      R4
001574 80E2              SJMP     ?C0046?MIFARE
  219: //		SPIWrite(FIFO_Reg,buff,count);
  220: }
001576         ?C0045?MIFARE:
001576 22                RET      
----- FUNCTION _Write_FIFO (END) -------


----- FUNCTION _Write_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  566: uchar Write_Block(uchar *buff,uchar index)
  567: {
001577 900052            MOV      DPTR,#buff
00157A 120EEB            LCALL    ?L?COM0004
;---- Variable 'index' assigned to Register 'R4' ----
00157D AC05              MOV      R4,AR5
  568:     uchar ucCmdLine[2],ucResult,ucData[16];
  569:     SPIWriteOne(ChannelRedundancy_Reg,0x07);   /* Note: this line is for 1702, different from RC500*/
00157F 7D07              MOV      R5,#07H
001581 7F22              MOV      R7,#022H
001583 1204C8            LCALL    _SPIWriteOne
  570:     ucCmdLine[0] = RF_CMD_WRITE;
001586 A3                INC      DPTR
001587 74A0              MOV      A,#0A0H
001589 F0                MOVX     @DPTR,A
  571:     ucCmdLine[1] = index;
00158A A3                INC      DPTR
00158B EC                MOV      A,R4
00158C F0                MOVX     @DPTR,A
  572:     ucResult = Command_Send(Transceive,ucCmdLine,2);
00158D 7B01              MOV      R3,#01H
00158F 7A00              MOV      R2,#HIGH ucCmdLine
001591 7955              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
001593 1207A4            LCALL    ?L?COM0020
001596 7003              JNZ      ?C0115?MIFARE
  573:     if(ucResult == FALSE)
  574:         return FM1702_NOTAGERR;
001598 7F01              MOV      R7,#01H
00159A 22                RET      
00159B         ?C0115?MIFARE:
  575:     ucResult = Read_FIFO(ucData);
00159B 7B01              MOV      R3,#01H
00159D 7A00              MOV      R2,#HIGH ucData
00159F 7957              MOV      R1,#LOW ucData
0015A1 1207B0            LCALL    _Read_FIFO
  576:     if(ucResult == 0)
0015A4 EF                MOV      A,R7
0015A5 7003              JNZ      ?C0117?MIFARE
  577:         return FM1702_BYTECOUNTERR;
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 70


0015A7 7F0C              MOV      R7,#0CH
0015A9 22                RET      
0015AA         ?C0117?MIFARE:
  578:     switch(ucData[0])
0015AA 900057            MOV      DPTR,#ucData
0015AD E0                MOVX     A,@DPTR
0015AE 14                DEC      A
0015AF 6015              JZ       ?C0122?MIFARE
0015B1 24FD              ADD      A,#0FDH
0015B3 600E              JZ       ?C0120?MIFARE
0015B5 14                DEC      A
0015B6 6011              JZ       ?C0123?MIFARE
0015B8 24FB              ADD      A,#0FBH
0015BA 6013              JZ       ?C0118?MIFARE
0015BC 240A              ADD      A,#0AH
0015BE 700C              JNZ      ?C0124?MIFARE
  579:     {
  580: 	    case 0x00:	return(FM1702_NOTAUTHERR);	
0015C0         ?C0119?MIFARE:
0015C0 7F0A              MOV      R7,#0AH
0015C2 22                RET      
  581: 	    case 0x04:	return(FM1702_EMPTY);
0015C3         ?C0120?MIFARE:
0015C3 7F03              MOV      R7,#03H
0015C5 22                RET      
  582: 	    case 0x0a:	break;                   //正常
  583: 	    case 0x01:	return(FM1702_CRCERR);
0015C6         ?C0122?MIFARE:
0015C6 7F02              MOV      R7,#02H
0015C8 22                RET      
  584: 	    case 0x05:	return(FM1702_PARITYERR); 
0015C9         ?C0123?MIFARE:
0015C9 7F05              MOV      R7,#05H
0015CB 22                RET      
  585: 	    default:	return(FM1702_WRITEERR);
0015CC         ?C0124?MIFARE:
0015CC 7F0F              MOV      R7,#0FH
0015CE 22                RET      
  586:     }
0015CF         ?C0118?MIFARE:
  587:     ucResult = Command_Send(Transceive,buff,16);
0015CF 900052            MOV      DPTR,#buff
0015D2 1207F0            LCALL    ?L?COM0002
0015D5 F9                MOV      R1,A
0015D6 90006B            MOV      DPTR,#?_Command_Send?BYTE+04H
0015D9 7410              MOV      A,#010H
0015DB 1207A9            LCALL    ?L?COM0021
0015DE B40103            CJNE     A,#01H,?C0125?MIFARE
  588:     if(ucResult == TRUE)
  589:         return FM1702_OK;
0015E1 7F00              MOV      R7,#00H
0015E3 22                RET      
0015E4         ?C0125?MIFARE:
  590:     else
  591:     {
  592:         ucResult = SPIReadOne(ErrorFlag_Reg);
0015E4 120754            LCALL    ?L?COM0024
0015E7 30E103            JNB      ACC.1,?C0127?MIFARE
0015EA 7F05              MOV      R7,#05H
0015EC 22                RET      
0015ED         ?C0127?MIFARE:
  593: 	    if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
  594: 	    else if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
0015ED EF                MOV      A,R7
0015EE 30E203            JNB      ACC.2,?C0129?MIFARE
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 71


0015F1 7F14              MOV      R7,#014H
0015F3 22                RET      
0015F4         ?C0129?MIFARE:
  595: 	    else if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
0015F4 EF                MOV      A,R7
0015F5 7F0F              MOV      R7,#0FH
0015F7 30E302            JNB      ACC.3,?C0131?MIFARE
0015FA 7F02              MOV      R7,#02H
0015FC         ?C0131?MIFARE:
  596:         else return FM1702_WRITEERR;
  597:     }
  598: }
0015FC 22                RET      
----- FUNCTION _Write_Block (END) -------


----- FUNCTION app_brushCard (BEGIN) -----
 FILE: 'App\app_brush.c'
   51: UINT8 app_brushCard(void)
   52: {
   53: 	UINT8 Sector;
   54: 	UINT8 CardIndex;
   55:     UINT8 i;
   56: 	for (CardIndex = MEM_CARD; CardIndex <= PWD_CARD; CardIndex++)
0015FD 900041            MOV      DPTR,#CardIndex
001600 7401              MOV      A,#01H
001602 F0                MOVX     @DPTR,A
001603         ?C0004?APP_BRUSH:
   57: 	{
   58: 		if (b_FactorySystem)
001603 300706            JNB      b_FactorySystem,?C0007?APP_BRUSH
   59: 		{
   60: 			CardIndex = PWD_CARD;
001606 900041            MOV      DPTR,#CardIndex
001609 7403              MOV      A,#03H
00160B F0                MOVX     @DPTR,A
   61: 		}
00160C         ?C0007?APP_BRUSH:
   62: 		if (CardIndex == MEM_CARD)
00160C 900041            MOV      DPTR,#CardIndex
00160F E0                MOVX     A,@DPTR
001610 B40108            CJNE     A,#01H,?C0008?APP_BRUSH
   63: 		{
   64: 			Load_Key(&s_System.MGM_Card);
001613 7B01              MOV      R3,#01H
001615 7A00              MOV      R2,#HIGH s_System
001617 7994              MOV      R1,#LOW s_System
   65: 		}
001619 801C              SJMP     ?C0047?APP_BRUSH
00161B         ?C0008?APP_BRUSH:
   66: 		else if (CardIndex == USER_CARD)
00161B 900041            MOV      DPTR,#CardIndex
00161E E0                MOVX     A,@DPTR
00161F B40208            CJNE     A,#02H,?C0010?APP_BRUSH
   67: 		{
   68: 			Load_Key(&s_System.USER_Card);
001622 7B01              MOV      R3,#01H
001624 7A00              MOV      R2,#HIGH s_System+0AH
001626 799E              MOV      R1,#LOW s_System+0AH
001628         
   69: 		}
001628 800D              SJMP     ?C0047?APP_BRUSH
00162A         ?C0010?APP_BRUSH:
   70: 		else if (CardIndex == PWD_CARD)
00162A 900041            MOV      DPTR,#CardIndex
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 72


00162D E0                MOVX     A,@DPTR
00162E B40308            CJNE     A,#03H,?C0009?APP_BRUSH
   71: 		{
   72: 			Load_Key(PWD_Card);
001631 7BFF              MOV      R3,#0FFH
001633 7A00              MOV      R2,#HIGH PWD_Card
001635 7903              MOV      R1,#LOW PWD_Card
001637         
001637 9180              ACALL    _Load_Key
   73: 		}
001639         ?C0009?APP_BRUSH:
   74: 		MIF_Halt();
001639 120729            LCALL    MIF_Halt
   75: 		if (Request(RF_CMD_REQUEST_STD) != FM1702_OK)
00163C 7F26              MOV      R7,#026H
00163E 1205DA            LCALL    _Request
001641 EF                MOV      A,R7
001642 7051              JNZ      ?C0006?APP_BRUSH
   76: 		{
   77: 			continue;
   78: 		}
001644         ?C0013?APP_BRUSH:
   79:         for(i=0; i<2; i++)
001644 E4                CLR      A
001645 900042            MOV      DPTR,#i
001648 F0                MOVX     @DPTR,A
001649         ?C0014?APP_BRUSH:
   80:         {
   81:             if (AntiColl() == FM1702_OK && SelectCard() == FM1702_OK)
001649 12052D            LCALL    AntiColl
00164C EF                MOV      A,R7
00164D 703A              JNZ      ?C0016?APP_BRUSH
00164F 120633            LCALL    SelectCard
001652 EF                MOV      A,R7
001653 7034              JNZ      ?C0016?APP_BRUSH
   82:             {
   83:                 if (CardIndex == USER_CARD)     //用户卡验证钱所在扇区
001655 900041            MOV      DPTR,#CardIndex
001658 E0                MOVX     A,@DPTR
001659 B4020A            CJNE     A,#02H,?C0018?APP_BRUSH
   84:                 {
   85:                     Sector = s_System.Sector;
00165C 90009A            MOV      DPTR,#s_System+06H
00165F E0                MOVX     A,@DPTR
001660 900040            MOV      DPTR,#Sector
001663 F0                MOVX     @DPTR,A
   86:                 }
001664 8006              SJMP     ?C0019?APP_BRUSH
001666         ?C0018?APP_BRUSH:
   87:                 else                            //管理和密码卡验证1扇区
   88:                 {
   89:                     Sector = 1;
001666 900040            MOV      DPTR,#Sector
001669 7401              MOV      A,#01H
00166B F0                MOVX     @DPTR,A
   90:                 }
00166C         ?C0019?APP_BRUSH:
   91:                 if (Authentication(gCard_UID, Sector, 0x60) == FM1702_OK)
00166C 7B01              MOV      R3,#01H
00166E 7A00              MOV      R2,#HIGH gCard_UID
001670 79A6              MOV      R1,#LOW gCard_UID
001672 900040            MOV      DPTR,#Sector
001675 E0                MOVX     A,@DPTR
001676 FD                MOV      R5,A
001677 900047            MOV      DPTR,#?_Authentication?BYTE+04H
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 73


00167A 7460              MOV      A,#060H
00167C F0                MOVX     @DPTR,A
00167D 120699            LCALL    _Authentication
001680 EF                MOV      A,R7
001681 7006              JNZ      ?C0016?APP_BRUSH
   92:                 {
   93:                     return CardIndex;
001683 900041            MOV      DPTR,#CardIndex
001686 E0                MOVX     A,@DPTR
001687 FF                MOV      R7,A
001688 22                RET      
   94:                 }
   95:             }
   96:         }
001689         ?C0016?APP_BRUSH:
001689 900042            MOV      DPTR,#i
00168C E0                MOVX     A,@DPTR
00168D 04                INC      A
00168E F0                MOVX     @DPTR,A
00168F E0                MOVX     A,@DPTR
001690 C3                CLR      C
001691 9402              SUBB     A,#02H
001693 40B4              JC       ?C0014?APP_BRUSH
   97: 	}
001695         ?C0006?APP_BRUSH:
001695 900041            MOV      DPTR,#CardIndex
001698 E0                MOVX     A,@DPTR
001699 04                INC      A
00169A F0                MOVX     @DPTR,A
00169B E0                MOVX     A,@DPTR
00169C D3                SETB     C
00169D 9403              SUBB     A,#03H
00169F 5002              JNC      $ + 4H
0016A1 C103              AJMP     ?C0004?APP_BRUSH
0016A3         ?C0005?APP_BRUSH:
   98: 	return NONE_CARD;
0016A3 7F00              MOV      R7,#00H
   99: }
0016A5 22                RET      
----- FUNCTION app_brushCard (END) -------


----- FUNCTION sys_uartInterrupt (BEGIN) -----
 FILE: 'System\sys_uart.c'
   27: void sys_uartInterrupt() interrupt 4
0016A6 C0E0              PUSH     ACC
0016A8 C0F0              PUSH     B
0016AA C083              PUSH     DPH
0016AC C082              PUSH     DPL
0016AE C0D0              PUSH     PSW
0016B0 75D000            MOV      PSW,#00H
0016B3 C000              PUSH     AR0
0016B5 C001              PUSH     AR1
0016B7 C002              PUSH     AR2
0016B9 C003              PUSH     AR3
0016BB C004              PUSH     AR4
0016BD C005              PUSH     AR5
0016BF C006              PUSH     AR6
0016C1 C007              PUSH     AR7
   28: {
   29:     if(RI)
0016C3 309804            JNB      RI,?C0002?SYS_UART
   30:     {
   31:         RI = 0;
0016C6 C298              CLR      RI
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 74


   32:         sys_uartRxHandler();
0016C8 D1EA              ACALL    sys_uartRxHandler
   33:     }
0016CA         ?C0002?SYS_UART:
   34:     if(TI)
0016CA 309902            JNB      TI,?C0004?SYS_UART
   35:     {
   36:         TI = 0;
0016CD C299              CLR      TI
   37:     }
   38: }
0016CF         ?C0004?SYS_UART:
0016CF D007              POP      AR7
0016D1 D006              POP      AR6
0016D3 D005              POP      AR5
0016D5 D004              POP      AR4
0016D7 D003              POP      AR3
0016D9 D002              POP      AR2
0016DB D001              POP      AR1
0016DD D000              POP      AR0
0016DF D0D0              POP      PSW
0016E1 D082              POP      DPL
0016E3 D083              POP      DPH
0016E5 D0F0              POP      B
0016E7 D0E0              POP      ACC
0016E9 32                RETI     
----- FUNCTION sys_uartInterrupt (END) -------


----- FUNCTION sys_uartRxHandler (BEGIN) -----
 FILE: 'System\sys_uart.c'
   41: void sys_uartRxHandler(void)
   42: {
   43:     if(SBUF == 0x7F)        //0x7F auto download     boud 2400 0x7F at boud 9600 is 0xF8
   44:     {
0016EA E599              MOV      A,SBUF
0016EC B47F10            CJNE     A,#07FH,?C0005?SYS_UART
   45:         RxNum++;
   46:         if(RxNum >= 40)
0016EF 9000CC            MOV      DPTR,#RxNum
0016F2 E0                MOVX     A,@DPTR
0016F3 04                INC      A
0016F4 F0                MOVX     @DPTR,A
   47:         {
0016F5 E0                MOVX     A,@DPTR
0016F6 C3                CLR      C
0016F7 9428              SUBB     A,#028H
0016F9 4009              JC       ?C0008?SYS_UART
   48:             IAP_CONTR = 0x60;
   49:         }
0016FB 75C760            MOV      IAP_CONTR,#060H
   50:     }
   51:     else
0016FE 22                RET      
0016FF         ?C0005?SYS_UART:
   52:     {
   53:         RxNum = 0;
0016FF E4                CLR      A
001700 9000CC            MOV      DPTR,#RxNum
001703 F0                MOVX     @DPTR,A
   54:     }
   55: }
001704         ?C0008?SYS_UART:
001704 22                RET      
----- FUNCTION sys_uartRxHandler (END) -------
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 75




----- FUNCTION app_pulseInit (BEGIN) -----
 FILE: 'App\app_pulse.c'
   12: void app_pulseInit(void)
   13: {
   14:     P3M1 &= ~0x80;      //推挽输出
   15:     P3M0 |= 0x80;
001705 53B17F            ANL      P3M1,#07FH
   16:     pulse = 1;
001708 43B280            ORL      P3M0,#080H
   17: }
00170B D2B7              SETB     pulse
   18: 
00170D 22                RET      
----- FUNCTION app_pulseInit (END) -------


----- FUNCTION _app_pulseSendPulse (BEGIN) -----
 FILE: 'App\app_pulse.c'
   40: void app_pulseSendPulse(UINT8 width, UINT8 n)
   41: {
;---- Variable 'n' assigned to Register 'R5' ----
;---- Variable 'width' assigned to Register 'R7' ----
   42:     u8_width = width;
   43:     u8_pulse = n;
00170E 9000C3            MOV      DPTR,#u8_width
001711 EF                MOV      A,R7
001712 F0                MOVX     @DPTR,A
   44: }
001713 A3                INC      DPTR
001714 ED                MOV      A,R5
001715 F0                MOVX     @DPTR,A
   45: 
001716 22                RET      
----- FUNCTION _app_pulseSendPulse (END) -------


----- FUNCTION hwa_eepromInit (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   33: void hwa_eepromInit(void)
   34: {
   35: }
   36: 
001717 22                RET      
----- FUNCTION hwa_eepromInit (END) -------


----- FUNCTION _hwa_eepromEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   37: void hwa_eepromEncrypt(UINT8 *dat, UINT16 size)        //加密
   38: {
001718 90004F            MOV      DPTR,#dat
00171B 120EEB            LCALL    ?L?COM0004
;---- Variable 'i' assigned to Register 'R6/R7' ----
00171E F149              ACALL    ?L?COM0040
001720         ?C0001?HWA_EEPROM_CFG:
001720 D3                SETB     C
001721 900053            MOV      DPTR,#size+01H
001724 E0                MOVX     A,@DPTR
001725 9F                SUBB     A,R7
001726 900052            MOV      DPTR,#size
001729 E0                MOVX     A,@DPTR
00172A 9E                SUBB     A,R6
00172B 401B              JC       ?C0004?HWA_EEPROM_CFG
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 76


   39: 	UINT16 i;
   40: 	UINT8 tmp;
   41: 	for (i = 0; i<size; i++)
   42: 	{
   43: 		tmp = dat[i];
00172D 90004F            MOV      DPTR,#dat
001730 1207F0            LCALL    ?L?COM0002
;---- Variable 'tmp' assigned to Register 'R5' ----
001733 F15E              ACALL    ?L?COM0033
   44: 		tmp ^= SecretKey;
   45: 		tmp = (tmp >> 1) | (tmp << 7);
001735 C4                SWAP     A
001736 33                RLC      A
001737 33                RLC      A
001738 33                RLC      A
001739 5480              ANL      A,#080H
00173B FC                MOV      R4,A
00173C ED                MOV      A,R5
00173D C3                CLR      C
00173E 13                RRC      A
00173F F153              ACALL    ?L?COM0036
   46: 		tmp ^= SecretKey;
   47: 		dat[i] = tmp;
   48: 	}
001741 0F                INC      R7
001742 BF0001            CJNE     R7,#00H,?C0009?HWA_EEPROM_CFG
001745 0E                INC      R6
001746         ?C0009?HWA_EEPROM_CFG:
001746 80D8              SJMP     ?C0001?HWA_EEPROM_CFG
   49: }
001748         ?C0004?HWA_EEPROM_CFG:
001748 22                RET      
----- FUNCTION _hwa_eepromEncrypt (END) -------


----- FUNCTION ?L?COM0040 (BEGIN) -----
001749 A3                INC      DPTR
00174A EC                MOV      A,R4
00174B F0                MOVX     @DPTR,A
00174C A3                INC      DPTR
00174D ED                MOV      A,R5
00174E F0                MOVX     @DPTR,A
00174F E4                CLR      A
001750 FF                MOV      R7,A
001751 FE                MOV      R6,A
001752 22                RET      
----- FUNCTION ?L?COM0040 (END) -------


----- FUNCTION ?L?COM0036 (BEGIN) -----
001753 4C                ORL      A,R4
001754 64A5              XRL      A,#0A5H
001756 FD                MOV      R5,A
001757 8F82              MOV      DPL,R7
001759 8E83              MOV      DPH,R6
00175B 020174            LJMP     ?C?CSTOPTR
----- FUNCTION ?L?COM0036 (END) -------


----- FUNCTION ?L?COM0033 (BEGIN) -----
00175E F9                MOV      R1,A
00175F 8F82              MOV      DPL,R7
001761 8E83              MOV      DPH,R6
001763 120135            LCALL    ?C?CLDOPTR
001766 64A5              XRL      A,#0A5H
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 77


001768 FD                MOV      R5,A
001769 22                RET      
----- FUNCTION ?L?COM0033 (END) -------


----- FUNCTION buzzer_Init (BEGIN) -----
 FILE: 'Driver\buzzer.c'
    8: void buzzer_Init(void)
    9: {
   10:     P3M1 &= ~0x20;      //推挽输出
   11:     P3M0 |= 0x20;
00176A 53B1DF            ANL      P3M1,#0DFH
   12:     P3 &= ~0x20;
00176D 43B220            ORL      P3M0,#020H
   13: }
001770 53B0DF            ANL      P3,#0DFH
   14: 
001773 22                RET      
----- FUNCTION buzzer_Init (END) -------


----- FUNCTION len_Init (BEGIN) -----
 FILE: 'Driver\LED.c'
   17: void len_Init(void)
   18: {
   19:     P1M1 &= ~0xFF;      //推挽输出
   20:     P1M0 |= 0xFF;
001774 759100            MOV      P1M1,#00H
   21:     P2M1 &= ~0xC1;      //推挽输出
001777 7592FF            MOV      P1M0,#0FFH
   22:     P2M0 |= 0xC1;
00177A 53953E            ANL      P2M1,#03EH
   23:     P5M1 &= ~0x30;      //推挽输出
00177D 4396C1            ORL      P2M0,#0C1H
   24:     P5M0 |= 0x30;
001780 53C9CF            ANL      P5M1,#0CFH
   25:     P3M1 &= ~0x40;      //推挽输出
001783 43CA30            ORL      P5M0,#030H
   26:     P3M0 |= 0x40;
001786 53B1BF            ANL      P3M1,#0BFH
   27: }
001789 43B240            ORL      P3M0,#040H
   28: 
00178C 22                RET      
----- FUNCTION len_Init (END) -------


----- FUNCTION _Read_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  532: uchar Read_Block(uchar *buff,uchar index)
  533: {
00178D 90004B            MOV      DPTR,#buff
001790 120EEB            LCALL    ?L?COM0004
;---- Variable 'index' assigned to Register 'R4' ----
001793 AC05              MOV      R4,AR5
  534:     uchar ucCmdLine[2],ucResult;
  535:     SPIWriteOne(ChannelRedundancy_Reg,0x0F);
001795 1207E7            LCALL    ?L?COM0048
  536:     ucCmdLine[0] = RF_CMD_READ;
001798 A3                INC      DPTR
001799 7430              MOV      A,#030H
00179B F0                MOVX     @DPTR,A
  537:     ucCmdLine[1] = index;
00179C A3                INC      DPTR
00179D EC                MOV      A,R4
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 78


00179E F0                MOVX     @DPTR,A
  538:     ucResult = Command_Send(Transceive,ucCmdLine,2);
00179F 7B01              MOV      R3,#01H
0017A1 7A00              MOV      R2,#HIGH ucCmdLine
0017A3 794E              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
0017A5 1207A4            LCALL    ?L?COM0020
0017A8 7003              JNZ      ?C0108?MIFARE
  539:     if(ucResult == FALSE)
  540:         return FM1702_NOTAGERR;   //无卡
0017AA 7F01              MOV      R7,#01H
0017AC 22                RET      
0017AD         ?C0108?MIFARE:
  541:     ucResult = SPIReadOne(ErrorFlag_Reg);
0017AD 120754            LCALL    ?L?COM0024
0017B0 30E103            JNB      ACC.1,?C0110?MIFARE
0017B3 7F05              MOV      R7,#05H
0017B5 22                RET      
0017B6         ?C0110?MIFARE:
  542: 	if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
  543: 	if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
0017B6 EF                MOV      A,R7
0017B7 30E203            JNB      ACC.2,?C0111?MIFARE
0017BA 7F14              MOV      R7,#014H
0017BC 22                RET      
0017BD         ?C0111?MIFARE:
  544: 	if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
0017BD EF                MOV      A,R7
0017BE 30E303            JNB      ACC.3,?C0112?MIFARE
0017C1 7F02              MOV      R7,#02H
0017C3 22                RET      
0017C4         ?C0112?MIFARE:
  545:     ucResult = Read_FIFO(buff);
0017C4 90004B            MOV      DPTR,#buff
0017C7 1207F0            LCALL    ?L?COM0002
0017CA F9                MOV      R1,A
0017CB 1207B0            LCALL    _Read_FIFO
  546:     if(ucResult!=0x10)
0017CE EF                MOV      A,R7
0017CF 6410              XRL      A,#010H
0017D1 7F00              MOV      R7,#00H
0017D3 6002              JZ       ?C0113?MIFARE
  547:         return FM1702_BYTECOUNTERR;
0017D5 7F0C              MOV      R7,#0CH
0017D7         ?C0113?MIFARE:
  548:     else
  549:         return FM1702_OK;
  550: }
0017D7 22                RET      
----- FUNCTION _Read_Block (END) -------


----- FUNCTION ?L?COM0029 (BEGIN) -----
0017D8 E0                MOVX     A,@DPTR
0017D9 FB                MOV      R3,A
0017DA 75F003            MOV      B,#03H
0017DD A4                MUL      AB
0017DE 2457              ADD      A,#LOW c_s_eepromConfig
0017E0 F582              MOV      DPL,A
0017E2 E5F0              MOV      A,B
0017E4 3404              ADDC     A,#HIGH c_s_eepromConfig
0017E6 F583              MOV      DPH,A
0017E8 E4                CLR      A
0017E9 93                MOVC     A,@A+DPTR
0017EA 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         11/29/2015  09:45:01  PAGE 79


----- FUNCTION ?L?COM0029 (END) -------


----- FUNCTION ?L?COM0038 (BEGIN) -----
0017EB E0                MOVX     A,@DPTR
0017EC FE                MOV      R6,A
0017ED A3                INC      DPTR
0017EE E0                MOVX     A,@DPTR
0017EF FF                MOV      R7,A
0017F0 7800              MOV      R0,#LOW e2_data
0017F2 7C00              MOV      R4,#HIGH e2_data
0017F4 7D01              MOV      R5,#01H
0017F6 22                RET      
----- FUNCTION ?L?COM0038 (END) -------


----- FUNCTION ?L?COM003E (BEGIN) -----
0017F7 9000BB            MOV      DPTR,#gLedBuf
0017FA 740C              MOV      A,#0CH
0017FC F0                MOVX     @DPTR,A
0017FD A3                INC      DPTR
0017FE F0                MOVX     @DPTR,A
0017FF A3                INC      DPTR
001800 F0                MOVX     @DPTR,A
001801 22                RET      
----- FUNCTION ?L?COM003E (END) -------


----- FUNCTION ?L?COM0041 (BEGIN) -----
001802 900456            MOV      DPTR,#c_u8_eepromSectorNum
001805 E4                CLR      A
001806 93                MOVC     A,@A+DPTR
001807 FF                MOV      R7,A
001808 ED                MOV      A,R5
001809 C3                CLR      C
00180A 9F                SUBB     A,R7
00180B 22                RET      
----- FUNCTION ?L?COM0041 (END) -------


