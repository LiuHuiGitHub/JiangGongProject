LX51 LINKER/LOCATER V4.66.1.0                                                           03/05/2016  21:15:44  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  .\Debug\PP01_01_02 (SYS_DELAY)


----- FUNCTION sys_gpioInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   23: void sys_gpioInit(void)
   24: {
   25: }
   26: 
000009 22                RET      
----- FUNCTION sys_gpioInit (END) -------


----- FUNCTION hwa_eepromInit (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   29: void hwa_eepromInit(void)
   30: {
   31: }
   32: 
00000A 22                RET      
----- FUNCTION hwa_eepromInit (END) -------


00000B 020FF6            LJMP     0FF6H
----- FUNCTION sys_taskHandler10ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   66: void sys_taskHandler10ms(void)            //10ms interrupt task
   67: {
   68: }
   69: 
000021 22                RET      
----- FUNCTION sys_taskHandler10ms (END) -------


----- FUNCTION sys_taskHandler1s (BEGIN) -----
 FILE: 'System\sys_task.c'
   75: void sys_taskHandler1s(void)              //1s interrupt task
   76: {
   77: }
   78: 
000022 22                RET      
----- FUNCTION sys_taskHandler1s (END) -------


000023 0211F1            LJMP     011F1H
----- FUNCTION _sys_delayus (BEGIN) -----
 FILE: 'System\sys_delay.c'
    5: void sys_delayus(UINT16 xus)
    6: {
;---- Variable 'xus' assigned to Register 'R6/R7' ----
    7:     while(xus--);
00044D         ?C0001?SYS_DELAY:
    8: }
00044D EF                MOV      A,R7
00044E 1F                DEC      R7
00044F AC06              MOV      R4,AR6
000451 7001              JNZ      ?C0012?SYS_DELAY
000453 1E                DEC      R6
000454         ?C0012?SYS_DELAY:
000454 4C                ORL      A,R4
000455 70F6              JNZ      ?C0001?SYS_DELAY
    9: 
000457 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 2


----- FUNCTION _sys_delayus (END) -------


----- FUNCTION Init_FM1702 (BEGIN) -----
 FILE: 'Driver\mifare.c'
  104: void Init_FM1702(void)
  105: {
  106: 	uchar temp;
  107: 	uint i;
  108: 	RC500SCK = 0;
000458 C2A1              CLR      RC500SCK
  109: 	RC500SO = 1;
00045A D2A2              SETB     RC500SO
  110: 	RC500SI = 1;
00045C D2A4              SETB     RC500SI
  111: 	RC500RST = 1;	// FM1702复位 
00045E D2A5              SETB     RC500RST
  112: 	sys_delayms(2);
000460 7F02              MOV      R7,#02H
000462 7E00              MOV      R6,#00H
000464 120806            LCALL    _sys_delayms
  113: 	RC500RST = 0;	
000467 C2A5              CLR      RC500RST
  114: 	//进入复位阶段，需要512个FM1702SL的时钟周期，约38us
  115: 	sys_delayus(100); 
000469 7F64              MOV      R7,#064H
00046B 7E00              MOV      R6,#00H
00046D 914D              ACALL    _sys_delayus
00046F         ?C0024?MIFARE:
  116: 	//进入初始化阶段，需要128个时钟周期，约10us
  117: 	do{ 		// 等待Command = 0,FM1702复位成功
  118: 		temp = SPIReadOne(Command_Reg);	 //(Command_Reg<<1)|0x80 = 0x82
;---- Variable 'temp' assigned to Register 'R4' ----
00046F F173              ACALL    ?L?COM0031
000471 70FC              JNZ      ?C0024?MIFARE
  119: 	}while(temp!=0);
  120: ///////////////////////////////////////////////////////////////////////////////////
  121: 	SPIWriteOne(Page_Reg,0x80);	//初始化SPI接口
000473 7D80              MOV      R5,#080H
000475 FF                MOV      R7,A
000476 91B2              ACALL    _SPIWriteOne
  122: 	for(i = 0; i < 0x1fff; i++) // 延时
;---- Variable 'i' assigned to Register 'R2/R3' ----
000478 E4                CLR      A
000479 FB                MOV      R3,A
00047A FA                MOV      R2,A
00047B         ?C0025?MIFARE:
  123: 	{
  124: 		temp = SPIReadOne(Command_Reg);
00047B F173              ACALL    ?L?COM0031
00047D 7006              JNZ      ?C0027?MIFARE
  125: 		if(temp == 0x00)	//SPI初始化成功
  126: 		{
  127: 			SPIWriteOne(Page_Reg,0);//可以使用SPI接口
00047F FD                MOV      R5,A
000480 FF                MOV      R7,A
000481 91B2              ACALL    _SPIWriteOne
  128: 			break;
000483 800B              SJMP     ?C0026?MIFARE
  129: 		}
  130: 	}
000485         ?C0027?MIFARE:
000485 0B                INC      R3
000486 BB0001            CJNE     R3,#00H,?C0138?MIFARE
000489 0A                INC      R2
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 3


00048A         ?C0138?MIFARE:
00048A BA1FEE            CJNE     R2,#01FH,?C0025?MIFARE
00048D BBFFEB            CJNE     R3,#0FFH,?C0025?MIFARE
000490         ?C0026?MIFARE:
  131: ////////////////////////////////////////////////////////////////////////////////////
  132: 	SPIWriteOne(InterruptEn_Reg,0x7F);	//  禁止所有中断请求（最高位置0）
000490 7D7F              MOV      R5,#07FH
000492 7F06              MOV      R7,#06H
000494 91B2              ACALL    _SPIWriteOne
  133: 	SPIWriteOne(InterruptRq_Reg,0x7F);	// 禁止所有中断请求标识置0（最高位置0）
000496 7D7F              MOV      R5,#07FH
000498 7F07              MOV      R7,#07H
00049A 91B2              ACALL    _SPIWriteOne
  134: 	
  135: 	//设置调制器的输入源为内部编码器, 并且设置TX1和TX2
  136: 	SPIWriteOne(TxControl_Reg,0x5B); 		// 发送控制寄存器 
00049C 7D5B              MOV      R5,#05BH
00049E 7F11              MOV      R7,#011H
0004A0 91B2              ACALL    _SPIWriteOne
  137: 	SPIWriteOne(RxControl2_Reg,0x01);
0004A2 7D01              MOV      R5,#01H
0004A4 7F1E              MOV      R7,#01EH
0004A6 91B2              ACALL    _SPIWriteOne
  138: 	SPIWriteOne(RxWait_Reg,5);
0004A8 7D05              MOV      R5,#05H
0004AA 7F21              MOV      R7,#021H
0004AC 8004              SJMP     _SPIWriteOne
----- FUNCTION Init_FM1702 (END) -------


----- FUNCTION ?L?COM0033 (BEGIN) -----
0004AE F0                MOVX     @DPTR,A
0004AF FD                MOV      R5,A
0004B0 7F01              MOV      R7,#01H
----- FUNCTION _SPIWriteOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   65: void SPIWriteOne(uchar SpiAddress,uchar wData)
   66: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
;---- Variable 'wData' assigned to Register 'R5' ----
   67: 	uchar i;
   68: 	SpiAddress = SpiAddress<<1;
0004B2 EF                MOV      A,R7
0004B3 25E0              ADD      A,ACC
   69: 	SpiAddress = SpiAddress & 0x7E;
0004B5 547E              ANL      A,#07EH
0004B7 FF                MOV      R7,A
   70: 
   71: 	//传输地址 从高位到低位传输
   72: 	RC500CS = 0;
0004B8 C2A3              CLR      RC500CS
   73: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
0004BA E4                CLR      A
0004BB FE                MOV      R6,A
0004BC         ?C0011?MIFARE:
   74: 	{
   75: 		if(SpiAddress&0x80)
0004BC EF                MOV      A,R7
0004BD 30E704            JNB      ACC.7,?C0014?MIFARE
   76: 			RC500SO = 1;
0004C0 D2A2              SETB     RC500SO
0004C2 8002              SJMP     ?C0015?MIFARE
0004C4         ?C0014?MIFARE:
   77: 		else
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 4


   78: 			RC500SO = 0;
0004C4 C2A2              CLR      RC500SO
0004C6         ?C0015?MIFARE:
   79: 		RC500SCK = 1;
0004C6 F1E9              ACALL    ?L?COM0041
0004C8 B408F1            CJNE     A,#08H,?C0011?MIFARE
0004CB         ?C0012?MIFARE:
   80: 		SpiAddress = SpiAddress<<1;
   81: 		RC500SCK = 0;
   82: 	}
   83: 	//传输数据，从高位开始
   84: 	for (i=0;i<8;i++)
0004CB E4                CLR      A
0004CC FE                MOV      R6,A
0004CD         ?C0016?MIFARE:
   85: 	{
   86: 		if(wData & 0x80)
0004CD ED                MOV      A,R5
0004CE 30E704            JNB      ACC.7,?C0019?MIFARE
   87: 			RC500SO = 1;
0004D1 D2A2              SETB     RC500SO
0004D3 8002              SJMP     ?C0020?MIFARE
0004D5         ?C0019?MIFARE:
   88: 		else
   89: 			RC500SO = 0;
0004D5 C2A2              CLR      RC500SO
0004D7         ?C0020?MIFARE:
   90: 		RC500SCK = 1;
0004D7 D2A1              SETB     RC500SCK
   91: 		wData = wData<<1;
0004D9 ED                MOV      A,R5
0004DA 25E0              ADD      A,ACC
0004DC FD                MOV      R5,A
   92: 		RC500SCK = 0;
0004DD C2A1              CLR      RC500SCK
   93: 	}
0004DF 0E                INC      R6
0004E0 EE                MOV      A,R6
0004E1 B408E9            CJNE     A,#08H,?C0016?MIFARE
0004E4         ?C0017?MIFARE:
   94: 	RC500CS = 1;
0004E4 D2A3              SETB     RC500CS
   95: }
0004E6 22                RET      
----- FUNCTION _SPIWriteOne (END) -------


----- FUNCTION _SPIReadOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   24: uchar SPIReadOne(uchar SpiAddress)
   25: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
   26: 	uchar i,rdata; 
   27: 	//地址字节最高位置1，表示为读数据，最低位固定为0，中间6位为地址
   28: 	SpiAddress = SpiAddress<<1;
0004E7 EF                MOV      A,R7
0004E8 25E0              ADD      A,ACC
   29: 	SpiAddress = SpiAddress | 0x80;
0004EA 4480              ORL      A,#080H
0004EC FF                MOV      R7,A
   30: 	//传输地址 从高位到低位传输
   31: 	RC500CS = 0;
0004ED C2A3              CLR      RC500CS
   32: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 5


0004EF E4                CLR      A
0004F0 FE                MOV      R6,A
0004F1         ?C0001?MIFARE:
   33: 	{
   34: 		if(SpiAddress&0x80)
0004F1 EF                MOV      A,R7
0004F2 30E704            JNB      ACC.7,?C0004?MIFARE
   35: 			RC500SO = 1;
0004F5 D2A2              SETB     RC500SO
0004F7 8002              SJMP     ?C0005?MIFARE
0004F9         ?C0004?MIFARE:
   36: 		else
   37: 			RC500SO = 0;
0004F9 C2A2              CLR      RC500SO
0004FB         ?C0005?MIFARE:
   38: 		RC500SCK = 1;
0004FB F1E9              ACALL    ?L?COM0041
0004FD B408F1            CJNE     A,#08H,?C0001?MIFARE
000500         ?C0002?MIFARE:
   39: 		SpiAddress = SpiAddress<<1;
   40: 		RC500SCK = 0;
   41: 	}
   42: 	
   43: 	//接收数据
   44: 	rdata = 0;
;---- Variable 'rdata' assigned to Register 'R7' ----
000500 E4                CLR      A
000501 FF                MOV      R7,A
   45: 	for (i=0;i<8;i++)
000502 FE                MOV      R6,A
000503         ?C0006?MIFARE:
   46: 	{
   47: 		RC500SCK = 1;
000503 D2A1              SETB     RC500SCK
   48: 		rdata = rdata<<1;
000505 EF                MOV      A,R7
000506 25E0              ADD      A,ACC
000508 FF                MOV      R7,A
   49: 		if (RC500SI)
000509 30A401            JNB      RC500SI,?C0009?MIFARE
   50: 			rdata+= 1;
00050C 0F                INC      R7
00050D         ?C0009?MIFARE:
   51: 		RC500SCK = 0;
00050D C2A1              CLR      RC500SCK
   52: 	}
00050F 0E                INC      R6
000510 EE                MOV      A,R6
000511 B408EF            CJNE     A,#08H,?C0006?MIFARE
000514         ?C0007?MIFARE:
   53: 	RC500CS=1;
000514 D2A3              SETB     RC500CS
   54: 	return (rdata);
   55: }
000516 22                RET      
----- FUNCTION _SPIReadOne (END) -------


----- FUNCTION AntiColl (BEGIN) -----
 FILE: 'Driver\mifare.c'
  278: uchar AntiColl(void)
  279: {
  280: 	
  281: 	uchar	temp,i;
  282: 
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 6


  283: 	//选择TX1、TX2的发射天线阻抗
  284: 	SPIWriteOne(CwConductance_Reg,0x3f);
000517 F144              ACALL    ?L?COM0014
000519 7493              MOV      A,#093H
00051B F0                MOVX     @DPTR,A
  285: 	//选择数据校验种类和模式
  286: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  287: 	
  288: 	gBuff[0] = RF_CMD_ANTICOL;
  289: 	gBuff[1] = 0x20;
00051C A3                INC      DPTR
00051D 7420              MOV      A,#020H
00051F D11C              ACALL    ?L?COM0009
000521 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
000524 7402              MOV      A,#02H
000526 F0                MOVX     @DPTR,A
000527 7F1E              MOV      R7,#01EH
000529 B17E              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R5' ----
00052B AD07              MOV      R5,AR7
  290: 	temp = Command_Send(Transceive,gBuff,2);
  291: 	if (temp==0)
00052D ED                MOV      A,R5
00052E 7003              JNZ      ?C0062?MIFARE
  292: 	{
  293: 		return(FM1702_NOTAGERR);
000530 7F01              MOV      R7,#01H
000532 22                RET      
  294: 	}
000533         ?C0062?MIFARE:
  295: 
  296: 	temp = SPIReadOne(FIFOLength_Reg);
000533 F17B              ACALL    ?L?COM003A
000535 7003              JNZ      ?C0064?MIFARE
  297: 	if (temp == 0)
  298: 	{
  299: 		return FM1702_BYTECOUNTERR;
000537 7F0C              MOV      R7,#0CH
000539 22                RET      
  300: 	}
00053A         ?C0064?MIFARE:
  301: 
  302: 	for(i=0;i<temp;i++)
;---- Variable 'i' assigned to Register 'R4' ----
00053A E4                CLR      A
00053B FC                MOV      R4,A
00053C         ?C0065?MIFARE:
00053C EC                MOV      A,R4
00053D C3                CLR      C
00053E 9D                SUBB     A,R5
00053F 500B              JNC      ?C0066?MIFARE
  303: 	{
  304: 		gBuff[i] = SPIReadOne(FIFO_Reg);
000541 7F02              MOV      R7,#02H
000543 91E7              ACALL    _SPIReadOne
000545 F1B9              ACALL    ?L?COM002E
000547 EF                MOV      A,R7
000548 F0                MOVX     @DPTR,A
  305: 	}
000549 0C                INC      R4
00054A 80F0              SJMP     ?C0065?MIFARE
00054C         ?C0066?MIFARE:
  306: 	temp = SPIReadOne(ErrorFlag_Reg);	// 判断接数据是否有冲突位
00054C 7F0A              MOV      R7,#0AH
00054E F17D              ACALL    ?L?COM003B
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 7


000550 5401              ANL      A,#01H
000552 FD                MOV      R5,A
  307: 	temp = temp & 0x01;
  308: 	if (temp == 0x00)
000553 7026              JNZ      ?C0068?MIFARE
  309: 	{
  310: 		for (i=0;i<5;i++)
000555 FC                MOV      R4,A
000556         ?C0069?MIFARE:
  311: 			temp^=gBuff[i];
000556 F1B9              ACALL    ?L?COM002E
000558 E0                MOVX     A,@DPTR
000559 6D                XRL      A,R5
00055A FD                MOV      R5,A
00055B 0C                INC      R4
00055C EC                MOV      A,R4
00055D B405F6            CJNE     A,#05H,?C0069?MIFARE
000560         ?C0070?MIFARE:
  312: 		if (temp)
000560 ED                MOV      A,R5
000561 6003              JZ       ?C0072?MIFARE
  313: 			return(FM1702_SERNRERR);
000563 7F08              MOV      R7,#08H
000565 22                RET      
000566         ?C0072?MIFARE:
  314:         for (i=0;i<5;i++)
000566 E4                CLR      A
000567 FC                MOV      R4,A
000568         ?C0073?MIFARE:
  315:         {
  316:             gCard_UID[i]=gBuff[i];
000568 F1B9              ACALL    ?L?COM002E
00056A E0                MOVX     A,@DPTR
00056B FF                MOV      R7,A
00056C 74B4              MOV      A,#LOW gCard_UID
00056E 2C                ADD      A,R4
00056F F1D6              ACALL    ?L?COM004E
000571 EF                MOV      A,R7
000572 F0                MOVX     @DPTR,A
  317:         }
000573 0C                INC      R4
000574 EC                MOV      A,R4
000575 B405F0            CJNE     A,#05H,?C0073?MIFARE
000578         ?C0074?MIFARE:
  318: 		return(FM1702_OK);
000578 7F00              MOV      R7,#00H
00057A 22                RET      
  319: 	}
00057B         ?C0068?MIFARE:
  320: 	else //有冲突位
  321: 		return FM1702_SERNRERR;
00057B 7F08              MOV      R7,#08H
  322: }
00057D 22                RET      
----- FUNCTION AntiColl (END) -------


----- FUNCTION _Command_Send (BEGIN) -----
 FILE: 'Driver\mifare.c'
  251: uchar Command_Send(uchar Comm_Set,uchar *buff, uchar count)
  252: {
00057E 900094            MOV      DPTR,#Comm_Set
000581 EF                MOV      A,R7
000582 F0                MOVX     @DPTR,A
;---- Variable 'buff' assigned to Register 'R1/R2/R3' ----
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 8


  253:     uchar ucResult1,ucResult2,i;
  254:     SPIWriteOne(Command_Reg,0x00);
000583 E4                CLR      A
000584 FD                MOV      R5,A
000585 7F01              MOV      R7,#01H
000587 91B2              ACALL    _SPIWriteOne
  255:     if(Clear_FIFO()==FALSE)
000589 F154              ACALL    Clear_FIFO
00058B EF                MOV      A,R7
00058C 7002              JNZ      ?C0055?MIFARE
  256:         return FALSE;
00058E FF                MOV      R7,A
00058F 22                RET      
000590         ?C0055?MIFARE:
  257:     Write_FIFO(buff,count);
000590 900098            MOV      DPTR,#count
000593 E0                MOVX     A,@DPTR
000594 FD                MOV      R5,A
000595 121792            LCALL    _Write_FIFO
  258: 	SPIWriteOne(Command_Reg,Comm_Set);
000598 900094            MOV      DPTR,#Comm_Set
00059B E0                MOVX     A,@DPTR
00059C FD                MOV      R5,A
00059D 7F01              MOV      R7,#01H
00059F 91B2              ACALL    _SPIWriteOne
  259: 	for (i=0;i<0xA0;i++)
;---- Variable 'i' assigned to Register 'R5' ----
0005A1 E4                CLR      A
0005A2 FD                MOV      R5,A
0005A3         ?C0057?MIFARE:
  260: 	{
  261:         ucResult1 = SPIReadOne(Command_Reg);
0005A3 7F01              MOV      R7,#01H
0005A5 91E7              ACALL    _SPIReadOne
;---- Variable 'ucResult1' assigned to Register 'R4' ----
0005A7 AC07              MOV      R4,AR7
  262:         ucResult2 = SPIReadOne(InterruptRq_Reg) & 0x80;
0005A9 7F07              MOV      R7,#07H
0005AB 91E7              ACALL    _SPIReadOne
0005AD EF                MOV      A,R7
0005AE 5480              ANL      A,#080H
0005B0 FF                MOV      R7,A
;---- Variable 'ucResult2' assigned to Register 'R7' ----
  263:         if(ucResult1 == 0 || ucResult2 ==0x80)
0005B1 EC                MOV      A,R4
0005B2 6004              JZ       ?C0061?MIFARE
0005B4 EF                MOV      A,R7
0005B5 B48003            CJNE     A,#080H,?C0059?MIFARE
0005B8         ?C0061?MIFARE:
  264:             return TRUE;
0005B8 7F01              MOV      R7,#01H
0005BA 22                RET      
  265: 	}
0005BB         ?C0059?MIFARE:
0005BB 0D                INC      R5
0005BC ED                MOV      A,R5
0005BD B4A0E3            CJNE     A,#0A0H,?C0057?MIFARE
0005C0         ?C0058?MIFARE:
  266: 	return FALSE;
0005C0 7F00              MOV      R7,#00H
  267: }
0005C2 22                RET      
----- FUNCTION _Command_Send (END) -------


LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 9


----- FUNCTION _Request (BEGIN) -----
 FILE: 'Driver\mifare.c'
  152: uchar Request(uchar mode)
  153: {
;---- Variable 'mode' assigned to Register 'R4' ----
0005C3 AC07              MOV      R4,AR7
  154: 	
  155: 	uchar temp;
  156: 	
  157: 	//选择TX1、TX2的发射天线阻抗
  158: 	SPIWriteOne(CwConductance_Reg,0x3f);
0005C5 F1B3              ACALL    ?L?COM004D
  159: 	//选择数据校验种类和模式
  160: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
0005C7 7D03              MOV      R5,#03H
0005C9 7F22              MOV      R7,#022H
0005CB 91B2              ACALL    _SPIWriteOne
  161: 	//调整面向bit的格式
  162: 	SPIWriteOne(BitFraming_Reg,0x07);
0005CD 7D07              MOV      R5,#07H
0005CF 7F0F              MOV      R7,#0FH
0005D1 F14E              ACALL    ?L?COM0016
0005D3 EC                MOV      A,R4
0005D4 F0                MOVX     @DPTR,A
  163: 	gBuff[0] = mode;		//Request模式选择 
  164: 	temp = SPIReadOne(Control_Reg);
0005D5 7F09              MOV      R7,#09H
0005D7 91E7              ACALL    _SPIReadOne
;---- Variable 'temp' assigned to Register 'R7' ----
  165: 	temp = temp & (0xf7);	
0005D9 EF                MOV      A,R7
0005DA 54F7              ANL      A,#0F7H
  166: 	SPIWriteOne(Control_Reg,temp);			//Control reset value is 00
0005DC FD                MOV      R5,A
0005DD 7F09              MOV      R7,#09H
0005DF 91B2              ACALL    _SPIWriteOne
  167: 	temp = Command_Send(Transceive, gBuff,1 );   //发送接收命令 
0005E1 D11D              ACALL    ?L?COM000A
0005E3 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
0005E6 7401              MOV      A,#01H
0005E8 F1C9              ACALL    ?L?COM001A
0005EA 7003              JNZ      ?C0030?MIFARE
  168: 	if(temp==0 )
  169: 	{
  170: 		return FM1702_NOTAGERR;
0005EC 7F01              MOV      R7,#01H
0005EE 22                RET      
  171: 	}
0005EF         ?C0030?MIFARE:
  172: 
  173: 	temp=Read_FIFO(gBuff);		//从FIFO中读取应答信息到gBuff中 
0005EF D11D              ACALL    ?L?COM000A
0005F1 F183              ACALL    _Read_FIFO
  174: 	// 判断应答信号是否正确 
  175: 	// 2  	Mifare Pro 卡
  176: 	//4 		Mifare One 卡
  177: 	if((gBuff[0] == 0x04) & (gBuff[1] == 0x0) &(temp == 2))
0005F3 9000BA            MOV      DPTR,#gBuff+01H
0005F6 E0                MOVX     A,@DPTR
0005F7 7E00              MOV      R6,#00H
0005F9 7002              JNZ      ?C0033?MIFARE
0005FB 7E01              MOV      R6,#01H
0005FD         ?C0033?MIFARE:
0005FD         ?C0034?MIFARE:
0005FD 9000B9            MOV      DPTR,#gBuff
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 10


000600 E0                MOVX     A,@DPTR
000601 7D00              MOV      R5,#00H
000603 B40402            CJNE     A,#04H,?C0035?MIFARE
000606 7D01              MOV      R5,#01H
000608         ?C0035?MIFARE:
000608         ?C0036?MIFARE:
000608 ED                MOV      A,R5
000609 5E                ANL      A,R6
00060A FE                MOV      R6,A
00060B EF                MOV      A,R7
00060C 7F00              MOV      R7,#00H
00060E B40202            CJNE     A,#02H,?C0037?MIFARE
000611 7F01              MOV      R7,#01H
000613         ?C0037?MIFARE:
000613         ?C0038?MIFARE:
000613 EF                MOV      A,R7
000614 5E                ANL      A,R6
000615 7F15              MOV      R7,#015H
000617 6002              JZ       ?C0032?MIFARE
  178: 	{
  179: 			return FM1702_OK;
000619 7F00              MOV      R7,#00H
  180: 	}
00061B         ?C0032?MIFARE:
  181: 	return FM1702_REQERR;
  182: }
00061B 22                RET      
----- FUNCTION _Request (END) -------


----- FUNCTION ?L?COM0009 (BEGIN) -----
00061C F0                MOVX     @DPTR,A
00061D         ?L?COM000A:
00061D 7B01              MOV      R3,#01H
00061F 7A00              MOV      R2,#HIGH gBuff
000621 79B9              MOV      R1,#LOW gBuff
000623 22                RET      
----- FUNCTION ?L?COM0009 (END) -------


----- FUNCTION _Authentication (BEGIN) -----
 FILE: 'Driver\mifare.c'
  472: uchar Authentication(uchar *UID, uchar SecNR, uchar mode)
  473: {
000624 900073            MOV      DPTR,#UID
000627 F1F9              ACALL    ?L?COM0002
;---- Variable 'SecNR' assigned to Register 'R4' ----
000629 AC05              MOV      R4,AR5
  474: 	uchar i;
  475: 	uchar temp, temp1;
  476: 
  477: 	if(SecNR >= 16)
00062B EC                MOV      A,R4
00062C C3                CLR      C
00062D 9410              SUBB     A,#010H
00062F 4004              JC       ?C0094?MIFARE
  478: 		SecNR = SecNR % 16;
000631 EC                MOV      A,R4
000632 540F              ANL      A,#0FH
000634 FC                MOV      R4,A
000635         ?C0094?MIFARE:
  479: 	
  480: 	//选择数据校验种类和模式
  481: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
000635 F1D0              ACALL    ?L?COM004B
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 11


  482: 	gBuff[0] = mode;
000637 900077            MOV      DPTR,#mode
00063A E0                MOVX     A,@DPTR
00063B 9000B9            MOV      DPTR,#gBuff
00063E F0                MOVX     @DPTR,A
  483: 	gBuff[1] = SecNR * 4 + 3;
00063F EC                MOV      A,R4
000640 25E0              ADD      A,ACC
000642 25E0              ADD      A,ACC
000644 2403              ADD      A,#03H
000646 A3                INC      DPTR
000647 F0                MOVX     @DPTR,A
  484: 	for(i = 0; i < 4; i++)
;---- Variable 'i' assigned to Register 'R7' ----
000648 E4                CLR      A
000649 FF                MOV      R7,A
00064A         ?C0095?MIFARE:
  485: 	{
  486: 		gBuff[2 + i] = UID[i];
00064A 900073            MOV      DPTR,#UID
00064D F1E1              ACALL    ?L?COM0004
00064F 120F61            LCALL    ?L?COM001F
000652 120FAB            LCALL    ?L?COM0028
000655 B404F2            CJNE     A,#04H,?C0095?MIFARE
000658         ?C0096?MIFARE:
  487: 	}
  488: 
  489: 	temp = Command_Send(Authent1, gBuff,6 );
000658 D11D              ACALL    ?L?COM000A
00065A 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
00065D 7406              MOV      A,#06H
00065F F0                MOVX     @DPTR,A
000660 7F0C              MOV      R7,#0CH
000662 B17E              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  490: 	if(temp==0)
000664 EF                MOV      A,R7
000665 7003              JNZ      ?C0098?MIFARE
  491: 	{
  492: 		return 0x99;
000667 7F99              MOV      R7,#099H
000669 22                RET      
  493: 	}
00066A         ?C0098?MIFARE:
  494: 
  495: 	temp = SPIReadOne(ErrorFlag_Reg);   
00066A F13E              ACALL    ?L?COM0027
00066C 30E103            JNB      ACC.1,?C0100?MIFARE
00066F 7F05              MOV      R7,#05H
000671 22                RET      
000672         ?C0100?MIFARE:
  496: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  497: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
000672 EF                MOV      A,R7
000673 30E203            JNB      ACC.2,?C0101?MIFARE
000676 7F14              MOV      R7,#014H
000678 22                RET      
000679         ?C0101?MIFARE:
  498: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
000679 EF                MOV      A,R7
00067A 30E303            JNB      ACC.3,?C0102?MIFARE
00067D 7F02              MOV      R7,#02H
00067F 22                RET      
000680         ?C0102?MIFARE:
  499: 	temp = Command_Send(Authent2, gBuff,0 );	
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 12


000680 D11D              ACALL    ?L?COM000A
000682 E4                CLR      A
000683 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
000686 F0                MOVX     @DPTR,A
000687 7F14              MOV      R7,#014H
000689 B17E              ACALL    _Command_Send
  500: 	if(temp ==0)
00068B EF                MOV      A,R7
00068C 7003              JNZ      ?C0103?MIFARE
  501: 	{
  502: 		return 0x88;
00068E 7F88              MOV      R7,#088H
000690 22                RET      
  503: 	}
000691         ?C0103?MIFARE:
  504: 
  505: 	temp = SPIReadOne(ErrorFlag_Reg);
000691 F13E              ACALL    ?L?COM0027
000693 30E103            JNB      ACC.1,?C0104?MIFARE
000696 7F05              MOV      R7,#05H
000698 22                RET      
000699         ?C0104?MIFARE:
  506: //	Show(temp,0);
  507: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  508: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
000699 EF                MOV      A,R7
00069A 30E203            JNB      ACC.2,?C0105?MIFARE
00069D 7F14              MOV      R7,#014H
00069F 22                RET      
0006A0         ?C0105?MIFARE:
  509: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
0006A0 EF                MOV      A,R7
0006A1 30E303            JNB      ACC.3,?C0106?MIFARE
0006A4 7F02              MOV      R7,#02H
0006A6 22                RET      
0006A7         ?C0106?MIFARE:
  510: 	temp1 = SPIReadOne(Control_Reg);
0006A7 7F09              MOV      R7,#09H
0006A9 91E7              ACALL    _SPIReadOne
;---- Variable 'temp1' assigned to Register 'R7' ----
  511: 	temp1 = temp1 & 0x08;	
0006AB EF                MOV      A,R7
0006AC 5408              ANL      A,#08H
  512: 	if(temp1 == 0x08)
0006AE 7F04              MOV      R7,#04H
0006B0 B40802            CJNE     A,#08H,?C0107?MIFARE
  513: 	{
  514: 		return FM1702_OK;
0006B3 7F00              MOV      R7,#00H
  515: 	}
0006B5         ?C0107?MIFARE:
  516: 
  517: 	return FM1702_AUTHERR;
  518: }
0006B5 22                RET      
----- FUNCTION _Authentication (END) -------


----- FUNCTION SelectCard (BEGIN) -----
 FILE: 'Driver\mifare.c'
  335: uchar SelectCard(void)
  336: {
  337: 	
  338: 	uchar	temp, i;
  339: 	
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 13


  340: 	//选择TX1、TX2的发射天线阻抗
  341: 	SPIWriteOne(CwConductance_Reg,0x3f);
0006B6 F1B3              ACALL    ?L?COM004D
  342: 	//选择数据校验种类和模式
  343: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
0006B8 7D0F              MOV      R5,#0FH
0006BA F14C              ACALL    ?L?COM0015
0006BC 7493              MOV      A,#093H
0006BE F0                MOVX     @DPTR,A
  344: 
  345: 	gBuff[0] = RF_CMD_SELECT;
  346: 	gBuff[1] = 0x70;
0006BF A3                INC      DPTR
0006C0 7470              MOV      A,#070H
0006C2 F0                MOVX     @DPTR,A
  347: 	for(i = 0; i < 5; i++)
;---- Variable 'i' assigned to Register 'R7' ----
0006C3 E4                CLR      A
0006C4 FF                MOV      R7,A
0006C5         ?C0077?MIFARE:
  348: 	{
  349: 		gBuff[i + 2] = gCard_UID[i];
0006C5 74B4              MOV      A,#LOW gCard_UID
0006C7 2F                ADD      A,R7
0006C8 F1D6              ACALL    ?L?COM004E
0006CA E0                MOVX     A,@DPTR
0006CB 120FAB            LCALL    ?L?COM0028
0006CE B405F4            CJNE     A,#05H,?C0077?MIFARE
0006D1         ?C0078?MIFARE:
  350: 	}
  351: 	temp = Command_Send(Transceive, gBuff,7 );
0006D1 D11D              ACALL    ?L?COM000A
0006D3 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
0006D6 7407              MOV      A,#07H
;---- Variable 'temp' assigned to Register 'R7' ----
0006D8 F1C9              ACALL    ?L?COM001A
0006DA 7003              JNZ      ?C0080?MIFARE
  352: 	if(temp==0 )
  353: 	{
  354: 		return(FM1702_NOTAGERR);
0006DC 7F01              MOV      R7,#01H
0006DE 22                RET      
  355: 	}
0006DF         ?C0080?MIFARE:
  356: 	else
  357: 	{
  358: 		temp = SPIReadOne(ErrorFlag_Reg);
0006DF F13E              ACALL    ?L?COM0027
0006E1 30E103            JNB      ACC.1,?C0083?MIFARE
0006E4 7F05              MOV      R7,#05H
0006E6 22                RET      
0006E7         ?C0083?MIFARE:
  359: 		if((temp & 0x02) == 0x02) return(FM1702_PARITYERR);
  360: 		if((temp & 0x04) == 0x04) return(FM1702_FRAMINGERR);
0006E7 EF                MOV      A,R7
0006E8 30E203            JNB      ACC.2,?C0084?MIFARE
0006EB 7F14              MOV      R7,#014H
0006ED 22                RET      
0006EE         ?C0084?MIFARE:
  361: 		if((temp & 0x08) == 0x08) return(FM1702_CRCERR);
0006EE EF                MOV      A,R7
0006EF 30E303            JNB      ACC.3,?C0085?MIFARE
0006F2 7F02              MOV      R7,#02H
0006F4 22                RET      
0006F5         ?C0085?MIFARE:
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 14


  362: 		temp = SPIReadOne(FIFOLength_Reg);
0006F5 7F04              MOV      R7,#04H
0006F7 91E7              ACALL    _SPIReadOne
  363: 		if(temp != 1) return(FM1702_BYTECOUNTERR);
0006F9 EF                MOV      A,R7
0006FA 6401              XRL      A,#01H
0006FC 6003              JZ       ?C0086?MIFARE
0006FE 7F0C              MOV      R7,#0CH
000700 22                RET      
000701         ?C0086?MIFARE:
  364: //		SPIRead(FIFO_Reg,gBuff,temp);	//从FIFO中读取应答信息
  365: 		gBuff[0] = SPIReadOne(FIFO_Reg);
000701 7F02              MOV      R7,#02H
000703 91E7              ACALL    _SPIReadOne
000705 9000B9            MOV      DPTR,#gBuff
000708 EF                MOV      A,R7
000709 F0                MOVX     @DPTR,A
  366: 		if(gBuff[0]==0x08) 	  	// 判断应答信号是否正确 
00070A BF0803            CJNE     R7,#08H,?C0087?MIFARE
  367: 			return(FM1702_OK);
00070D 7F00              MOV      R7,#00H
00070F 22                RET      
000710         ?C0087?MIFARE:
  368: 		else
  369: 			return(FM1702_SELERR);
000710 7F16              MOV      R7,#016H
  370: 	}
  371: }
000712 22                RET      
----- FUNCTION SelectCard (END) -------


----- FUNCTION MIF_Halt (BEGIN) -----
 FILE: 'Driver\mifare.c'
  610: uchar MIF_Halt(void)
  611: {
  612: 	uchar	temp;
  613: 	//选择TX1、TX2的发射天线阻抗
  614: 	SPIWriteOne(CwConductance_Reg,0x3f);
000713 F144              ACALL    ?L?COM0014
000715 7450              MOV      A,#050H
000717 F0                MOVX     @DPTR,A
  615: 	//选择数据校验种类和模式
  616: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  617: 	*gBuff = RF_CMD_HALT;
  618: 	*(gBuff + 1) = 0x00;
000718 E4                CLR      A
000719 A3                INC      DPTR
00071A D11C              ACALL    ?L?COM0009
00071C 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
00071F 7402              MOV      A,#02H
000721 F0                MOVX     @DPTR,A
000722 7F1A              MOV      R7,#01AH
000724 B17E              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  619: 	temp = Command_Send(Transmit, gBuff, 2);//发送FIFO缓存地址
  620: 	if(temp == TRUE)
000726 EF                MOV      A,R7
000727 B40103            CJNE     A,#01H,?C0133?MIFARE
  621: 		return FM1702_OK;
00072A 7F00              MOV      R7,#00H
00072C 22                RET      
00072D         ?C0133?MIFARE:
  622: 	else
  623: 	{
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 15


  624: 		temp = SPIReadOne(ErrorFlag_Reg);
00072D F13E              ACALL    ?L?COM0027
00072F 30E103            JNB      ACC.1,?C0136?MIFARE
  625: 		if((temp & 0x02) == 0x02)
  626: 		{
  627: 			return(FM1702_PARITYERR);
000732 7F05              MOV      R7,#05H
000734 22                RET      
  628: 		}
000735         ?C0136?MIFARE:
  629: 
  630: 		if((temp & 0x04) == 0x04)
000735 EF                MOV      A,R7
000736 7F01              MOV      R7,#01H
000738 30E202            JNB      ACC.2,?C0137?MIFARE
  631: 		{
  632: 			return(FM1702_FRAMINGERR);
00073B 7F14              MOV      R7,#014H
  633: 		}
00073D         ?C0137?MIFARE:
  634: 		return(FM1702_NOTAGERR);
  635: 	}
  636: }
00073D 22                RET      
----- FUNCTION MIF_Halt (END) -------


----- FUNCTION ?L?COM0027 (BEGIN) -----
00073E 7F0A              MOV      R7,#0AH
000740 91E7              ACALL    _SPIReadOne
000742 EF                MOV      A,R7
000743 22                RET      
----- FUNCTION ?L?COM0027 (END) -------


----- FUNCTION ?L?COM0014 (BEGIN) -----
000744 7D3F              MOV      R5,#03FH
000746 7F12              MOV      R7,#012H
000748 91B2              ACALL    _SPIWriteOne
00074A 7D03              MOV      R5,#03H
00074C         ?L?COM0015:
00074C 7F22              MOV      R7,#022H
00074E         ?L?COM0016:
00074E 91B2              ACALL    _SPIWriteOne
000750 9000B9            MOV      DPTR,#gBuff
000753 22                RET      
----- FUNCTION ?L?COM0014 (END) -------


----- FUNCTION Clear_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  190: uchar Clear_FIFO(void)
  191: {
  192:     uchar ucResult,i;
  193:     ucResult = SPIReadOne(Control_Reg);
000754 7F09              MOV      R7,#09H
;---- Variable 'ucResult' assigned to Register 'R4' ----
000756 F175              ACALL    ?L?COM0032
000758 4401              ORL      A,#01H
00075A FC                MOV      R4,A
  194:     ucResult |=0x01;
  195:     SPIWriteOne(Control_Reg,ucResult);
00075B FD                MOV      R5,A
00075C 7F09              MOV      R7,#09H
00075E 91B2              ACALL    _SPIWriteOne
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 16


  196:     for(i=0;i<0xA0;i++)
;---- Variable 'i' assigned to Register 'R5' ----
000760 E4                CLR      A
000761 FD                MOV      R5,A
000762         ?C0039?MIFARE:
  197:     {
  198:         ucResult = SPIReadOne(FIFOLength_Reg);
000762 7F04              MOV      R7,#04H
000764 F175              ACALL    ?L?COM0032
000766 7003              JNZ      ?C0041?MIFARE
  199:         if(ucResult == 0)
  200:             return TRUE;
000768 7F01              MOV      R7,#01H
00076A 22                RET      
  201:     }
00076B         ?C0041?MIFARE:
00076B 0D                INC      R5
00076C ED                MOV      A,R5
00076D B4A0F2            CJNE     A,#0A0H,?C0039?MIFARE
000770         ?C0040?MIFARE:
  202:     return FALSE;
000770 7F00              MOV      R7,#00H
  203: }
000772 22                RET      
----- FUNCTION Clear_FIFO (END) -------


----- FUNCTION ?L?COM0031 (BEGIN) -----
000773 7F01              MOV      R7,#01H
000775         ?L?COM0032:
000775 91E7              ACALL    _SPIReadOne
000777 AC07              MOV      R4,AR7
000779 EC                MOV      A,R4
00077A 22                RET      
----- FUNCTION ?L?COM0031 (END) -------


----- FUNCTION ?L?COM003A (BEGIN) -----
00077B 7F04              MOV      R7,#04H
00077D         ?L?COM003B:
00077D 91E7              ACALL    _SPIReadOne
00077F AD07              MOV      R5,AR7
000781 ED                MOV      A,R5
000782 22                RET      
----- FUNCTION ?L?COM003A (END) -------


----- FUNCTION _Read_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  228: uchar Read_FIFO(uchar *buff)
  229: {
000783 900094            MOV      DPTR,#buff
000786 F1F9              ACALL    ?L?COM0002
  230: 	uchar	ucResult,i;
  231: 	ucResult = SPIReadOne(FIFOLength_Reg);
;---- Variable 'ucResult' assigned to Register 'R5' ----
000788 F17B              ACALL    ?L?COM003A
00078A 6005              JZ       ?C0050?MIFARE
00078C D3                SETB     C
00078D 9410              SUBB     A,#010H
00078F 4003              JC       ?C0049?MIFARE
000791         ?C0050?MIFARE:
  232: 	if(ucResult == 0 || ucResult>16)
  233: 		return 0;
000791 7F00              MOV      R7,#00H
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 17


000793 22                RET      
000794         ?C0049?MIFARE:
  234: 	for(i=0;i<ucResult;i++)
;---- Variable 'i' assigned to Register 'R4' ----
000794 E4                CLR      A
000795 FC                MOV      R4,A
000796         ?C0052?MIFARE:
000796 EC                MOV      A,R4
000797 C3                CLR      C
000798 9D                SUBB     A,R5
000799 5015              JNC      ?C0053?MIFARE
  235: 	{
  236: 		buff[i] = SPIReadOne(FIFO_Reg);
00079B 7F02              MOV      R7,#02H
00079D 91E7              ACALL    _SPIReadOne
00079F 900094            MOV      DPTR,#buff
0007A2 F1E1              ACALL    ?L?COM0004
0007A4 F9                MOV      R1,A
0007A5 8C82              MOV      DPL,R4
0007A7 758300            MOV      DPH,#00H
0007AA EF                MOV      A,R7
0007AB 3174              ACALL    ?C?CSTOPTR
  237: 	}
0007AD 0C                INC      R4
0007AE 80E6              SJMP     ?C0052?MIFARE
0007B0         ?C0053?MIFARE:
  238: 
  239: 	return ucResult;
0007B0 AF05              MOV      R7,AR5
  240: }
0007B2 22                RET      
----- FUNCTION _Read_FIFO (END) -------


----- FUNCTION ?L?COM004D (BEGIN) -----
0007B3 7D3F              MOV      R5,#03FH
0007B5 7F12              MOV      R7,#012H
0007B7 81B2              AJMP     _SPIWriteOne
----- FUNCTION ?L?COM004D (END) -------


----- FUNCTION ?L?COM002E (BEGIN) -----
0007B9 74B9              MOV      A,#LOW gBuff
0007BB 2C                ADD      A,R4
0007BC F582              MOV      DPL,A
0007BE E4                CLR      A
0007BF 3400              ADDC     A,#HIGH gBuff
0007C1 F583              MOV      DPH,A
0007C3 22                RET      
----- FUNCTION ?L?COM002E (END) -------


----- FUNCTION ?L?COM0019 (BEGIN) -----
0007C4 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
0007C7 7402              MOV      A,#02H
0007C9         ?L?COM001A:
0007C9 F0                MOVX     @DPTR,A
0007CA 7F1E              MOV      R7,#01EH
0007CC B17E              ACALL    _Command_Send
0007CE EF                MOV      A,R7
0007CF 22                RET      
----- FUNCTION ?L?COM0019 (END) -------


----- FUNCTION ?L?COM004B (BEGIN) -----
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 18


0007D0 7D0F              MOV      R5,#0FH
0007D2 7F22              MOV      R7,#022H
0007D4 81B2              AJMP     _SPIWriteOne
----- FUNCTION ?L?COM004B (END) -------


----- FUNCTION ?L?COM004E (BEGIN) -----
0007D6 F582              MOV      DPL,A
0007D8 E4                CLR      A
0007D9 3400              ADDC     A,#HIGH gCard_UID
0007DB F583              MOV      DPH,A
0007DD 22                RET      
----- FUNCTION ?L?COM004E (END) -------


----- FUNCTION ?L?COM0003 (BEGIN) -----
0007DE 90007F            MOV      DPTR,#buff
0007E1         ?L?COM0004:
0007E1 E0                MOVX     A,@DPTR
0007E2 FB                MOV      R3,A
0007E3 A3                INC      DPTR
0007E4 E0                MOVX     A,@DPTR
0007E5 FA                MOV      R2,A
0007E6 A3                INC      DPTR
0007E7 E0                MOVX     A,@DPTR
0007E8 22                RET      
----- FUNCTION ?L?COM0003 (END) -------


----- FUNCTION ?L?COM0041 (BEGIN) -----
0007E9 D2A1              SETB     RC500SCK
0007EB EF                MOV      A,R7
0007EC 25E0              ADD      A,ACC
0007EE FF                MOV      R7,A
0007EF C2A1              CLR      RC500SCK
0007F1 0E                INC      R6
0007F2 EE                MOV      A,R6
0007F3 22                RET      
----- FUNCTION ?L?COM0041 (END) -------


----- FUNCTION app_brushInit (BEGIN) -----
 FILE: 'App\app_brush.c'
   31: void app_brushInit(void)
   32: {
   33: 	Init_FM1702();
   34: }
0007F4 8158              AJMP     Init_FM1702
----- FUNCTION app_brushInit (END) -------


----- FUNCTION ?L?COM0001 (BEGIN) -----
0007F6 90007F            MOV      DPTR,#buff
0007F9         ?L?COM0002:
0007F9 EB                MOV      A,R3
0007FA F0                MOVX     @DPTR,A
0007FB A3                INC      DPTR
0007FC EA                MOV      A,R2
0007FD F0                MOVX     @DPTR,A
0007FE A3                INC      DPTR
0007FF E9                MOV      A,R1
000800 F0                MOVX     @DPTR,A
000801 22                RET      
----- FUNCTION ?L?COM0001 (END) -------

LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 19



----- FUNCTION ?L?COM003E (BEGIN) -----
000802 7FF4              MOV      R7,#0F4H
000804 7E01              MOV      R6,#01H
----- FUNCTION _sys_delayms (BEGIN) -----
 FILE: 'System\sys_delay.c'
   10: void sys_delayms(UINT16 xms)
   11: {   
;---- Variable 'xms' assigned to Register 'R6/R7' ----
   12:     UINT8 i, j;
000806         ?C0004?SYS_DELAY:
   13: 	while(xms--)
000806 EF                MOV      A,R7
000807 1F                DEC      R7
000808 AC06              MOV      R4,AR6
00080A 7001              JNZ      ?C0013?SYS_DELAY
00080C 1E                DEC      R6
00080D         ?C0013?SYS_DELAY:
00080D 4C                ORL      A,R4
00080E 600D              JZ       ?C0011?SYS_DELAY
   14:     {
   15:     	WDT_CONTR |= 0x35;
000810 43C135            ORL      WDT_CONTR,#035H
   16:         i = 22;
;---- Variable 'i' assigned to Register 'R5' ----
000813 7D16              MOV      R5,#016H
   17:         j = 128;
;---- Variable 'j' assigned to Register 'R4' ----
000815 7C80              MOV      R4,#080H
   18:         do
   19:         {
000817         ?C0009?SYS_DELAY:
   20:             while (--j);
000817 DCFE              DJNZ     R4,?C0009?SYS_DELAY
000819         ?C0010?SYS_DELAY:
   21:         } while (--i);
000819         ?C0006?SYS_DELAY:
000819 DDFC              DJNZ     R5,?C0009?SYS_DELAY
   22:     }
00081B 80E9              SJMP     ?C0004?SYS_DELAY
   22: }
00081D         ?C0011?SYS_DELAY:
00081D 22                RET      
----- FUNCTION _sys_delayms (END) -------


----- FUNCTION app_Show (BEGIN) -----
 FILE: 'App\app_brush.c'
   18: void app_Show(void)
   19: {
   20:     sys_delayms(500);
   21:     led_ShowNumber(s_System.Money/100, s_System.Money%100, 1<<3);
00081E 1102              ACALL    ?L?COM003E
   22:     gLedBuf[0] = 12;
000820 51CE              ACALL    ?L?COM0010
000822 C006              PUSH     AR6
000824 C007              PUSH     AR7
000826 51BA              ACALL    ?L?COM002B
000828 1201A8            LCALL    ?C?UIDIV
00082B D007              POP      AR7
00082D D006              POP      AR6
00082F 7B08              MOV      R3,#08H
000831 5144              ACALL    _led_ShowNumber
   23:     gLedBuf[1] = 12;
000833 F17A              ACALL    ?L?COM0042
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 20


   24:     gLedBuf[2] = 12;
   25:     sys_delayms(500);
000835 1102              ACALL    ?L?COM003E
   26:     led_ShowNumber(MoneySum/100/100, MoneySum/100%100, 0);
000837 F111              ACALL    ?L?COM000D
000839 120299            LCALL    ?C?ULDIV
00083C C006              PUSH     AR6
00083E C007              PUSH     AR7
000840 F111              ACALL    ?L?COM000D
000842 120299            LCALL    ?C?ULDIV
000845 AF03              MOV      R7,AR3
000847 AD07              MOV      R5,AR7
000849 D007              POP      AR7
00084B D006              POP      AR6
00084D E4                CLR      A
00084E FB                MOV      R3,A
00084F 5144              ACALL    _led_ShowNumber
   27:     sys_delayms(500);
000851 1102              ACALL    ?L?COM003E
;----                  JMP      Led_ShowZero
   28:     Led_ShowZero();
----- FUNCTION app_Show (END) -------


----- FUNCTION Led_ShowZero (BEGIN) -----
 FILE: 'Driver\LED.c'
  114: void Led_ShowZero(void)
  115: {
  116:     gLedBuf[0] = 12;
  117:     gLedBuf[1] = 12;
000853 F17A              ACALL    ?L?COM0042
  118:     gLedBuf[2] = 12;
  119:     gLedBuf[3] = 12;
000855 A3                INC      DPTR
000856 F0                MOVX     @DPTR,A
  120:     gLedBuf[4] = 12;
000857 A3                INC      DPTR
000858 F0                MOVX     @DPTR,A
  121:     gLedBuf[5] = 0;
000859 E4                CLR      A
00085A A3                INC      DPTR
00085B F0                MOVX     @DPTR,A
  122:     gShowDot = 0;
00085C 9000D0            MOV      DPTR,#gShowDot
00085F F0                MOVX     @DPTR,A
  123: }
000860 22                RET      
----- FUNCTION Led_ShowZero (END) -------


----- FUNCTION app_brushCycle1s (BEGIN) -----
 FILE: 'App\app_brush.c'
  106: void app_brushCycle1s(void)
  107: {
  108:     switch (app_brushCard())
  109:     {
000861 121649            LCALL    app_brushCard
000864 EF                MOV      A,R7
000865 24FE              ADD      A,#0FEH
000867 7002              JNZ      $ + 4H
000869 2175              AJMP     ?C0038?APP_BRUSH
00086B 14                DEC      A
00086C 7002              JNZ      $ + 4H
00086E 2110              AJMP     ?C0032?APP_BRUSH
000870 2402              ADD      A,#02H
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 21


000872 6002              JZ       $ + 4H
000874 4136              AJMP     ?C0022?APP_BRUSH
  110:         case MEM_CARD:
  111:             if(hwa_mifareReadBlock(gBuff,4))
000876         ?C0023?APP_BRUSH:
  112:             {
000876 12061D            LCALL    ?L?COM000A
000879 7D04              MOV      R5,#04H
00087B 71BB              ACALL    _hwa_mifareReadBlock
00087D 4002              JC       $ + 4H
00087F 4136              AJMP     ?C0022?APP_BRUSH
  113:                 if(u8_FirstBrushCardDly)
  114:                 {
000881 9000D9            MOV      DPTR,#u8_FirstBrushCardDly
000884 E0                MOVX     A,@DPTR
000885 6066              JZ       ?C0025?APP_BRUSH
  115:                     if(gBuff[0]==0x01 && gBuff[1]==0x0A)
  116:                     {
000887 9000B9            MOV      DPTR,#gBuff
00088A E0                MOVX     A,@DPTR
00088B FF                MOV      R7,A
00088C B40128            CJNE     A,#01H,?C0026?APP_BRUSH
00088F A3                INC      DPTR
000890 E0                MOVX     A,@DPTR
000891 B40A23            CJNE     A,#0AH,?C0026?APP_BRUSH
  117:                         s_System.Money += 10;
  118: 						if (s_System.Money > 500)
000894 9000B3            MOV      DPTR,#s_System+012H
000897 E0                MOVX     A,@DPTR
000898 240A              ADD      A,#0AH
00089A F0                MOVX     @DPTR,A
00089B 9000B2            MOV      DPTR,#s_System+011H
00089E E0                MOVX     A,@DPTR
00089F 3400              ADDC     A,#00H
0008A1 F0                MOVX     @DPTR,A
  119: 						{
0008A2 D3                SETB     C
0008A3 A3                INC      DPTR
0008A4 E0                MOVX     A,@DPTR
0008A5 94F4              SUBB     A,#0F4H
0008A7 9000B2            MOV      DPTR,#s_System+011H
0008AA E0                MOVX     A,@DPTR
0008AB 9401              SUBB     A,#01H
0008AD 403A              JC       ?C0028?APP_BRUSH
  120: 							s_System.Money = 10;
  121: 						}
0008AF E4                CLR      A
0008B0 F0                MOVX     @DPTR,A
0008B1 A3                INC      DPTR
0008B2 740A              MOV      A,#0AH
0008B4 F0                MOVX     @DPTR,A
  122:                     }
  123:                     else if(gBuff[0]==0xFA && gBuff[1]==0x01)
0008B5 8032              SJMP     ?C0028?APP_BRUSH
0008B7         ?C0026?APP_BRUSH:
  124:                     {
0008B7 EF                MOV      A,R7
0008B8 B4FA2E            CJNE     A,#0FAH,?C0028?APP_BRUSH
0008BB 9000BA            MOV      DPTR,#gBuff+01H
0008BE E0                MOVX     A,@DPTR
0008BF B40127            CJNE     A,#01H,?C0028?APP_BRUSH
  125: 						if(s_System.Money > 10)
  126: 						{
0008C2 D3                SETB     C
0008C3 9000B3            MOV      DPTR,#s_System+012H
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 22


0008C6 E0                MOVX     A,@DPTR
0008C7 940A              SUBB     A,#0AH
0008C9 9000B2            MOV      DPTR,#s_System+011H
0008CC E0                MOVX     A,@DPTR
0008CD 9400              SUBB     A,#00H
0008CF 400E              JC       ?C0030?APP_BRUSH
  127:                         	s_System.Money -= 10;
  128: 						}
0008D1 A3                INC      DPTR
0008D2 E0                MOVX     A,@DPTR
0008D3 24F6              ADD      A,#0F6H
0008D5 F0                MOVX     @DPTR,A
0008D6 9000B2            MOV      DPTR,#s_System+011H
0008D9 E0                MOVX     A,@DPTR
0008DA 34FF              ADDC     A,#0FFH
0008DC F0                MOVX     @DPTR,A
  129:                         else
0008DD 800A              SJMP     ?C0028?APP_BRUSH
0008DF         ?C0030?APP_BRUSH:
  130:                         {
  131:                             s_System.Money = 500;
0008DF 9000B2            MOV      DPTR,#s_System+011H
0008E2 7401              MOV      A,#01H
0008E4 F0                MOVX     @DPTR,A
0008E5 A3                INC      DPTR
0008E6 74F4              MOV      A,#0F4H
0008E8 F0                MOVX     @DPTR,A
  132:                         }
  133:                     }
0008E9         ?C0028?APP_BRUSH:
  134:                     app_configWrite(SYSTEM_SETTING_SECTOR);
0008E9 E4                CLR      A
0008EA FF                MOV      R7,A
0008EB 51E0              ACALL    _app_configWrite
  135:                 }
0008ED         ?C0025?APP_BRUSH:
  136:                 u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
0008ED 9000D9            MOV      DPTR,#u8_FirstBrushCardDly
0008F0 7403              MOV      A,#03H
0008F2 F0                MOVX     @DPTR,A
  137:                 buzzer_SoundNumber(1);
0008F3 7F01              MOV      R7,#01H
0008F5 51A3              ACALL    _buzzer_SoundNumber
  138:                 led_ShowNumber(s_System.Money/100, s_System.Money%100, 1<<3);
0008F7 51CE              ACALL    ?L?COM0010
0008F9 C006              PUSH     AR6
0008FB C007              PUSH     AR7
0008FD 51BA              ACALL    ?L?COM002B
0008FF 1201A8            LCALL    ?C?UIDIV
000902 D007              POP      AR7
000904 D006              POP      AR6
000906 7B08              MOV      R3,#08H
000908 5144              ACALL    _led_ShowNumber
  139:                 sys_delayms(1000);
00090A 7FE8              MOV      R7,#0E8H
00090C 7E03              MOV      R6,#03H
  140:             }
  141:             break;
00090E 412E              AJMP     ?C0052?APP_BRUSH
  142:             
  143:         case PWD_CARD:                                 //从初始卡中读取管理卡密码，并储存至E2
000910         ?C0032?APP_BRUSH:
  144:             if(hwa_mifareReadBlock(gBuff,4))       //读取管理卡密码
000910 12061D            LCALL    ?L?COM000A
000913 7D04              MOV      R5,#04H
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 23


000915 71BB              ACALL    _hwa_mifareReadBlock
000917 4002              JC       $ + 4H
000919 4136              AJMP     ?C0022?APP_BRUSH
  145:             {
  146:                 memcpy(&s_System, gBuff, 16);
00091B 78A1              MOV      R0,#LOW s_System
00091D 7C00              MOV      R4,#HIGH s_System
00091F 7D01              MOV      R5,#01H
000921 12061D            LCALL    ?L?COM000A
000924 D19C              ACALL    ?L?COM003C
  147: 
  148: 	            if (hwa_mifareReadBlock(gBuff, 5))			//读取管理卡和用户卡密码以及扇区
000926 12061D            LCALL    ?L?COM000A
000929 7D05              MOV      R5,#05H
00092B 71BB              ACALL    _hwa_mifareReadBlock
00092D 4002              JC       $ + 4H
00092F 4136              AJMP     ?C0022?APP_BRUSH
  149: 	            {
  150: 	                if(gBuff[0] == 0x01)
000931 9000B9            MOV      DPTR,#gBuff
000934 E0                MOVX     A,@DPTR
000935 B40108            CJNE     A,#01H,?C0035?APP_BRUSH
  151: 	                {
  152: 	                    s_System.RecoveryOldCard = 1;
000938 9000B1            MOV      DPTR,#s_System+010H
00093B 7401              MOV      A,#01H
00093D F0                MOVX     @DPTR,A
  153: 	                }
00093E 8005              SJMP     ?C0037?APP_BRUSH
000940         ?C0035?APP_BRUSH:
  154: 	                else
  155: 	                {
  156: 	                    s_System.RecoveryOldCard = 0;
000940 E4                CLR      A
000941 9000B1            MOV      DPTR,#s_System+010H
000944 F0                MOVX     @DPTR,A
  157: 	                }
  158: 	            }
  159: 	            else
  160: 	            {
  161: 	                break;
  162: 	            }
000945         ?C0037?APP_BRUSH:
  163:                 app_configWrite(SYSTEM_SETTING_SECTOR);
000945 E4                CLR      A
000946 FF                MOV      R7,A
000947 51E0              ACALL    _app_configWrite
  164:                 Led_ShowZero();
000949 1153              ACALL    Led_ShowZero
  165:                 gLedBuf[0] = s_System.Sector/10;
00094B 9000A7            MOV      DPTR,#s_System+06H
00094E E0                MOVX     A,@DPTR
00094F FF                MOV      R7,A
000950 75F00A            MOV      B,#0AH
000953 84                DIV      AB
000954 9000C9            MOV      DPTR,#gLedBuf
000957 51C3              ACALL    ?L?COM0025
  166:                 gLedBuf[1] = s_System.Sector%10;
  167:                 gLedBuf[4] = s_System.PulseWidth/10;
000959 9000A8            MOV      DPTR,#s_System+07H
00095C E0                MOVX     A,@DPTR
00095D FF                MOV      R7,A
00095E 75F00A            MOV      B,#0AH
000961 84                DIV      AB
000962 9000CD            MOV      DPTR,#gLedBuf+04H
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 24


000965 51C3              ACALL    ?L?COM0025
  168:                 gLedBuf[5] = s_System.PulseWidth%10;
  169:                 buzzer_SoundNumber(1);
000967 7F01              MOV      R7,#01H
000969 51A3              ACALL    _buzzer_SoundNumber
  170:                 sys_delayms(1000);
00096B 7FE8              MOV      R7,#0E8H
00096D 7E03              MOV      R6,#03H
00096F 1106              ACALL    _sys_delayms
  171:                 b_FactorySystem = FALSE;
000971 C207              CLR      b_FactorySystem
  172:             }
  173:             break;
000973 4136              AJMP     ?C0022?APP_BRUSH
  174:             
  175:         case USER_CARD:
000975         ?C0038?APP_BRUSH:
  176: //                memset(gBuff, 0x00, sizeof(gBuff));
  177: //                pMoney->money = 20000;										//充钱
  178: //                if (hwa_mifareWriteSector(gBuff, s_System.Sector))
  179: //                {
  180: //                    buzzer_SoundNumber(1);
  181: //                }
  182: //                break;
  183:             if(hwa_mifareReadSector(gBuff, s_System.Sector))
000975 12061D            LCALL    ?L?COM000A
000978 9000A7            MOV      DPTR,#s_System+06H
00097B E0                MOVX     A,@DPTR
00097C FD                MOV      R5,A
00097D 71F1              ACALL    _hwa_mifareReadSector
00097F 4002              JC       $ + 4H
000981 4136              AJMP     ?C0022?APP_BRUSH
  184:             {
  185:                 if (pMoney->money >= s_System.Money)//确保余额充足
000983 71E8              ACALL    ?L?COM0030
000985 FF                MOV      R7,A
000986 AEF0              MOV      R6,B
000988 9000B2            MOV      DPTR,#s_System+011H
00098B 1211DB            LCALL    ?L?COM004A
00098E 9E                SUBB     A,R6
00098F 4002              JC       $ + 4H
000991 4132              AJMP     ?C0040?APP_BRUSH
  186:                 {
  187:                     pMoney->money -= s_System.Money;
000993 C3                CLR      C
000994 EF                MOV      A,R7
000995 9D                SUBB     A,R5
000996 FF                MOV      R7,A
000997 EE                MOV      A,R6
000998 9C                SUBB     A,R4
000999 8FF0              MOV      B,R7
00099B 12023E            LCALL    ?C?ISTPTR
  188:                     if(hwa_mifareWriteSector(gBuff, s_System.Sector))
00099E 12061D            LCALL    ?L?COM000A
0009A1 9000A7            MOV      DPTR,#s_System+06H
0009A4 E0                MOVX     A,@DPTR
0009A5 FD                MOV      R5,A
0009A6 B1EF              ACALL    _hwa_mifareWriteSector
0009A8 4002              JC       $ + 4H
0009AA 4136              AJMP     ?C0022?APP_BRUSH
  189:                     {
  190:                     	led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
0009AC 71E8              ACALL    ?L?COM0030
0009AE FB                MOV      R3,A
0009AF AAF0              MOV      R2,B
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 25


0009B1 51D6              ACALL    ?L?COM0011
0009B3 C006              PUSH     AR6
0009B5 C007              PUSH     AR7
0009B7 51BA              ACALL    ?L?COM002B
0009B9 1201A8            LCALL    ?C?UIDIV
0009BC D007              POP      AR7
0009BE D006              POP      AR6
0009C0 7B08              MOV      R3,#08H
0009C2 5144              ACALL    _led_ShowNumber
  191:                         MoneySum += s_System.Money;
0009C4 90009D            MOV      DPTR,#MoneySum
0009C7 E0                MOVX     A,@DPTR
0009C8 F8                MOV      R0,A
0009C9 A3                INC      DPTR
0009CA E0                MOVX     A,@DPTR
0009CB F9                MOV      R1,A
0009CC A3                INC      DPTR
0009CD E0                MOVX     A,@DPTR
0009CE FA                MOV      R2,A
0009CF A3                INC      DPTR
0009D0 E0                MOVX     A,@DPTR
0009D1 FB                MOV      R3,A
0009D2 9000B2            MOV      DPTR,#s_System+011H
0009D5 E0                MOVX     A,@DPTR
0009D6 FE                MOV      R6,A
0009D7 A3                INC      DPTR
0009D8 E0                MOVX     A,@DPTR
0009D9 FF                MOV      R7,A
0009DA E4                CLR      A
0009DB FC                MOV      R4,A
0009DC FD                MOV      R5,A
0009DD EB                MOV      A,R3
0009DE 2F                ADD      A,R7
0009DF FF                MOV      R7,A
0009E0 EA                MOV      A,R2
0009E1 3E                ADDC     A,R6
0009E2 FE                MOV      R6,A
0009E3 ED                MOV      A,R5
0009E4 39                ADDC     A,R1
0009E5 FD                MOV      R5,A
0009E6 EC                MOV      A,R4
0009E7 38                ADDC     A,R0
0009E8 FC                MOV      R4,A
0009E9 90009D            MOV      DPTR,#MoneySum
0009EC 12032B            LCALL    ?C?LSTXDATA
  192:     					app_configWrite(MONEY_SECTOR);
0009EF 7F01              MOV      R7,#01H
0009F1 51E0              ACALL    _app_configWrite
  193:                         
  194:                         if(s_System.Money != 100)
0009F3 9000B2            MOV      DPTR,#s_System+011H
0009F6 E0                MOVX     A,@DPTR
0009F7 7004              JNZ      ?C0049?APP_BRUSH
0009F9 A3                INC      DPTR
0009FA E0                MOVX     A,@DPTR
0009FB 6464              XRL      A,#064H
0009FD         ?C0049?APP_BRUSH:
0009FD 9000A8            MOV      DPTR,#s_System+07H
000A00 6006              JZ       ?C0042?APP_BRUSH
  195:                         {
  196:                             app_pulseSendPulse(s_System.PulseWidth, 9);     //充电站->1,洗衣机->9
000A02 E0                MOVX     A,@DPTR
000A03 FF                MOV      R7,A
000A04 7D09              MOV      R5,#09H
  197:                         }
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 26


000A06 8004              SJMP     ?C0053?APP_BRUSH
000A08         ?C0042?APP_BRUSH:
  198:                         else
  199:                         {
  200:                             app_pulseSendPulse(s_System.PulseWidth, 1);
000A08 E0                MOVX     A,@DPTR
000A09 FF                MOV      R7,A
000A0A 7D01              MOV      R5,#01H
000A0C         
000A0C F1DB              ACALL    _app_pulseSendPulse
  201:                         }
000A0E         ?C0043?APP_BRUSH:
  202:                         buzzer_SoundNumber(1);
000A0E 7F01              MOV      R7,#01H
000A10 51A3              ACALL    _buzzer_SoundNumber
  203:                         led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
000A12 71E8              ACALL    ?L?COM0030
000A14 FB                MOV      R3,A
000A15 AAF0              MOV      R2,B
000A17 51D6              ACALL    ?L?COM0011
000A19 C006              PUSH     AR6
000A1B C007              PUSH     AR7
000A1D 51BA              ACALL    ?L?COM002B
000A1F 1201A8            LCALL    ?C?UIDIV
000A22 D007              POP      AR7
000A24 D006              POP      AR6
000A26 7B08              MOV      R3,#08H
000A28 5144              ACALL    _led_ShowNumber
  204:                         sys_delayms(3000);
000A2A 7FB8              MOV      R7,#0B8H
000A2C 7E0B              MOV      R6,#0BH
000A2E         
000A2E 1106              ACALL    _sys_delayms
  205:                         break;
000A30 8004              SJMP     ?C0022?APP_BRUSH
  206:                     }
  207:                 }
000A32         ?C0040?APP_BRUSH:
  208:                 else
  209:                 {
  210:                     buzzer_SoundNumber(3);
000A32 7F03              MOV      R7,#03H
000A34 51A3              ACALL    _buzzer_SoundNumber
  211:                 }
  212:             }
  213:             break;
  214:             
  215:         default:
  216:             break;
  217:     }
000A36         ?C0022?APP_BRUSH:
  218:     
  219:     if(u8_FirstBrushCardDly)
000A36 9000D9            MOV      DPTR,#u8_FirstBrushCardDly
000A39 E0                MOVX     A,@DPTR
000A3A 6002              JZ       ?C0046?APP_BRUSH
  220:     {
  221:         u8_FirstBrushCardDly--;
000A3C 14                DEC      A
000A3D F0                MOVX     @DPTR,A
  222:     }
000A3E         ?C0046?APP_BRUSH:
  223:     if(!b_FactorySystem)
000A3E 200702            JB       b_FactorySystem,?C0048?APP_BRUSH
  224:     {
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 27


  225:         Led_ShowZero();
000A41 1153              ACALL    Led_ShowZero
  226:     }
  227: }
000A43         ?C0048?APP_BRUSH:
000A43 22                RET      
----- FUNCTION app_brushCycle1s (END) -------


----- FUNCTION _led_ShowNumber (BEGIN) -----
 FILE: 'Driver\LED.c'
   95: void led_ShowNumber(UINT16 L_num, UINT8 R_num, UINT8 DotPlace)
   96: {
000A44 900070            MOV      DPTR,#L_num
000A47 EE                MOV      A,R6
000A48 F0                MOVX     @DPTR,A
000A49 A3                INC      DPTR
000A4A EF                MOV      A,R7
000A4B F0                MOVX     @DPTR,A
;---- Variable 'R_num' assigned to Register 'R2' ----
000A4C AA05              MOV      R2,AR5
;---- Variable 'DotPlace' assigned to Register 'R3' ----
   97:     if(L_num>9999)
   98:     {
000A4E D3                SETB     C
000A4F E0                MOVX     A,@DPTR
000A50 940F              SUBB     A,#0FH
000A52 900070            MOV      DPTR,#L_num
000A55 E0                MOVX     A,@DPTR
000A56 9427              SUBB     A,#027H
000A58 4007              JC       ?C0034?LED
   99:         L_num = 9999;
  100:     }
000A5A 7427              MOV      A,#027H
000A5C F0                MOVX     @DPTR,A
000A5D A3                INC      DPTR
000A5E 740F              MOV      A,#0FH
000A60 F0                MOVX     @DPTR,A
  101:     if(R_num>99)
000A61         ?C0034?LED:
  102:     {
000A61 EA                MOV      A,R2
000A62 D3                SETB     C
000A63 9463              SUBB     A,#063H
000A65 4002              JC       ?C0035?LED
  103:         R_num = 99;
  104:     }
000A67 7A63              MOV      R2,#063H
  105:     gLedBuf[0] = L_num/1000;
000A69         ?C0035?LED:
  106:     gLedBuf[1] = L_num/100%10;
000A69 D1B8              ACALL    ?L?COM0043
000A6B 7C03              MOV      R4,#03H
000A6D 7DE8              MOV      R5,#0E8H
000A6F 1201A8            LCALL    ?C?UIDIV
000A72 9000C9            MOV      DPTR,#gLedBuf
000A75 EF                MOV      A,R7
000A76 F0                MOVX     @DPTR,A
  107:     gLedBuf[2] = L_num/10%10;
000A77 D1B8              ACALL    ?L?COM0043
000A79 7C00              MOV      R4,#00H
000A7B 7D64              MOV      R5,#064H
000A7D 1201A8            LCALL    ?C?UIDIV
000A80 51B3              ACALL    ?L?COM0018
000A82 9000CA            MOV      DPTR,#gLedBuf+01H
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 28


000A85 51A9              ACALL    ?L?COM0017
000A87 51B3              ACALL    ?L?COM0018
000A89 9000CB            MOV      DPTR,#gLedBuf+02H
000A8C 51A9              ACALL    ?L?COM0017
000A8E 9000CC            MOV      DPTR,#gLedBuf+03H
000A91 ED                MOV      A,R5
000A92 F0                MOVX     @DPTR,A
  108:     gLedBuf[3] = L_num%10;
  109:     gLedBuf[4] = R_num/10%10;
000A93 EA                MOV      A,R2
000A94 75F00A            MOV      B,#0AH
000A97 84                DIV      AB
000A98 51C5              ACALL    ?L?COM0026
  110:     gLedBuf[5] = R_num%10;
000A9A EA                MOV      A,R2
000A9B 51C5              ACALL    ?L?COM0026
  111:     gShowDot = DotPlace;
000A9D 9000D0            MOV      DPTR,#gShowDot
000AA0 EB                MOV      A,R3
000AA1 F0                MOVX     @DPTR,A
  112: }
000AA2 22                RET      
----- FUNCTION _led_ShowNumber (END) -------


----- FUNCTION _buzzer_SoundNumber (BEGIN) -----
 FILE: 'Driver\buzzer.c'
   28: void buzzer_SoundNumber(UINT8 num)
   29: {
;---- Variable 'num' assigned to Register 'R7' ----
   30:     SoundNumberCount = num;
   30: }
000AA3 9000DB            MOV      DPTR,#SoundNumberCount
000AA6 EF                MOV      A,R7
000AA7 F0                MOVX     @DPTR,A
   30: 
000AA8 22                RET      
----- FUNCTION _buzzer_SoundNumber (END) -------


----- FUNCTION ?L?COM0017 (BEGIN) -----
000AA9 ED                MOV      A,R5
000AAA F0                MOVX     @DPTR,A
000AAB 900070            MOV      DPTR,#L_num
000AAE E0                MOVX     A,@DPTR
000AAF FE                MOV      R6,A
000AB0 A3                INC      DPTR
000AB1 E0                MOVX     A,@DPTR
000AB2 FF                MOV      R7,A
000AB3         ?L?COM0018:
000AB3 7C00              MOV      R4,#00H
000AB5 7D0A              MOV      R5,#0AH
000AB7 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM0017 (END) -------


----- FUNCTION ?L?COM002B (BEGIN) -----
000ABA 7C00              MOV      R4,#00H
000ABC 7D64              MOV      R5,#064H
000ABE AF03              MOV      R7,AR3
000AC0 AE02              MOV      R6,AR2
000AC2 22                RET      
----- FUNCTION ?L?COM002B (END) -------


LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 29


----- FUNCTION ?L?COM0025 (BEGIN) -----
000AC3 F0                MOVX     @DPTR,A
000AC4 EF                MOV      A,R7
000AC5         ?L?COM0026:
000AC5 75F00A            MOV      B,#0AH
000AC8 84                DIV      AB
000AC9 A3                INC      DPTR
000ACA E5F0              MOV      A,B
000ACC F0                MOVX     @DPTR,A
000ACD 22                RET      
----- FUNCTION ?L?COM0025 (END) -------


----- FUNCTION ?L?COM0010 (BEGIN) -----
000ACE 9000B2            MOV      DPTR,#s_System+011H
000AD1 E0                MOVX     A,@DPTR
000AD2 FA                MOV      R2,A
000AD3 A3                INC      DPTR
000AD4 E0                MOVX     A,@DPTR
000AD5 FB                MOV      R3,A
000AD6         ?L?COM0011:
000AD6 7C00              MOV      R4,#00H
000AD8 7D64              MOV      R5,#064H
000ADA FF                MOV      R7,A
000ADB AE02              MOV      R6,AR2
000ADD 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM0010 (END) -------


----- FUNCTION _app_configWrite (BEGIN) -----
 FILE: 'App\app_config.c'
  104: void app_configWrite(UINT8 Sector)
  105: {
000AE0 900070            MOV      DPTR,#Sector
000AE3 EF                MOV      A,R7
000AE4 F0                MOVX     @DPTR,A
  106:     led_Switch(OFF);
  107:     if(Sector == SYSTEM_SETTING_SECTOR)
000AE5 C201              CLR      ?led_Switch?BIT
000AE7 7103              ACALL    led_Switch
  108:     {
000AE9 900070            MOV      DPTR,#Sector
000AEC E0                MOVX     A,@DPTR
000AED 7B01              MOV      R3,#01H
000AEF 7007              JNZ      ?C0013?APP_CONFIG
  109:         hwa_eepromWriteSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
  110:     }
000AF1 7A00              MOV      R2,#HIGH s_System
000AF3 79A1              MOV      R1,#LOW s_System
000AF5 FD                MOV      R5,A
  111:     else
000AF6 8006              SJMP     ?C0018?APP_CONFIG
000AF8         ?C0013?APP_CONFIG:
  112:     {
  113:         hwa_eepromWriteSector((UINT8*)&MoneySum, MONEY_SECTOR);
000AF8 7A00              MOV      R2,#HIGH MoneySum
000AFA 799D              MOV      R1,#LOW MoneySum
000AFC 7D01              MOV      R5,#01H
000AFE         
000AFE 1213AF            LCALL    _hwa_eepromWriteSector
  114:     }
000B01         ?C0014?APP_CONFIG:
  115:     led_Switch(ON);
000B01 D201              SETB     ?led_Switch?BIT
;----                  JMP      led_Switch
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 30


----- FUNCTION _app_configWrite (END) -------


----- FUNCTION led_Switch (BEGIN) -----
 FILE: 'Driver\LED.c'
  125: void led_Switch(bit sw)
  126: {
  127:     ledsw = sw;
  128:     if(ledsw==0)
000B03 A201              MOV      C,sw
000B05 9208              MOV      ledsw,C
  129:     {
000B07 200803            JB       ledsw,?C0039?LED
  130:     	LED_CS0 = 1;
  131:     	LED_CS1 = 1;
000B0A 1211E4            LCALL    ?L?COM0037
  132:     	LED_CS2 = 1;
  133:     	LED_CS3 = 1;
  134:     	LED_CS4 = 1;
  135:     	LED_CS5 = 1;
  136:     }
  137: }
000B0D         ?C0039?LED:
000B0D 22                RET      
----- FUNCTION led_Switch (END) -------


----- FUNCTION app_configInit (BEGIN) -----
 FILE: 'App\app_config.c'
   47: void app_configInit(void)
   48: {
   49:     BOOL state = FALSE;
   50:     led_Switch(OFF);
000B0E C200              CLR      state
   51:     hwa_eepromInit();
000B10 C201              CLR      ?led_Switch?BIT
000B12 7103              ACALL    led_Switch
   52:     if(app_configRead(SYSTEM_SETTING_SECTOR) == FALSE)
000B14 12000A            LCALL    hwa_eepromInit
   53:     {
000B17 E4                CLR      A
000B18 FF                MOV      R7,A
000B19 D1C1              ACALL    _app_configRead
000B1B 4021              JC       ?C0001?APP_CONFIG
   54:         memcpy(&s_System, &s_FactorySystem, sizeof(s_System));
   55:         b_FactorySystem = TRUE;
000B1D 78A1              MOV      R0,#LOW s_System
000B1F 7C00              MOV      R4,#HIGH s_System
000B21 7D01              MOV      R5,#01H
000B23 7BFF              MOV      R3,#0FFH
000B25 7A00              MOV      R2,#HIGH s_FactorySystem
000B27 790E              MOV      R1,#LOW s_FactorySystem
000B29 7E00              MOV      R6,#00H
000B2B 7F13              MOV      R7,#013H
000B2D 1200F6            LCALL    ?C?COPY
   56:         led_ShowNumber(8888,88,0xFF);
000B30 D207              SETB     b_FactorySystem
   57:     }
000B32 7BFF              MOV      R3,#0FFH
000B34 7D58              MOV      R5,#058H
000B36 7FB8              MOV      R7,#0B8H
000B38 7E22              MOV      R6,#022H
000B3A 5144              ACALL    _led_ShowNumber
   58:     else
000B3C 8060              SJMP     ?C0002?APP_CONFIG
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 31


000B3E         ?C0001?APP_CONFIG:
   59:     {
   60:         if(s_System.Sector > 16 || s_System.Sector < 1)                 //钱包分区不在1~16
000B3E 9000A7            MOV      DPTR,#s_System+06H
000B41 E0                MOVX     A,@DPTR
000B42 FF                MOV      R7,A
000B43 D3                SETB     C
000B44 9410              SUBB     A,#010H
000B46 5006              JNC      ?C0004?APP_CONFIG
000B48 EF                MOV      A,R7
000B49 C3                CLR      C
000B4A 9401              SUBB     A,#01H
000B4C 500B              JNC      ?C0003?APP_CONFIG
000B4E         ?C0004?APP_CONFIG:
   61:         {
   62:             s_System.Sector = s_FactorySystem.Sector;
000B4E 900014            MOV      DPTR,#s_FactorySystem+06H
000B51 E4                CLR      A
000B52 93                MOVC     A,@A+DPTR
000B53 9000A7            MOV      DPTR,#s_System+06H
000B56 F0                MOVX     @DPTR,A
   63:             state = TRUE;
000B57 D200              SETB     state
   64:         }
000B59         ?C0003?APP_CONFIG:
   65:         if(s_System.PulseWidth<10 && s_System.PulseWidth>60)
000B59 9000A8            MOV      DPTR,#s_System+07H
000B5C E0                MOVX     A,@DPTR
000B5D FF                MOV      R7,A
000B5E C3                CLR      C
000B5F 940A              SUBB     A,#0AH
000B61 5010              JNC      ?C0005?APP_CONFIG
000B63 EF                MOV      A,R7
000B64 943C              SUBB     A,#03CH
000B66 400B              JC       ?C0005?APP_CONFIG
   66:         {
   67:             s_System.PulseWidth = s_FactorySystem.PulseWidth;
000B68 900015            MOV      DPTR,#s_FactorySystem+07H
000B6B E4                CLR      A
000B6C 93                MOVC     A,@A+DPTR
000B6D 9000A8            MOV      DPTR,#s_System+07H
000B70 F0                MOVX     @DPTR,A
   68:             state = TRUE;
000B71 D200              SETB     state
   69:         }
000B73         ?C0005?APP_CONFIG:
   70:         if(s_System.Money > 200)                                        //金额整数部分大于10
000B73 D3                SETB     C
000B74 9000B3            MOV      DPTR,#s_System+012H
000B77 E0                MOVX     A,@DPTR
000B78 94C8              SUBB     A,#0C8H
000B7A 9000B2            MOV      DPTR,#s_System+011H
000B7D E0                MOVX     A,@DPTR
000B7E 9400              SUBB     A,#00H
000B80 4013              JC       ?C0006?APP_CONFIG
   71:         {
   72:             s_System.Money = s_FactorySystem.Money;
000B82 90001F            MOV      DPTR,#s_FactorySystem+011H
000B85 E4                CLR      A
000B86 93                MOVC     A,@A+DPTR
000B87 FF                MOV      R7,A
000B88 7401              MOV      A,#01H
000B8A 93                MOVC     A,@A+DPTR
000B8B 9000B2            MOV      DPTR,#s_System+011H
000B8E CF                XCH      A,R7
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 32


000B8F F0                MOVX     @DPTR,A
000B90 A3                INC      DPTR
000B91 EF                MOV      A,R7
000B92 F0                MOVX     @DPTR,A
   73:             state = TRUE;
000B93 D200              SETB     state
   74:         }
000B95         ?C0006?APP_CONFIG:
   75:         if(state)
000B95 300006            JNB      state,?C0002?APP_CONFIG
   76:         {
   77: 			app_configWrite(SYSTEM_SETTING_SECTOR);
000B98 E4                CLR      A
000B99 FF                MOV      R7,A
000B9A 51E0              ACALL    _app_configWrite
   78:             b_FactorySystem = TRUE;
000B9C D207              SETB     b_FactorySystem
   79:         }
   80:     }
000B9E         ?C0002?APP_CONFIG:
   81:     
   82:     if(app_configRead(MONEY_SECTOR) == FALSE)
000B9E 7F01              MOV      R7,#01H
000BA0 D1C1              ACALL    _app_configRead
000BA2 4013              JC       ?C0008?APP_CONFIG
   83:     {
   84:         memset(&MoneySum, 0x00, sizeof(MoneySum));
000BA4 7E00              MOV      R6,#00H
000BA6 7F04              MOV      R7,#04H
000BA8 7D00              MOV      R5,#00H
000BAA 7B01              MOV      R3,#01H
000BAC 7A00              MOV      R2,#HIGH MoneySum
000BAE 799D              MOV      R1,#LOW MoneySum
000BB0 120337            LCALL    ?C?MEMSET
   85: 		app_configWrite(MONEY_SECTOR);
000BB3 7F01              MOV      R7,#01H
000BB5 51E0              ACALL    _app_configWrite
   86:     }
000BB7         ?C0008?APP_CONFIG:
   87:     led_Switch(ON);
000BB7 D201              SETB     ?led_Switch?BIT
000BB9 6103              AJMP     led_Switch
----- FUNCTION app_configInit (END) -------


----- FUNCTION _hwa_mifareReadBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   57: BOOL hwa_mifareReadBlock(UINT8 *buff, UINT8 block)
   58: {
000BBB 900076            MOV      DPTR,#buff
000BBE 1207F9            LCALL    ?L?COM0002
000BC1 A3                INC      DPTR
000BC2 ED                MOV      A,R5
000BC3 F0                MOVX     @DPTR,A
   59: 	UINT8 u8_ReadErrCount;
   60: 	UINT8 u8_Result;
   61: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
000BC4 E4                CLR      A
000BC5 A3                INC      DPTR
000BC6 F0                MOVX     @DPTR,A
000BC7         ?C0018?HWA_MIFARE:
   62: 	{
   63: 		u8_Result = Read_Block(buff, block);
000BC7 900076            MOV      DPTR,#buff
000BCA 1207E1            LCALL    ?L?COM0004
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 33


000BCD F9                MOV      R1,A
000BCE A3                INC      DPTR
000BCF E0                MOVX     A,@DPTR
000BD0 FD                MOV      R5,A
000BD1 1217BF            LCALL    _Read_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   64: 		if (u8_Result == FM1702_OK)
000BD4 EF                MOV      A,R7
000BD5 7002              JNZ      ?C0021?HWA_MIFARE
   65: 		{
   66: 			return TRUE;
000BD7 D3                SETB     C
000BD8 22                RET      
   67: 		}
000BD9         ?C0021?HWA_MIFARE:
   68: 		else if (u8_Result == FM1702_NOTAGERR)
000BD9 EF                MOV      A,R7
000BDA B40102            CJNE     A,#01H,?C0020?HWA_MIFARE
   69: 		{
   70: 			return FALSE;
000BDD C3                CLR      C
000BDE 22                RET      
   71: 		}
   72: 	}
000BDF         ?C0020?HWA_MIFARE:
000BDF 90007A            MOV      DPTR,#u8_ReadErrCount
000BE2 F172              ACALL    ?L?COM0052
000BE4 40E1              JC       ?C0018?HWA_MIFARE
000BE6         ?C0019?HWA_MIFARE:
   73: 	return FALSE;
000BE6 C3                CLR      C
   74: }
000BE7 22                RET      
----- FUNCTION _hwa_mifareReadBlock (END) -------


----- FUNCTION ?L?COM0030 (BEGIN) -----
000BE8 AB08              MOV      R3,pMoney
000BEA AA09              MOV      R2,pMoney+01H
000BEC A90A              MOV      R1,pMoney+02H
000BEE 020213            LJMP     ?C?ILDPTR
----- FUNCTION ?L?COM0030 (END) -------


----- FUNCTION _hwa_mifareReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  194: BOOL hwa_mifareReadSector(UINT8 *dat, UINT8 sector)
  195: {
000BF1 900070            MOV      DPTR,#dat
000BF4 1207F9            LCALL    ?L?COM0002
000BF7 A3                INC      DPTR
000BF8 ED                MOV      A,R5
000BF9 F0                MOVX     @DPTR,A
  196: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  197: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
000BFA F185              ACALL    ?L?COM0034
  198: 
  199: 	if (dat != NULL && sector > 0 && sector < 16)
000BFC 900070            MOV      DPTR,#dat
000BFF 1207E1            LCALL    ?L?COM0004
000C02 4A                ORL      A,R2
000C03 4B                ORL      A,R3
000C04 7002              JNZ      $ + 4H
000C06 81A0              AJMP     ?C0051?HWA_MIFARE
000C08 A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 34


000C09 E0                MOVX     A,@DPTR
000C0A FF                MOV      R7,A
000C0B D3                SETB     C
000C0C 9400              SUBB     A,#00H
000C0E 5002              JNC      $ + 4H
000C10 81A0              AJMP     ?C0051?HWA_MIFARE
000C12 EF                MOV      A,R7
000C13 9410              SUBB     A,#010H
000C15 4002              JC       $ + 4H
000C17 81A0              AJMP     ?C0051?HWA_MIFARE
  200: 	{
  201: 		if (hwa_mifareReadBlock((UINT8*)&s_NormalBuff, block) == FALSE)
000C19 91A2              ACALL    ?L?COM001B
000C1B A3                INC      DPTR
000C1C E0                MOVX     A,@DPTR
000C1D FD                MOV      R5,A
000C1E 71BB              ACALL    _hwa_mifareReadBlock
000C20 4001              JC       ?C0052?HWA_MIFARE
  202: 		{
  203: 			return FALSE;
000C22 22                RET      
  204: 		}
000C23         ?C0052?HWA_MIFARE:
  205: 
  206: 		if (hwa_mifareReadBlock((UINT8*)&s_BackupBuff, blockBak) == FALSE)
000C23 91DF              ACALL    ?L?COM001C
000C25 900075            MOV      DPTR,#blockBak
000C28 E0                MOVX     A,@DPTR
000C29 FD                MOV      R5,A
000C2A 71BB              ACALL    _hwa_mifareReadBlock
000C2C 4001              JC       ?C0054?HWA_MIFARE
  207: 		{
  208: 			return FALSE;
000C2E 22                RET      
  209: 		}
000C2F         ?C0054?HWA_MIFARE:
  210: 
  211: 		hwa_mifareCheckBlock();
000C2F 91E6              ACALL    hwa_mifareCheckBlock
  212: 
  213: 		if (NormalErrorFlag && BackupErrorFlag)				//正常块和备份块都校验错误
000C31 300518            JNB      NormalErrorFlag,?C0055?HWA_MIFARE
000C34 300415            JNB      BackupErrorFlag,?C0055?HWA_MIFARE
  214: 		{
  215:             if(s_System.RecoveryOldCard)
000C37 9000B1            MOV      DPTR,#s_System+010H
000C3A E0                MOVX     A,@DPTR
000C3B 900073            MOV      DPTR,#sector
000C3E 6006              JZ       ?C0056?HWA_MIFARE
  216:             {
  217:                 hwa_mifareRecoveryOldCard(sector);				//兼容旧卡
000C40 E0                MOVX     A,@DPTR
000C41 FF                MOV      R7,A
000C42 B126              ACALL    _hwa_mifareRecoveryOldCard
  218:             }
000C44 8004              SJMP     ?C0057?HWA_MIFARE
000C46         ?C0056?HWA_MIFARE:
  219:             else
  220:             {
  221:                 hwa_mifareRecoveryNewCard(sector);				//兼容新卡
000C46 E0                MOVX     A,@DPTR
000C47 FF                MOV      R7,A
000C48 91A9              ACALL    _hwa_mifareRecoveryNewCard
  222:             }
000C4A         ?C0057?HWA_MIFARE:
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 35


  223: 			return FALSE;
000C4A C3                CLR      C
000C4B 22                RET      
  224: 		}
000C4C         ?C0055?HWA_MIFARE:
  225: 		else if (NormalErrorFlag)							//正常块校验错误
000C4C 30050C            JNB      NormalErrorFlag,?C0059?HWA_MIFARE
  226: 		{
  227: 			if (hwa_mifareWriteBlock((UINT8*)&s_BackupBuff, block) == FALSE)
000C4F 91DF              ACALL    ?L?COM001C
000C51 900074            MOV      DPTR,#block
000C54 E0                MOVX     A,@DPTR
000C55 FD                MOV      R5,A
000C56 B1AE              ACALL    _hwa_mifareWriteBlock
000C58 4028              JC       ?C0058?HWA_MIFARE
  228: 			{
  229: 				return FALSE;
000C5A 22                RET      
  230: 			}
  231: 		}
000C5B         ?C0059?HWA_MIFARE:
  232: 		else if (BackupErrorFlag							//备份块校验错误
000C5B 200418            JB       BackupErrorFlag,?C0063?HWA_MIFARE
000C5E 900042            MOV      DPTR,#s_BackupBuff+02H
000C61 E0                MOVX     A,@DPTR
000C62 FF                MOV      R7,A
000C63 900052            MOV      DPTR,#s_NormalBuff+02H
000C66 E0                MOVX     A,@DPTR
000C67 B5070C            CJNE     A,AR7,?C0063?HWA_MIFARE
000C6A 900043            MOV      DPTR,#s_BackupBuff+03H
000C6D E0                MOVX     A,@DPTR
000C6E FF                MOV      R7,A
000C6F 900053            MOV      DPTR,#s_NormalBuff+03H
000C72 E0                MOVX     A,@DPTR
000C73 6F                XRL      A,R7
000C74 600C              JZ       ?C0058?HWA_MIFARE
000C76         ?C0063?HWA_MIFARE:
  233: 			|| s_NormalBuff.crc[0] != s_BackupBuff.crc[0]	//正常块和备份块校验正确但数据不一样，用正常块替换备份块
  234: 			|| s_NormalBuff.crc[1] != s_BackupBuff.crc[1]
  235:         )
  236: 		{
  237: 			if (hwa_mifareWriteBlock((UINT8*)&s_NormalBuff, blockBak) == FALSE)
000C76 91A2              ACALL    ?L?COM001B
000C78 900075            MOV      DPTR,#blockBak
000C7B E0                MOVX     A,@DPTR
000C7C FD                MOV      R5,A
000C7D B1AE              ACALL    _hwa_mifareWriteBlock
000C7F 4001              JC       ?C0058?HWA_MIFARE
  238: 			{
  239: 				return FALSE;
000C81 22                RET      
  240: 			}
  241: 		}
000C82         ?C0058?HWA_MIFARE:
  242: 		if (BackupErrorFlag)
000C82 900070            MOV      DPTR,#dat
000C85 1207E1            LCALL    ?L?COM0004
000C88 F8                MOV      R0,A
000C89 AC02              MOV      R4,AR2
000C8B AD03              MOV      R5,AR3
000C8D 7B01              MOV      R3,#01H
000C8F 300406            JNB      BackupErrorFlag,?C0065?HWA_MIFARE
  243: 		{
  244: 			memcpy(dat, (UINT8*)&s_NormalBuff, DATA_BLOCK_SIZE);
000C92 7A00              MOV      R2,#HIGH s_NormalBuff
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 36


000C94 7950              MOV      R1,#LOW s_NormalBuff
  245: 		}
000C96 8004              SJMP     ?C0083?HWA_MIFARE
000C98         ?C0065?HWA_MIFARE:
  246: 		else
  247: 		{
  248: 			memcpy(dat, (UINT8*)&s_BackupBuff, DATA_BLOCK_SIZE);
000C98 7A00              MOV      R2,#HIGH s_BackupBuff
000C9A 7940              MOV      R1,#LOW s_BackupBuff
000C9C         
000C9C D19C              ACALL    ?L?COM003C
  249: 		}
000C9E         ?C0066?HWA_MIFARE:
  250: 		return TRUE;
000C9E D3                SETB     C
000C9F 22                RET      
  251: 	}
000CA0         ?C0051?HWA_MIFARE:
  252: 	return FALSE;
000CA0 C3                CLR      C
  253: }
000CA1 22                RET      
----- FUNCTION _hwa_mifareReadSector (END) -------


----- FUNCTION ?L?COM001B (BEGIN) -----
000CA2 7B01              MOV      R3,#01H
000CA4 7A00              MOV      R2,#HIGH s_NormalBuff
000CA6 7950              MOV      R1,#LOW s_NormalBuff
000CA8 22                RET      
----- FUNCTION ?L?COM001B (END) -------


----- FUNCTION _hwa_mifareRecoveryNewCard (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  172: static void hwa_mifareRecoveryNewCard(UINT8 sector)
  173: {
000CA9 900076            MOV      DPTR,#sector
000CAC EF                MOV      A,R7
000CAD F0                MOVX     @DPTR,A
  174:     hwa_mifareEncrypt((UINT8*)&s_NormalBuff);             //旧卡由于未加密，校验时进行了解密操作，故此时利用卡ID
>> 用
  175: 	if (s_NormalBuff.money == 0
000CAE 91A2              ACALL    ?L?COM001B
000CB0 D1B1              ACALL    ?L?COM004F
000CB2 7002              JNZ      ?C0077?HWA_MIFARE
000CB4 A3                INC      DPTR
000CB5 E0                MOVX     A,@DPTR
000CB6         ?C0077?HWA_MIFARE:
000CB6 700E              JNZ      ?C0048?HWA_MIFARE
000CB8 900052            MOV      DPTR,#s_NormalBuff+02H
000CBB E0                MOVX     A,@DPTR
000CBC 7008              JNZ      ?C0048?HWA_MIFARE
000CBE A3                INC      DPTR
000CBF E0                MOVX     A,@DPTR
000CC0 7004              JNZ      ?C0048?HWA_MIFARE
  176: 		&& s_NormalBuff.crc[0] == 0
  177: 		&& s_NormalBuff.crc[1] == 0
  178: 		)
  179: 	{
  180: 		hwa_mifareWriteSector((UINT8*)&s_NormalBuff, sector);
000CC2 91A2              ACALL    ?L?COM001B
000CC4 8016              SJMP     ?C0082?HWA_MIFARE
  181: 		return;
  182: 	}
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 37


000CC6         ?C0048?HWA_MIFARE:
  183:     hwa_mifareEncrypt((UINT8*)&s_BackupBuff);             //旧卡由于未加密，校验时进行了解密操作，故此时利用卡ID
>> 用
000CC6 91DF              ACALL    ?L?COM001C
000CC8 D1AA              ACALL    ?L?COM004C
000CCA 7002              JNZ      ?C0078?HWA_MIFARE
000CCC A3                INC      DPTR
000CCD E0                MOVX     A,@DPTR
000CCE         ?C0078?HWA_MIFARE:
000CCE 700E              JNZ      ?C0049?HWA_MIFARE
000CD0 900042            MOV      DPTR,#s_BackupBuff+02H
000CD3 E0                MOVX     A,@DPTR
000CD4 7008              JNZ      ?C0049?HWA_MIFARE
000CD6 A3                INC      DPTR
000CD7 E0                MOVX     A,@DPTR
000CD8 7004              JNZ      ?C0049?HWA_MIFARE
  184: 	if (s_BackupBuff.money == 0
  185: 		&& s_BackupBuff.crc[0] == 0
  186: 		&& s_BackupBuff.crc[1] == 0
  187: 		)
  188: 	{
  189: 		hwa_mifareWriteSector((UINT8*)&s_BackupBuff, sector);
000CDA 91DF              ACALL    ?L?COM001C
000CDC         
000CDC B1EA              ACALL    ?L?COM0045
  190: 		return;
  191: 	}
  192: }
000CDE         ?C0049?HWA_MIFARE:
000CDE 22                RET      
----- FUNCTION _hwa_mifareRecoveryNewCard (END) -------


----- FUNCTION ?L?COM001C (BEGIN) -----
000CDF 7B01              MOV      R3,#01H
000CE1 7A00              MOV      R2,#HIGH s_BackupBuff
000CE3 7940              MOV      R1,#LOW s_BackupBuff
000CE5 22                RET      
----- FUNCTION ?L?COM001C (END) -------


----- FUNCTION hwa_mifareCheckBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  120: void hwa_mifareCheckBlock(void)
  121: {
  122: 	UINT16 crc, crcBak;
  123: 	hwa_mifareDecrypt((UINT8*)&s_NormalBuff);        //利用卡ID解密
000CE6 91A2              ACALL    ?L?COM001B
000CE8 F12F              ACALL    _hwa_mifareDecrypt
  124: 	crc = hwa_mifareCheckOut((UINT8*)&s_NormalBuff, USE_DATA_BLOCK_LEN);
000CEA 91A2              ACALL    ?L?COM001B
;---- Variable 'crc' assigned to Register 'R4/R5' ----
000CEC D151              ACALL    ?L?COM002F
000CEE AC06              MOV      R4,AR6
  125: 	if (crc == (s_NormalBuff.crc[0] << 8 | s_NormalBuff.crc[1]))
000CF0 900052            MOV      DPTR,#s_NormalBuff+02H
000CF3 E0                MOVX     A,@DPTR
000CF4 FE                MOV      R6,A
000CF5 A3                INC      DPTR
000CF6 E0                MOVX     A,@DPTR
000CF7 FB                MOV      R3,A
000CF8 EB                MOV      A,R3
000CF9 B50508            CJNE     A,AR5,?C0040?HWA_MIFARE
000CFC EE                MOV      A,R6
000CFD B50404            CJNE     A,AR4,?C0040?HWA_MIFARE
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 38


  126: 	{
  127: 		NormalErrorFlag = FALSE;
000D00 C205              CLR      NormalErrorFlag
  128: 	}
000D02 8002              SJMP     ?C0041?HWA_MIFARE
000D04         ?C0040?HWA_MIFARE:
  129: 	else
  130: 	{
  131: 		NormalErrorFlag = TRUE;
000D04 D205              SETB     NormalErrorFlag
  132: 	}
000D06         ?C0041?HWA_MIFARE:
  133: 	hwa_mifareDecrypt((UINT8*)&s_BackupBuff);        //利用卡ID解密
000D06 91DF              ACALL    ?L?COM001C
000D08 F12F              ACALL    _hwa_mifareDecrypt
  134: 	crcBak = hwa_mifareCheckOut((UINT8*)&s_BackupBuff, USE_DATA_BLOCK_LEN);
000D0A 91DF              ACALL    ?L?COM001C
;---- Variable 'crcBak' assigned to Register 'R4/R5' ----
000D0C D151              ACALL    ?L?COM002F
000D0E AC06              MOV      R4,AR6
  135: 	if (crcBak == (s_BackupBuff.crc[0] << 8 | s_BackupBuff.crc[1]))
000D10 900042            MOV      DPTR,#s_BackupBuff+02H
000D13 E0                MOVX     A,@DPTR
000D14 FE                MOV      R6,A
000D15 A3                INC      DPTR
000D16 E0                MOVX     A,@DPTR
000D17 FB                MOV      R3,A
000D18 EB                MOV      A,R3
000D19 B50507            CJNE     A,AR5,?C0042?HWA_MIFARE
000D1C EE                MOV      A,R6
000D1D B50403            CJNE     A,AR4,?C0042?HWA_MIFARE
  136: 	{
  137: 		BackupErrorFlag = FALSE;
000D20 C204              CLR      BackupErrorFlag
  138: 	}
000D22 22                RET      
000D23         ?C0042?HWA_MIFARE:
  139: 	else
  140: 	{
  141: 		BackupErrorFlag = TRUE;
000D23 D204              SETB     BackupErrorFlag
  142: 	}
  143: }
000D25 22                RET      
----- FUNCTION hwa_mifareCheckBlock (END) -------


----- FUNCTION _hwa_mifareRecoveryOldCard (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  145: static void hwa_mifareRecoveryOldCard(UINT8 sector)
  146: {
000D26 900076            MOV      DPTR,#sector
000D29 EF                MOV      A,R7
000D2A F0                MOVX     @DPTR,A
  147: 	UINT8 money;
  148:     hwa_mifareEncrypt((UINT8*)&s_NormalBuff);             //旧卡由于未加密，校验时进行了解密操作，故此时利用卡ID
>> 用
000D2B 91A2              ACALL    ?L?COM001B
000D2D D1B1              ACALL    ?L?COM004F
000D2F 900077            MOV      DPTR,#money
000D32 F0                MOVX     @DPTR,A
  149: 	money = *(UINT8*)&s_NormalBuff;
  150: 	if (money != 0xFF && money <= 200
000D33 F4                CPL      A
000D34 601F              JZ       ?C0045?HWA_MIFARE
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 39


000D36 E0                MOVX     A,@DPTR
000D37 FF                MOV      R7,A
000D38 D3                SETB     C
000D39 94C8              SUBB     A,#0C8H
000D3B 5018              JNC      ?C0045?HWA_MIFARE
000D3D 900052            MOV      DPTR,#s_NormalBuff+02H
000D40 E0                MOVX     A,@DPTR
000D41 7012              JNZ      ?C0045?HWA_MIFARE
000D43 A3                INC      DPTR
000D44 E0                MOVX     A,@DPTR
000D45 700E              JNZ      ?C0045?HWA_MIFARE
  151: 		&& s_NormalBuff.crc[0] == 0
  152: 		&& s_NormalBuff.crc[1] == 0
  153: 		)
  154: 	{
  155: 		s_NormalBuff.money = (UINT16)money * 100;
000D47 D1A3              ACALL    ?L?COM0051
000D49 900050            MOV      DPTR,#s_NormalBuff
000D4C EE                MOV      A,R6
000D4D F0                MOVX     @DPTR,A
000D4E A3                INC      DPTR
000D4F EF                MOV      A,R7
000D50 F0                MOVX     @DPTR,A
  156: 		hwa_mifareWriteSector((UINT8*)&s_NormalBuff, sector);
000D51 91A2              ACALL    ?L?COM001B
000D53 8028              SJMP     ?C0081?HWA_MIFARE
  157: 		return;
  158: 	}
000D55         ?C0045?HWA_MIFARE:
  159:     hwa_mifareEncrypt((UINT8*)&s_BackupBuff);             //旧卡由于未加密，校验时进行了解密操作，故此时利用卡ID
>> 用
000D55 91DF              ACALL    ?L?COM001C
000D57 D1AA              ACALL    ?L?COM004C
000D59 900077            MOV      DPTR,#money
000D5C F0                MOVX     @DPTR,A
  160: 	money = *(UINT8*)&s_BackupBuff;
  161: 	if (money != 0xFF && money <= 200
000D5D F4                CPL      A
000D5E 601F              JZ       ?C0046?HWA_MIFARE
000D60 E0                MOVX     A,@DPTR
000D61 FF                MOV      R7,A
000D62 D3                SETB     C
000D63 94C8              SUBB     A,#0C8H
000D65 5018              JNC      ?C0046?HWA_MIFARE
000D67 900042            MOV      DPTR,#s_BackupBuff+02H
000D6A E0                MOVX     A,@DPTR
000D6B 7012              JNZ      ?C0046?HWA_MIFARE
000D6D A3                INC      DPTR
000D6E E0                MOVX     A,@DPTR
000D6F 700E              JNZ      ?C0046?HWA_MIFARE
  162: 		&& s_BackupBuff.crc[0] == 0
  163: 		&& s_BackupBuff.crc[1] == 0
  164: 		)
  165: 	{
  166: 		s_BackupBuff.money = (UINT16)money * 100;
000D71 D1A3              ACALL    ?L?COM0051
000D73 900040            MOV      DPTR,#s_BackupBuff
000D76 EE                MOV      A,R6
000D77 F0                MOVX     @DPTR,A
000D78 A3                INC      DPTR
000D79 EF                MOV      A,R7
000D7A F0                MOVX     @DPTR,A
  167: 		hwa_mifareWriteSector((UINT8*)&s_BackupBuff, sector);
000D7B 91DF              ACALL    ?L?COM001C
000D7D         
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 40


000D7D B1EA              ACALL    ?L?COM0045
  168: 		return;
  169: 	}
  170: }
000D7F         ?C0046?HWA_MIFARE:
000D7F 22                RET      
----- FUNCTION _hwa_mifareRecoveryOldCard (END) -------


----- FUNCTION _hwa_mifareEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   30: void hwa_mifareEncrypt(UINT8 *pData)        //利用卡ID加密
   31: {
000D80 1207F6            LCALL    ?L?COM0001
   32: 	UINT8 i, j;
   33: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
000D83 E4                CLR      A
000D84 FE                MOV      R6,A
000D85         ?C0004?HWA_MIFARE:
   34: 	{
   35: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
000D85 7D04              MOV      R5,#04H
000D87         ?C0007?HWA_MIFARE:
   36: 		{
   37: 			pData[i] ^= gCard_UID[i % 5];
000D87 1207DE            LCALL    ?L?COM0003
000D8A F193              ACALL    ?L?COM0023
000D8C F583              MOV      DPH,A
000D8E E0                MOVX     A,@DPTR
000D8F 6F                XRL      A,R7
000D90 120162            LCALL    ?C?CSTPTR
   38: 			pData[i] = _cror_(pData[i], 1);
000D93 1207DE            LCALL    ?L?COM0003
000D96 F9                MOV      R1,A
000D97 8E82              MOV      DPL,R6
000D99 F164              ACALL    ?L?COM0021
000D9B FF                MOV      R7,A
000D9C 7801              MOV      R0,#01H
000D9E 08                INC      R0
000D9F 8001              SJMP     ?C0072?HWA_MIFARE
000DA1         ?C0071?HWA_MIFARE:
000DA1 03                RR       A
000DA2         ?C0072?HWA_MIFARE:
000DA2 D8FD              DJNZ     R0,?C0071?HWA_MIFARE
000DA4 F16A              ACALL    ?L?COM0047
   39: 		}
000DA6 DDDF              DJNZ     R5,?C0007?HWA_MIFARE
   40: 	}
000DA8         ?C0006?HWA_MIFARE:
000DA8 0E                INC      R6
000DA9 EE                MOV      A,R6
000DAA B404D8            CJNE     A,#04H,?C0004?HWA_MIFARE
   41: }
000DAD 22                RET      
----- FUNCTION _hwa_mifareEncrypt (END) -------


----- FUNCTION _hwa_mifareWriteBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   76: BOOL hwa_mifareWriteBlock(UINT8 *buff, UINT8 block)
   77: {
000DAE 90007D            MOV      DPTR,#block
000DB1 ED                MOV      A,R5
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 41


000DB2 F0                MOVX     @DPTR,A
;---- Variable 'buff' assigned to Register 'R1/R2/R3' ----
   78: 	UINT8 u8_ReadErrCount;
   79: 	UINT8 u8_Result;
   80:     memcpy((UINT8*)&s_TempBuff, buff, 16);
000DB3 7860              MOV      R0,#LOW s_TempBuff
000DB5 7C00              MOV      R4,#HIGH s_TempBuff
000DB7 7D01              MOV      R5,#01H
000DB9 D19C              ACALL    ?L?COM003C
   81:     hwa_mifareEncrypt((UINT8*)&s_TempBuff);             //利用卡ID加密
000DBB 7B01              MOV      R3,#01H
000DBD 7A00              MOV      R2,#HIGH s_TempBuff
000DBF 7960              MOV      R1,#LOW s_TempBuff
000DC1 B180              ACALL    _hwa_mifareEncrypt
   82: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
000DC3 E4                CLR      A
000DC4 90007E            MOV      DPTR,#u8_ReadErrCount
000DC7 F0                MOVX     @DPTR,A
000DC8         ?C0025?HWA_MIFARE:
   83: 	{
   84: 		u8_Result = Write_Block((UINT8*)&s_TempBuff, block);
000DC8 7B01              MOV      R3,#01H
000DCA 7A00              MOV      R2,#HIGH s_TempBuff
000DCC 7960              MOV      R1,#LOW s_TempBuff
000DCE 90007D            MOV      DPTR,#block
000DD1 E0                MOVX     A,@DPTR
000DD2 FD                MOV      R5,A
000DD3 12180A            LCALL    _Write_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   85: 		if (u8_Result == FM1702_OK)
000DD6 EF                MOV      A,R7
000DD7 7002              JNZ      ?C0028?HWA_MIFARE
   86: 		{
   87: 			return TRUE;
000DD9 D3                SETB     C
000DDA 22                RET      
   88: 		}
000DDB         ?C0028?HWA_MIFARE:
   89: 		else if (u8_Result == FM1702_NOTAGERR)
000DDB EF                MOV      A,R7
000DDC B40102            CJNE     A,#01H,?C0027?HWA_MIFARE
   90: 		{
   91: 			return FALSE;
000DDF C3                CLR      C
000DE0 22                RET      
   92: 		}
   93: 	}
000DE1         ?C0027?HWA_MIFARE:
000DE1 90007E            MOV      DPTR,#u8_ReadErrCount
000DE4 F172              ACALL    ?L?COM0052
000DE6 40E0              JC       ?C0025?HWA_MIFARE
000DE8         ?C0026?HWA_MIFARE:
   94: 	return FALSE;
000DE8 C3                CLR      C
   95: }
000DE9 22                RET      
----- FUNCTION _hwa_mifareWriteBlock (END) -------


----- FUNCTION ?L?COM0045 (BEGIN) -----
000DEA 900076            MOV      DPTR,#sector
000DED E0                MOVX     A,@DPTR
000DEE FD                MOV      R5,A
----- FUNCTION _hwa_mifareWriteSector (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 42


  255: BOOL hwa_mifareWriteSector(UINT8 *dat, UINT8 sector)
  256: {
000DEF 900078            MOV      DPTR,#dat
000DF2 1207F9            LCALL    ?L?COM0002
;---- Variable 'sector' assigned to Register 'R5' ----
  257: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  258: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
000DF5 ED                MOV      A,R5
000DF6 F185              ACALL    ?L?COM0034
  259: 	UINT16 crc;
  260:     BOOL falg = FALSE;
000DF8 C200              CLR      falg
  261: 	if (dat != NULL && sector > 0 && sector < 16)
000DFA 900078            MOV      DPTR,#dat
000DFD 1207E1            LCALL    ?L?COM0004
000E00 4A                ORL      A,R2
000E01 4B                ORL      A,R3
000E02 604A              JZ       ?C0067?HWA_MIFARE
000E04 ED                MOV      A,R5
000E05 D3                SETB     C
000E06 9400              SUBB     A,#00H
000E08 4044              JC       ?C0067?HWA_MIFARE
000E0A ED                MOV      A,R5
000E0B 9410              SUBB     A,#010H
000E0D 503F              JNC      ?C0067?HWA_MIFARE
  262: 	{
  263: 		crc = hwa_mifareCheckOut(dat, USE_DATA_BLOCK_LEN);
000E0F 900078            MOV      DPTR,#dat
000E12 A3                INC      DPTR
000E13 A3                INC      DPTR
000E14 E0                MOVX     A,@DPTR
000E15 F9                MOV      R1,A
;---- Variable 'crc' assigned to Register 'R4/R5' ----
000E16 D151              ACALL    ?L?COM002F
000E18 AC06              MOV      R4,AR6
  264: 		dat[USE_DATA_BLOCK_LEN] = (UINT8)(crc >> 8);
000E1A EC                MOV      A,R4
000E1B FF                MOV      R7,A
000E1C 900078            MOV      DPTR,#dat
000E1F 1207E1            LCALL    ?L?COM0004
000E22 F9                MOV      R1,A
000E23 900002            MOV      DPTR,#02H
000E26 EF                MOV      A,R7
000E27 120174            LCALL    ?C?CSTOPTR
  265: 		dat[USE_DATA_BLOCK_LEN + 1] = (UINT8)(crc & 0xFF);
000E2A ED                MOV      A,R5
000E2B 900003            MOV      DPTR,#03H
000E2E 120174            LCALL    ?C?CSTOPTR
  266: 		if (hwa_mifareWriteBlock(dat, block))
000E31 90007B            MOV      DPTR,#block
000E34 E0                MOVX     A,@DPTR
000E35 FD                MOV      R5,A
000E36 B1AE              ACALL    _hwa_mifareWriteBlock
000E38 5002              JNC      ?C0068?HWA_MIFARE
  267: 		{
  268: 			falg = TRUE;
000E3A D200              SETB     falg
  269: 		}
000E3C         ?C0068?HWA_MIFARE:
  270: 		if (hwa_mifareWriteBlock(dat, blockBak))
000E3C 900078            MOV      DPTR,#dat
000E3F 1207E1            LCALL    ?L?COM0004
000E42 F9                MOV      R1,A
000E43 90007C            MOV      DPTR,#blockBak
000E46 E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 43


000E47 FD                MOV      R5,A
000E48 B1AE              ACALL    _hwa_mifareWriteBlock
000E4A 5002              JNC      ?C0067?HWA_MIFARE
  271: 		{
  272: 			falg = TRUE;
000E4C D200              SETB     falg
  273: 		}
  274: 	}
000E4E         ?C0067?HWA_MIFARE:
  275:     return falg;
000E4E A200              MOV      C,falg
  276: }
000E50 22                RET      
----- FUNCTION _hwa_mifareWriteSector (END) -------


----- FUNCTION ?L?COM002F (BEGIN) -----
000E51 7D02              MOV      R5,#02H
000E53 7C00              MOV      R4,#00H
000E55 D15A              ACALL    _hwa_mifareCheckOut
000E57 AD07              MOV      R5,AR7
000E59 22                RET      
----- FUNCTION ?L?COM002F (END) -------


----- FUNCTION _hwa_mifareCheckOut (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   97: UINT16 hwa_mifareCheckOut(UINT8 *dat, UINT16 len)
   98: {
000E5A 90007D            MOV      DPTR,#dat
000E5D 1207F9            LCALL    ?L?COM0002
000E60 F1CB              ACALL    ?L?COM0036
   99: 	UINT16 crc = 0xFFFF;
  100:     UINT8 i;
;---- Variable 'crc' assigned to Register 'R6/R7' ----
000E62 74FF              MOV      A,#0FFH
000E64 FF                MOV      R7,A
000E65 FE                MOV      R6,A
000E66         ?C0032?HWA_MIFARE:
  101:     while(len--)
000E66 900080            MOV      DPTR,#len
000E69 12156D            LCALL    ?L?COM001E
000E6C 602D              JZ       ?C0033?HWA_MIFARE
  102:     {
  103:         crc = crc ^*dat++;
000E6E 90007D            MOV      DPTR,#dat
000E71 1215D0            LCALL    ?L?COM0022
000E74 F1E4              ACALL    ?L?COM0044
000E76 900082            MOV      DPTR,#i
000E79 F0                MOVX     @DPTR,A
000E7A         ?C0034?HWA_MIFARE:
000E7A 900082            MOV      DPTR,#i
000E7D E0                MOVX     A,@DPTR
000E7E C3                CLR      C
000E7F 9408              SUBB     A,#08H
000E81 50E3              JNC      ?C0032?HWA_MIFARE
  104:         for ( i = 0; i < 8; i++)
  105:         {
  106:             if( ( crc & 0x0001) > 0)
000E83 F1ED              ACALL    ?L?COM0046
000E85 EE                MOV      A,R6
000E86 4005              JC       ?C0037?HWA_MIFARE
  107:             {
  108:                 crc = crc >> 1;
000E88 12163B            LCALL    ?L?COM0035
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 44


  109:                 crc = crc ^ 0xa001;
  110:             }
000E8B 8006              SJMP     ?C0036?HWA_MIFARE
000E8D         ?C0037?HWA_MIFARE:
  111:             else
  112:             {
  113:                 crc = crc >> 1;
000E8D C3                CLR      C
000E8E 13                RRC      A
000E8F FE                MOV      R6,A
000E90 EF                MOV      A,R7
000E91 13                RRC      A
000E92 FF                MOV      R7,A
  114:             }
  115:         }
000E93         ?C0036?HWA_MIFARE:
000E93 900082            MOV      DPTR,#i
000E96 E0                MOVX     A,@DPTR
000E97 04                INC      A
000E98 F0                MOVX     @DPTR,A
000E99 80DF              SJMP     ?C0034?HWA_MIFARE
  116:     }
000E9B         ?C0033?HWA_MIFARE:
  117:     return ( crc );
  118: }
000E9B 22                RET      
----- FUNCTION _hwa_mifareCheckOut (END) -------


----- FUNCTION ?L?COM003C (BEGIN) -----
000E9C 7E00              MOV      R6,#00H
000E9E 7F10              MOV      R7,#010H
000EA0 0200F6            LJMP     ?C?COPY
----- FUNCTION ?L?COM003C (END) -------


----- FUNCTION ?L?COM0051 (BEGIN) -----
000EA3 FE                MOV      R6,A
000EA4 FC                MOV      R4,A
000EA5 7D64              MOV      R5,#064H
000EA7 020196            LJMP     ?C?IMUL
----- FUNCTION ?L?COM0051 (END) -------


----- FUNCTION ?L?COM004C (BEGIN) -----
000EAA B180              ACALL    _hwa_mifareEncrypt
000EAC 900040            MOV      DPTR,#s_BackupBuff
000EAF E0                MOVX     A,@DPTR
000EB0 22                RET      
----- FUNCTION ?L?COM004C (END) -------


----- FUNCTION ?L?COM004F (BEGIN) -----
000EB1 B180              ACALL    _hwa_mifareEncrypt
000EB3 900050            MOV      DPTR,#s_NormalBuff
000EB6 E0                MOVX     A,@DPTR
000EB7 22                RET      
----- FUNCTION ?L?COM004F (END) -------


----- FUNCTION ?L?COM0043 (BEGIN) -----
000EB8 900070            MOV      DPTR,#L_num
000EBB E0                MOVX     A,@DPTR
000EBC FE                MOV      R6,A
000EBD A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 45


000EBE E0                MOVX     A,@DPTR
000EBF FF                MOV      R7,A
000EC0 22                RET      
----- FUNCTION ?L?COM0043 (END) -------


----- FUNCTION _app_configRead (BEGIN) -----
 FILE: 'App\app_config.c'
   90: BOOL app_configRead(UINT8 Sector)
   91: {
;---- Variable 'Sector' assigned to Register 'R7' ----
   92:     BOOL state;
   93:     if(Sector == SYSTEM_SETTING_SECTOR)
000EC1 EF                MOV      A,R7
000EC2 7B01              MOV      R3,#01H
000EC4 7007              JNZ      ?C0010?APP_CONFIG
   94:     {
   95:         state = hwa_eepromReadSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
000EC6 7A00              MOV      R2,#HIGH s_System
000EC8 79A1              MOV      R1,#LOW s_System
000ECA FD                MOV      R5,A
   96:     }
000ECB 8006              SJMP     ?C0017?APP_CONFIG
000ECD         ?C0010?APP_CONFIG:
   97:     else
   98:     {
   99:         state = hwa_eepromReadSector((UINT8*)&MoneySum, MONEY_SECTOR);
000ECD 7A00              MOV      R2,#HIGH MoneySum
000ECF 799D              MOV      R1,#LOW MoneySum
000ED1 7D01              MOV      R5,#01H
000ED3         
000ED3 121270            LCALL    _hwa_eepromReadSector
000ED6 9201              MOV      state,C
  100:     }
000ED8         ?C0011?APP_CONFIG:
  101:     return state;
000ED8 A201              MOV      C,state
  102: }
000EDA 22                RET      
----- FUNCTION _app_configRead (END) -------


----- FUNCTION sys_taskInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   27: void sys_taskInit(void)
   28: {
   29:     WDT_CONTR = 0x33;
   30:     app_pulseInit();
000EDB 75C133            MOV      WDT_CONTR,#033H
   31:     len_Init();
000EDE F1D2              ACALL    app_pulseInit
   32:     sys_gpioInit();
000EE0 121779            LCALL    len_Init
   33:     buzzer_Init();
000EE3 120009            LCALL    sys_gpioInit
   34:     sys_uartInit();	  
000EE6 12176F            LCALL    buzzer_Init
   35:     app_configInit();
000EE9 1211C1            LCALL    sys_uartInit
   36:     sys_tim0Init();
000EEC 710E              ACALL    app_configInit
   37: 	app_Show();
000EEE F1BB              ACALL    sys_tim0Init
   38:     app_brushInit();
000EF0 111E              ACALL    app_Show
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 46


   39: }
000EF2 0207F4            LJMP     app_brushInit
----- FUNCTION sys_taskInit (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: 'System\sys_task.c'
   79: void main(void)
   80: {
   81:     sys_taskInit();
   82:     buzzer_SoundNumber(1);
000EF5 D1DB              ACALL    sys_taskInit
   83:     while(1)
000EF7 7F01              MOV      R7,#01H
000EF9 51A3              ACALL    _buzzer_SoundNumber
000EFB         ?C0010?SYS_TASK:
   84:     {
   85:         WDT_CONTR = 0x33;          //reset watch dog      SyttemClk is 11.0592M Over Time 568.8ms
   86:         if(taskCycle1sFlag == TRUE)
000EFB 75C133            MOV      WDT_CONTR,#033H
   87:         {
000EFE 3006FA            JNB      taskCycle1sFlag,?C0010?SYS_TASK
   88:         	taskCycle1sFlag = FALSE;
   89:             app_confingHandler1s();
000F01 C206              CLR      taskCycle1sFlag
   90:             app_brushCycle1s();
000F03 F109              ACALL    app_confingHandler1s
   91:         }
000F05 1161              ACALL    app_brushCycle1s
   92:     }
   93: }
000F07 80F2              SJMP     ?C0010?SYS_TASK
----- FUNCTION main (END) -------


----- FUNCTION app_confingHandler1s (BEGIN) -----
 FILE: 'App\app_config.c'
  118: void app_confingHandler1s(void)
  119: {
  120:     led_Switch(OFF);
  121: //    hwa_eepromReadSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
000F09 C201              CLR      ?led_Switch?BIT
000F0B 7103              ACALL    led_Switch
  122: //    sys_uartSendData((UINT8*)&USER_Card_ID, 5);
  123: //    USER_Card_ID[0][0]++;
  124: //    hwa_eepromWriteSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
  125:     led_Switch(ON);
000F0D D201              SETB     ?led_Switch?BIT
000F0F 6103              AJMP     led_Switch
----- FUNCTION app_confingHandler1s (END) -------


----- FUNCTION ?L?COM000D (BEGIN) -----
000F11 E4                CLR      A
000F12 7B64              MOV      R3,#064H
000F14 FA                MOV      R2,A
000F15 F9                MOV      R1,A
000F16 F8                MOV      R0,A
000F17 90009D            MOV      DPTR,#MoneySum
000F1A E0                MOVX     A,@DPTR
000F1B FC                MOV      R4,A
000F1C A3                INC      DPTR
000F1D E0                MOVX     A,@DPTR
000F1E FD                MOV      R5,A
000F1F A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 47


000F20 E0                MOVX     A,@DPTR
000F21 FE                MOV      R6,A
000F22 A3                INC      DPTR
000F23 E0                MOVX     A,@DPTR
000F24 FF                MOV      R7,A
000F25 120299            LCALL    ?C?ULDIV
000F28 E4                CLR      A
000F29 7B64              MOV      R3,#064H
000F2B FA                MOV      R2,A
000F2C F9                MOV      R1,A
000F2D F8                MOV      R0,A
000F2E 22                RET      
----- FUNCTION ?L?COM000D (END) -------


----- FUNCTION _hwa_mifareDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   44: void hwa_mifareDecrypt(UINT8 *pData)        //利用卡ID解密
   45: {
000F2F 900076            MOV      DPTR,#pData
000F32 1207F9            LCALL    ?L?COM0002
   46: 	UINT8 i, j;
   47: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
000F35 E4                CLR      A
000F36 FE                MOV      R6,A
000F37         ?C0011?HWA_MIFARE:
   48: 	{
   49: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
000F37 7D04              MOV      R5,#04H
000F39         ?C0014?HWA_MIFARE:
   50: 		{
   51: 			pData[i] = _crol_(pData[i], 1);
000F39 900076            MOV      DPTR,#pData
000F3C 1207E1            LCALL    ?L?COM0004
000F3F F9                MOV      R1,A
000F40 8E82              MOV      DPL,R6
000F42 F164              ACALL    ?L?COM0021
000F44 FF                MOV      R7,A
000F45 7801              MOV      R0,#01H
000F47 08                INC      R0
000F48 8001              SJMP     ?C0074?HWA_MIFARE
000F4A         ?C0073?HWA_MIFARE:
000F4A 23                RL       A
000F4B         ?C0074?HWA_MIFARE:
000F4B D8FD              DJNZ     R0,?C0073?HWA_MIFARE
000F4D F16A              ACALL    ?L?COM0047
   52: 			pData[i] ^= gCard_UID[i % 5];
000F4F E9                MOV      A,R1
000F50 F193              ACALL    ?L?COM0023
000F52 F583              MOV      DPH,A
000F54 E0                MOVX     A,@DPTR
000F55 6F                XRL      A,R7
000F56 120162            LCALL    ?C?CSTPTR
   53: 		}
000F59 DDDE              DJNZ     R5,?C0014?HWA_MIFARE
   54: 	}
000F5B         ?C0013?HWA_MIFARE:
000F5B 0E                INC      R6
000F5C EE                MOV      A,R6
000F5D B404D7            CJNE     A,#04H,?C0011?HWA_MIFARE
   55: }
000F60 22                RET      
----- FUNCTION _hwa_mifareDecrypt (END) -------
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 48




----- FUNCTION ?L?COM001F (BEGIN) -----
000F61 F9                MOV      R1,A
000F62         ?L?COM0020:
000F62 8F82              MOV      DPL,R7
000F64         ?L?COM0021:
000F64 758300            MOV      DPH,#00H
000F67 020135            LJMP     ?C?CLDOPTR
----- FUNCTION ?L?COM001F (END) -------


----- FUNCTION ?L?COM0047 (BEGIN) -----
000F6A 8E82              MOV      DPL,R6
000F6C 758300            MOV      DPH,#00H
000F6F 020174            LJMP     ?C?CSTOPTR
----- FUNCTION ?L?COM0047 (END) -------


----- FUNCTION ?L?COM0052 (BEGIN) -----
000F72 E0                MOVX     A,@DPTR
000F73 04                INC      A
000F74 F0                MOVX     @DPTR,A
000F75 E0                MOVX     A,@DPTR
000F76 C3                CLR      C
000F77 9403              SUBB     A,#03H
000F79 22                RET      
----- FUNCTION ?L?COM0052 (END) -------


----- FUNCTION ?L?COM0042 (BEGIN) -----
000F7A 9000C9            MOV      DPTR,#gLedBuf
000F7D 740C              MOV      A,#0CH
000F7F F0                MOVX     @DPTR,A
000F80 A3                INC      DPTR
000F81 F0                MOVX     @DPTR,A
000F82 A3                INC      DPTR
000F83 F0                MOVX     @DPTR,A
000F84 22                RET      
----- FUNCTION ?L?COM0042 (END) -------


----- FUNCTION ?L?COM0034 (BEGIN) -----
000F85 25E0              ADD      A,ACC
000F87 25E0              ADD      A,ACC
000F89 FE                MOV      R6,A
000F8A 04                INC      A
000F8B A3                INC      DPTR
000F8C F0                MOVX     @DPTR,A
000F8D EE                MOV      A,R6
000F8E 2402              ADD      A,#02H
000F90 A3                INC      DPTR
000F91 F0                MOVX     @DPTR,A
000F92 22                RET      
----- FUNCTION ?L?COM0034 (END) -------


----- FUNCTION ?L?COM0023 (BEGIN) -----
000F93 2E                ADD      A,R6
000F94 F9                MOV      R1,A
000F95 E4                CLR      A
000F96 3A                ADDC     A,R2
000F97 FA                MOV      R2,A
000F98 12011C            LCALL    ?C?CLDPTR
000F9B FF                MOV      R7,A
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 49


000F9C EE                MOV      A,R6
000F9D 75F005            MOV      B,#05H
000FA0 84                DIV      AB
000FA1 74B4              MOV      A,#LOW gCard_UID
000FA3 25F0              ADD      A,B
000FA5 F582              MOV      DPL,A
000FA7 E4                CLR      A
000FA8 3400              ADDC     A,#HIGH gCard_UID
000FAA 22                RET      
----- FUNCTION ?L?COM0023 (END) -------


----- FUNCTION ?L?COM0028 (BEGIN) -----
000FAB FE                MOV      R6,A
000FAC 74BB              MOV      A,#LOW gBuff+02H
000FAE 2F                ADD      A,R7
000FAF F582              MOV      DPL,A
000FB1 E4                CLR      A
000FB2 3400              ADDC     A,#HIGH gBuff+02H
000FB4         ?L?COM0029:
000FB4 F583              MOV      DPH,A
000FB6 EE                MOV      A,R6
000FB7 F0                MOVX     @DPTR,A
000FB8 0F                INC      R7
000FB9 EF                MOV      A,R7
000FBA 22                RET      
----- FUNCTION ?L?COM0028 (END) -------


----- FUNCTION sys_tim0Init (BEGIN) -----
 FILE: 'System\sys_tim.c'
  101: void sys_tim0Init(void)
  102: {
  103: 	TMOD &= 0xF0;
  104: 	TH0 = (UINT8)(T1MS>>8);
000FBB 5389F0            ANL      TMOD,#0F0H
  105: 	TL0 = (UINT8)T1MS;
000FBE 758CF8            MOV      TH0,#0F8H
  106: 	ET0 = 1;
000FC1 758ACD            MOV      TL0,#0CDH
  107: 	TR0 = 1;
000FC4 D2A9              SETB     ET0
  108: //	PT1 = 1;
000FC6 D28C              SETB     TR0
  109:     EA = 1;
000FC8 D2AF              SETB     EA
  110: }
000FCA 22                RET      
----- FUNCTION sys_tim0Init (END) -------


----- FUNCTION ?L?COM0036 (BEGIN) -----
000FCB A3                INC      DPTR
000FCC EC                MOV      A,R4
000FCD F0                MOVX     @DPTR,A
000FCE A3                INC      DPTR
000FCF ED                MOV      A,R5
000FD0 F0                MOVX     @DPTR,A
000FD1 22                RET      
----- FUNCTION ?L?COM0036 (END) -------


----- FUNCTION app_pulseInit (BEGIN) -----
 FILE: 'App\app_pulse.c'
   12: void app_pulseInit(void)
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 50


   13: {
   14:     P3M1 &= ~0x80;      //推挽输出
   15:     P3M0 |= 0x80;
000FD2 53B17F            ANL      P3M1,#07FH
   16:     pulse = 0;
000FD5 43B280            ORL      P3M0,#080H
   17: }
000FD8 C2B7              CLR      pulse
   18: 
000FDA 22                RET      
----- FUNCTION app_pulseInit (END) -------


----- FUNCTION _app_pulseSendPulse (BEGIN) -----
 FILE: 'App\app_pulse.c'
   40: void app_pulseSendPulse(UINT8 width, UINT8 n)
   41: {
;---- Variable 'n' assigned to Register 'R5' ----
;---- Variable 'width' assigned to Register 'R7' ----
   42:     u8_width = width;
   43:     u8_pulse = n;
000FDB 9000D1            MOV      DPTR,#u8_width
000FDE EF                MOV      A,R7
000FDF F0                MOVX     @DPTR,A
   44: }
000FE0 A3                INC      DPTR
000FE1 ED                MOV      A,R5
000FE2 F0                MOVX     @DPTR,A
   45: 
000FE3 22                RET      
----- FUNCTION _app_pulseSendPulse (END) -------


----- FUNCTION ?L?COM0044 (BEGIN) -----
000FE4 12011C            LCALL    ?C?CLDPTR
000FE7 FD                MOV      R5,A
000FE8 ED                MOV      A,R5
000FE9 6F                XRL      A,R7
000FEA FF                MOV      R7,A
000FEB E4                CLR      A
000FEC 22                RET      
----- FUNCTION ?L?COM0044 (END) -------


----- FUNCTION ?L?COM0046 (BEGIN) -----
000FED EF                MOV      A,R7
000FEE 5401              ANL      A,#01H
000FF0 9400              SUBB     A,#00H
000FF2 E4                CLR      A
000FF3 9400              SUBB     A,#00H
000FF5 22                RET      
----- FUNCTION ?L?COM0046 (END) -------


----- FUNCTION sys_tim0Isr (BEGIN) -----
 FILE: 'System\sys_task.c'
   41: void sys_tim0Isr(void) interrupt 1      //1ms interrupt task
000FF6 C0E0              PUSH     ACC
000FF8 C0F0              PUSH     B
000FFA C083              PUSH     DPH
000FFC C082              PUSH     DPL
000FFE C0D0              PUSH     PSW
001000 75D000            MOV      PSW,#00H
001003 C000              PUSH     AR0
001005 C001              PUSH     AR1
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 51


001007 C002              PUSH     AR2
001009 C003              PUSH     AR3
00100B C004              PUSH     AR4
00100D C005              PUSH     AR5
00100F C006              PUSH     AR6
001011 C007              PUSH     AR7
   42: {
   43:     led_Handler1ms();
001013 11BC              ACALL    led_Handler1ms
   44:     app_pulseHandler1ms();
001015 117D              ACALL    app_pulseHandler1ms
   45: 	taskHandlerCnt10ms++;
001017 9000D7            MOV      DPTR,#taskHandlerCnt10ms
00101A E0                MOVX     A,@DPTR
00101B 04                INC      A
00101C F0                MOVX     @DPTR,A
   46:     if(taskHandlerCnt10ms>=10)
00101D E0                MOVX     A,@DPTR
00101E C3                CLR      C
00101F 940A              SUBB     A,#0AH
001021 400B              JC       ?C0003?SYS_TASK
   47:     {
   48:         taskHandlerCnt10ms = 0;
001023 E4                CLR      A
001024 F0                MOVX     @DPTR,A
   49:         sys_taskHandler10ms();
001025 120021            LCALL    sys_taskHandler10ms
   50:         taskHandlerCnt100ms++;
001028 9000D5            MOV      DPTR,#taskHandlerCnt100ms
00102B E0                MOVX     A,@DPTR
00102C 04                INC      A
00102D F0                MOVX     @DPTR,A
   51:     }
00102E         ?C0003?SYS_TASK:
   52:     if(taskHandlerCnt100ms>=10)
00102E 9000D5            MOV      DPTR,#taskHandlerCnt100ms
001031 E0                MOVX     A,@DPTR
001032 C3                CLR      C
001033 940A              SUBB     A,#0AH
001035 400A              JC       ?C0004?SYS_TASK
   53:     {
   54:         taskHandlerCnt100ms = 0;
001037 E4                CLR      A
001038 F0                MOVX     @DPTR,A
   55:         sys_taskHandler100ms();
001039 116C              ACALL    sys_taskHandler100ms
   56:         taskHandlerCnt1s++;
00103B 9000D6            MOV      DPTR,#taskHandlerCnt1s
00103E E0                MOVX     A,@DPTR
00103F 04                INC      A
001040 F0                MOVX     @DPTR,A
   57:     }
001041         ?C0004?SYS_TASK:
   58:     if(taskHandlerCnt1s>=10)
001041 9000D6            MOV      DPTR,#taskHandlerCnt1s
001044 E0                MOVX     A,@DPTR
001045 C3                CLR      C
001046 940A              SUBB     A,#0AH
001048 4007              JC       ?C0006?SYS_TASK
   59:     {
   60:         taskHandlerCnt1s = 0;
00104A E4                CLR      A
00104B F0                MOVX     @DPTR,A
   61:         sys_taskHandler1s();
00104C 120022            LCALL    sys_taskHandler1s
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 52


   62:         taskCycle1sFlag = TRUE;
00104F D206              SETB     taskCycle1sFlag
   63:     }
   64: }
001051         ?C0006?SYS_TASK:
001051 D007              POP      AR7
001053 D006              POP      AR6
001055 D005              POP      AR5
001057 D004              POP      AR4
001059 D003              POP      AR3
00105B D002              POP      AR2
00105D D001              POP      AR1
00105F D000              POP      AR0
001061 D0D0              POP      PSW
001063 D082              POP      DPL
001065 D083              POP      DPH
001067 D0F0              POP      B
001069 D0E0              POP      ACC
00106B 32                RETI     
----- FUNCTION sys_tim0Isr (END) -------


----- FUNCTION sys_taskHandler100ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   70: void sys_taskHandler100ms(void)           //100ms interrupt task
;----                  JMP      buzzer_Handler100ms
   71: {
----- FUNCTION sys_taskHandler100ms (END) -------


----- FUNCTION buzzer_Handler100ms (BEGIN) -----
 FILE: 'Driver\buzzer.c'
   15: void buzzer_Handler100ms(void)
   16: {
   17:     if(Buzzer)
   18: 	{
00106C 30B503            JNB      Buzzer,?C0002?BUZZER
   19: 		Buzzer = 0;
   20: 	}
00106F C2B5              CLR      Buzzer
   21: 	else if(SoundNumberCount)
001071 22                RET      
001072         ?C0002?BUZZER:
   22: 	{
001072 9000DB            MOV      DPTR,#SoundNumberCount
001075 E0                MOVX     A,@DPTR
001076 6004              JZ       ?C0005?BUZZER
   23: 		Buzzer = 1;
   24: 		SoundNumberCount--;
001078 D2B5              SETB     Buzzer
   25: 	}
00107A 14                DEC      A
00107B F0                MOVX     @DPTR,A
   26: }
   27: 
00107C         ?C0005?BUZZER:
00107C 22                RET      
----- FUNCTION buzzer_Handler100ms (END) -------


----- FUNCTION app_pulseHandler1ms (BEGIN) -----
 FILE: 'App\app_pulse.c'
   19: void app_pulseHandler1ms(void)
   20: {
   21:     if(u8_pulse)
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 53


   22:     {
00107D 9000D2            MOV      DPTR,#u8_pulse
001080 E0                MOVX     A,@DPTR
001081 6038              JZ       ?C0007?APP_PULSE
   23:         u16_count++;
   24:         if(u16_count<=u8_width)
001083 9000D4            MOV      DPTR,#u16_count+01H
001086 E0                MOVX     A,@DPTR
001087 04                INC      A
001088 F0                MOVX     @DPTR,A
001089 7006              JNZ      ?C0009?APP_PULSE
00108B 9000D3            MOV      DPTR,#u16_count
00108E E0                MOVX     A,@DPTR
00108F 04                INC      A
001090 F0                MOVX     @DPTR,A
001091         ?C0009?APP_PULSE:
   25:         {
001091 9000D1            MOV      DPTR,#u8_width
001094 E0                MOVX     A,@DPTR
001095 FF                MOV      R7,A
001096 9000D3            MOV      DPTR,#u16_count
001099 31DB              ACALL    ?L?COM004A
00109B 9400              SUBB     A,#00H
00109D 5003              JNC      ?C0003?APP_PULSE
   26:             pulse = 1;
   27:         }
00109F D2B7              SETB     pulse
   28:         else if(u16_count<=PULSE_Interval)
0010A1 22                RET      
0010A2         ?C0003?APP_PULSE:
   29:         {
0010A2 D3                SETB     C
0010A3 ED                MOV      A,R5
0010A4 942C              SUBB     A,#02CH
0010A6 EC                MOV      A,R4
0010A7 9401              SUBB     A,#01H
0010A9 5003              JNC      ?C0005?APP_PULSE
   30:             pulse = 0;
   31:         }
0010AB C2B7              CLR      pulse
   32:         else
0010AD 22                RET      
0010AE         ?C0005?APP_PULSE:
   33:         {
   34:             u16_count = 0;
0010AE E4                CLR      A
0010AF 9000D3            MOV      DPTR,#u16_count
0010B2 F0                MOVX     @DPTR,A
0010B3 A3                INC      DPTR
0010B4 F0                MOVX     @DPTR,A
   35:             u8_pulse--;
0010B5 9000D2            MOV      DPTR,#u8_pulse
0010B8 E0                MOVX     A,@DPTR
0010B9 14                DEC      A
0010BA F0                MOVX     @DPTR,A
   36:         }
   37:     }
   38: }
0010BB         ?C0007?APP_PULSE:
0010BB 22                RET      
----- FUNCTION app_pulseHandler1ms (END) -------


----- FUNCTION led_Handler1ms (BEGIN) -----
 FILE: 'Driver\LED.c'
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 54


   30: void led_Handler1ms(void)
   31: {
   32:     if(ledsw)
   33:     {
0010BC 200802            JB       ledsw,$ + 5H
0010BF 21C0              AJMP     ?C0033?LED
   34:     	if (gCurLed<5)
   35:     		gCurLed++;
0010C1 9000CF            MOV      DPTR,#gCurLed
0010C4 E0                MOVX     A,@DPTR
0010C5 C3                CLR      C
0010C6 9405              SUBB     A,#05H
0010C8 5005              JNC      ?C0003?LED
   36:     	else
0010CA E0                MOVX     A,@DPTR
0010CB 04                INC      A
0010CC F0                MOVX     @DPTR,A
0010CD 8005              SJMP     ?C0004?LED
0010CF         ?C0003?LED:
   37:     		gCurLed=0;
0010CF E4                CLR      A
0010D0 9000CF            MOV      DPTR,#gCurLed
0010D3 F0                MOVX     @DPTR,A
0010D4         ?C0004?LED:
   38:     	LED_CS0 = 1;
0010D4 31E4              ACALL    ?L?COM0037
   39:     	LED_CS1 = 1;
   40:     	LED_CS2 = 1;
   41:     	LED_CS3 = 1;
   42:     	LED_CS4 = 1;
   43:     	LED_CS5 = 1;
   44:     	switch ( gLedBuf[gCurLed])		 //switch case 语句中 switch中的条件case都不满足就执行default
0010D6 9000CF            MOV      DPTR,#gCurLed
0010D9 E0                MOVX     A,@DPTR
0010DA FF                MOV      R7,A
0010DB 24C9              ADD      A,#LOW gLedBuf
0010DD F582              MOV      DPL,A
0010DF E4                CLR      A
0010E0 3400              ADDC     A,#HIGH gLedBuf
0010E2 F583              MOV      DPH,A
0010E4 E0                MOVX     A,@DPTR
0010E5 B41100            CJNE     A,#011H,?C0040?LED
0010E8         ?C0040?LED:
0010E8 4002              JC       $ + 4H
0010EA 2178              AJMP     ?C0023?LED
0010EC 9010F3            MOV      DPTR,#010F3H
0010EF F8                MOV      R0,A
0010F0 28                ADD      A,R0
0010F1 28                ADD      A,R0
0010F2 73                JMP      @A+DPTR
0010F3         ?C0041?LED:
0010F3 021126            LJMP     ?C0006?LED
0010F6 02112B            LJMP     ?C0007?LED
0010F9 021130            LJMP     ?C0008?LED
0010FC 021135            LJMP     ?C0009?LED
0010FF 02113A            LJMP     ?C0010?LED
001102 02113F            LJMP     ?C0011?LED
001105 021144            LJMP     ?C0012?LED
001108 021149            LJMP     ?C0013?LED
00110B 02114E            LJMP     ?C0014?LED
00110E 021153            LJMP     ?C0015?LED
001111 021158            LJMP     ?C0016?LED
001114 02115D            LJMP     ?C0017?LED
001117 021162            LJMP     ?C0018?LED
00111A 021164            LJMP     ?C0019?LED
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 55


00111D 021169            LJMP     ?C0020?LED
001120 02116E            LJMP     ?C0021?LED
001123 021173            LJMP     ?C0022?LED
   45:     	{
   46:     	    case 0:	P1 = 0xeb; break;//0X88
001126         ?C0006?LED:
001126 7590EB            MOV      P1,#0EBH
001129 8050              SJMP     ?C0005?LED
   47:     		case 1:	P1 = 0x88; break;//0XEB
00112B         ?C0007?LED:
00112B 759088            MOV      P1,#088H
00112E 804B              SJMP     ?C0005?LED
   48:     		case 2:	P1 = 0xB3; break;//0X92
001130         ?C0008?LED:
001130 7590B3            MOV      P1,#0B3H
001133 8046              SJMP     ?C0005?LED
   49:     		case 3:	P1 = 0xba; break;//0XC2
001135         ?C0009?LED:
001135 7590BA            MOV      P1,#0BAH
001138 8041              SJMP     ?C0005?LED
   50:     		case 4:	P1 = 0xd8; break;//0XE1
00113A         ?C0010?LED:
00113A 7590D8            MOV      P1,#0D8H
00113D 803C              SJMP     ?C0005?LED
   51:     		case 5:	P1 = 0x7a; break;//0XC4
00113F         ?C0011?LED:
00113F 75907A            MOV      P1,#07AH
001142 8037              SJMP     ?C0005?LED
   52:     		case 6:	P1 = 0x7b; break;//0X84
001144         ?C0012?LED:
001144 75907B            MOV      P1,#07BH
001147 8032              SJMP     ?C0005?LED
   53:     		case 7:	P1 = 0xa8; break;//0XEA
001149         ?C0013?LED:
001149 7590A8            MOV      P1,#0A8H
00114C 802D              SJMP     ?C0005?LED
   54:     		case 8:	P1 = 0xfb; break;//0X80
00114E         ?C0014?LED:
00114E 7590FB            MOV      P1,#0FBH
001151 8028              SJMP     ?C0005?LED
   55:     		case 9:	P1 = 0xfa; break;//0XC0
001153         ?C0015?LED:
001153 7590FA            MOV      P1,#0FAH
001156 8023              SJMP     ?C0005?LED
   56:     		case 10:P1 = 0xcb; break;//0XC0 U
001158         ?C0016?LED:
001158 7590CB            MOV      P1,#0CBH
00115B 801E              SJMP     ?C0005?LED
   57:     		case 11:P1 = 0xbe; break;//3.
00115D         ?C0017?LED:
00115D 7590BE            MOV      P1,#0BEH
001160 8019              SJMP     ?C0005?LED
   58:     		case 12:P1 = 0x00; break;//空
001162         ?C0018?LED:
001162 8014              SJMP     ?C0044?LED
   59:     		case 13:P1 = 0x7e; break;//5.
001164         ?C0019?LED:
001164 75907E            MOV      P1,#07EH
001167 8012              SJMP     ?C0005?LED
   60:             case 14:P1 = 0xf1;break;//P
001169         ?C0020?LED:
001169 7590F1            MOV      P1,#0F1H
00116C 800D              SJMP     ?C0005?LED
   61:             case 15:P1 = 0x10;break;//-
00116E         ?C0021?LED:
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 56


00116E 759010            MOV      P1,#010H
001171 8008              SJMP     ?C0005?LED
   62:             case 16:P1 = 0xf9;break;//-
001173         ?C0022?LED:
001173 7590F9            MOV      P1,#0F9H
001176 8003              SJMP     ?C0005?LED
   63:     		default:P1 = 0x00; break;
001178         ?C0023?LED:
001178         
001178 E4                CLR      A
001179 F590              MOV      P1,A
   64:     	}
00117B         ?C0005?LED:
   65:         if(gShowDot & (1<<gCurLed))//show dot
00117B 7401              MOV      A,#01H
00117D 7E00              MOV      R6,#00H
00117F A807              MOV      R0,AR7
001181 08                INC      R0
001182 8005              SJMP     ?C0043?LED
001184         ?C0042?LED:
001184 C3                CLR      C
001185 33                RLC      A
001186 CE                XCH      A,R6
001187 33                RLC      A
001188 CE                XCH      A,R6
001189         ?C0043?LED:
001189 D8F9              DJNZ     R0,?C0042?LED
00118B FF                MOV      R7,A
00118C 9000D0            MOV      DPTR,#gShowDot
00118F E0                MOVX     A,@DPTR
001190 FD                MOV      R5,A
001191 EF                MOV      A,R7
001192 5D                ANL      A,R5
001193 6003              JZ       ?C0024?LED
   66:         {
   67:      		P1 |= 0X04;
001195 439004            ORL      P1,#04H
   68:         }
001198         ?C0024?LED:
   69:     	switch (gCurLed)
001198 9000CF            MOV      DPTR,#gCurLed
00119B E0                MOVX     A,@DPTR
00119C 14                DEC      A
00119D 6013              JZ       ?C0027?LED
00119F 14                DEC      A
0011A0 6013              JZ       ?C0028?LED
0011A2 14                DEC      A
0011A3 6013              JZ       ?C0029?LED
0011A5 14                DEC      A
0011A6 6013              JZ       ?C0030?LED
0011A8 14                DEC      A
0011A9 6013              JZ       ?C0031?LED
0011AB 2405              ADD      A,#05H
0011AD 7011              JNZ      ?C0033?LED
   70:     	{
   71:     		case 0:
0011AF         ?C0026?LED:
   72:     			LED_CS0 = 0;
0011AF C2A6              CLR      LED_CS0
   73:     			break;
0011B1 22                RET      
   74:     		case 1:
0011B2         ?C0027?LED:
   75:     			LED_CS1 = 0;
0011B2 C2A7              CLR      LED_CS1
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 57


   76:     			break;
0011B4 22                RET      
   77:     		case 2:
0011B5         ?C0028?LED:
   78:     			LED_CS2 = 0;
0011B5 C2A0              CLR      LED_CS2
   79:     			break;
0011B7 22                RET      
   80:     		case 3:
0011B8         ?C0029?LED:
   81:     			LED_CS3 = 0;
0011B8 C2CD              CLR      LED_CS3
   82:     			break;
0011BA 22                RET      
   83:     		case 4:
0011BB         ?C0030?LED:
   84:     			LED_CS4 = 0;
0011BB C2CC              CLR      LED_CS4
   85:     			break;
0011BD 22                RET      
   86:     		case 5:
0011BE         ?C0031?LED:
   87:     			LED_CS5 = 0;
0011BE C2B6              CLR      LED_CS5
   88:     			break;
   89:     		default:
   90:     			break;
   91:     	}
   92:     }
   93: }
0011C0         ?C0033?LED:
0011C0 22                RET      
----- FUNCTION led_Handler1ms (END) -------


----- FUNCTION sys_uartInit (BEGIN) -----
 FILE: 'System\sys_uart.c'
   13: void sys_uartInit(void)
   14: {
   15:     ACC = P_SW1;
   16:     ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
0011C1 E5A2              MOV      A,P_SW1
   17:     P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
0011C3 543F              ANL      A,#03FH
   18:     SCON = 0x50;                //8位可变波特率
0011C5 F5A2              MOV      P_SW1,A
   19:     T2L = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
0011C7 759850            MOV      SCON,#050H
   20:     T2H = (65536 - (FOSC/4/BAUD))>>8;
0011CA 75D7E0            MOV      T2L,#0E0H
   21:     AUXR |= 0x14;                //T2为1T模式, 并启动定时器2
0011CD 75D6FE            MOV      T2H,#0FEH
   22:     AUXR |= 0x01;               //选择定时器2为串口1的波特率发生器
0011D0 438E14            ORL      AUXR,#014H
   23:     ES = 1;                     //使能串口1中断
0011D3 438E01            ORL      AUXR,#01H
   24:     EA = 1;
0011D6 D2AC              SETB     ES
   25: }
0011D8 D2AF              SETB     EA
   26: 
0011DA 22                RET      
----- FUNCTION sys_uartInit (END) -------


LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 58


----- FUNCTION ?L?COM004A (BEGIN) -----
0011DB E0                MOVX     A,@DPTR
0011DC FC                MOV      R4,A
0011DD A3                INC      DPTR
0011DE E0                MOVX     A,@DPTR
0011DF FD                MOV      R5,A
0011E0 D3                SETB     C
0011E1 9F                SUBB     A,R7
0011E2 EC                MOV      A,R4
0011E3 22                RET      
----- FUNCTION ?L?COM004A (END) -------


----- FUNCTION ?L?COM0037 (BEGIN) -----
0011E4 D2A6              SETB     LED_CS0
0011E6 D2A7              SETB     LED_CS1
0011E8 D2A0              SETB     LED_CS2
0011EA D2CD              SETB     LED_CS3
0011EC D2CC              SETB     LED_CS4
0011EE D2B6              SETB     LED_CS5
0011F0 22                RET      
----- FUNCTION ?L?COM0037 (END) -------


----- FUNCTION sys_uartInterrupt (BEGIN) -----
 FILE: 'System\sys_uart.c'
   27: void sys_uartInterrupt() interrupt 4
0011F1 C0E0              PUSH     ACC
0011F3 C0F0              PUSH     B
0011F5 C083              PUSH     DPH
0011F7 C082              PUSH     DPL
0011F9 C0D0              PUSH     PSW
0011FB 75D000            MOV      PSW,#00H
0011FE C000              PUSH     AR0
001200 C001              PUSH     AR1
001202 C002              PUSH     AR2
001204 C003              PUSH     AR3
001206 C004              PUSH     AR4
001208 C005              PUSH     AR5
00120A C006              PUSH     AR6
00120C C007              PUSH     AR7
   28: {
   29:     if(RI)
00120E 309804            JNB      RI,?C0002?SYS_UART
   30:     {
   31:         RI = 0;
001211 C298              CLR      RI
   32:         sys_uartRxHandler();
001213 5135              ACALL    sys_uartRxHandler
   33:     }
001215         ?C0002?SYS_UART:
   34:     if(TI)
001215 309902            JNB      TI,?C0004?SYS_UART
   35:     {
   36:         TI = 0;
001218 C299              CLR      TI
   37:     }
   38: }
00121A         ?C0004?SYS_UART:
00121A D007              POP      AR7
00121C D006              POP      AR6
00121E D005              POP      AR5
001220 D004              POP      AR4
001222 D003              POP      AR3
001224 D002              POP      AR2
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 59


001226 D001              POP      AR1
001228 D000              POP      AR0
00122A D0D0              POP      PSW
00122C D082              POP      DPL
00122E D083              POP      DPH
001230 D0F0              POP      B
001232 D0E0              POP      ACC
001234 32                RETI     
----- FUNCTION sys_uartInterrupt (END) -------


----- FUNCTION sys_uartRxHandler (BEGIN) -----
 FILE: 'System\sys_uart.c'
   41: void sys_uartRxHandler(void)
   42: {
   43:     if(SBUF == 0x7F)        //0x7F auto download     boud 2400 0x7F at boud 9600 is 0xF8
   44:     {
001235 E599              MOV      A,SBUF
001237 B47F10            CJNE     A,#07FH,?C0005?SYS_UART
   45:         RxNum++;
   46:         if(RxNum >= 40)
00123A 9000DA            MOV      DPTR,#RxNum
00123D E0                MOVX     A,@DPTR
00123E 04                INC      A
00123F F0                MOVX     @DPTR,A
   47:         {
001240 E0                MOVX     A,@DPTR
001241 C3                CLR      C
001242 9428              SUBB     A,#028H
001244 4009              JC       ?C0008?SYS_UART
   48:             IAP_CONTR = 0x60;
   49:         }
001246 75C760            MOV      IAP_CONTR,#060H
   50:     }
   51:     else
001249 22                RET      
00124A         ?C0005?SYS_UART:
   52:     {
   53:         RxNum = 0;
00124A E4                CLR      A
00124B 9000DA            MOV      DPTR,#RxNum
00124E F0                MOVX     @DPTR,A
   54:     }
   55: }
00124F         ?C0008?SYS_UART:
00124F 22                RET      
----- FUNCTION sys_uartRxHandler (END) -------


----- FUNCTION IapIdle (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   24: void IapIdle(void)
   25: {
   26:     IAP_CONTR = 0;                  //关闭IAP功能
   27:     IAP_CMD = 0;                    //清除命令寄存器
001250 E4                CLR      A
001251 F5C7              MOV      IAP_CONTR,A
   28:     IAP_TRIG = 0;                   //清除触发寄存器
001253 F5C5              MOV      IAP_CMD,A
   29:     IAP_ADDRH = 0x80;               //将地址设置到非IAP区域
001255 F5C6              MOV      IAP_TRIG,A
   30:     IAP_ADDRL = 0;
001257 75C380            MOV      IAP_ADDRH,#080H
   31: }
00125A F5C4              MOV      IAP_ADDRL,A
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 60


   32: 
00125C 22                RET      
----- FUNCTION IapIdle (END) -------


----- FUNCTION ?L?COM002A (BEGIN) -----
00125D E0                MOVX     A,@DPTR
00125E FE                MOV      R6,A
00125F A3                INC      DPTR
001260 E0                MOVX     A,@DPTR
001261 FF                MOV      R7,A
----- FUNCTION _sys_eepromEraseSector (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   72: void sys_eepromEraseSector(UINT16 addr)
   73: {
;---- Variable 'addr' assigned to Register 'R6/R7' ----
   74:     IAP_CONTR = ENABLE_IAP;         //使能IAP
   75:     IAP_CMD = CMD_ERASE;            //设置IAP命令
001262 75C780            MOV      IAP_CONTR,#080H
   76:     IAP_ADDRL = addr;               //设置IAP低地址
001265 75C503            MOV      IAP_CMD,#03H
   77:     IAP_ADDRH = addr >> 8;          //设置IAP高地址
001268 8FC4              MOV      IAP_ADDRL,R7
   78:     IAP_TRIG = 0x5a;                //写触发命令(0x5a)
00126A EE                MOV      A,R6
00126B B158              ACALL    ?L?COM003F
   79:     IAP_TRIG = 0xa5;                //写触发命令(0xa5)
   80:     _nop_();                        //等待ISP/IAP/EEPROM操作完成
00126D 00                NOP      
   81:     IapIdle();
00126E 80E0              SJMP     IapIdle
----- FUNCTION _sys_eepromEraseSector (END) -------


----- FUNCTION _hwa_eepromReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   33: BOOL hwa_eepromReadSector(UINT8 *dat, UINT8 sector)
   34: {
001270 1207F6            LCALL    ?L?COM0001
001273 A3                INC      DPTR
001274 ED                MOV      A,R5
001275 F0                MOVX     @DPTR,A
   35:     BOOL e2_error = FALSE, e2_bak_error = FALSE;
   36:     UINT16 e2_addr, e2_bak_addr;
001276 C202              CLR      e2_error
001278 C203              CLR      e2_bak_error
   37:     UINT16 e2_check_sum, e2_bak_check_sum;
   38:     UINT16 Size, SectorSize;
   39: 
   40:     if(sector >= c_u8_eepromSectorNum)
00127A B1BB              ACALL    ?L?COM0049
00127C 9F                SUBB     A,R7
00127D 4001              JC       ?C0010?HWA_EEPROM
   41:     {
   42:     	return FALSE;
00127F 22                RET      
   43:     }
001280         ?C0010?HWA_EEPROM:
   44: 	Size = c_s_eepromConfig[sector].UseSize;
001280 900082            MOV      DPTR,#sector
001283 B1DE              ACALL    ?L?COM0024
001285 93                MOVC     A,@A+DPTR
001286 FD                MOV      R5,A
001287 90008B            MOV      DPTR,#Size
00128A 9191              ACALL    ?L?COM0005
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 61


00128C 900083            MOV      DPTR,#e2_addr
00128F B1AB              ACALL    ?L?COM0053
001291 91B8              ACALL    ?L?COM0006
001293 900085            MOV      DPTR,#e2_bak_addr
001296 F0                MOVX     @DPTR,A
001297 A3                INC      DPTR
001298 CE                XCH      A,R6
001299 F0                MOVX     @DPTR,A
   45:     SectorSize = Size+2;
   46:     
   47:     e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
   48:     e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
   49: 
   50:     sys_eepromRead(e2_addr, e2_data, SectorSize);
00129A 7191              ACALL    ?L?COM000E
00129C 90008D            MOV      DPTR,#SectorSize
00129F 915F              ACALL    ?L?COM0008
0012A1 91D0              ACALL    ?L?COM000B
0012A3 6006              JZ       ?C0012?HWA_EEPROM
   51: 	if (c_s_eepromConfig[sector].Encrypt)
   52: 	{
   53: 		hwa_eepromDecrypt(e2_data, Size);
0012A5 7199              ACALL    ?L?COM000F
0012A7 71A6              ACALL    ?L?COM0013
0012A9 B177              ACALL    _hwa_eepromDecrypt
   54: 	}
0012AB         ?C0012?HWA_EEPROM:
   55:     e2_check_sum = e2_data[Size] << 8 | e2_data[Size + 1];
0012AB 71A6              ACALL    ?L?COM0013
0012AD 2400              ADD      A,#LOW e2_data
0012AF F582              MOV      DPL,A
0012B1 7400              MOV      A,#HIGH e2_data
0012B3 3C                ADDC     A,R4
0012B4 F583              MOV      DPH,A
0012B6 E0                MOVX     A,@DPTR
0012B7 FE                MOV      R6,A
0012B8 7401              MOV      A,#LOW e2_data+01H
0012BA 2D                ADD      A,R5
0012BB F582              MOV      DPL,A
0012BD 7400              MOV      A,#HIGH e2_data+01H
0012BF B150              ACALL    ?L?COM0054
0012C1 900087            MOV      DPTR,#e2_check_sum
0012C4 EE                MOV      A,R6
0012C5 F0                MOVX     @DPTR,A
0012C6 A3                INC      DPTR
0012C7 EF                MOV      A,R7
0012C8 F0                MOVX     @DPTR,A
   56: 
   57: 	sys_eepromRead(e2_bak_addr, e2_data_bak, SectorSize);
0012C9 91C1              ACALL    ?L?COM002C
0012CB 90008D            MOV      DPTR,#SectorSize
0012CE 915F              ACALL    ?L?COM0008
0012D0 91D0              ACALL    ?L?COM000B
0012D2 6004              JZ       ?C0013?HWA_EEPROM
   58: 	if (c_s_eepromConfig[sector].Encrypt)
   59: 	{
   60: 		hwa_eepromDecrypt(e2_data_bak, Size);
0012D4 71A0              ACALL    ?L?COM0012
0012D6 B177              ACALL    _hwa_eepromDecrypt
   61: 	}
0012D8         ?C0013?HWA_EEPROM:
   62:     e2_bak_check_sum = e2_data_bak[Size] << 8 | e2_data_bak[Size + 1];
0012D8 71A6              ACALL    ?L?COM0013
0012DA 2420              ADD      A,#LOW e2_data_bak
0012DC F582              MOV      DPL,A
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 62


0012DE 7400              MOV      A,#HIGH e2_data_bak
0012E0 3C                ADDC     A,R4
0012E1 F583              MOV      DPH,A
0012E3 E0                MOVX     A,@DPTR
0012E4 FE                MOV      R6,A
0012E5 7421              MOV      A,#LOW e2_data_bak+01H
0012E7 2D                ADD      A,R5
0012E8 F582              MOV      DPL,A
0012EA 7400              MOV      A,#HIGH e2_data_bak+01H
0012EC B150              ACALL    ?L?COM0054
0012EE 900089            MOV      DPTR,#e2_bak_check_sum
0012F1 EE                MOV      A,R6
0012F2 F0                MOVX     @DPTR,A
0012F3 A3                INC      DPTR
0012F4 EF                MOV      A,R7
0012F5 F0                MOVX     @DPTR,A
   63: 
   64:     if(e2_check_sum != hwa_eepromCheck(e2_data, Size))
0012F6 7199              ACALL    ?L?COM000F
0012F8 A3                INC      DPTR
0012F9 A3                INC      DPTR
0012FA E0                MOVX     A,@DPTR
0012FB FD                MOV      R5,A
0012FC B10E              ACALL    _hwa_eepromCheck
0012FE 900087            MOV      DPTR,#e2_check_sum
001301 E0                MOVX     A,@DPTR
001302 6E                XRL      A,R6
001303 7003              JNZ      ?C0025?HWA_EEPROM
001305 A3                INC      DPTR
001306 E0                MOVX     A,@DPTR
001307 6F                XRL      A,R7
001308         ?C0025?HWA_EEPROM:
001308 6002              JZ       ?C0014?HWA_EEPROM
   65:     {
   66:         e2_error = TRUE;
00130A D202              SETB     e2_error
   67:     }
00130C         ?C0014?HWA_EEPROM:
   68:     if(e2_bak_check_sum != hwa_eepromCheck(e2_data_bak, Size))
00130C 71A0              ACALL    ?L?COM0012
00130E B10E              ACALL    _hwa_eepromCheck
001310 900089            MOV      DPTR,#e2_bak_check_sum
001313 E0                MOVX     A,@DPTR
001314 6E                XRL      A,R6
001315 7003              JNZ      ?C0026?HWA_EEPROM
001317 A3                INC      DPTR
001318 E0                MOVX     A,@DPTR
001319 6F                XRL      A,R7
00131A         ?C0026?HWA_EEPROM:
00131A 6002              JZ       ?C0015?HWA_EEPROM
   69:     {
   70:         e2_bak_error = TRUE;
00131C D203              SETB     e2_bak_error
   71:     }
00131E         ?C0015?HWA_EEPROM:
   72: 
   73:     if(e2_error && e2_bak_error)    //~1~备份块和正常块都校验错误，返回错误
00131E 300205            JNB      e2_error,?C0016?HWA_EEPROM
001321 300302            JNB      e2_bak_error,?C0016?HWA_EEPROM
   74:     {
   75:         return FALSE;
001324 C3                CLR      C
001325 22                RET      
   76:     }
001326         ?C0016?HWA_EEPROM:
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 63


   77:     else if(e2_error)                                 //~2~备份块校验错误，恢复正常块
001326 300213            JNB      e2_error,?C0018?HWA_EEPROM
   78:     {
   79:         memcpy(e2_data, e2_data_bak, SectorSize);
001329 90008D            MOV      DPTR,#SectorSize
00132C B1C4              ACALL    ?L?COM003D
00132E 91C9              ACALL    ?L?COM002D
001330 1200F6            LCALL    ?C?COPY
   80: 		sys_eepromEraseSector(e2_addr);
001333 900083            MOV      DPTR,#e2_addr
001336 515D              ACALL    ?L?COM002A
   81:         sys_eepromWrite(e2_addr, e2_data, SectorSize);
001338 7191              ACALL    ?L?COM000E
   82:     }
00133A 8037              SJMP     ?C0028?HWA_EEPROM
00133C         ?C0018?HWA_EEPROM:
   83:     else if(e2_bak_error ||                          //~3~正常块校验错误，恢复备份块
00133C 20031A            JB       e2_bak_error,?C0021?HWA_EEPROM
00133F 200238            JB       e2_error,?C0017?HWA_EEPROM
001342 200335            JB       e2_bak_error,?C0017?HWA_EEPROM
001345 900089            MOV      DPTR,#e2_bak_check_sum
001348 E0                MOVX     A,@DPTR
001349 FE                MOV      R6,A
00134A A3                INC      DPTR
00134B E0                MOVX     A,@DPTR
00134C FF                MOV      R7,A
00134D 900087            MOV      DPTR,#e2_check_sum
001350 E0                MOVX     A,@DPTR
001351 6E                XRL      A,R6
001352 7003              JNZ      ?C0027?HWA_EEPROM
001354 A3                INC      DPTR
001355 E0                MOVX     A,@DPTR
001356 6F                XRL      A,R7
001357         ?C0027?HWA_EEPROM:
001357 6021              JZ       ?C0017?HWA_EEPROM
001359         ?C0021?HWA_EEPROM:
   84:             (e2_error == FALSE                                //~4~正常块、备份块都检验正确，但数据不同，则以
   85:              && e2_bak_error == FALSE                         //   最新写入的正常块覆盖备份块
   86:              && e2_check_sum != e2_bak_check_sum)
   87:     )
   88:     {
   89:         memcpy(e2_data_bak, e2_data, SectorSize);
001359 90008D            MOV      DPTR,#SectorSize
00135C E0                MOVX     A,@DPTR
00135D FE                MOV      R6,A
00135E A3                INC      DPTR
00135F E0                MOVX     A,@DPTR
001360 FF                MOV      R7,A
001361 7820              MOV      R0,#LOW e2_data_bak
001363 7C00              MOV      R4,#HIGH e2_data_bak
001365 7D01              MOV      R5,#01H
001367 7199              ACALL    ?L?COM000F
001369 1200F6            LCALL    ?C?COPY
   90: 		sys_eepromEraseSector(e2_bak_addr);
00136C 900085            MOV      DPTR,#e2_bak_addr
00136F 515D              ACALL    ?L?COM002A
   91:         sys_eepromWrite(e2_bak_addr, e2_data_bak, SectorSize);
001371 91C1              ACALL    ?L?COM002C
001373         
001373 90008D            MOV      DPTR,#SectorSize
001376 915F              ACALL    ?L?COM0008
001378 916C              ACALL    _sys_eepromWrite
   92:     }
00137A         ?C0017?HWA_EEPROM:
   93:     memcpy(dat, e2_data, Size);
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 64


00137A 90008B            MOV      DPTR,#Size
00137D E0                MOVX     A,@DPTR
00137E FE                MOV      R6,A
00137F A3                INC      DPTR
001380 E0                MOVX     A,@DPTR
001381 FF                MOV      R7,A
001382 1207DE            LCALL    ?L?COM0003
001385 F8                MOV      R0,A
001386 AC02              MOV      R4,AR2
001388 AD03              MOV      R5,AR3
00138A 7199              ACALL    ?L?COM000F
00138C 1200F6            LCALL    ?C?COPY
   94:     return TRUE;
00138F D3                SETB     C
   95: }
001390 22                RET      
----- FUNCTION _hwa_eepromReadSector (END) -------


----- FUNCTION ?L?COM000E (BEGIN) -----
001391 900083            MOV      DPTR,#e2_addr
001394 E0                MOVX     A,@DPTR
001395 FE                MOV      R6,A
001396 A3                INC      DPTR
001397 E0                MOVX     A,@DPTR
001398 FF                MOV      R7,A
001399         ?L?COM000F:
001399 7B01              MOV      R3,#01H
00139B 7A00              MOV      R2,#HIGH e2_data
00139D 7900              MOV      R1,#LOW e2_data
00139F 22                RET      
----- FUNCTION ?L?COM000E (END) -------


----- FUNCTION ?L?COM0012 (BEGIN) -----
0013A0 7B01              MOV      R3,#01H
0013A2 7A00              MOV      R2,#HIGH e2_data_bak
0013A4 7920              MOV      R1,#LOW e2_data_bak
0013A6         ?L?COM0013:
0013A6 90008B            MOV      DPTR,#Size
0013A9 E0                MOVX     A,@DPTR
0013AA FC                MOV      R4,A
0013AB A3                INC      DPTR
0013AC E0                MOVX     A,@DPTR
0013AD FD                MOV      R5,A
0013AE 22                RET      
----- FUNCTION ?L?COM0012 (END) -------


----- FUNCTION _hwa_eepromWriteSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   97: BOOL hwa_eepromWriteSector(UINT8 *dat, UINT8 sector)
   98: {
0013AF 900071            MOV      DPTR,#dat
0013B2 1207F9            LCALL    ?L?COM0002
0013B5 A3                INC      DPTR
0013B6 ED                MOV      A,R5
0013B7 F0                MOVX     @DPTR,A
   99:     UINT16 e2_addr, e2_bak_addr;
  100:     UINT16 e2_check_sum;
  101:     
  102:     UINT16 Size, SectorSize;
  103:     
  104:     if(sector >= c_u8_eepromSectorNum)
0013B8 B1BB              ACALL    ?L?COM0049
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 65


0013BA 9F                SUBB     A,R7
0013BB 4001              JC       ?C0022?HWA_EEPROM
  105:     {
  106:     	return FALSE;
0013BD 22                RET      
  107:     }
0013BE         ?C0022?HWA_EEPROM:
  108: 	Size = c_s_eepromConfig[sector].UseSize;
0013BE 900074            MOV      DPTR,#sector
0013C1 B1DE              ACALL    ?L?COM0024
0013C3 93                MOVC     A,@A+DPTR
0013C4 FD                MOV      R5,A
0013C5 90007B            MOV      DPTR,#Size
0013C8 9191              ACALL    ?L?COM0005
0013CA 900075            MOV      DPTR,#e2_addr
0013CD B1AB              ACALL    ?L?COM0053
0013CF 91B8              ACALL    ?L?COM0006
0013D1 900077            MOV      DPTR,#e2_bak_addr
0013D4 F0                MOVX     @DPTR,A
0013D5 A3                INC      DPTR
0013D6 CE                XCH      A,R6
0013D7 F0                MOVX     @DPTR,A
  109:     SectorSize = Size+2;
  110: 
  111:     e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
  112:     e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
  113:     e2_check_sum = hwa_eepromCheck(dat, Size);
0013D8 900071            MOV      DPTR,#dat
0013DB 1207E1            LCALL    ?L?COM0004
0013DE F9                MOV      R1,A
0013DF B161              ACALL    ?L?COM0048
0013E1 B10E              ACALL    _hwa_eepromCheck
0013E3 900079            MOV      DPTR,#e2_check_sum
0013E6 EE                MOV      A,R6
0013E7 F0                MOVX     @DPTR,A
0013E8 A3                INC      DPTR
0013E9 EF                MOV      A,R7
0013EA F0                MOVX     @DPTR,A
  114: 
  115:     hwa_eepromReadSector(e2_data, sector);                                  //  写入之前，如果有错误块，先恢复
0013EB 7199              ACALL    ?L?COM000F
0013ED 900074            MOV      DPTR,#sector
0013F0 E0                MOVX     A,@DPTR
0013F1 FD                MOV      R5,A
0013F2 5170              ACALL    _hwa_eepromReadSector
  116: 
  117:     memcpy(e2_data, dat, Size);
0013F4 90007B            MOV      DPTR,#Size
0013F7 B1C4              ACALL    ?L?COM003D
0013F9 900071            MOV      DPTR,#dat
0013FC 1207E1            LCALL    ?L?COM0004
0013FF F9                MOV      R1,A
001400 1200F6            LCALL    ?C?COPY
  118: 
  119: 	if (c_s_eepromConfig[sector].Encrypt)
001403 900074            MOV      DPTR,#sector
001406 91D5              ACALL    ?L?COM000C
001408 6006              JZ       ?C0024?HWA_EEPROM
  120: 	{
  121: 		hwa_eepromEncrypt(e2_data, Size);
00140A 7199              ACALL    ?L?COM000F
00140C B161              ACALL    ?L?COM0048
00140E B1F4              ACALL    _hwa_eepromEncrypt
  122: 	}
001410         ?C0024?HWA_EEPROM:
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 66


  123:     e2_data[Size] = (UINT8)(e2_check_sum >> 8);
001410 900079            MOV      DPTR,#e2_check_sum
001413 E0                MOVX     A,@DPTR
001414 FC                MOV      R4,A
001415 A3                INC      DPTR
001416 E0                MOVX     A,@DPTR
001417 FD                MOV      R5,A
001418 EC                MOV      A,R4
001419 FF                MOV      R7,A
00141A A3                INC      DPTR
00141B E0                MOVX     A,@DPTR
00141C FA                MOV      R2,A
00141D A3                INC      DPTR
00141E E0                MOVX     A,@DPTR
00141F FB                MOV      R3,A
001420 2400              ADD      A,#LOW e2_data
001422 F582              MOV      DPL,A
001424 7400              MOV      A,#HIGH e2_data
001426 3A                ADDC     A,R2
001427 F583              MOV      DPH,A
001429 EF                MOV      A,R7
00142A F0                MOVX     @DPTR,A
  124:     e2_data[Size + 1] = (UINT8)(e2_check_sum&0xFF);
00142B 7401              MOV      A,#LOW e2_data+01H
00142D 2B                ADD      A,R3
00142E F582              MOV      DPL,A
001430 7400              MOV      A,#HIGH e2_data+01H
001432 3A                ADDC     A,R2
001433 F583              MOV      DPH,A
001435 ED                MOV      A,R5
001436 F0                MOVX     @DPTR,A
  125: 	sys_eepromEraseSector(e2_addr);
001437 900075            MOV      DPTR,#e2_addr
00143A 515D              ACALL    ?L?COM002A
  126:     sys_eepromWrite(e2_addr, e2_data, SectorSize);
00143C 900075            MOV      DPTR,#e2_addr
00143F 9151              ACALL    ?L?COM0007
001441 916C              ACALL    _sys_eepromWrite
  127: 	
  128: //    memcpy(e2_data_bak, e2_data, SectorSize);
  129: 	sys_eepromEraseSector(e2_bak_addr);
001443 900077            MOV      DPTR,#e2_bak_addr
001446 515D              ACALL    ?L?COM002A
  130: 	sys_eepromWrite(e2_bak_addr, e2_data, SectorSize);
001448 900077            MOV      DPTR,#e2_bak_addr
00144B 9151              ACALL    ?L?COM0007
00144D 916C              ACALL    _sys_eepromWrite
  131:     return TRUE;
00144F D3                SETB     C
  132: }
001450 22                RET      
----- FUNCTION _hwa_eepromWriteSector (END) -------


----- FUNCTION ?L?COM0007 (BEGIN) -----
001451 E0                MOVX     A,@DPTR
001452 FE                MOV      R6,A
001453 A3                INC      DPTR
001454 E0                MOVX     A,@DPTR
001455 FF                MOV      R7,A
001456 7B01              MOV      R3,#01H
001458 7A00              MOV      R2,#HIGH e2_data
00145A 7900              MOV      R1,#LOW e2_data
00145C 90007D            MOV      DPTR,#SectorSize
00145F         ?L?COM0008:
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 67


00145F E0                MOVX     A,@DPTR
001460 FD                MOV      R5,A
001461 A3                INC      DPTR
001462 E0                MOVX     A,@DPTR
001463 900094            MOV      DPTR,#?_sys_eepromWrite?BYTE+05H
001466 CD                XCH      A,R5
001467 F0                MOVX     @DPTR,A
001468 A3                INC      DPTR
001469 ED                MOV      A,R5
00146A F0                MOVX     @DPTR,A
00146B 22                RET      
----- FUNCTION ?L?COM0007 (END) -------


----- FUNCTION _sys_eepromWrite (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
  100: void sys_eepromWrite(UINT16 addr, UINT8 *Data, UINT16 num)
  101: {
;---- Variable 'Data' assigned to Register 'R1/R2/R3' ----
;---- Variable 'addr' assigned to Register 'R4/R5' ----
00146C B1B3              ACALL    ?L?COM0055
  102:     IAP_CONTR = ENABLE_IAP;
  103:     IAP_CMD = CMD_PROGRAM;
00146E 75C502            MOV      IAP_CMD,#02H
001471         ?C0006?SYS_EEPROM:
  104:     while(num--)
001471 B16A              ACALL    ?L?COM001D
001473 601A              JZ       ?C0007?SYS_EEPROM
  105:     {
  106:         IAP_ADDRL = addr;
001475 8DC4              MOV      IAP_ADDRL,R5
  107:         IAP_ADDRH = addr >> 8;
001477 EC                MOV      A,R4
001478 F5C3              MOV      IAP_ADDRH,A
  108:         IAP_DATA = *Data;
00147A 12011C            LCALL    ?C?CLDPTR
00147D F5C2              MOV      IAP_DATA,A
  109:         IAP_TRIG = 0x5a;
00147F B15A              ACALL    ?L?COM0040
  110:         IAP_TRIG = 0xa5;
  111:         addr++;
001481 0D                INC      R5
001482 BD0001            CJNE     R5,#00H,?C0010?SYS_EEPROM
001485 0C                INC      R4
001486         ?C0010?SYS_EEPROM:
  112:         Data++;
001486 7401              MOV      A,#01H
001488 29                ADD      A,R1
001489 F9                MOV      R1,A
00148A E4                CLR      A
00148B 3A                ADDC     A,R2
00148C FA                MOV      R2,A
  113:     }
00148D 80E2              SJMP     ?C0006?SYS_EEPROM
00148F         ?C0007?SYS_EEPROM:
  114:     IapIdle();
00148F 4150              AJMP     IapIdle
----- FUNCTION _sys_eepromWrite (END) -------


----- FUNCTION ?L?COM0005 (BEGIN) -----
001491 EC                MOV      A,R4
001492 F0                MOVX     @DPTR,A
001493 A3                INC      DPTR
001494 ED                MOV      A,R5
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 68


001495 F0                MOVX     @DPTR,A
001496 2402              ADD      A,#02H
001498 FE                MOV      R6,A
001499 E4                CLR      A
00149A 3C                ADDC     A,R4
00149B A3                INC      DPTR
00149C F0                MOVX     @DPTR,A
00149D A3                INC      DPTR
00149E CE                XCH      A,R6
00149F F0                MOVX     @DPTR,A
0014A0 EB                MOV      A,R3
0014A1 FF                MOV      R7,A
0014A2 7E00              MOV      R6,#00H
0014A4 900447            MOV      DPTR,#c_u16_eepromSectorSize
0014A7 E4                CLR      A
0014A8 93                MOVC     A,@A+DPTR
0014A9 FC                MOV      R4,A
0014AA 7401              MOV      A,#01H
0014AC 93                MOVC     A,@A+DPTR
0014AD FD                MOV      R5,A
0014AE 120196            LCALL    ?C?IMUL
0014B1 AA06              MOV      R2,AR6
0014B3 AB07              MOV      R3,AR7
0014B5 900449            MOV      DPTR,#c_u16_eepromSectorAddr
0014B8         ?L?COM0006:
0014B8 7401              MOV      A,#01H
0014BA 93                MOVC     A,@A+DPTR
0014BB 2B                ADD      A,R3
0014BC FE                MOV      R6,A
0014BD E4                CLR      A
0014BE 93                MOVC     A,@A+DPTR
0014BF 3A                ADDC     A,R2
0014C0 22                RET      
----- FUNCTION ?L?COM0005 (END) -------


----- FUNCTION ?L?COM002C (BEGIN) -----
0014C1 900085            MOV      DPTR,#e2_bak_addr
0014C4 E0                MOVX     A,@DPTR
0014C5 FE                MOV      R6,A
0014C6 A3                INC      DPTR
0014C7 E0                MOVX     A,@DPTR
0014C8 FF                MOV      R7,A
0014C9         ?L?COM002D:
0014C9 7B01              MOV      R3,#01H
0014CB 7A00              MOV      R2,#HIGH e2_data_bak
0014CD 7920              MOV      R1,#LOW e2_data_bak
0014CF 22                RET      
----- FUNCTION ?L?COM002C (END) -------


----- FUNCTION ?L?COM000B (BEGIN) -----
0014D0 91E7              ACALL    _sys_eepromRead
0014D2 900082            MOV      DPTR,#sector
0014D5         ?L?COM000C:
0014D5 E0                MOVX     A,@DPTR
0014D6 75F003            MOV      B,#03H
0014D9 A4                MUL      AB
0014DA 2443              ADD      A,#LOW c_s_eepromConfig+02H
0014DC F582              MOV      DPL,A
0014DE E5F0              MOV      A,B
0014E0 3404              ADDC     A,#HIGH c_s_eepromConfig+02H
0014E2 F583              MOV      DPH,A
0014E4 E4                CLR      A
0014E5 93                MOVC     A,@A+DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 69


0014E6 22                RET      
----- FUNCTION ?L?COM000B (END) -------


----- FUNCTION _sys_eepromRead (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   84: void sys_eepromRead(UINT16 addr, UINT8 *Data, UINT16 num)
   85: {
0014E7 900091            MOV      DPTR,#Data
0014EA 1207F9            LCALL    ?L?COM0002
;---- Variable 'addr' assigned to Register 'R4/R5' ----
0014ED B1B3              ACALL    ?L?COM0055
   86:     IAP_CONTR = ENABLE_IAP;
   87:     IAP_CMD = CMD_READ;
0014EF 75C501            MOV      IAP_CMD,#01H
0014F2         ?C0003?SYS_EEPROM:
   88:     while(num--)
0014F2 B16A              ACALL    ?L?COM001D
0014F4 6016              JZ       ?C0004?SYS_EEPROM
   89:     {
   90:         IAP_ADDRL = addr;
0014F6 8DC4              MOV      IAP_ADDRL,R5
   91:         IAP_ADDRH = addr >> 8;
0014F8 EC                MOV      A,R4
0014F9 B158              ACALL    ?L?COM003F
   92:         IAP_TRIG = 0x5a;
   93:         IAP_TRIG = 0xa5;
   94:         addr++;
0014FB 0D                INC      R5
0014FC BD0001            CJNE     R5,#00H,?C0009?SYS_EEPROM
0014FF 0C                INC      R4
001500         ?C0009?SYS_EEPROM:
   95:         *Data++ = IAP_DATA;
001500 900091            MOV      DPTR,#Data
001503 B1D0              ACALL    ?L?COM0022
001505 E5C2              MOV      A,IAP_DATA
001507 120162            LCALL    ?C?CSTPTR
   96:     }
00150A 80E6              SJMP     ?C0003?SYS_EEPROM
00150C         ?C0004?SYS_EEPROM:
   97:     IapIdle();
00150C 4150              AJMP     IapIdle
----- FUNCTION _sys_eepromRead (END) -------


----- FUNCTION _hwa_eepromCheck (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
    6: static UINT16 hwa_eepromCheck( UINT8 *dat, UINT16 len)
    7: {
00150E 90008F            MOV      DPTR,#dat
001511 1207F9            LCALL    ?L?COM0002
001514 120FCB            LCALL    ?L?COM0036
    8:     UINT16 crc = 0xFFFF;
    9:     UINT8 i;
;---- Variable 'crc' assigned to Register 'R6/R7' ----
001517 74FF              MOV      A,#0FFH
001519 FF                MOV      R7,A
00151A FE                MOV      R6,A
00151B         ?C0001?HWA_EEPROM:
   10:     while(len--)
00151B 900092            MOV      DPTR,#len
00151E B16D              ACALL    ?L?COM001E
001520 602D              JZ       ?C0002?HWA_EEPROM
   11:     {
   12:         crc = crc ^*dat++;
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 70


001522 90008F            MOV      DPTR,#dat
001525 B1D0              ACALL    ?L?COM0022
001527 120FE4            LCALL    ?L?COM0044
00152A 900094            MOV      DPTR,#i
00152D F0                MOVX     @DPTR,A
00152E         ?C0003?HWA_EEPROM:
00152E 900094            MOV      DPTR,#i
001531 E0                MOVX     A,@DPTR
001532 C3                CLR      C
001533 9408              SUBB     A,#08H
001535 50E4              JNC      ?C0001?HWA_EEPROM
   13:         for ( i = 0; i < 8; i++)
   14:         {
   15:             if( ( crc & 0x0001) > 0)
001537 120FED            LCALL    ?L?COM0046
00153A EE                MOV      A,R6
00153B 4004              JC       ?C0006?HWA_EEPROM
   16:             {
   17:                 crc = crc >> 1;
00153D D13B              ACALL    ?L?COM0035
   18:                 crc = crc ^ 0xa001;
   19:             }
00153F 8006              SJMP     ?C0005?HWA_EEPROM
001541         ?C0006?HWA_EEPROM:
   20:             else
   21:             {
   22:                 crc = crc >> 1;
001541 C3                CLR      C
001542 13                RRC      A
001543 FE                MOV      R6,A
001544 EF                MOV      A,R7
001545 13                RRC      A
001546 FF                MOV      R7,A
   23:             }
   24:         }
001547         ?C0005?HWA_EEPROM:
001547 900094            MOV      DPTR,#i
00154A E0                MOVX     A,@DPTR
00154B 04                INC      A
00154C F0                MOVX     @DPTR,A
00154D 80DF              SJMP     ?C0003?HWA_EEPROM
   25:     }
00154F         ?C0002?HWA_EEPROM:
   26:     return ( crc );
   27: }
00154F 22                RET      
----- FUNCTION _hwa_eepromCheck (END) -------


----- FUNCTION ?L?COM0054 (BEGIN) -----
001550 3C                ADDC     A,R4
001551 F583              MOV      DPH,A
001553 E0                MOVX     A,@DPTR
001554 FD                MOV      R5,A
001555 ED                MOV      A,R5
001556 FF                MOV      R7,A
001557 22                RET      
----- FUNCTION ?L?COM0054 (END) -------


----- FUNCTION ?L?COM003F (BEGIN) -----
001558 F5C3              MOV      IAP_ADDRH,A
00155A         ?L?COM0040:
00155A 75C65A            MOV      IAP_TRIG,#05AH
00155D 75C6A5            MOV      IAP_TRIG,#0A5H
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 71


001560 22                RET      
----- FUNCTION ?L?COM003F (END) -------


----- FUNCTION ?L?COM0048 (BEGIN) -----
001561 90007B            MOV      DPTR,#Size
001564 E0                MOVX     A,@DPTR
001565 FC                MOV      R4,A
001566 A3                INC      DPTR
001567 E0                MOVX     A,@DPTR
001568 FD                MOV      R5,A
001569 22                RET      
----- FUNCTION ?L?COM0048 (END) -------


----- FUNCTION ?L?COM001D (BEGIN) -----
00156A 900094            MOV      DPTR,#num
00156D         ?L?COM001E:
00156D 74FF              MOV      A,#0FFH
00156F F5F0              MOV      B,A
001571 1201FD            LCALL    ?C?ILDIX
001574 45F0              ORL      A,B
001576 22                RET      
----- FUNCTION ?L?COM001D (END) -------


----- FUNCTION _hwa_eepromDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   51: void hwa_eepromDecrypt(UINT8 *dat, UINT16 size)        //解密
   52: {
001577 90008F            MOV      DPTR,#dat
00157A 1207F9            LCALL    ?L?COM0002
00157D 120FCB            LCALL    ?L?COM0036
   53: 	UINT16 i;
   54: 	UINT8 tmp;
   55: 	for (i = 0; i<size; i++)
;---- Variable 'i' assigned to Register 'R6/R7' ----
001580 E4                CLR      A
001581 FF                MOV      R7,A
001582 FE                MOV      R6,A
001583         ?C0005?HWA_EEPROM_CFG:
001583 D3                SETB     C
001584 900093            MOV      DPTR,#size+01H
001587 E0                MOVX     A,@DPTR
001588 9F                SUBB     A,R7
001589 900092            MOV      DPTR,#size
00158C E0                MOVX     A,@DPTR
00158D 9E                SUBB     A,R6
00158E 401A              JC       ?C0008?HWA_EEPROM_CFG
   56: 	{
   57: 		tmp = dat[i];
001590 90008F            MOV      DPTR,#dat
001593 1207E1            LCALL    ?L?COM0004
;---- Variable 'tmp' assigned to Register 'R5' ----
001596 D122              ACALL    ?L?COM0039
   58: 		tmp ^= SecretKey;
   59: 		tmp = (tmp << 1) | (tmp >> 7);
001598 25E0              ADD      A,ACC
00159A FC                MOV      R4,A
00159B ED                MOV      A,R5
00159C C4                SWAP     A
00159D 13                RRC      A
00159E 13                RRC      A
00159F 13                RRC      A
0015A0 5401              ANL      A,#01H
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 72


0015A2 D12E              ACALL    ?L?COM0038
0015A4 BF0001            CJNE     R7,#00H,?C0010?HWA_EEPROM_CFG
0015A7 0E                INC      R6
0015A8         ?C0010?HWA_EEPROM_CFG:
0015A8 80D9              SJMP     ?C0005?HWA_EEPROM_CFG
   60: 		tmp ^= SecretKey;
   61: 		dat[i] = tmp;
   62: 	}
   63: }
0015AA         ?C0008?HWA_EEPROM_CFG:
0015AA 22                RET      
----- FUNCTION _hwa_eepromDecrypt (END) -------


----- FUNCTION ?L?COM0053 (BEGIN) -----
0015AB F0                MOVX     @DPTR,A
0015AC A3                INC      DPTR
0015AD CE                XCH      A,R6
0015AE F0                MOVX     @DPTR,A
0015AF 90044B            MOV      DPTR,#c_u16_eepromSectorBakAddr
0015B2 22                RET      
----- FUNCTION ?L?COM0053 (END) -------


----- FUNCTION ?L?COM0055 (BEGIN) -----
0015B3 AD07              MOV      R5,AR7
0015B5 AC06              MOV      R4,AR6
0015B7 75C780            MOV      IAP_CONTR,#080H
0015BA 22                RET      
----- FUNCTION ?L?COM0055 (END) -------


----- FUNCTION ?L?COM0049 (BEGIN) -----
0015BB 900440            MOV      DPTR,#c_u8_eepromSectorNum
0015BE E4                CLR      A
0015BF 93                MOVC     A,@A+DPTR
0015C0 FF                MOV      R7,A
0015C1 ED                MOV      A,R5
0015C2 C3                CLR      C
0015C3 22                RET      
----- FUNCTION ?L?COM0049 (END) -------


----- FUNCTION ?L?COM003D (BEGIN) -----
0015C4 E0                MOVX     A,@DPTR
0015C5 FE                MOV      R6,A
0015C6 A3                INC      DPTR
0015C7 E0                MOVX     A,@DPTR
0015C8 FF                MOV      R7,A
0015C9 7800              MOV      R0,#LOW e2_data
0015CB 7C00              MOV      R4,#HIGH e2_data
0015CD 7D01              MOV      R5,#01H
0015CF 22                RET      
----- FUNCTION ?L?COM003D (END) -------


----- FUNCTION ?L?COM0022 (BEGIN) -----
0015D0 E0                MOVX     A,@DPTR
0015D1 FB                MOV      R3,A
0015D2 A3                INC      DPTR
0015D3 E4                CLR      A
0015D4 75F001            MOV      B,#01H
0015D7 1201FD            LCALL    ?C?ILDIX
0015DA A9F0              MOV      R1,B
0015DC FA                MOV      R2,A
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 73


0015DD 22                RET      
----- FUNCTION ?L?COM0022 (END) -------


----- FUNCTION ?L?COM0024 (BEGIN) -----
0015DE E0                MOVX     A,@DPTR
0015DF FB                MOV      R3,A
0015E0 75F003            MOV      B,#03H
0015E3 A4                MUL      AB
0015E4 2441              ADD      A,#LOW c_s_eepromConfig
0015E6 F582              MOV      DPL,A
0015E8 E5F0              MOV      A,B
0015EA 3404              ADDC     A,#HIGH c_s_eepromConfig
0015EC F583              MOV      DPH,A
0015EE E4                CLR      A
0015EF 93                MOVC     A,@A+DPTR
0015F0 FC                MOV      R4,A
0015F1 7401              MOV      A,#01H
0015F3 22                RET      
----- FUNCTION ?L?COM0024 (END) -------


----- FUNCTION _hwa_eepromEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   37: void hwa_eepromEncrypt(UINT8 *dat, UINT16 size)        //加密
   38: {
0015F4 1207F6            LCALL    ?L?COM0001
0015F7 120FCB            LCALL    ?L?COM0036
   39: 	UINT16 i;
   40: 	UINT8 tmp;
   41: 	for (i = 0; i<size; i++)
;---- Variable 'i' assigned to Register 'R6/R7' ----
0015FA E4                CLR      A
0015FB FF                MOV      R7,A
0015FC FE                MOV      R6,A
0015FD         ?C0001?HWA_EEPROM_CFG:
0015FD D3                SETB     C
0015FE 900083            MOV      DPTR,#size+01H
001601 E0                MOVX     A,@DPTR
001602 9F                SUBB     A,R7
001603 900082            MOV      DPTR,#size
001606 E0                MOVX     A,@DPTR
001607 9E                SUBB     A,R6
001608 4017              JC       ?C0004?HWA_EEPROM_CFG
   42: 	{
   43: 		tmp = dat[i];
00160A 1207DE            LCALL    ?L?COM0003
;---- Variable 'tmp' assigned to Register 'R5' ----
00160D D122              ACALL    ?L?COM0039
   44: 		tmp ^= SecretKey;
   45: 		tmp = (tmp >> 1) | (tmp << 7);
00160F C4                SWAP     A
001610 33                RLC      A
001611 33                RLC      A
001612 33                RLC      A
001613 5480              ANL      A,#080H
001615 FC                MOV      R4,A
001616 ED                MOV      A,R5
001617 C3                CLR      C
001618 13                RRC      A
001619 D12E              ACALL    ?L?COM0038
00161B BF0001            CJNE     R7,#00H,?C0009?HWA_EEPROM_CFG
00161E 0E                INC      R6
00161F         ?C0009?HWA_EEPROM_CFG:
00161F 80DC              SJMP     ?C0001?HWA_EEPROM_CFG
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 74


   46: 		tmp ^= SecretKey;
   47: 		dat[i] = tmp;
   48: 	}
   49: }
001621         ?C0004?HWA_EEPROM_CFG:
001621 22                RET      
----- FUNCTION _hwa_eepromEncrypt (END) -------


----- FUNCTION ?L?COM0039 (BEGIN) -----
001622 F9                MOV      R1,A
001623 8F82              MOV      DPL,R7
001625 8E83              MOV      DPH,R6
001627 120135            LCALL    ?C?CLDOPTR
00162A 64A5              XRL      A,#0A5H
00162C FD                MOV      R5,A
00162D 22                RET      
----- FUNCTION ?L?COM0039 (END) -------


----- FUNCTION ?L?COM0038 (BEGIN) -----
00162E 4C                ORL      A,R4
00162F 64A5              XRL      A,#0A5H
001631 FD                MOV      R5,A
001632 8F82              MOV      DPL,R7
001634 8E83              MOV      DPH,R6
001636 120174            LCALL    ?C?CSTOPTR
001639 0F                INC      R7
00163A 22                RET      
----- FUNCTION ?L?COM0038 (END) -------


----- FUNCTION ?L?COM0035 (BEGIN) -----
00163B 13                RRC      A
00163C FE                MOV      R6,A
00163D EF                MOV      A,R7
00163E 13                RRC      A
00163F FF                MOV      R7,A
001640 EE                MOV      A,R6
001641 64A0              XRL      A,#0A0H
001643 FE                MOV      R6,A
001644 EF                MOV      A,R7
001645 6401              XRL      A,#01H
001647 FF                MOV      R7,A
001648 22                RET      
----- FUNCTION ?L?COM0035 (END) -------


----- FUNCTION app_brushCard (BEGIN) -----
 FILE: 'App\app_brush.c'
   51: UINT8 app_brushCard(void)
   52: {
   53: 	UINT8 Sector;
   54: 	UINT8 CardIndex;
   55:     UINT8 i;
   56: 	for (CardIndex = MEM_CARD; CardIndex <= PWD_CARD; CardIndex++)
001649 900071            MOV      DPTR,#CardIndex
00164C 7401              MOV      A,#01H
00164E F0                MOVX     @DPTR,A
00164F         ?C0004?APP_BRUSH:
   57: 	{
   58: 		if (b_FactorySystem)
00164F 300706            JNB      b_FactorySystem,?C0007?APP_BRUSH
   59: 		{
   60: 			CardIndex = PWD_CARD;
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 75


001652 900071            MOV      DPTR,#CardIndex
001655 7403              MOV      A,#03H
001657 F0                MOVX     @DPTR,A
   61: 		}
001658         ?C0007?APP_BRUSH:
   62: 		if (CardIndex == MEM_CARD)
001658 900071            MOV      DPTR,#CardIndex
00165B E0                MOVX     A,@DPTR
00165C B40108            CJNE     A,#01H,?C0008?APP_BRUSH
   63: 		{
   64: 			Load_Key(&s_System.MGM_Card);
00165F 7B01              MOV      R3,#01H
001661 7A00              MOV      R2,#HIGH s_System
001663 79A1              MOV      R1,#LOW s_System
   65: 		}
001665 801C              SJMP     ?C0051?APP_BRUSH
001667         ?C0008?APP_BRUSH:
   66: 		else if (CardIndex == USER_CARD)
001667 900071            MOV      DPTR,#CardIndex
00166A E0                MOVX     A,@DPTR
00166B B40208            CJNE     A,#02H,?C0010?APP_BRUSH
   67: 		{
   68: 			Load_Key(&s_System.USER_Card);
00166E 7B01              MOV      R3,#01H
001670 7A00              MOV      R2,#HIGH s_System+0AH
001672 79AB              MOV      R1,#LOW s_System+0AH
001674         
   69: 		}
001674 800D              SJMP     ?C0051?APP_BRUSH
001676         ?C0010?APP_BRUSH:
   70: 		else if (CardIndex == PWD_CARD)
001676 900071            MOV      DPTR,#CardIndex
001679 E0                MOVX     A,@DPTR
00167A B40308            CJNE     A,#03H,?C0009?APP_BRUSH
   71: 		{
   72: 			Load_Key(PWD_Card);
00167D 7BFF              MOV      R3,#0FFH
00167F 7A00              MOV      R2,#HIGH PWD_Card
001681 7903              MOV      R1,#LOW PWD_Card
001683         
001683 D1F2              ACALL    _Load_Key
   73: 		}
001685         ?C0009?APP_BRUSH:
   74: 		MIF_Halt();
001685 120713            LCALL    MIF_Halt
   75: 		if (Request(RF_CMD_REQUEST_STD) != FM1702_OK)
001688 7F26              MOV      R7,#026H
00168A 1205C3            LCALL    _Request
00168D EF                MOV      A,R7
00168E 7051              JNZ      ?C0006?APP_BRUSH
   76: 		{
   77: 			continue;
   78: 		}
001690         ?C0013?APP_BRUSH:
   79:         for(i=0; i<2; i++)
001690 E4                CLR      A
001691 900072            MOV      DPTR,#i
001694 F0                MOVX     @DPTR,A
001695         ?C0014?APP_BRUSH:
   80:         {
   81:             if (AntiColl() == FM1702_OK && SelectCard() == FM1702_OK)
001695 120517            LCALL    AntiColl
001698 EF                MOV      A,R7
001699 703A              JNZ      ?C0016?APP_BRUSH
00169B 1206B6            LCALL    SelectCard
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 76


00169E EF                MOV      A,R7
00169F 7034              JNZ      ?C0016?APP_BRUSH
   82:             {
   83:                 if (CardIndex == USER_CARD)     //用户卡验证钱所在扇区
0016A1 900071            MOV      DPTR,#CardIndex
0016A4 E0                MOVX     A,@DPTR
0016A5 B4020A            CJNE     A,#02H,?C0018?APP_BRUSH
   84:                 {
   85:                     Sector = s_System.Sector;
0016A8 9000A7            MOV      DPTR,#s_System+06H
0016AB E0                MOVX     A,@DPTR
0016AC 900070            MOV      DPTR,#Sector
0016AF F0                MOVX     @DPTR,A
   86:                 }
0016B0 8006              SJMP     ?C0019?APP_BRUSH
0016B2         ?C0018?APP_BRUSH:
   87:                 else                            //管理和密码卡验证1扇区
   88:                 {
   89:                     Sector = 1;
0016B2 900070            MOV      DPTR,#Sector
0016B5 7401              MOV      A,#01H
0016B7 F0                MOVX     @DPTR,A
   90:                 }
0016B8         ?C0019?APP_BRUSH:
   91:                 if (Authentication(gCard_UID, Sector, 0x60) == FM1702_OK)
0016B8 7B01              MOV      R3,#01H
0016BA 7A00              MOV      R2,#HIGH gCard_UID
0016BC 79B4              MOV      R1,#LOW gCard_UID
0016BE 900070            MOV      DPTR,#Sector
0016C1 E0                MOVX     A,@DPTR
0016C2 FD                MOV      R5,A
0016C3 900077            MOV      DPTR,#?_Authentication?BYTE+04H
0016C6 7460              MOV      A,#060H
0016C8 F0                MOVX     @DPTR,A
0016C9 120624            LCALL    _Authentication
0016CC EF                MOV      A,R7
0016CD 7006              JNZ      ?C0016?APP_BRUSH
   92:                 {
   93:                     return CardIndex;
0016CF 900071            MOV      DPTR,#CardIndex
0016D2 E0                MOVX     A,@DPTR
0016D3 FF                MOV      R7,A
0016D4 22                RET      
   94:                 }
   95:             }
   96:         }
0016D5         ?C0016?APP_BRUSH:
0016D5 900072            MOV      DPTR,#i
0016D8 E0                MOVX     A,@DPTR
0016D9 04                INC      A
0016DA F0                MOVX     @DPTR,A
0016DB E0                MOVX     A,@DPTR
0016DC C3                CLR      C
0016DD 9402              SUBB     A,#02H
0016DF 40B4              JC       ?C0014?APP_BRUSH
   97: 	}
0016E1         ?C0006?APP_BRUSH:
0016E1 900071            MOV      DPTR,#CardIndex
0016E4 E0                MOVX     A,@DPTR
0016E5 04                INC      A
0016E6 F0                MOVX     @DPTR,A
0016E7 E0                MOVX     A,@DPTR
0016E8 D3                SETB     C
0016E9 9403              SUBB     A,#03H
0016EB 5002              JNC      $ + 4H
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 77


0016ED C14F              AJMP     ?C0004?APP_BRUSH
0016EF         ?C0005?APP_BRUSH:
   98: 	return NONE_CARD;
0016EF 7F00              MOV      R7,#00H
   99: }
0016F1 22                RET      
----- FUNCTION app_brushCard (END) -------


----- FUNCTION _Load_Key (BEGIN) -----
 FILE: 'Driver\mifare.c'
  406: uchar Load_Key(uchar *ramadr)
  407: {
0016F2 900073            MOV      DPTR,#ramadr
0016F5 1207F9            LCALL    ?L?COM0002
  408: 	uchar acktemp,temp[1],i;
  409: 	uchar ucBuff[12];
  410: 	for (i=0;i<6;i++)
;---- Variable 'i' assigned to Register 'R7' ----
0016F8 E4                CLR      A
0016F9 FF                MOV      R7,A
0016FA         ?C0089?MIFARE:
  411: 	{
  412: 		temp[0]=ramadr[i];
0016FA 900073            MOV      DPTR,#ramadr
0016FD 1207E1            LCALL    ?L?COM0004
001700 120F61            LCALL    ?L?COM001F
001703 900077            MOV      DPTR,#temp
001706 F0                MOVX     @DPTR,A
001707 FD                MOV      R5,A
  413: 		ucBuff[2*i]=(((ramadr[i]&0xf0)>>4)|((~ramadr[i])&0xf0));
001708 54F0              ANL      A,#0F0H
00170A C4                SWAP     A
00170B 540F              ANL      A,#0FH
00170D FE                MOV      R6,A
00170E 120F62            LCALL    ?L?COM0020
001711 F4                CPL      A
001712 F167              ACALL    ?L?COM0050
001714 2478              ADD      A,#LOW ucBuff
001716 F582              MOV      DPL,A
001718 E4                CLR      A
001719 3400              ADDC     A,#HIGH ucBuff
00171B F583              MOV      DPH,A
00171D EE                MOV      A,R6
00171E F0                MOVX     @DPTR,A
  414: 		ucBuff[2*i+1]=((temp[0]&0xf)|(~(temp[0]&0xf)<<4));
00171F ED                MOV      A,R5
001720 540F              ANL      A,#0FH
001722 FE                MOV      R6,A
001723 F4                CPL      A
001724 FD                MOV      R5,A
001725 C4                SWAP     A
001726 F167              ACALL    ?L?COM0050
001728 2479              ADD      A,#LOW ucBuff+01H
00172A F582              MOV      DPL,A
00172C E4                CLR      A
00172D 3400              ADDC     A,#HIGH ucBuff+01H
00172F 120FB4            LCALL    ?L?COM0029
001732 B406C5            CJNE     A,#06H,?C0089?MIFARE
001735         ?C0090?MIFARE:
  415: 	}
  416: 	acktemp=Command_Send(LOAD_KEY, ucBuff, 12);
001735 7B01              MOV      R3,#01H
001737 7A00              MOV      R2,#HIGH ucBuff
001739 7978              MOV      R1,#LOW ucBuff
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 78


00173B 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
00173E 740C              MOV      A,#0CH
001740 F0                MOVX     @DPTR,A
001741 7F19              MOV      R7,#019H
001743 12057E            LCALL    _Command_Send
001746 900076            MOV      DPTR,#acktemp
001749 EF                MOV      A,R7
00174A F0                MOVX     @DPTR,A
  417: 	temp[0] = SPIReadOne(SecondaryStatus_Reg);
00174B 7F05              MOV      R7,#05H
00174D 1204E7            LCALL    _SPIReadOne
001750 A3                INC      DPTR
001751 EF                MOV      A,R7
001752 F0                MOVX     @DPTR,A
  418: 	if (temp[0]&0x40)
001753 30E607            JNB      ACC.6,?C0092?MIFARE
  419: 	{
  420: 		temp[0]=0x0;
001756 E4                CLR      A
001757 1204AE            LCALL    ?L?COM0033
  421: 		SPIWriteOne(Command_Reg,temp[0]);
  422: 		return(0);
00175A 7F00              MOV      R7,#00H
00175C 22                RET      
  423: 	}
00175D         ?C0092?MIFARE:
  424: 	temp[0]=0x0;
00175D E4                CLR      A
00175E 900077            MOV      DPTR,#temp
001761 1204AE            LCALL    ?L?COM0033
  425: 	SPIWriteOne(Command_Reg,temp[0]);
  426: 	return(1);
001764 7F01              MOV      R7,#01H
  427: }
001766 22                RET      
----- FUNCTION _Load_Key (END) -------


----- FUNCTION ?L?COM0050 (BEGIN) -----
001767 54F0              ANL      A,#0F0H
001769 4E                ORL      A,R6
00176A FE                MOV      R6,A
00176B EF                MOV      A,R7
00176C 25E0              ADD      A,ACC
00176E 22                RET      
----- FUNCTION ?L?COM0050 (END) -------


----- FUNCTION buzzer_Init (BEGIN) -----
 FILE: 'Driver\buzzer.c'
    8: void buzzer_Init(void)
    9: {
   10:     P3M1 &= ~0x20;      //推挽输出
   11:     P3M0 |= 0x20;
00176F 53B1DF            ANL      P3M1,#0DFH
   12:     P3 &= ~0x20;
001772 43B220            ORL      P3M0,#020H
   13: }
001775 53B0DF            ANL      P3,#0DFH
   14: 
001778 22                RET      
----- FUNCTION buzzer_Init (END) -------


----- FUNCTION len_Init (BEGIN) -----
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 79


 FILE: 'Driver\LED.c'
   17: void len_Init(void)
   18: {
   19:     P1M1 &= ~0xFF;      //推挽输出
   20:     P1M0 |= 0xFF;
001779 759100            MOV      P1M1,#00H
   21:     P2M1 &= ~0xC1;      //推挽输出
00177C 7592FF            MOV      P1M0,#0FFH
   22:     P2M0 |= 0xC1;
00177F 53953E            ANL      P2M1,#03EH
   23:     P5M1 &= ~0x30;      //推挽输出
001782 4396C1            ORL      P2M0,#0C1H
   24:     P5M0 |= 0x30;
001785 53C9CF            ANL      P5M1,#0CFH
   25:     P3M1 &= ~0x40;      //推挽输出
001788 43CA30            ORL      P5M0,#030H
   26:     P3M0 |= 0x40;
00178B 53B1BF            ANL      P3M1,#0BFH
   27: }
00178E 43B240            ORL      P3M0,#040H
   28: 
001791 22                RET      
----- FUNCTION len_Init (END) -------


----- FUNCTION _Write_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  212: void Write_FIFO(uchar *buff,uchar count)
  213: {
001792 900099            MOV      DPTR,#buff
001795 1207F9            LCALL    ?L?COM0002
001798 A3                INC      DPTR
001799 ED                MOV      A,R5
00179A F0                MOVX     @DPTR,A
  214: 	uchar i;
  215: 	if(count == 0)
00179B 6021              JZ       ?C0045?MIFARE
00179D         ?C0044?MIFARE:
  216:         return;
  217: 	for(i=0;i<count;i++)
;---- Variable 'i' assigned to Register 'R4' ----
00179D E4                CLR      A
00179E FC                MOV      R4,A
00179F         ?C0046?MIFARE:
00179F 90009C            MOV      DPTR,#count
0017A2 E0                MOVX     A,@DPTR
0017A3 FF                MOV      R7,A
0017A4 EC                MOV      A,R4
0017A5 C3                CLR      C
0017A6 9F                SUBB     A,R7
0017A7 5015              JNC      ?C0045?MIFARE
  218: 		SPIWriteOne(FIFO_Reg,buff[i]);
0017A9 900099            MOV      DPTR,#buff
0017AC 1207E1            LCALL    ?L?COM0004
0017AF F9                MOV      R1,A
0017B0 8C82              MOV      DPL,R4
0017B2 120F64            LCALL    ?L?COM0021
0017B5 FD                MOV      R5,A
0017B6 7F02              MOV      R7,#02H
0017B8 1204B2            LCALL    _SPIWriteOne
0017BB 0C                INC      R4
0017BC 80E1              SJMP     ?C0046?MIFARE
  219: //		SPIWrite(FIFO_Reg,buff,count);
  220: }
0017BE         ?C0045?MIFARE:
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 80


0017BE 22                RET      
----- FUNCTION _Write_FIFO (END) -------


----- FUNCTION _Read_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  532: uchar Read_Block(uchar *buff,uchar index)
  533: {
0017BF 90007B            MOV      DPTR,#buff
0017C2 1207F9            LCALL    ?L?COM0002
;---- Variable 'index' assigned to Register 'R4' ----
0017C5 AC05              MOV      R4,AR5
  534:     uchar ucCmdLine[2],ucResult;
  535:     SPIWriteOne(ChannelRedundancy_Reg,0x0F);
0017C7 1207D0            LCALL    ?L?COM004B
  536:     ucCmdLine[0] = RF_CMD_READ;
0017CA A3                INC      DPTR
0017CB 7430              MOV      A,#030H
0017CD F0                MOVX     @DPTR,A
  537:     ucCmdLine[1] = index;
0017CE A3                INC      DPTR
0017CF EC                MOV      A,R4
0017D0 F0                MOVX     @DPTR,A
  538:     ucResult = Command_Send(Transceive,ucCmdLine,2);
0017D1 7B01              MOV      R3,#01H
0017D3 7A00              MOV      R2,#HIGH ucCmdLine
0017D5 797E              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
0017D7 1207C4            LCALL    ?L?COM0019
0017DA 7003              JNZ      ?C0108?MIFARE
  539:     if(ucResult == FALSE)
  540:         return FM1702_NOTAGERR;   //无卡
0017DC 7F01              MOV      R7,#01H
0017DE 22                RET      
0017DF         ?C0108?MIFARE:
  541:     ucResult = SPIReadOne(ErrorFlag_Reg);
0017DF 12073E            LCALL    ?L?COM0027
0017E2 30E103            JNB      ACC.1,?C0110?MIFARE
0017E5 7F05              MOV      R7,#05H
0017E7 22                RET      
0017E8         ?C0110?MIFARE:
  542: 	if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
  543: 	if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
0017E8 EF                MOV      A,R7
0017E9 30E203            JNB      ACC.2,?C0111?MIFARE
0017EC 7F14              MOV      R7,#014H
0017EE 22                RET      
0017EF         ?C0111?MIFARE:
  544: 	if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
0017EF EF                MOV      A,R7
0017F0 30E303            JNB      ACC.3,?C0112?MIFARE
0017F3 7F02              MOV      R7,#02H
0017F5 22                RET      
0017F6         ?C0112?MIFARE:
  545:     ucResult = Read_FIFO(buff);
0017F6 90007B            MOV      DPTR,#buff
0017F9 1207E1            LCALL    ?L?COM0004
0017FC F9                MOV      R1,A
0017FD 120783            LCALL    _Read_FIFO
  546:     if(ucResult!=0x10)
001800 EF                MOV      A,R7
001801 6410              XRL      A,#010H
001803 7F00              MOV      R7,#00H
001805 6002              JZ       ?C0113?MIFARE
  547:         return FM1702_BYTECOUNTERR;
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 81


001807 7F0C              MOV      R7,#0CH
001809         ?C0113?MIFARE:
  548:     else
  549:         return FM1702_OK;
  550: }
001809 22                RET      
----- FUNCTION _Read_Block (END) -------


----- FUNCTION _Write_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  566: uchar Write_Block(uchar *buff,uchar index)
  567: {
00180A 1207F6            LCALL    ?L?COM0001
;---- Variable 'index' assigned to Register 'R4' ----
00180D AC05              MOV      R4,AR5
  568:     uchar ucCmdLine[2],ucResult,ucData[16];
  569:     SPIWriteOne(ChannelRedundancy_Reg,0x07);   /* Note: this line is for 1702, different from RC500*/
00180F 7D07              MOV      R5,#07H
001811 7F22              MOV      R7,#022H
001813 1204B2            LCALL    _SPIWriteOne
  570:     ucCmdLine[0] = RF_CMD_WRITE;
001816 A3                INC      DPTR
001817 74A0              MOV      A,#0A0H
001819 F0                MOVX     @DPTR,A
  571:     ucCmdLine[1] = index;
00181A A3                INC      DPTR
00181B EC                MOV      A,R4
00181C F0                MOVX     @DPTR,A
  572:     ucResult = Command_Send(Transceive,ucCmdLine,2);
00181D 7B01              MOV      R3,#01H
00181F 7A00              MOV      R2,#HIGH ucCmdLine
001821 7982              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
001823 1207C4            LCALL    ?L?COM0019
001826 7003              JNZ      ?C0115?MIFARE
  573:     if(ucResult == FALSE)
  574:         return FM1702_NOTAGERR;
001828 7F01              MOV      R7,#01H
00182A 22                RET      
00182B         ?C0115?MIFARE:
  575:     ucResult = Read_FIFO(ucData);
00182B 7B01              MOV      R3,#01H
00182D 7A00              MOV      R2,#HIGH ucData
00182F 7984              MOV      R1,#LOW ucData
001831 120783            LCALL    _Read_FIFO
  576:     if(ucResult == 0)
001834 EF                MOV      A,R7
001835 7003              JNZ      ?C0117?MIFARE
  577:         return FM1702_BYTECOUNTERR;
001837 7F0C              MOV      R7,#0CH
001839 22                RET      
00183A         ?C0117?MIFARE:
  578:     switch(ucData[0])
00183A 900084            MOV      DPTR,#ucData
00183D E0                MOVX     A,@DPTR
00183E 14                DEC      A
00183F 6015              JZ       ?C0122?MIFARE
001841 24FD              ADD      A,#0FDH
001843 600E              JZ       ?C0120?MIFARE
001845 14                DEC      A
001846 6011              JZ       ?C0123?MIFARE
001848 24FB              ADD      A,#0FBH
00184A 6013              JZ       ?C0118?MIFARE
00184C 240A              ADD      A,#0AH
LX51 LINKER/LOCATER V4.66.1.0                                                         03/05/2016  21:15:44  PAGE 82


00184E 700C              JNZ      ?C0124?MIFARE
  579:     {
  580: 	    case 0x00:	return(FM1702_NOTAUTHERR);	
001850         ?C0119?MIFARE:
001850 7F0A              MOV      R7,#0AH
001852 22                RET      
  581: 	    case 0x04:	return(FM1702_EMPTY);
001853         ?C0120?MIFARE:
001853 7F03              MOV      R7,#03H
001855 22                RET      
  582: 	    case 0x0a:	break;                   //正常
  583: 	    case 0x01:	return(FM1702_CRCERR);
001856         ?C0122?MIFARE:
001856 7F02              MOV      R7,#02H
001858 22                RET      
  584: 	    case 0x05:	return(FM1702_PARITYERR); 
001859         ?C0123?MIFARE:
001859 7F05              MOV      R7,#05H
00185B 22                RET      
  585: 	    default:	return(FM1702_WRITEERR);
00185C         ?C0124?MIFARE:
00185C 7F0F              MOV      R7,#0FH
00185E 22                RET      
  586:     }
00185F         ?C0118?MIFARE:
  587:     ucResult = Command_Send(Transceive,buff,16);
00185F 1207DE            LCALL    ?L?COM0003
001862 F9                MOV      R1,A
001863 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
001866 7410              MOV      A,#010H
001868 1207C9            LCALL    ?L?COM001A
00186B B40103            CJNE     A,#01H,?C0125?MIFARE
  588:     if(ucResult == TRUE)
  589:         return FM1702_OK;
00186E 7F00              MOV      R7,#00H
001870 22                RET      
001871         ?C0125?MIFARE:
  590:     else
  591:     {
  592:         ucResult = SPIReadOne(ErrorFlag_Reg);
001871 12073E            LCALL    ?L?COM0027
001874 30E103            JNB      ACC.1,?C0127?MIFARE
001877 7F05              MOV      R7,#05H
001879 22                RET      
00187A         ?C0127?MIFARE:
  593: 	    if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
  594: 	    else if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
00187A EF                MOV      A,R7
00187B 30E203            JNB      ACC.2,?C0129?MIFARE
00187E 7F14              MOV      R7,#014H
001880 22                RET      
001881         ?C0129?MIFARE:
  595: 	    else if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
001881 EF                MOV      A,R7
001882 7F0F              MOV      R7,#0FH
001884 30E302            JNB      ACC.3,?C0131?MIFARE
001887 7F02              MOV      R7,#02H
001889         ?C0131?MIFARE:
  596:         else return FM1702_WRITEERR;
  597:     }
  598: }
001889 22                RET      
----- FUNCTION _Write_Block (END) -------


