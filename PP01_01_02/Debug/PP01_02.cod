LX51 LINKER/LOCATER V4.66.1.0                                                           12/12/2015  19:50:21  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  .\Debug\PP01_02 (SYS_DELAY)


----- FUNCTION sys_gpioInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   23: void sys_gpioInit(void)
   24: {
   25: }
   26: 
000009 22                RET      
----- FUNCTION sys_gpioInit (END) -------


----- FUNCTION sys_taskHandler10ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   66: void sys_taskHandler10ms(void)            //10ms interrupt task
   67: {
   68: }
   69: 
00000A 22                RET      
----- FUNCTION sys_taskHandler10ms (END) -------


00000B 02100A            LJMP     0100AH
----- FUNCTION sys_taskHandler1s (BEGIN) -----
 FILE: 'System\sys_task.c'
   75: void sys_taskHandler1s(void)              //1s interrupt task
   76: {
   77: }
   78: 
000021 22                RET      
----- FUNCTION sys_taskHandler1s (END) -------


----- FUNCTION hwa_eepromInit (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   33: void hwa_eepromInit(void)
   34: {
   35: }
   36: 
000022 22                RET      
----- FUNCTION hwa_eepromInit (END) -------


000023 02121F            LJMP     0121FH
----- FUNCTION _sys_delayus (BEGIN) -----
 FILE: 'System\sys_delay.c'
    5: void sys_delayus(UINT16 xus)
    6: {
;---- Variable 'xus' assigned to Register 'R6/R7' ----
    7:     while(xus--);
000463         ?C0001?SYS_DELAY:
    8: }
000463 EF                MOV      A,R7
000464 1F                DEC      R7
000465 AC06              MOV      R4,AR6
000467 7001              JNZ      ?C0012?SYS_DELAY
000469 1E                DEC      R6
00046A         ?C0012?SYS_DELAY:
00046A 4C                ORL      A,R4
00046B 70F6              JNZ      ?C0001?SYS_DELAY
    9: 
00046D 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 2


----- FUNCTION _sys_delayus (END) -------


----- FUNCTION Init_FM1702 (BEGIN) -----
 FILE: 'Driver\mifare.c'
  104: void Init_FM1702(void)
  105: {
  106: 	uchar temp;
  107: 	uint i;
  108: 	RC500SCK = 0;
00046E C2A1              CLR      RC500SCK
  109: 	RC500SO = 1;
000470 D2A2              SETB     RC500SO
  110: 	RC500SI = 1;
000472 D2A4              SETB     RC500SI
  111: 	RC500RST = 1;	// FM1702复位 
000474 D2A5              SETB     RC500RST
  112: 	sys_delayms(2);
000476 7F02              MOV      R7,#02H
000478 7E00              MOV      R6,#00H
00047A 12080A            LCALL    _sys_delayms
  113: 	RC500RST = 0;	
00047D C2A5              CLR      RC500RST
  114: 	//进入复位阶段，需要512个FM1702SL的时钟周期，约38us
  115: 	sys_delayus(100); 
00047F 7F64              MOV      R7,#064H
000481 7E00              MOV      R6,#00H
000483 9163              ACALL    _sys_delayus
000485         ?C0024?MIFARE:
  116: 	//进入初始化阶段，需要128个时钟周期，约10us
  117: 	do{ 		// 等待Command = 0,FM1702复位成功
  118: 		temp = SPIReadOne(Command_Reg);	 //(Command_Reg<<1)|0x80 = 0x82
;---- Variable 'temp' assigned to Register 'R4' ----
000485 F18C              ACALL    ?L?COM002F
000487 70FC              JNZ      ?C0024?MIFARE
  119: 	}while(temp!=0);
  120: ///////////////////////////////////////////////////////////////////////////////////
  121: 	SPIWriteOne(Page_Reg,0x80);	//初始化SPI接口
000489 7D80              MOV      R5,#080H
00048B FF                MOV      R7,A
00048C 91C8              ACALL    _SPIWriteOne
  122: 	for(i = 0; i < 0x1fff; i++) // 延时
;---- Variable 'i' assigned to Register 'R2/R3' ----
00048E E4                CLR      A
00048F FB                MOV      R3,A
000490 FA                MOV      R2,A
000491         ?C0025?MIFARE:
  123: 	{
  124: 		temp = SPIReadOne(Command_Reg);
000491 F18C              ACALL    ?L?COM002F
000493 7006              JNZ      ?C0027?MIFARE
  125: 		if(temp == 0x00)	//SPI初始化成功
  126: 		{
  127: 			SPIWriteOne(Page_Reg,0);//可以使用SPI接口
000495 FD                MOV      R5,A
000496 FF                MOV      R7,A
000497 91C8              ACALL    _SPIWriteOne
  128: 			break;
000499 800B              SJMP     ?C0026?MIFARE
  129: 		}
  130: 	}
00049B         ?C0027?MIFARE:
00049B 0B                INC      R3
00049C BB0001            CJNE     R3,#00H,?C0138?MIFARE
00049F 0A                INC      R2
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 3


0004A0         ?C0138?MIFARE:
0004A0 BA1FEE            CJNE     R2,#01FH,?C0025?MIFARE
0004A3 BBFFEB            CJNE     R3,#0FFH,?C0025?MIFARE
0004A6         ?C0026?MIFARE:
  131: ////////////////////////////////////////////////////////////////////////////////////
  132: 	SPIWriteOne(InterruptEn_Reg,0x7F);	//  禁止所有中断请求（最高位置0）
0004A6 7D7F              MOV      R5,#07FH
0004A8 7F06              MOV      R7,#06H
0004AA 91C8              ACALL    _SPIWriteOne
  133: 	SPIWriteOne(InterruptRq_Reg,0x7F);	// 禁止所有中断请求标识置0（最高位置0）
0004AC 7D7F              MOV      R5,#07FH
0004AE 7F07              MOV      R7,#07H
0004B0 91C8              ACALL    _SPIWriteOne
  134: 	
  135: 	//设置调制器的输入源为内部编码器, 并且设置TX1和TX2
  136: 	SPIWriteOne(TxControl_Reg,0x5B); 		// 发送控制寄存器 
0004B2 7D5B              MOV      R5,#05BH
0004B4 7F11              MOV      R7,#011H
0004B6 91C8              ACALL    _SPIWriteOne
  137: 	SPIWriteOne(RxControl2_Reg,0x01);
0004B8 7D01              MOV      R5,#01H
0004BA 7F1E              MOV      R7,#01EH
0004BC 91C8              ACALL    _SPIWriteOne
  138: 	SPIWriteOne(RxWait_Reg,5);
0004BE 7D05              MOV      R5,#05H
0004C0 7F21              MOV      R7,#021H
0004C2 8004              SJMP     _SPIWriteOne
----- FUNCTION Init_FM1702 (END) -------


----- FUNCTION ?L?COM0031 (BEGIN) -----
0004C4 F0                MOVX     @DPTR,A
0004C5 FD                MOV      R5,A
0004C6 7F01              MOV      R7,#01H
----- FUNCTION _SPIWriteOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   65: void SPIWriteOne(uchar SpiAddress,uchar wData)
   66: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
;---- Variable 'wData' assigned to Register 'R5' ----
   67: 	uchar i;
   68: 	SpiAddress = SpiAddress<<1;
0004C8 EF                MOV      A,R7
0004C9 25E0              ADD      A,ACC
   69: 	SpiAddress = SpiAddress & 0x7E;
0004CB 547E              ANL      A,#07EH
0004CD FF                MOV      R7,A
   70: 
   71: 	//传输地址 从高位到低位传输
   72: 	RC500CS = 0;
0004CE C2A3              CLR      RC500CS
   73: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
0004D0 E4                CLR      A
0004D1 FE                MOV      R6,A
0004D2         ?C0011?MIFARE:
   74: 	{
   75: 		if(SpiAddress&0x80)
0004D2 EF                MOV      A,R7
0004D3 30E704            JNB      ACC.7,?C0014?MIFARE
   76: 			RC500SO = 1;
0004D6 D2A2              SETB     RC500SO
0004D8 8002              SJMP     ?C0015?MIFARE
0004DA         ?C0014?MIFARE:
   77: 		else
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 4


   78: 			RC500SO = 0;
0004DA C2A2              CLR      RC500SO
0004DC         ?C0015?MIFARE:
   79: 		RC500SCK = 1;
0004DC F1FB              ACALL    ?L?COM003D
0004DE B408F1            CJNE     A,#08H,?C0011?MIFARE
0004E1         ?C0012?MIFARE:
   80: 		SpiAddress = SpiAddress<<1;
   81: 		RC500SCK = 0;
   82: 	}
   83: 	//传输数据，从高位开始
   84: 	for (i=0;i<8;i++)
0004E1 E4                CLR      A
0004E2 FE                MOV      R6,A
0004E3         ?C0016?MIFARE:
   85: 	{
   86: 		if(wData & 0x80)
0004E3 ED                MOV      A,R5
0004E4 30E704            JNB      ACC.7,?C0019?MIFARE
   87: 			RC500SO = 1;
0004E7 D2A2              SETB     RC500SO
0004E9 8002              SJMP     ?C0020?MIFARE
0004EB         ?C0019?MIFARE:
   88: 		else
   89: 			RC500SO = 0;
0004EB C2A2              CLR      RC500SO
0004ED         ?C0020?MIFARE:
   90: 		RC500SCK = 1;
0004ED D2A1              SETB     RC500SCK
   91: 		wData = wData<<1;
0004EF ED                MOV      A,R5
0004F0 25E0              ADD      A,ACC
0004F2 FD                MOV      R5,A
   92: 		RC500SCK = 0;
0004F3 C2A1              CLR      RC500SCK
   93: 	}
0004F5 0E                INC      R6
0004F6 EE                MOV      A,R6
0004F7 B408E9            CJNE     A,#08H,?C0016?MIFARE
0004FA         ?C0017?MIFARE:
   94: 	RC500CS = 1;
0004FA D2A3              SETB     RC500CS
   95: }
0004FC 22                RET      
----- FUNCTION _SPIWriteOne (END) -------


----- FUNCTION _SPIReadOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   24: uchar SPIReadOne(uchar SpiAddress)
   25: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
   26: 	uchar i,rdata; 
   27: 	//地址字节最高位置1，表示为读数据，最低位固定为0，中间6位为地址
   28: 	SpiAddress = SpiAddress<<1;
0004FD EF                MOV      A,R7
0004FE 25E0              ADD      A,ACC
   29: 	SpiAddress = SpiAddress | 0x80;
000500 4480              ORL      A,#080H
000502 FF                MOV      R7,A
   30: 	//传输地址 从高位到低位传输
   31: 	RC500CS = 0;
000503 C2A3              CLR      RC500CS
   32: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 5


000505 E4                CLR      A
000506 FE                MOV      R6,A
000507         ?C0001?MIFARE:
   33: 	{
   34: 		if(SpiAddress&0x80)
000507 EF                MOV      A,R7
000508 30E704            JNB      ACC.7,?C0004?MIFARE
   35: 			RC500SO = 1;
00050B D2A2              SETB     RC500SO
00050D 8002              SJMP     ?C0005?MIFARE
00050F         ?C0004?MIFARE:
   36: 		else
   37: 			RC500SO = 0;
00050F C2A2              CLR      RC500SO
000511         ?C0005?MIFARE:
   38: 		RC500SCK = 1;
000511 F1FB              ACALL    ?L?COM003D
000513 B408F1            CJNE     A,#08H,?C0001?MIFARE
000516         ?C0002?MIFARE:
   39: 		SpiAddress = SpiAddress<<1;
   40: 		RC500SCK = 0;
   41: 	}
   42: 	
   43: 	//接收数据
   44: 	rdata = 0;
;---- Variable 'rdata' assigned to Register 'R7' ----
000516 E4                CLR      A
000517 FF                MOV      R7,A
   45: 	for (i=0;i<8;i++)
000518 FE                MOV      R6,A
000519         ?C0006?MIFARE:
   46: 	{
   47: 		RC500SCK = 1;
000519 D2A1              SETB     RC500SCK
   48: 		rdata = rdata<<1;
00051B EF                MOV      A,R7
00051C 25E0              ADD      A,ACC
00051E FF                MOV      R7,A
   49: 		if (RC500SI)
00051F 30A401            JNB      RC500SI,?C0009?MIFARE
   50: 			rdata+= 1;
000522 0F                INC      R7
000523         ?C0009?MIFARE:
   51: 		RC500SCK = 0;
000523 C2A1              CLR      RC500SCK
   52: 	}
000525 0E                INC      R6
000526 EE                MOV      A,R6
000527 B408EF            CJNE     A,#08H,?C0006?MIFARE
00052A         ?C0007?MIFARE:
   53: 	RC500CS=1;
00052A D2A3              SETB     RC500CS
   54: 	return (rdata);
   55: }
00052C 22                RET      
----- FUNCTION _SPIReadOne (END) -------


----- FUNCTION AntiColl (BEGIN) -----
 FILE: 'Driver\mifare.c'
  278: uchar AntiColl(void)
  279: {
  280: 	
  281: 	uchar	temp,i;
  282: 
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 6


  283: 	//选择TX1、TX2的发射天线阻抗
  284: 	SPIWriteOne(CwConductance_Reg,0x3f);
00052D F15D              ACALL    ?L?COM0019
00052F 7493              MOV      A,#093H
000531 F0                MOVX     @DPTR,A
  285: 	//选择数据校验种类和模式
  286: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  287: 	
  288: 	gBuff[0] = RF_CMD_ANTICOL;
  289: 	gBuff[1] = 0x20;
000532 A3                INC      DPTR
000533 7420              MOV      A,#020H
000535 D133              ACALL    ?L?COM0009
000537 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
00053A 7402              MOV      A,#02H
00053C F0                MOVX     @DPTR,A
00053D 7F1E              MOV      R7,#01EH
00053F B195              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R5' ----
000541 AD07              MOV      R5,AR7
  290: 	temp = Command_Send(Transceive,gBuff,2);
  291: 	if (temp==0)
000543 ED                MOV      A,R5
000544 7003              JNZ      ?C0062?MIFARE
  292: 	{
  293: 		return(FM1702_NOTAGERR);
000546 7F01              MOV      R7,#01H
000548 22                RET      
  294: 	}
000549         ?C0062?MIFARE:
  295: 
  296: 	temp = SPIReadOne(FIFOLength_Reg);
000549 F194              ACALL    ?L?COM0034
00054B 7003              JNZ      ?C0064?MIFARE
  297: 	if (temp == 0)
  298: 	{
  299: 		return FM1702_BYTECOUNTERR;
00054D 7F0C              MOV      R7,#0CH
00054F 22                RET      
  300: 	}
000550         ?C0064?MIFARE:
  301: 
  302: 	for(i=0;i<temp;i++)
;---- Variable 'i' assigned to Register 'R4' ----
000550 E4                CLR      A
000551 FC                MOV      R4,A
000552         ?C0065?MIFARE:
000552 EC                MOV      A,R4
000553 C3                CLR      C
000554 9D                SUBB     A,R5
000555 500B              JNC      ?C0066?MIFARE
  303: 	{
  304: 		gBuff[i] = SPIReadOne(FIFO_Reg);
000557 7F02              MOV      R7,#02H
000559 91FD              ACALL    _SPIReadOne
00055B F19C              ACALL    ?L?COM002C
00055D EF                MOV      A,R7
00055E F0                MOVX     @DPTR,A
  305: 	}
00055F 0C                INC      R4
000560 80F0              SJMP     ?C0065?MIFARE
000562         ?C0066?MIFARE:
  306: 	temp = SPIReadOne(ErrorFlag_Reg);	// 判断接数据是否有冲突位
000562 7F0A              MOV      R7,#0AH
000564 F196              ACALL    ?L?COM0035
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 7


000566 5401              ANL      A,#01H
000568 FD                MOV      R5,A
  307: 	temp = temp & 0x01;
  308: 	if (temp == 0x00)
000569 7027              JNZ      ?C0068?MIFARE
  309: 	{
  310: 		for (i=0;i<5;i++)
00056B FC                MOV      R4,A
00056C         ?C0069?MIFARE:
  311: 			temp^=gBuff[i];
00056C F19C              ACALL    ?L?COM002C
00056E E0                MOVX     A,@DPTR
00056F 6D                XRL      A,R5
000570 FD                MOV      R5,A
000571 0C                INC      R4
000572 EC                MOV      A,R4
000573 B405F6            CJNE     A,#05H,?C0069?MIFARE
000576         ?C0070?MIFARE:
  312: 		if (temp)
000576 ED                MOV      A,R5
000577 6003              JZ       ?C0072?MIFARE
  313: 			return(FM1702_SERNRERR);
000579 7F08              MOV      R7,#08H
00057B 22                RET      
00057C         ?C0072?MIFARE:
  314:         for (i=0;i<5;i++)
00057C E4                CLR      A
00057D FC                MOV      R4,A
00057E         ?C0073?MIFARE:
  315:         {
  316:             gCard_UID[i]=gBuff[i];
00057E F19C              ACALL    ?L?COM002C
000580 E0                MOVX     A,@DPTR
000581 FF                MOV      R7,A
000582 74B4              MOV      A,#LOW gCard_UID
000584 2C                ADD      A,R4
000585 1211E9            LCALL    ?L?COM000F
000588 EF                MOV      A,R7
000589 F0                MOVX     @DPTR,A
  317:         }
00058A 0C                INC      R4
00058B EC                MOV      A,R4
00058C B405EF            CJNE     A,#05H,?C0073?MIFARE
00058F         ?C0074?MIFARE:
  318: 		return(FM1702_OK);
00058F 7F00              MOV      R7,#00H
000591 22                RET      
  319: 	}
000592         ?C0068?MIFARE:
  320: 	else //有冲突位
  321: 		return FM1702_SERNRERR;
000592 7F08              MOV      R7,#08H
  322: }
000594 22                RET      
----- FUNCTION AntiColl (END) -------


----- FUNCTION _Command_Send (BEGIN) -----
 FILE: 'Driver\mifare.c'
  251: uchar Command_Send(uchar Comm_Set,uchar *buff, uchar count)
  252: {
000595 900094            MOV      DPTR,#Comm_Set
000598 EF                MOV      A,R7
000599 F0                MOVX     @DPTR,A
;---- Variable 'buff' assigned to Register 'R1/R2/R3' ----
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 8


  253:     uchar ucResult1,ucResult2,i;
  254:     SPIWriteOne(Command_Reg,0x00);
00059A E4                CLR      A
00059B FD                MOV      R5,A
00059C 7F01              MOV      R7,#01H
00059E 91C8              ACALL    _SPIWriteOne
  255:     if(Clear_FIFO()==FALSE)
0005A0 F16D              ACALL    Clear_FIFO
0005A2 EF                MOV      A,R7
0005A3 7002              JNZ      ?C0055?MIFARE
  256:         return FALSE;
0005A5 FF                MOV      R7,A
0005A6 22                RET      
0005A7         ?C0055?MIFARE:
  257:     Write_FIFO(buff,count);
0005A7 900098            MOV      DPTR,#count
0005AA E0                MOVX     A,@DPTR
0005AB FD                MOV      R5,A
0005AC 12170B            LCALL    _Write_FIFO
  258: 	SPIWriteOne(Command_Reg,Comm_Set);
0005AF 900094            MOV      DPTR,#Comm_Set
0005B2 E0                MOVX     A,@DPTR
0005B3 FD                MOV      R5,A
0005B4 7F01              MOV      R7,#01H
0005B6 91C8              ACALL    _SPIWriteOne
  259: 	for (i=0;i<0xA0;i++)
;---- Variable 'i' assigned to Register 'R5' ----
0005B8 E4                CLR      A
0005B9 FD                MOV      R5,A
0005BA         ?C0057?MIFARE:
  260: 	{
  261:         ucResult1 = SPIReadOne(Command_Reg);
0005BA 7F01              MOV      R7,#01H
0005BC 91FD              ACALL    _SPIReadOne
;---- Variable 'ucResult1' assigned to Register 'R4' ----
0005BE AC07              MOV      R4,AR7
  262:         ucResult2 = SPIReadOne(InterruptRq_Reg) & 0x80;
0005C0 7F07              MOV      R7,#07H
0005C2 91FD              ACALL    _SPIReadOne
0005C4 EF                MOV      A,R7
0005C5 5480              ANL      A,#080H
0005C7 FF                MOV      R7,A
;---- Variable 'ucResult2' assigned to Register 'R7' ----
  263:         if(ucResult1 == 0 || ucResult2 ==0x80)
0005C8 EC                MOV      A,R4
0005C9 6004              JZ       ?C0061?MIFARE
0005CB EF                MOV      A,R7
0005CC B48003            CJNE     A,#080H,?C0059?MIFARE
0005CF         ?C0061?MIFARE:
  264:             return TRUE;
0005CF 7F01              MOV      R7,#01H
0005D1 22                RET      
  265: 	}
0005D2         ?C0059?MIFARE:
0005D2 0D                INC      R5
0005D3 ED                MOV      A,R5
0005D4 B4A0E3            CJNE     A,#0A0H,?C0057?MIFARE
0005D7         ?C0058?MIFARE:
  266: 	return FALSE;
0005D7 7F00              MOV      R7,#00H
  267: }
0005D9 22                RET      
----- FUNCTION _Command_Send (END) -------


LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 9


----- FUNCTION _Request (BEGIN) -----
 FILE: 'Driver\mifare.c'
  152: uchar Request(uchar mode)
  153: {
;---- Variable 'mode' assigned to Register 'R4' ----
0005DA AC07              MOV      R4,AR7
  154: 	
  155: 	uchar temp;
  156: 	
  157: 	//选择TX1、TX2的发射天线阻抗
  158: 	SPIWriteOne(CwConductance_Reg,0x3f);
0005DC F1E4              ACALL    ?L?COM0049
  159: 	//选择数据校验种类和模式
  160: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
0005DE 7D03              MOV      R5,#03H
0005E0 7F22              MOV      R7,#022H
0005E2 91C8              ACALL    _SPIWriteOne
  161: 	//调整面向bit的格式
  162: 	SPIWriteOne(BitFraming_Reg,0x07);
0005E4 7D07              MOV      R5,#07H
0005E6 7F0F              MOV      R7,#0FH
0005E8 F167              ACALL    ?L?COM001B
0005EA EC                MOV      A,R4
0005EB F0                MOVX     @DPTR,A
  163: 	gBuff[0] = mode;		//Request模式选择 
  164: 	temp = SPIReadOne(Control_Reg);
0005EC 7F09              MOV      R7,#09H
0005EE 91FD              ACALL    _SPIReadOne
;---- Variable 'temp' assigned to Register 'R7' ----
  165: 	temp = temp & (0xf7);	
0005F0 EF                MOV      A,R7
0005F1 54F7              ANL      A,#0F7H
  166: 	SPIWriteOne(Control_Reg,temp);			//Control reset value is 00
0005F3 FD                MOV      R5,A
0005F4 7F09              MOV      R7,#09H
0005F6 91C8              ACALL    _SPIWriteOne
  167: 	temp = Command_Send(Transceive, gBuff,1 );   //发送接收命令 
0005F8 D134              ACALL    ?L?COM000A
0005FA 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
0005FD 7401              MOV      A,#01H
0005FF F1AC              ACALL    ?L?COM001F
000601 7003              JNZ      ?C0030?MIFARE
  168: 	if(temp==0 )
  169: 	{
  170: 		return FM1702_NOTAGERR;
000603 7F01              MOV      R7,#01H
000605 22                RET      
  171: 	}
000606         ?C0030?MIFARE:
  172: 
  173: 	temp=Read_FIFO(gBuff);		//从FIFO中读取应答信息到gBuff中 
000606 D134              ACALL    ?L?COM000A
000608 F1B3              ACALL    _Read_FIFO
  174: 	// 判断应答信号是否正确 
  175: 	// 2  	Mifare Pro 卡
  176: 	//4 		Mifare One 卡
  177: 	if((gBuff[0] == 0x04) & (gBuff[1] == 0x0) &(temp == 2))
00060A 9000BA            MOV      DPTR,#gBuff+01H
00060D E0                MOVX     A,@DPTR
00060E 7E00              MOV      R6,#00H
000610 7002              JNZ      ?C0033?MIFARE
000612 7E01              MOV      R6,#01H
000614         ?C0033?MIFARE:
000614         ?C0034?MIFARE:
000614 9000B9            MOV      DPTR,#gBuff
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 10


000617 E0                MOVX     A,@DPTR
000618 7D00              MOV      R5,#00H
00061A B40402            CJNE     A,#04H,?C0035?MIFARE
00061D 7D01              MOV      R5,#01H
00061F         ?C0035?MIFARE:
00061F         ?C0036?MIFARE:
00061F ED                MOV      A,R5
000620 5E                ANL      A,R6
000621 FE                MOV      R6,A
000622 EF                MOV      A,R7
000623 7F00              MOV      R7,#00H
000625 B40202            CJNE     A,#02H,?C0037?MIFARE
000628 7F01              MOV      R7,#01H
00062A         ?C0037?MIFARE:
00062A         ?C0038?MIFARE:
00062A EF                MOV      A,R7
00062B 5E                ANL      A,R6
00062C 7F15              MOV      R7,#015H
00062E 6002              JZ       ?C0032?MIFARE
  178: 	{
  179: 			return FM1702_OK;
000630 7F00              MOV      R7,#00H
  180: 	}
000632         ?C0032?MIFARE:
  181: 	return FM1702_REQERR;
  182: }
000632 22                RET      
----- FUNCTION _Request (END) -------


----- FUNCTION ?L?COM0009 (BEGIN) -----
000633 F0                MOVX     @DPTR,A
000634         ?L?COM000A:
000634 7B01              MOV      R3,#01H
000636 7A00              MOV      R2,#HIGH gBuff
000638 79B9              MOV      R1,#LOW gBuff
00063A 22                RET      
----- FUNCTION ?L?COM0009 (END) -------


----- FUNCTION _Authentication (BEGIN) -----
 FILE: 'Driver\mifare.c'
  472: uchar Authentication(uchar *UID, uchar SecNR, uchar mode)
  473: {
00063B 900073            MOV      DPTR,#UID
00063E 120EA0            LCALL    ?L?COM0004
;---- Variable 'SecNR' assigned to Register 'R4' ----
000641 AC05              MOV      R4,AR5
  474: 	uchar i;
  475: 	uchar temp, temp1;
  476: 
  477: 	if(SecNR >= 16)
000643 EC                MOV      A,R4
000644 C3                CLR      C
000645 9410              SUBB     A,#010H
000647 4004              JC       ?C0094?MIFARE
  478: 		SecNR = SecNR % 16;
000649 EC                MOV      A,R4
00064A 540F              ANL      A,#0FH
00064C FC                MOV      R4,A
00064D         ?C0094?MIFARE:
  479: 	
  480: 	//选择数据校验种类和模式
  481: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
00064D F1EA              ACALL    ?L?COM0048
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 11


  482: 	gBuff[0] = mode;
00064F 900077            MOV      DPTR,#mode
000652 E0                MOVX     A,@DPTR
000653 9000B9            MOV      DPTR,#gBuff
000656 F0                MOVX     @DPTR,A
  483: 	gBuff[1] = SecNR * 4 + 3;
000657 EC                MOV      A,R4
000658 25E0              ADD      A,ACC
00065A 25E0              ADD      A,ACC
00065C 2403              ADD      A,#03H
00065E A3                INC      DPTR
00065F F0                MOVX     @DPTR,A
  484: 	for(i = 0; i < 4; i++)
;---- Variable 'i' assigned to Register 'R7' ----
000660 E4                CLR      A
000661 FF                MOV      R7,A
000662         ?C0095?MIFARE:
  485: 	{
  486: 		gBuff[2 + i] = UID[i];
000662 900073            MOV      DPTR,#UID
000665 F1F3              ACALL    ?L?COM0002
000667 120ED9            LCALL    ?L?COM0016
00066A 120FEA            LCALL    ?L?COM0025
00066D B404F2            CJNE     A,#04H,?C0095?MIFARE
000670         ?C0096?MIFARE:
  487: 	}
  488: 
  489: 	temp = Command_Send(Authent1, gBuff,6 );
000670 D134              ACALL    ?L?COM000A
000672 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
000675 7406              MOV      A,#06H
000677 F0                MOVX     @DPTR,A
000678 7F0C              MOV      R7,#0CH
00067A B195              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  490: 	if(temp==0)
00067C EF                MOV      A,R7
00067D 7003              JNZ      ?C0098?MIFARE
  491: 	{
  492: 		return 0x99;
00067F 7F99              MOV      R7,#099H
000681 22                RET      
  493: 	}
000682         ?C0098?MIFARE:
  494: 
  495: 	temp = SPIReadOne(ErrorFlag_Reg);   
000682 F157              ACALL    ?L?COM0024
000684 30E103            JNB      ACC.1,?C0100?MIFARE
000687 7F05              MOV      R7,#05H
000689 22                RET      
00068A         ?C0100?MIFARE:
  496: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  497: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
00068A EF                MOV      A,R7
00068B 30E203            JNB      ACC.2,?C0101?MIFARE
00068E 7F14              MOV      R7,#014H
000690 22                RET      
000691         ?C0101?MIFARE:
  498: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
000691 EF                MOV      A,R7
000692 30E303            JNB      ACC.3,?C0102?MIFARE
000695 7F02              MOV      R7,#02H
000697 22                RET      
000698         ?C0102?MIFARE:
  499: 	temp = Command_Send(Authent2, gBuff,0 );	
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 12


000698 D134              ACALL    ?L?COM000A
00069A E4                CLR      A
00069B 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
00069E F0                MOVX     @DPTR,A
00069F 7F14              MOV      R7,#014H
0006A1 B195              ACALL    _Command_Send
  500: 	if(temp ==0)
0006A3 EF                MOV      A,R7
0006A4 7003              JNZ      ?C0103?MIFARE
  501: 	{
  502: 		return 0x88;
0006A6 7F88              MOV      R7,#088H
0006A8 22                RET      
  503: 	}
0006A9         ?C0103?MIFARE:
  504: 
  505: 	temp = SPIReadOne(ErrorFlag_Reg);
0006A9 F157              ACALL    ?L?COM0024
0006AB 30E103            JNB      ACC.1,?C0104?MIFARE
0006AE 7F05              MOV      R7,#05H
0006B0 22                RET      
0006B1         ?C0104?MIFARE:
  506: //	Show(temp,0);
  507: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  508: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
0006B1 EF                MOV      A,R7
0006B2 30E203            JNB      ACC.2,?C0105?MIFARE
0006B5 7F14              MOV      R7,#014H
0006B7 22                RET      
0006B8         ?C0105?MIFARE:
  509: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
0006B8 EF                MOV      A,R7
0006B9 30E303            JNB      ACC.3,?C0106?MIFARE
0006BC 7F02              MOV      R7,#02H
0006BE 22                RET      
0006BF         ?C0106?MIFARE:
  510: 	temp1 = SPIReadOne(Control_Reg);
0006BF 7F09              MOV      R7,#09H
0006C1 91FD              ACALL    _SPIReadOne
;---- Variable 'temp1' assigned to Register 'R7' ----
  511: 	temp1 = temp1 & 0x08;	
0006C3 EF                MOV      A,R7
0006C4 5408              ANL      A,#08H
  512: 	if(temp1 == 0x08)
0006C6 7F04              MOV      R7,#04H
0006C8 B40802            CJNE     A,#08H,?C0107?MIFARE
  513: 	{
  514: 		return FM1702_OK;
0006CB 7F00              MOV      R7,#00H
  515: 	}
0006CD         ?C0107?MIFARE:
  516: 
  517: 	return FM1702_AUTHERR;
  518: }
0006CD 22                RET      
----- FUNCTION _Authentication (END) -------


----- FUNCTION SelectCard (BEGIN) -----
 FILE: 'Driver\mifare.c'
  335: uchar SelectCard(void)
  336: {
  337: 	
  338: 	uchar	temp, i;
  339: 	
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 13


  340: 	//选择TX1、TX2的发射天线阻抗
  341: 	SPIWriteOne(CwConductance_Reg,0x3f);
0006CE F1E4              ACALL    ?L?COM0049
  342: 	//选择数据校验种类和模式
  343: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
0006D0 7D0F              MOV      R5,#0FH
0006D2 F165              ACALL    ?L?COM001A
0006D4 7493              MOV      A,#093H
0006D6 F0                MOVX     @DPTR,A
  344: 
  345: 	gBuff[0] = RF_CMD_SELECT;
  346: 	gBuff[1] = 0x70;
0006D7 A3                INC      DPTR
0006D8 7470              MOV      A,#070H
0006DA F0                MOVX     @DPTR,A
  347: 	for(i = 0; i < 5; i++)
;---- Variable 'i' assigned to Register 'R7' ----
0006DB E4                CLR      A
0006DC FF                MOV      R7,A
0006DD         ?C0077?MIFARE:
  348: 	{
  349: 		gBuff[i + 2] = gCard_UID[i];
0006DD 74B4              MOV      A,#LOW gCard_UID
0006DF 2F                ADD      A,R7
0006E0 1211E9            LCALL    ?L?COM000F
0006E3 E0                MOVX     A,@DPTR
0006E4 120FEA            LCALL    ?L?COM0025
0006E7 B405F3            CJNE     A,#05H,?C0077?MIFARE
0006EA         ?C0078?MIFARE:
  350: 	}
  351: 	temp = Command_Send(Transceive, gBuff,7 );
0006EA D134              ACALL    ?L?COM000A
0006EC 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
0006EF 7407              MOV      A,#07H
;---- Variable 'temp' assigned to Register 'R7' ----
0006F1 F1AC              ACALL    ?L?COM001F
0006F3 7003              JNZ      ?C0080?MIFARE
  352: 	if(temp==0 )
  353: 	{
  354: 		return(FM1702_NOTAGERR);
0006F5 7F01              MOV      R7,#01H
0006F7 22                RET      
  355: 	}
0006F8         ?C0080?MIFARE:
  356: 	else
  357: 	{
  358: 		temp = SPIReadOne(ErrorFlag_Reg);
0006F8 F157              ACALL    ?L?COM0024
0006FA 30E103            JNB      ACC.1,?C0083?MIFARE
0006FD 7F05              MOV      R7,#05H
0006FF 22                RET      
000700         ?C0083?MIFARE:
  359: 		if((temp & 0x02) == 0x02) return(FM1702_PARITYERR);
  360: 		if((temp & 0x04) == 0x04) return(FM1702_FRAMINGERR);
000700 EF                MOV      A,R7
000701 30E203            JNB      ACC.2,?C0084?MIFARE
000704 7F14              MOV      R7,#014H
000706 22                RET      
000707         ?C0084?MIFARE:
  361: 		if((temp & 0x08) == 0x08) return(FM1702_CRCERR);
000707 EF                MOV      A,R7
000708 30E303            JNB      ACC.3,?C0085?MIFARE
00070B 7F02              MOV      R7,#02H
00070D 22                RET      
00070E         ?C0085?MIFARE:
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 14


  362: 		temp = SPIReadOne(FIFOLength_Reg);
00070E 7F04              MOV      R7,#04H
000710 91FD              ACALL    _SPIReadOne
  363: 		if(temp != 1) return(FM1702_BYTECOUNTERR);
000712 EF                MOV      A,R7
000713 6401              XRL      A,#01H
000715 6003              JZ       ?C0086?MIFARE
000717 7F0C              MOV      R7,#0CH
000719 22                RET      
00071A         ?C0086?MIFARE:
  364: //		SPIRead(FIFO_Reg,gBuff,temp);	//从FIFO中读取应答信息
  365: 		gBuff[0] = SPIReadOne(FIFO_Reg);
00071A 7F02              MOV      R7,#02H
00071C 91FD              ACALL    _SPIReadOne
00071E 9000B9            MOV      DPTR,#gBuff
000721 EF                MOV      A,R7
000722 F0                MOVX     @DPTR,A
  366: 		if(gBuff[0]==0x08) 	  	// 判断应答信号是否正确 
000723 BF0803            CJNE     R7,#08H,?C0087?MIFARE
  367: 			return(FM1702_OK);
000726 7F00              MOV      R7,#00H
000728 22                RET      
000729         ?C0087?MIFARE:
  368: 		else
  369: 			return(FM1702_SELERR);
000729 7F16              MOV      R7,#016H
  370: 	}
  371: }
00072B 22                RET      
----- FUNCTION SelectCard (END) -------


----- FUNCTION MIF_Halt (BEGIN) -----
 FILE: 'Driver\mifare.c'
  610: uchar MIF_Halt(void)
  611: {
  612: 	uchar	temp;
  613: 	//选择TX1、TX2的发射天线阻抗
  614: 	SPIWriteOne(CwConductance_Reg,0x3f);
00072C F15D              ACALL    ?L?COM0019
00072E 7450              MOV      A,#050H
000730 F0                MOVX     @DPTR,A
  615: 	//选择数据校验种类和模式
  616: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  617: 	*gBuff = RF_CMD_HALT;
  618: 	*(gBuff + 1) = 0x00;
000731 E4                CLR      A
000732 A3                INC      DPTR
000733 D133              ACALL    ?L?COM0009
000735 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
000738 7402              MOV      A,#02H
00073A F0                MOVX     @DPTR,A
00073B 7F1A              MOV      R7,#01AH
00073D B195              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  619: 	temp = Command_Send(Transmit, gBuff, 2);//发送FIFO缓存地址
  620: 	if(temp == TRUE)
00073F EF                MOV      A,R7
000740 B40103            CJNE     A,#01H,?C0133?MIFARE
  621: 		return FM1702_OK;
000743 7F00              MOV      R7,#00H
000745 22                RET      
000746         ?C0133?MIFARE:
  622: 	else
  623: 	{
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 15


  624: 		temp = SPIReadOne(ErrorFlag_Reg);
000746 F157              ACALL    ?L?COM0024
000748 30E103            JNB      ACC.1,?C0136?MIFARE
  625: 		if((temp & 0x02) == 0x02)
  626: 		{
  627: 			return(FM1702_PARITYERR);
00074B 7F05              MOV      R7,#05H
00074D 22                RET      
  628: 		}
00074E         ?C0136?MIFARE:
  629: 
  630: 		if((temp & 0x04) == 0x04)
00074E EF                MOV      A,R7
00074F 7F01              MOV      R7,#01H
000751 30E202            JNB      ACC.2,?C0137?MIFARE
  631: 		{
  632: 			return(FM1702_FRAMINGERR);
000754 7F14              MOV      R7,#014H
  633: 		}
000756         ?C0137?MIFARE:
  634: 		return(FM1702_NOTAGERR);
  635: 	}
  636: }
000756 22                RET      
----- FUNCTION MIF_Halt (END) -------


----- FUNCTION ?L?COM0024 (BEGIN) -----
000757 7F0A              MOV      R7,#0AH
000759 91FD              ACALL    _SPIReadOne
00075B EF                MOV      A,R7
00075C 22                RET      
----- FUNCTION ?L?COM0024 (END) -------


----- FUNCTION ?L?COM0019 (BEGIN) -----
00075D 7D3F              MOV      R5,#03FH
00075F 7F12              MOV      R7,#012H
000761 91C8              ACALL    _SPIWriteOne
000763 7D03              MOV      R5,#03H
000765         ?L?COM001A:
000765 7F22              MOV      R7,#022H
000767         ?L?COM001B:
000767 91C8              ACALL    _SPIWriteOne
000769 9000B9            MOV      DPTR,#gBuff
00076C 22                RET      
----- FUNCTION ?L?COM0019 (END) -------


----- FUNCTION Clear_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  190: uchar Clear_FIFO(void)
  191: {
  192:     uchar ucResult,i;
  193:     ucResult = SPIReadOne(Control_Reg);
00076D 7F09              MOV      R7,#09H
;---- Variable 'ucResult' assigned to Register 'R4' ----
00076F F18E              ACALL    ?L?COM0030
000771 4401              ORL      A,#01H
000773 FC                MOV      R4,A
  194:     ucResult |=0x01;
  195:     SPIWriteOne(Control_Reg,ucResult);
000774 FD                MOV      R5,A
000775 7F09              MOV      R7,#09H
000777 91C8              ACALL    _SPIWriteOne
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 16


  196:     for(i=0;i<0xA0;i++)
;---- Variable 'i' assigned to Register 'R5' ----
000779 E4                CLR      A
00077A FD                MOV      R5,A
00077B         ?C0039?MIFARE:
  197:     {
  198:         ucResult = SPIReadOne(FIFOLength_Reg);
00077B 7F04              MOV      R7,#04H
00077D F18E              ACALL    ?L?COM0030
00077F 7003              JNZ      ?C0041?MIFARE
  199:         if(ucResult == 0)
  200:             return TRUE;
000781 7F01              MOV      R7,#01H
000783 22                RET      
  201:     }
000784         ?C0041?MIFARE:
000784 0D                INC      R5
000785 ED                MOV      A,R5
000786 B4A0F2            CJNE     A,#0A0H,?C0039?MIFARE
000789         ?C0040?MIFARE:
  202:     return FALSE;
000789 7F00              MOV      R7,#00H
  203: }
00078B 22                RET      
----- FUNCTION Clear_FIFO (END) -------


----- FUNCTION ?L?COM002F (BEGIN) -----
00078C 7F01              MOV      R7,#01H
00078E         ?L?COM0030:
00078E 91FD              ACALL    _SPIReadOne
000790 AC07              MOV      R4,AR7
000792 EC                MOV      A,R4
000793 22                RET      
----- FUNCTION ?L?COM002F (END) -------


----- FUNCTION ?L?COM0034 (BEGIN) -----
000794 7F04              MOV      R7,#04H
000796         ?L?COM0035:
000796 91FD              ACALL    _SPIReadOne
000798 AD07              MOV      R5,AR7
00079A ED                MOV      A,R5
00079B 22                RET      
----- FUNCTION ?L?COM0034 (END) -------


----- FUNCTION ?L?COM002C (BEGIN) -----
00079C 74B9              MOV      A,#LOW gBuff
00079E 2C                ADD      A,R4
00079F F582              MOV      DPL,A
0007A1 E4                CLR      A
0007A2 3400              ADDC     A,#HIGH gBuff
0007A4 F583              MOV      DPH,A
0007A6 22                RET      
----- FUNCTION ?L?COM002C (END) -------


----- FUNCTION ?L?COM001E (BEGIN) -----
0007A7 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
0007AA 7402              MOV      A,#02H
0007AC         ?L?COM001F:
0007AC F0                MOVX     @DPTR,A
0007AD 7F1E              MOV      R7,#01EH
0007AF B195              ACALL    _Command_Send
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 17


0007B1 EF                MOV      A,R7
0007B2 22                RET      
----- FUNCTION ?L?COM001E (END) -------


----- FUNCTION _Read_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  228: uchar Read_FIFO(uchar *buff)
  229: {
0007B3 900094            MOV      DPTR,#buff
0007B6 120EA0            LCALL    ?L?COM0004
  230: 	uchar	ucResult,i;
  231: 	ucResult = SPIReadOne(FIFOLength_Reg);
;---- Variable 'ucResult' assigned to Register 'R5' ----
0007B9 F194              ACALL    ?L?COM0034
0007BB 6005              JZ       ?C0050?MIFARE
0007BD D3                SETB     C
0007BE 9410              SUBB     A,#010H
0007C0 4003              JC       ?C0049?MIFARE
0007C2         ?C0050?MIFARE:
  232: 	if(ucResult == 0 || ucResult>16)
  233: 		return 0;
0007C2 7F00              MOV      R7,#00H
0007C4 22                RET      
0007C5         ?C0049?MIFARE:
  234: 	for(i=0;i<ucResult;i++)
;---- Variable 'i' assigned to Register 'R4' ----
0007C5 E4                CLR      A
0007C6 FC                MOV      R4,A
0007C7         ?C0052?MIFARE:
0007C7 EC                MOV      A,R4
0007C8 C3                CLR      C
0007C9 9D                SUBB     A,R5
0007CA 5015              JNC      ?C0053?MIFARE
  235: 	{
  236: 		buff[i] = SPIReadOne(FIFO_Reg);
0007CC 7F02              MOV      R7,#02H
0007CE 91FD              ACALL    _SPIReadOne
0007D0 900094            MOV      DPTR,#buff
0007D3 F1F3              ACALL    ?L?COM0002
0007D5 F9                MOV      R1,A
0007D6 8C82              MOV      DPL,R4
0007D8 758300            MOV      DPH,#00H
0007DB EF                MOV      A,R7
0007DC 3174              ACALL    ?C?CSTOPTR
  237: 	}
0007DE 0C                INC      R4
0007DF 80E6              SJMP     ?C0052?MIFARE
0007E1         ?C0053?MIFARE:
  238: 
  239: 	return ucResult;
0007E1 AF05              MOV      R7,AR5
  240: }
0007E3 22                RET      
----- FUNCTION _Read_FIFO (END) -------


----- FUNCTION ?L?COM0049 (BEGIN) -----
0007E4 7D3F              MOV      R5,#03FH
0007E6 7F12              MOV      R7,#012H
0007E8 81C8              AJMP     _SPIWriteOne
----- FUNCTION ?L?COM0049 (END) -------


----- FUNCTION ?L?COM0048 (BEGIN) -----
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 18


0007EA 7D0F              MOV      R5,#0FH
0007EC 7F22              MOV      R7,#022H
0007EE 81C8              AJMP     _SPIWriteOne
----- FUNCTION ?L?COM0048 (END) -------


----- FUNCTION ?L?COM0001 (BEGIN) -----
0007F0 90007F            MOV      DPTR,#buff
0007F3         ?L?COM0002:
0007F3 E0                MOVX     A,@DPTR
0007F4 FB                MOV      R3,A
0007F5 A3                INC      DPTR
0007F6 E0                MOVX     A,@DPTR
0007F7 FA                MOV      R2,A
0007F8 A3                INC      DPTR
0007F9 E0                MOVX     A,@DPTR
0007FA 22                RET      
----- FUNCTION ?L?COM0001 (END) -------


----- FUNCTION ?L?COM003D (BEGIN) -----
0007FB D2A1              SETB     RC500SCK
0007FD EF                MOV      A,R7
0007FE 25E0              ADD      A,ACC
000800 FF                MOV      R7,A
000801 C2A1              CLR      RC500SCK
000803 0E                INC      R6
000804 EE                MOV      A,R6
000805 22                RET      
----- FUNCTION ?L?COM003D (END) -------


----- FUNCTION ?L?COM003A (BEGIN) -----
000806 7FF4              MOV      R7,#0F4H
000808 7E01              MOV      R6,#01H
----- FUNCTION _sys_delayms (BEGIN) -----
 FILE: 'System\sys_delay.c'
   10: void sys_delayms(UINT16 xms)
   11: {   
;---- Variable 'xms' assigned to Register 'R6/R7' ----
   12:     UINT8 i, j;
00080A         ?C0004?SYS_DELAY:
   13: 	while(xms--)
00080A EF                MOV      A,R7
00080B 1F                DEC      R7
00080C AC06              MOV      R4,AR6
00080E 7001              JNZ      ?C0013?SYS_DELAY
000810 1E                DEC      R6
000811         ?C0013?SYS_DELAY:
000811 4C                ORL      A,R4
000812 600D              JZ       ?C0011?SYS_DELAY
   14:     {
   15:     	WDT_CONTR |= 0x35;
000814 43C135            ORL      WDT_CONTR,#035H
   16:         i = 22;
;---- Variable 'i' assigned to Register 'R5' ----
000817 7D16              MOV      R5,#016H
   17:         j = 128;
;---- Variable 'j' assigned to Register 'R4' ----
000819 7C80              MOV      R4,#080H
   18:         do
   19:         {
00081B         ?C0009?SYS_DELAY:
   20:             while (--j);
00081B DCFE              DJNZ     R4,?C0009?SYS_DELAY
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 19


00081D         ?C0010?SYS_DELAY:
   21:         } while (--i);
00081D         ?C0006?SYS_DELAY:
00081D DDFC              DJNZ     R5,?C0009?SYS_DELAY
   22:     }
00081F 80E9              SJMP     ?C0004?SYS_DELAY
   22: }
000821         ?C0011?SYS_DELAY:
000821 22                RET      
----- FUNCTION _sys_delayms (END) -------


----- FUNCTION app_Show (BEGIN) -----
 FILE: 'App\app_brush.c'
   18: void app_Show(void)
   19: {
   20:     sys_delayms(500);
   21:     led_ShowNumber(s_System.Money/100, s_System.Money%100, 1<<3);
000822 1106              ACALL    ?L?COM003A
   22:     gLedBuf[0] = 12;
000824 51D5              ACALL    ?L?COM0012
000826 C006              PUSH     AR6
000828 C007              PUSH     AR7
00082A 51C1              ACALL    ?L?COM0029
00082C 1201A8            LCALL    ?C?UIDIV
00082F D007              POP      AR7
000831 D006              POP      AR6
000833 7B08              MOV      R3,#08H
000835 514B              ACALL    _led_ShowNumber
   23:     gLedBuf[1] = 12;
000837 F1DF              ACALL    ?L?COM003F
   24:     gLedBuf[2] = 12;
   25:     sys_delayms(500);
000839 1106              ACALL    ?L?COM003A
   26:     led_ShowNumber(MoneySum/100/100, MoneySum/100%100, 0);
00083B 121803            LCALL    ?L?COM000D
00083E 120299            LCALL    ?C?ULDIV
000841 C006              PUSH     AR6
000843 C007              PUSH     AR7
000845 121803            LCALL    ?L?COM000D
000848 120299            LCALL    ?C?ULDIV
00084B AF03              MOV      R7,AR3
00084D AD07              MOV      R5,AR7
00084F D007              POP      AR7
000851 D006              POP      AR6
000853 E4                CLR      A
000854 FB                MOV      R3,A
000855 514B              ACALL    _led_ShowNumber
   27:     sys_delayms(500);
000857 1106              ACALL    ?L?COM003A
;----                  JMP      Led_ShowZero
   28:     Led_ShowZero();
----- FUNCTION app_Show (END) -------


----- FUNCTION Led_ShowZero (BEGIN) -----
 FILE: 'Driver\LED.c'
  114: void Led_ShowZero(void)
  115: {
  116:     gLedBuf[0] = 12;
  117:     gLedBuf[1] = 12;
000859 F1DF              ACALL    ?L?COM003F
  118:     gLedBuf[2] = 12;
  119:     gLedBuf[3] = 12;
00085B A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 20


00085C F0                MOVX     @DPTR,A
  120:     gLedBuf[4] = 12;
00085D A3                INC      DPTR
00085E F0                MOVX     @DPTR,A
  121:     gLedBuf[5] = 0;
00085F E4                CLR      A
000860 A3                INC      DPTR
000861 F0                MOVX     @DPTR,A
  122:     gShowDot = 0;
000862 9000D0            MOV      DPTR,#gShowDot
000865 F0                MOVX     @DPTR,A
  123: }
000866 22                RET      
----- FUNCTION Led_ShowZero (END) -------


----- FUNCTION app_brushCycle1s (BEGIN) -----
 FILE: 'App\app_brush.c'
  106: void app_brushCycle1s(void)
  107: {
  108:     switch (app_brushCard())
  109:     {
000867 12162C            LCALL    app_brushCard
00086A EF                MOV      A,R7
00086B 24FE              ADD      A,#0FEH
00086D 7002              JNZ      $ + 4H
00086F 217B              AJMP     ?C0038?APP_BRUSH
000871 14                DEC      A
000872 7002              JNZ      $ + 4H
000874 2116              AJMP     ?C0032?APP_BRUSH
000876 2402              ADD      A,#02H
000878 6002              JZ       $ + 4H
00087A 413D              AJMP     ?C0022?APP_BRUSH
  110:         case MEM_CARD:
  111:             if(hwa_mifareReadBlock(gBuff,4))
00087C         ?C0023?APP_BRUSH:
  112:             {
00087C 120634            LCALL    ?L?COM000A
00087F 7D04              MOV      R5,#04H
000881 71C4              ACALL    _hwa_mifareReadBlock
000883 4002              JC       $ + 4H
000885 413D              AJMP     ?C0022?APP_BRUSH
  113:                 if(u8_FirstBrushCardDly)
  114:                 {
000887 9000D9            MOV      DPTR,#u8_FirstBrushCardDly
00088A E0                MOVX     A,@DPTR
00088B 6066              JZ       ?C0025?APP_BRUSH
  115:                     if(gBuff[0]==0x01 && gBuff[1]==0x0A)
  116:                     {
00088D 9000B9            MOV      DPTR,#gBuff
000890 E0                MOVX     A,@DPTR
000891 FF                MOV      R7,A
000892 B40128            CJNE     A,#01H,?C0026?APP_BRUSH
000895 A3                INC      DPTR
000896 E0                MOVX     A,@DPTR
000897 B40A23            CJNE     A,#0AH,?C0026?APP_BRUSH
  117:                         s_System.Money += 10;
  118: 						if (s_System.Money > 500)
00089A 9000B3            MOV      DPTR,#s_System+012H
00089D E0                MOVX     A,@DPTR
00089E 240A              ADD      A,#0AH
0008A0 F0                MOVX     @DPTR,A
0008A1 9000B2            MOV      DPTR,#s_System+011H
0008A4 E0                MOVX     A,@DPTR
0008A5 3400              ADDC     A,#00H
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 21


0008A7 F0                MOVX     @DPTR,A
  119: 						{
0008A8 D3                SETB     C
0008A9 A3                INC      DPTR
0008AA E0                MOVX     A,@DPTR
0008AB 94F4              SUBB     A,#0F4H
0008AD 9000B2            MOV      DPTR,#s_System+011H
0008B0 E0                MOVX     A,@DPTR
0008B1 9401              SUBB     A,#01H
0008B3 403A              JC       ?C0028?APP_BRUSH
  120: 							s_System.Money = 10;
  121: 						}
0008B5 E4                CLR      A
0008B6 F0                MOVX     @DPTR,A
0008B7 A3                INC      DPTR
0008B8 740A              MOV      A,#0AH
0008BA F0                MOVX     @DPTR,A
  122:                     }
  123:                     else if(gBuff[0]==0xFA && gBuff[1]==0x01)
0008BB 8032              SJMP     ?C0028?APP_BRUSH
0008BD         ?C0026?APP_BRUSH:
  124:                     {
0008BD EF                MOV      A,R7
0008BE B4FA2E            CJNE     A,#0FAH,?C0028?APP_BRUSH
0008C1 9000BA            MOV      DPTR,#gBuff+01H
0008C4 E0                MOVX     A,@DPTR
0008C5 B40127            CJNE     A,#01H,?C0028?APP_BRUSH
  125: 						if(s_System.Money > 10)
  126: 						{
0008C8 D3                SETB     C
0008C9 9000B3            MOV      DPTR,#s_System+012H
0008CC E0                MOVX     A,@DPTR
0008CD 940A              SUBB     A,#0AH
0008CF 9000B2            MOV      DPTR,#s_System+011H
0008D2 E0                MOVX     A,@DPTR
0008D3 9400              SUBB     A,#00H
0008D5 400E              JC       ?C0030?APP_BRUSH
  127:                         	s_System.Money -= 10;
  128: 						}
0008D7 A3                INC      DPTR
0008D8 E0                MOVX     A,@DPTR
0008D9 24F6              ADD      A,#0F6H
0008DB F0                MOVX     @DPTR,A
0008DC 9000B2            MOV      DPTR,#s_System+011H
0008DF E0                MOVX     A,@DPTR
0008E0 34FF              ADDC     A,#0FFH
0008E2 F0                MOVX     @DPTR,A
  129:                         else
0008E3 800A              SJMP     ?C0028?APP_BRUSH
0008E5         ?C0030?APP_BRUSH:
  130:                         {
  131:                             s_System.Money = 500;
0008E5 9000B2            MOV      DPTR,#s_System+011H
0008E8 7401              MOV      A,#01H
0008EA F0                MOVX     @DPTR,A
0008EB A3                INC      DPTR
0008EC 74F4              MOV      A,#0F4H
0008EE F0                MOVX     @DPTR,A
  132:                         }
  133:                     }
0008EF         ?C0028?APP_BRUSH:
  134:                     app_configWrite(SYSTEM_SETTING_SECTOR);
0008EF E4                CLR      A
0008F0 FF                MOV      R7,A
0008F1 51E7              ACALL    _app_configWrite
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 22


  135:                 }
0008F3         ?C0025?APP_BRUSH:
  136:                 u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
0008F3 9000D9            MOV      DPTR,#u8_FirstBrushCardDly
0008F6 7403              MOV      A,#03H
0008F8 F0                MOVX     @DPTR,A
  137:                 buzzer_SoundNumber(1);
0008F9 7F01              MOV      R7,#01H
0008FB 51AA              ACALL    _buzzer_SoundNumber
  138:                 led_ShowNumber(s_System.Money/100, s_System.Money%100, 1<<3);
0008FD 51D5              ACALL    ?L?COM0012
0008FF C006              PUSH     AR6
000901 C007              PUSH     AR7
000903 51C1              ACALL    ?L?COM0029
000905 1201A8            LCALL    ?C?UIDIV
000908 D007              POP      AR7
00090A D006              POP      AR6
00090C 7B08              MOV      R3,#08H
00090E 514B              ACALL    _led_ShowNumber
  139:                 sys_delayms(1000);
000910 7FE8              MOV      R7,#0E8H
000912 7E03              MOV      R6,#03H
  140:             }
  141:             break;
000914 4135              AJMP     ?C0052?APP_BRUSH
  142:             
  143:         case PWD_CARD:                                 //从初始卡中读取管理卡密码，并储存至E2
000916         ?C0032?APP_BRUSH:
  144:             if(hwa_mifareReadBlock(gBuff,4))       //读取管理卡密码
000916 120634            LCALL    ?L?COM000A
000919 7D04              MOV      R5,#04H
00091B 71C4              ACALL    _hwa_mifareReadBlock
00091D 4002              JC       $ + 4H
00091F 413D              AJMP     ?C0022?APP_BRUSH
  145:             {
  146:                 memcpy(&s_System, gBuff, 16);
000921 78A1              MOV      R0,#LOW s_System
000923 7C00              MOV      R4,#HIGH s_System
000925 7D01              MOV      R5,#01H
000927 120634            LCALL    ?L?COM000A
00092A F153              ACALL    ?L?COM0037
  147: 
  148: 	            if (hwa_mifareReadBlock(gBuff, 5))			//读取管理卡和用户卡密码以及扇区
00092C 120634            LCALL    ?L?COM000A
00092F 7D05              MOV      R5,#05H
000931 71C4              ACALL    _hwa_mifareReadBlock
000933 4002              JC       $ + 4H
000935 413D              AJMP     ?C0022?APP_BRUSH
  149: 	            {
  150: 	                if(gBuff[0] == 0x01)
000937 9000B9            MOV      DPTR,#gBuff
00093A E0                MOVX     A,@DPTR
00093B B40108            CJNE     A,#01H,?C0035?APP_BRUSH
  151: 	                {
  152: 	                    s_System.RecoveryOldCard = 1;
00093E 9000B1            MOV      DPTR,#s_System+010H
000941 7401              MOV      A,#01H
000943 F0                MOVX     @DPTR,A
  153: 	                }
000944 8005              SJMP     ?C0037?APP_BRUSH
000946         ?C0035?APP_BRUSH:
  154: 	                else
  155: 	                {
  156: 	                    s_System.RecoveryOldCard = 0;
000946 E4                CLR      A
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 23


000947 9000B1            MOV      DPTR,#s_System+010H
00094A F0                MOVX     @DPTR,A
  157: 	                }
  158: 	            }
  159: 	            else
  160: 	            {
  161: 	                break;
  162: 	            }
00094B         ?C0037?APP_BRUSH:
  163:                 app_configWrite(SYSTEM_SETTING_SECTOR);
00094B E4                CLR      A
00094C FF                MOV      R7,A
00094D 51E7              ACALL    _app_configWrite
  164:                 Led_ShowZero();
00094F 1159              ACALL    Led_ShowZero
  165:                 gLedBuf[0] = s_System.Sector/10;
000951 9000A7            MOV      DPTR,#s_System+06H
000954 E0                MOVX     A,@DPTR
000955 FF                MOV      R7,A
000956 75F00A            MOV      B,#0AH
000959 84                DIV      AB
00095A 9000C9            MOV      DPTR,#gLedBuf
00095D 51CA              ACALL    ?L?COM0022
  166:                 gLedBuf[1] = s_System.Sector%10;
  167:                 gLedBuf[4] = s_System.PulseWidth/10;
00095F 9000A8            MOV      DPTR,#s_System+07H
000962 E0                MOVX     A,@DPTR
000963 FF                MOV      R7,A
000964 75F00A            MOV      B,#0AH
000967 84                DIV      AB
000968 9000CD            MOV      DPTR,#gLedBuf+04H
00096B 51CA              ACALL    ?L?COM0022
  168:                 gLedBuf[5] = s_System.PulseWidth%10;
  169:                 buzzer_SoundNumber(1);
00096D 7F01              MOV      R7,#01H
00096F 51AA              ACALL    _buzzer_SoundNumber
  170:                 sys_delayms(1000);
000971 7FE8              MOV      R7,#0E8H
000973 7E03              MOV      R6,#03H
000975 110A              ACALL    _sys_delayms
  171:                 b_FactorySystem = FALSE;
000977 C207              CLR      b_FactorySystem
  172:             }
  173:             break;
000979 413D              AJMP     ?C0022?APP_BRUSH
  174:             
  175:         case USER_CARD:
00097B         ?C0038?APP_BRUSH:
  176: //                memset(gBuff, 0x00, sizeof(gBuff));
  177: //                pMoney->money = 20000;										//充钱
  178: //                if (hwa_mifareWriteSector(gBuff, s_System.Sector))
  179: //                {
  180: //                    buzzer_SoundNumber(1);
  181: //                }
  182: //                break;
  183:             if(hwa_mifareReadSector(gBuff, s_System.Sector))
00097B 120634            LCALL    ?L?COM000A
00097E 9000A7            MOV      DPTR,#s_System+06H
000981 E0                MOVX     A,@DPTR
000982 FD                MOV      R5,A
000983 71F0              ACALL    _hwa_mifareReadSector
000985 4002              JC       $ + 4H
000987 413D              AJMP     ?C0022?APP_BRUSH
  184:             {
  185:                 if (pMoney->money >= s_System.Money)//确保余额充足
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 24


000989 91BE              ACALL    ?L?COM002E
00098B FF                MOV      R7,A
00098C AEF0              MOV      R6,B
00098E 9000B2            MOV      DPTR,#s_System+011H
000991 12120B            LCALL    ?L?COM0047
000994 9E                SUBB     A,R6
000995 4002              JC       $ + 4H
000997 4139              AJMP     ?C0040?APP_BRUSH
  186:                 {
  187:                     pMoney->money -= s_System.Money;
000999 C3                CLR      C
00099A EF                MOV      A,R7
00099B 9D                SUBB     A,R5
00099C FF                MOV      R7,A
00099D EE                MOV      A,R6
00099E 9C                SUBB     A,R4
00099F 8FF0              MOV      B,R7
0009A1 12023E            LCALL    ?C?ISTPTR
  188:                     if(hwa_mifareWriteSector(gBuff, s_System.Sector))
0009A4 120634            LCALL    ?L?COM000A
0009A7 9000A7            MOV      DPTR,#s_System+06H
0009AA E0                MOVX     A,@DPTR
0009AB FD                MOV      R5,A
0009AC B1E2              ACALL    _hwa_mifareWriteSector
0009AE 4002              JC       $ + 4H
0009B0 413D              AJMP     ?C0022?APP_BRUSH
  189:                     {
  190:                     	led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
0009B2 91BE              ACALL    ?L?COM002E
0009B4 FB                MOV      R3,A
0009B5 AAF0              MOV      R2,B
0009B7 51DD              ACALL    ?L?COM0013
0009B9 C006              PUSH     AR6
0009BB C007              PUSH     AR7
0009BD 51C1              ACALL    ?L?COM0029
0009BF 1201A8            LCALL    ?C?UIDIV
0009C2 D007              POP      AR7
0009C4 D006              POP      AR6
0009C6 7B08              MOV      R3,#08H
0009C8 514B              ACALL    _led_ShowNumber
  191:                         MoneySum += s_System.Money;
0009CA 90009D            MOV      DPTR,#MoneySum
0009CD E0                MOVX     A,@DPTR
0009CE F8                MOV      R0,A
0009CF A3                INC      DPTR
0009D0 E0                MOVX     A,@DPTR
0009D1 F9                MOV      R1,A
0009D2 A3                INC      DPTR
0009D3 E0                MOVX     A,@DPTR
0009D4 FA                MOV      R2,A
0009D5 A3                INC      DPTR
0009D6 E0                MOVX     A,@DPTR
0009D7 FB                MOV      R3,A
0009D8 9000B2            MOV      DPTR,#s_System+011H
0009DB E0                MOVX     A,@DPTR
0009DC FE                MOV      R6,A
0009DD A3                INC      DPTR
0009DE E0                MOVX     A,@DPTR
0009DF FF                MOV      R7,A
0009E0 E4                CLR      A
0009E1 FC                MOV      R4,A
0009E2 FD                MOV      R5,A
0009E3 EB                MOV      A,R3
0009E4 2F                ADD      A,R7
0009E5 FF                MOV      R7,A
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 25


0009E6 EA                MOV      A,R2
0009E7 3E                ADDC     A,R6
0009E8 FE                MOV      R6,A
0009E9 ED                MOV      A,R5
0009EA 39                ADDC     A,R1
0009EB FD                MOV      R5,A
0009EC EC                MOV      A,R4
0009ED 38                ADDC     A,R0
0009EE FC                MOV      R4,A
0009EF 90009D            MOV      DPTR,#MoneySum
0009F2 120341            LCALL    ?C?LSTXDATA
  192:     					app_configWrite(MONEY_SECTOR);
0009F5 7F01              MOV      R7,#01H
0009F7 51E7              ACALL    _app_configWrite
  193:                         
  194:                         if(s_System.Money != 100)
0009F9 9000B2            MOV      DPTR,#s_System+011H
0009FC E0                MOVX     A,@DPTR
0009FD 7004              JNZ      ?C0049?APP_BRUSH
0009FF A3                INC      DPTR
000A00 E0                MOVX     A,@DPTR
000A01 6464              XRL      A,#064H
000A03         ?C0049?APP_BRUSH:
000A03 9000A8            MOV      DPTR,#s_System+07H
000A06 6006              JZ       ?C0042?APP_BRUSH
  195:                         {
  196:                             app_pulseSendPulse(s_System.PulseWidth, 9);     //充电站->1,洗衣机->9
000A08 E0                MOVX     A,@DPTR
000A09 FF                MOV      R7,A
000A0A 7D09              MOV      R5,#09H
  197:                         }
000A0C 8004              SJMP     ?C0053?APP_BRUSH
000A0E         ?C0042?APP_BRUSH:
  198:                         else
  199:                         {
  200:                             app_pulseSendPulse(s_System.PulseWidth, 1);
000A0E E0                MOVX     A,@DPTR
000A0F FF                MOV      R7,A
000A10 7D01              MOV      R5,#01H
000A12         
000A12 1216DF            LCALL    _app_pulseSendPulse
  201:                         }
000A15         ?C0043?APP_BRUSH:
  202:                         buzzer_SoundNumber(1);
000A15 7F01              MOV      R7,#01H
000A17 51AA              ACALL    _buzzer_SoundNumber
  203:                         led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
000A19 91BE              ACALL    ?L?COM002E
000A1B FB                MOV      R3,A
000A1C AAF0              MOV      R2,B
000A1E 51DD              ACALL    ?L?COM0013
000A20 C006              PUSH     AR6
000A22 C007              PUSH     AR7
000A24 51C1              ACALL    ?L?COM0029
000A26 1201A8            LCALL    ?C?UIDIV
000A29 D007              POP      AR7
000A2B D006              POP      AR6
000A2D 7B08              MOV      R3,#08H
000A2F 514B              ACALL    _led_ShowNumber
  204:                         sys_delayms(3000);
000A31 7FB8              MOV      R7,#0B8H
000A33 7E0B              MOV      R6,#0BH
000A35         
000A35 110A              ACALL    _sys_delayms
  205:                         break;
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 26


000A37 8004              SJMP     ?C0022?APP_BRUSH
  206:                     }
  207:                 }
000A39         ?C0040?APP_BRUSH:
  208:                 else
  209:                 {
  210:                     buzzer_SoundNumber(3);
000A39 7F03              MOV      R7,#03H
000A3B 51AA              ACALL    _buzzer_SoundNumber
  211:                 }
  212:             }
  213:             break;
  214:             
  215:         default:
  216:             break;
  217:     }
000A3D         ?C0022?APP_BRUSH:
  218:     
  219:     if(u8_FirstBrushCardDly)
000A3D 9000D9            MOV      DPTR,#u8_FirstBrushCardDly
000A40 E0                MOVX     A,@DPTR
000A41 6002              JZ       ?C0046?APP_BRUSH
  220:     {
  221:         u8_FirstBrushCardDly--;
000A43 14                DEC      A
000A44 F0                MOVX     @DPTR,A
  222:     }
000A45         ?C0046?APP_BRUSH:
  223:     if(!b_FactorySystem)
000A45 200702            JB       b_FactorySystem,?C0048?APP_BRUSH
  224:     {
  225:         Led_ShowZero();
000A48 1159              ACALL    Led_ShowZero
  226:     }
  227: }
000A4A         ?C0048?APP_BRUSH:
000A4A 22                RET      
----- FUNCTION app_brushCycle1s (END) -------


----- FUNCTION _led_ShowNumber (BEGIN) -----
 FILE: 'Driver\LED.c'
   95: void led_ShowNumber(UINT16 L_num, UINT8 R_num, UINT8 DotPlace)
   96: {
000A4B 900070            MOV      DPTR,#L_num
000A4E EE                MOV      A,R6
000A4F F0                MOVX     @DPTR,A
000A50 A3                INC      DPTR
000A51 EF                MOV      A,R7
000A52 F0                MOVX     @DPTR,A
;---- Variable 'R_num' assigned to Register 'R2' ----
000A53 AA05              MOV      R2,AR5
;---- Variable 'DotPlace' assigned to Register 'R3' ----
   97:     if(L_num>9999)
   98:     {
000A55 D3                SETB     C
000A56 E0                MOVX     A,@DPTR
000A57 940F              SUBB     A,#0FH
000A59 900070            MOV      DPTR,#L_num
000A5C E0                MOVX     A,@DPTR
000A5D 9427              SUBB     A,#027H
000A5F 4007              JC       ?C0034?LED
   99:         L_num = 9999;
  100:     }
000A61 7427              MOV      A,#027H
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 27


000A63 F0                MOVX     @DPTR,A
000A64 A3                INC      DPTR
000A65 740F              MOV      A,#0FH
000A67 F0                MOVX     @DPTR,A
  101:     if(R_num>99)
000A68         ?C0034?LED:
  102:     {
000A68 EA                MOV      A,R2
000A69 D3                SETB     C
000A6A 9463              SUBB     A,#063H
000A6C 4002              JC       ?C0035?LED
  103:         R_num = 99;
  104:     }
000A6E 7A63              MOV      R2,#063H
  105:     gLedBuf[0] = L_num/1000;
000A70         ?C0035?LED:
  106:     gLedBuf[1] = L_num/100%10;
000A70 F169              ACALL    ?L?COM0044
000A72 7C03              MOV      R4,#03H
000A74 7DE8              MOV      R5,#0E8H
000A76 1201A8            LCALL    ?C?UIDIV
000A79 9000C9            MOV      DPTR,#gLedBuf
000A7C EF                MOV      A,R7
000A7D F0                MOVX     @DPTR,A
  107:     gLedBuf[2] = L_num/10%10;
000A7E F169              ACALL    ?L?COM0044
000A80 7C00              MOV      R4,#00H
000A82 7D64              MOV      R5,#064H
000A84 1201A8            LCALL    ?C?UIDIV
000A87 51BA              ACALL    ?L?COM001D
000A89 9000CA            MOV      DPTR,#gLedBuf+01H
000A8C 51B0              ACALL    ?L?COM001C
000A8E 51BA              ACALL    ?L?COM001D
000A90 9000CB            MOV      DPTR,#gLedBuf+02H
000A93 51B0              ACALL    ?L?COM001C
000A95 9000CC            MOV      DPTR,#gLedBuf+03H
000A98 ED                MOV      A,R5
000A99 F0                MOVX     @DPTR,A
  108:     gLedBuf[3] = L_num%10;
  109:     gLedBuf[4] = R_num/10%10;
000A9A EA                MOV      A,R2
000A9B 75F00A            MOV      B,#0AH
000A9E 84                DIV      AB
000A9F 51CC              ACALL    ?L?COM0023
  110:     gLedBuf[5] = R_num%10;
000AA1 EA                MOV      A,R2
000AA2 51CC              ACALL    ?L?COM0023
  111:     gShowDot = DotPlace;
000AA4 9000D0            MOV      DPTR,#gShowDot
000AA7 EB                MOV      A,R3
000AA8 F0                MOVX     @DPTR,A
  112: }
000AA9 22                RET      
----- FUNCTION _led_ShowNumber (END) -------


----- FUNCTION _buzzer_SoundNumber (BEGIN) -----
 FILE: 'Driver\buzzer.c'
   28: void buzzer_SoundNumber(UINT8 num)
   29: {
;---- Variable 'num' assigned to Register 'R7' ----
   30:     SoundNumberCount = num;
   30: }
000AAA 9000DB            MOV      DPTR,#SoundNumberCount
000AAD EF                MOV      A,R7
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 28


000AAE F0                MOVX     @DPTR,A
   30: 
000AAF 22                RET      
----- FUNCTION _buzzer_SoundNumber (END) -------


----- FUNCTION ?L?COM001C (BEGIN) -----
000AB0 ED                MOV      A,R5
000AB1 F0                MOVX     @DPTR,A
000AB2 900070            MOV      DPTR,#L_num
000AB5 E0                MOVX     A,@DPTR
000AB6 FE                MOV      R6,A
000AB7 A3                INC      DPTR
000AB8 E0                MOVX     A,@DPTR
000AB9 FF                MOV      R7,A
000ABA         ?L?COM001D:
000ABA 7C00              MOV      R4,#00H
000ABC 7D0A              MOV      R5,#0AH
000ABE 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM001C (END) -------


----- FUNCTION ?L?COM0029 (BEGIN) -----
000AC1 7C00              MOV      R4,#00H
000AC3 7D64              MOV      R5,#064H
000AC5 AF03              MOV      R7,AR3
000AC7 AE02              MOV      R6,AR2
000AC9 22                RET      
----- FUNCTION ?L?COM0029 (END) -------


----- FUNCTION ?L?COM0022 (BEGIN) -----
000ACA F0                MOVX     @DPTR,A
000ACB EF                MOV      A,R7
000ACC         ?L?COM0023:
000ACC 75F00A            MOV      B,#0AH
000ACF 84                DIV      AB
000AD0 A3                INC      DPTR
000AD1 E5F0              MOV      A,B
000AD3 F0                MOVX     @DPTR,A
000AD4 22                RET      
----- FUNCTION ?L?COM0022 (END) -------


----- FUNCTION ?L?COM0012 (BEGIN) -----
000AD5 9000B2            MOV      DPTR,#s_System+011H
000AD8 E0                MOVX     A,@DPTR
000AD9 FA                MOV      R2,A
000ADA A3                INC      DPTR
000ADB E0                MOVX     A,@DPTR
000ADC FB                MOV      R3,A
000ADD         ?L?COM0013:
000ADD 7C00              MOV      R4,#00H
000ADF 7D64              MOV      R5,#064H
000AE1 FF                MOV      R7,A
000AE2 AE02              MOV      R6,AR2
000AE4 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM0012 (END) -------


----- FUNCTION _app_configWrite (BEGIN) -----
 FILE: 'App\app_config.c'
  104: void app_configWrite(UINT8 Sector)
  105: {
000AE7 900070            MOV      DPTR,#Sector
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 29


000AEA EF                MOV      A,R7
000AEB F0                MOVX     @DPTR,A
  106:     led_Switch(OFF);
  107:     if(Sector == SYSTEM_SETTING_SECTOR)
000AEC C201              CLR      ?led_Switch?BIT
000AEE 710A              ACALL    led_Switch
  108:     {
000AF0 900070            MOV      DPTR,#Sector
000AF3 E0                MOVX     A,@DPTR
000AF4 7B01              MOV      R3,#01H
000AF6 7007              JNZ      ?C0013?APP_CONFIG
  109:         hwa_eepromWriteSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
  110:     }
000AF8 7A00              MOV      R2,#HIGH s_System
000AFA 79A1              MOV      R1,#LOW s_System
000AFC FD                MOV      R5,A
  111:     else
000AFD 8006              SJMP     ?C0018?APP_CONFIG
000AFF         ?C0013?APP_CONFIG:
  112:     {
  113:         hwa_eepromWriteSector((UINT8*)&MoneySum, MONEY_SECTOR);
000AFF 7A00              MOV      R2,#HIGH MoneySum
000B01 799D              MOV      R1,#LOW MoneySum
000B03 7D01              MOV      R5,#01H
000B05         
000B05 1213E1            LCALL    _hwa_eepromWriteSector
  114:     }
000B08         ?C0014?APP_CONFIG:
  115:     led_Switch(ON);
000B08 D201              SETB     ?led_Switch?BIT
;----                  JMP      led_Switch
----- FUNCTION _app_configWrite (END) -------


----- FUNCTION led_Switch (BEGIN) -----
 FILE: 'Driver\LED.c'
  125: void led_Switch(bit sw)
  126: {
  127:     ledsw = sw;
  128:     if(ledsw==0)
000B0A A201              MOV      C,sw
000B0C 9208              MOV      ledsw,C
  129:     {
000B0E 200805            JB       ledsw,?C0039?LED
  130:     	LED_CS0 = 1;
  131:     	LED_CS1 = 1;
000B11 121214            LCALL    ?L?COM003E
  132:     	LED_CS2 = 1;
  133:     	LED_CS3 = 1;
  134:     	LED_CS4 = 1;
  135:     	LED_CS5 = 1;
000B14 D2B6              SETB     LED_CS5
  136:     }
  137: }
000B16         ?C0039?LED:
000B16 22                RET      
----- FUNCTION led_Switch (END) -------


----- FUNCTION app_configInit (BEGIN) -----
 FILE: 'App\app_config.c'
   47: void app_configInit(void)
   48: {
   49:     BOOL state = FALSE;
   50:     led_Switch(OFF);
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 30


000B17 C200              CLR      state
   51:     hwa_eepromInit();
000B19 C201              CLR      ?led_Switch?BIT
000B1B 710A              ACALL    led_Switch
   52:     if(app_configRead(SYSTEM_SETTING_SECTOR) == FALSE)
000B1D 120022            LCALL    hwa_eepromInit
   53:     {
000B20 E4                CLR      A
000B21 FF                MOV      R7,A
000B22 F17E              ACALL    _app_configRead
000B24 4021              JC       ?C0001?APP_CONFIG
   54:         memcpy(&s_System, &s_FactorySystem, sizeof(s_System));
   55:         b_FactorySystem = TRUE;
000B26 78A1              MOV      R0,#LOW s_System
000B28 7C00              MOV      R4,#HIGH s_System
000B2A 7D01              MOV      R5,#01H
000B2C 7BFF              MOV      R3,#0FFH
000B2E 7A00              MOV      R2,#HIGH s_FactorySystem
000B30 790E              MOV      R1,#LOW s_FactorySystem
000B32 7E00              MOV      R6,#00H
000B34 7F13              MOV      R7,#013H
000B36 1200F6            LCALL    ?C?COPY
   56:         led_ShowNumber(8888,88,0xFF);
000B39 D207              SETB     b_FactorySystem
   57:     }
000B3B 7BFF              MOV      R3,#0FFH
000B3D 7D58              MOV      R5,#058H
000B3F 7FB8              MOV      R7,#0B8H
000B41 7E22              MOV      R6,#022H
000B43 514B              ACALL    _led_ShowNumber
   58:     else
000B45 8060              SJMP     ?C0002?APP_CONFIG
000B47         ?C0001?APP_CONFIG:
   59:     {
   60:         if(s_System.Sector > 16 || s_System.Sector < 1)                 //钱包分区不在1~16
000B47 9000A7            MOV      DPTR,#s_System+06H
000B4A E0                MOVX     A,@DPTR
000B4B FF                MOV      R7,A
000B4C D3                SETB     C
000B4D 9410              SUBB     A,#010H
000B4F 5006              JNC      ?C0004?APP_CONFIG
000B51 EF                MOV      A,R7
000B52 C3                CLR      C
000B53 9401              SUBB     A,#01H
000B55 500B              JNC      ?C0003?APP_CONFIG
000B57         ?C0004?APP_CONFIG:
   61:         {
   62:             s_System.Sector = s_FactorySystem.Sector;
000B57 900014            MOV      DPTR,#s_FactorySystem+06H
000B5A E4                CLR      A
000B5B 93                MOVC     A,@A+DPTR
000B5C 9000A7            MOV      DPTR,#s_System+06H
000B5F F0                MOVX     @DPTR,A
   63:             state = TRUE;
000B60 D200              SETB     state
   64:         }
000B62         ?C0003?APP_CONFIG:
   65:         if(s_System.PulseWidth<10 && s_System.PulseWidth>60)
000B62 9000A8            MOV      DPTR,#s_System+07H
000B65 E0                MOVX     A,@DPTR
000B66 FF                MOV      R7,A
000B67 C3                CLR      C
000B68 940A              SUBB     A,#0AH
000B6A 5010              JNC      ?C0005?APP_CONFIG
000B6C EF                MOV      A,R7
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 31


000B6D 943C              SUBB     A,#03CH
000B6F 400B              JC       ?C0005?APP_CONFIG
   66:         {
   67:             s_System.PulseWidth = s_FactorySystem.PulseWidth;
000B71 900015            MOV      DPTR,#s_FactorySystem+07H
000B74 E4                CLR      A
000B75 93                MOVC     A,@A+DPTR
000B76 9000A8            MOV      DPTR,#s_System+07H
000B79 F0                MOVX     @DPTR,A
   68:             state = TRUE;
000B7A D200              SETB     state
   69:         }
000B7C         ?C0005?APP_CONFIG:
   70:         if(s_System.Money > 200)                                        //金额整数部分大于10
000B7C D3                SETB     C
000B7D 9000B3            MOV      DPTR,#s_System+012H
000B80 E0                MOVX     A,@DPTR
000B81 94C8              SUBB     A,#0C8H
000B83 9000B2            MOV      DPTR,#s_System+011H
000B86 E0                MOVX     A,@DPTR
000B87 9400              SUBB     A,#00H
000B89 4013              JC       ?C0006?APP_CONFIG
   71:         {
   72:             s_System.Money = s_FactorySystem.Money;
000B8B 90001F            MOV      DPTR,#s_FactorySystem+011H
000B8E E4                CLR      A
000B8F 93                MOVC     A,@A+DPTR
000B90 FF                MOV      R7,A
000B91 7401              MOV      A,#01H
000B93 93                MOVC     A,@A+DPTR
000B94 9000B2            MOV      DPTR,#s_System+011H
000B97 CF                XCH      A,R7
000B98 F0                MOVX     @DPTR,A
000B99 A3                INC      DPTR
000B9A EF                MOV      A,R7
000B9B F0                MOVX     @DPTR,A
   73:             state = TRUE;
000B9C D200              SETB     state
   74:         }
000B9E         ?C0006?APP_CONFIG:
   75:         if(state)
000B9E 300006            JNB      state,?C0002?APP_CONFIG
   76:         {
   77: 			app_configWrite(SYSTEM_SETTING_SECTOR);
000BA1 E4                CLR      A
000BA2 FF                MOV      R7,A
000BA3 51E7              ACALL    _app_configWrite
   78:             b_FactorySystem = TRUE;
000BA5 D207              SETB     b_FactorySystem
   79:         }
   80:     }
000BA7         ?C0002?APP_CONFIG:
   81:     
   82:     if(app_configRead(MONEY_SECTOR) == FALSE)
000BA7 7F01              MOV      R7,#01H
000BA9 F17E              ACALL    _app_configRead
000BAB 4013              JC       ?C0008?APP_CONFIG
   83:     {
   84:         memset(&MoneySum, 0x00, sizeof(MoneySum));
000BAD 7E00              MOV      R6,#00H
000BAF 7F04              MOV      R7,#04H
000BB1 7D00              MOV      R5,#00H
000BB3 7B01              MOV      R3,#01H
000BB5 7A00              MOV      R2,#HIGH MoneySum
000BB7 799D              MOV      R1,#LOW MoneySum
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 32


000BB9 12034D            LCALL    ?C?MEMSET
   85: 		app_configWrite(MONEY_SECTOR);
000BBC 7F01              MOV      R7,#01H
000BBE 51E7              ACALL    _app_configWrite
   86:     }
000BC0         ?C0008?APP_CONFIG:
   87:     led_Switch(ON);
000BC0 D201              SETB     ?led_Switch?BIT
000BC2 610A              AJMP     led_Switch
----- FUNCTION app_configInit (END) -------


----- FUNCTION _hwa_mifareReadBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   55: BOOL hwa_mifareReadBlock(UINT8 *buff, UINT8 block)
   56: {
000BC4 900076            MOV      DPTR,#buff
000BC7 D1A0              ACALL    ?L?COM0004
000BC9 A3                INC      DPTR
000BCA ED                MOV      A,R5
000BCB F0                MOVX     @DPTR,A
   57: 	UINT8 u8_ReadErrCount;
   58: 	UINT8 u8_Result;
   59: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
000BCC E4                CLR      A
000BCD A3                INC      DPTR
000BCE F0                MOVX     @DPTR,A
000BCF         ?C0018?HWA_MIFARE:
   60: 	{
   61: 		u8_Result = Read_Block(buff, block);
000BCF 900076            MOV      DPTR,#buff
000BD2 1207F3            LCALL    ?L?COM0002
000BD5 F9                MOV      R1,A
000BD6 A3                INC      DPTR
000BD7 E0                MOVX     A,@DPTR
000BD8 FD                MOV      R5,A
000BD9 121738            LCALL    _Read_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   62: 		if (u8_Result == FM1702_OK)
000BDC EF                MOV      A,R7
000BDD 7002              JNZ      ?C0021?HWA_MIFARE
   63: 		{
   64: 			return TRUE;
000BDF D3                SETB     C
000BE0 22                RET      
   65: 		}
000BE1         ?C0021?HWA_MIFARE:
   66: 		else if (u8_Result == FM1702_NOTAGERR)
000BE1 EF                MOV      A,R7
000BE2 B40102            CJNE     A,#01H,?C0020?HWA_MIFARE
   67: 		{
   68: 			return FALSE;
000BE5 C3                CLR      C
000BE6 22                RET      
   69: 		}
   70: 	}
000BE7         ?C0020?HWA_MIFARE:
000BE7 90007A            MOV      DPTR,#u8_ReadErrCount
000BEA F1D7              ACALL    ?L?COM004C
000BEC 40E1              JC       ?C0018?HWA_MIFARE
000BEE         ?C0019?HWA_MIFARE:
   71: 	return FALSE;
000BEE C3                CLR      C
   72: }
000BEF 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 33


----- FUNCTION _hwa_mifareReadBlock (END) -------


----- FUNCTION _hwa_mifareReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  159: BOOL hwa_mifareReadSector(UINT8 *dat, UINT8 sector)
  160: {
000BF0 900070            MOV      DPTR,#dat
000BF3 D1A0              ACALL    ?L?COM0004
000BF5 A3                INC      DPTR
000BF6 ED                MOV      A,R5
000BF7 F0                MOVX     @DPTR,A
  161: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  162: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
000BF8 121821            LCALL    ?L?COM0032
  163: 
  164: 	if (dat != NULL && sector > 0 && sector < 16)
000BFB 900070            MOV      DPTR,#dat
000BFE 1207F3            LCALL    ?L?COM0002
000C01 4A                ORL      A,R2
000C02 4B                ORL      A,R3
000C03 7002              JNZ      $ + 4H
000C05 81B3              AJMP     ?C0044?HWA_MIFARE
000C07 A3                INC      DPTR
000C08 E0                MOVX     A,@DPTR
000C09 FF                MOV      R7,A
000C0A D3                SETB     C
000C0B 9400              SUBB     A,#00H
000C0D 5002              JNC      $ + 4H
000C0F 81B3              AJMP     ?C0044?HWA_MIFARE
000C11 EF                MOV      A,R7
000C12 9410              SUBB     A,#010H
000C14 4002              JC       $ + 4H
000C16 81B3              AJMP     ?C0044?HWA_MIFARE
  165: 	{
  166: 		if (hwa_mifareReadBlock((UINT8*)&s_NormalBuff, block) == FALSE)
000C18 91B7              ACALL    ?L?COM0021
000C1A A3                INC      DPTR
000C1B E0                MOVX     A,@DPTR
000C1C FD                MOV      R5,A
000C1D 71C4              ACALL    _hwa_mifareReadBlock
000C1F 4001              JC       ?C0045?HWA_MIFARE
  167: 		{
  168: 			return FALSE;
000C21 22                RET      
  169: 		}
000C22         ?C0045?HWA_MIFARE:
  170: 
  171: 		if (hwa_mifareReadBlock((UINT8*)&s_BackupBuff, block) == FALSE)
000C22 F172              ACALL    ?L?COM0038
000C24 71C4              ACALL    _hwa_mifareReadBlock
000C26 4001              JC       ?C0047?HWA_MIFARE
  172: 		{
  173: 			return FALSE;
000C28 22                RET      
  174: 		}
000C29         ?C0047?HWA_MIFARE:
  175: 
  176: 		hwa_mifareCheckBlock();
000C29 91C7              ACALL    hwa_mifareCheckBlock
  177: 
  178: 		if (NormalErrorFlag && BackupErrorFlag)				//正常块和备份块都校验错误
000C2B 300512            JNB      NormalErrorFlag,?C0048?HWA_MIFARE
000C2E 30040F            JNB      BackupErrorFlag,?C0048?HWA_MIFARE
  179: 		{
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 34


  180:             if(s_System.RecoveryOldCard)
000C31 9000B1            MOV      DPTR,#s_System+010H
000C34 E0                MOVX     A,@DPTR
000C35 6007              JZ       ?C0049?HWA_MIFARE
  181:             {
  182:                 hwa_mifareRecoveryOldCard(sector);				//兼容旧卡
000C37 900073            MOV      DPTR,#sector
000C3A E0                MOVX     A,@DPTR
000C3B FF                MOV      R7,A
000C3C B10F              ACALL    _hwa_mifareRecoveryOldCard
  183:             }
000C3E         ?C0049?HWA_MIFARE:
  184: 			return FALSE;
000C3E C3                CLR      C
000C3F 22                RET      
  185: 		}
000C40         ?C0048?HWA_MIFARE:
  186: 		else if (NormalErrorFlag)							//正常块校验错误
000C40 300509            JNB      NormalErrorFlag,?C0051?HWA_MIFARE
  187: 		{
  188:             hwa_mifareEncrypt((UINT8*)&s_BackupBuff);
000C43 B174              ACALL    ?L?COM0042
  189: 			if (hwa_mifareWriteBlock((UINT8*)&s_BackupBuff, block) == FALSE)
000C45 F172              ACALL    ?L?COM0038
000C47 B1A6              ACALL    _hwa_mifareWriteBlock
000C49 402C              JC       ?C0050?HWA_MIFARE
  190: 			{
  191: 				return FALSE;
000C4B 22                RET      
  192: 			}
  193: 		}
000C4C         ?C0051?HWA_MIFARE:
  194: 		else if (BackupErrorFlag							//备份块校验错误
000C4C 200418            JB       BackupErrorFlag,?C0055?HWA_MIFARE
000C4F 900042            MOV      DPTR,#s_BackupBuff+02H
000C52 E0                MOVX     A,@DPTR
000C53 FF                MOV      R7,A
000C54 900052            MOV      DPTR,#s_NormalBuff+02H
000C57 E0                MOVX     A,@DPTR
000C58 B5070C            CJNE     A,AR7,?C0055?HWA_MIFARE
000C5B 900043            MOV      DPTR,#s_BackupBuff+03H
000C5E E0                MOVX     A,@DPTR
000C5F FF                MOV      R7,A
000C60 900053            MOV      DPTR,#s_NormalBuff+03H
000C63 E0                MOVX     A,@DPTR
000C64 6F                XRL      A,R7
000C65 6010              JZ       ?C0050?HWA_MIFARE
000C67         ?C0055?HWA_MIFARE:
  195: 			|| s_NormalBuff.crc[0] != s_BackupBuff.crc[0]	//正常块和备份块校验正确但数据不一样，用备份块替换正常块
  196: 			|| s_NormalBuff.crc[1] != s_BackupBuff.crc[1]
  197:         )
  198: 		{
  199:             hwa_mifareEncrypt((UINT8*)&s_NormalBuff);
000C67 91B7              ACALL    ?L?COM0021
000C69 B17A              ACALL    _hwa_mifareEncrypt
  200: 			if (hwa_mifareWriteBlock((UINT8*)&s_NormalBuff, blockBak) == FALSE)
000C6B 91B7              ACALL    ?L?COM0021
000C6D 900075            MOV      DPTR,#blockBak
000C70 E0                MOVX     A,@DPTR
000C71 FD                MOV      R5,A
000C72 B1A6              ACALL    _hwa_mifareWriteBlock
000C74 4001              JC       ?C0050?HWA_MIFARE
  201: 			{
  202: 				return FALSE;
000C76 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 35


  203: 			}
  204: 		}
000C77         ?C0050?HWA_MIFARE:
  205: 		if (BackupErrorFlag)
000C77 900070            MOV      DPTR,#dat
000C7A 1207F3            LCALL    ?L?COM0002
000C7D F8                MOV      R0,A
000C7E AC02              MOV      R4,AR2
000C80 AD03              MOV      R5,AR3
000C82 7B01              MOV      R3,#01H
000C84 300406            JNB      BackupErrorFlag,?C0057?HWA_MIFARE
  206: 		{
  207: 			memcpy(dat, (UINT8*)&s_NormalBuff, DATA_BLOCK_SIZE);
000C87 7A00              MOV      R2,#HIGH s_NormalBuff
000C89 7950              MOV      R1,#LOW s_NormalBuff
  208: 		}
000C8B 8004              SJMP     ?C0073?HWA_MIFARE
000C8D         ?C0057?HWA_MIFARE:
  209: 		else
  210: 		{
  211: 			memcpy(dat, (UINT8*)&s_BackupBuff, DATA_BLOCK_SIZE);
000C8D 7A00              MOV      R2,#HIGH s_BackupBuff
000C8F 7940              MOV      R1,#LOW s_BackupBuff
000C91         
000C91 F153              ACALL    ?L?COM0037
  212: 		}
000C93         ?C0058?HWA_MIFARE:
  213: 		if (*(UINT16*)dat > 50000)
000C93 900070            MOV      DPTR,#dat
000C96 1207F3            LCALL    ?L?COM0002
000C99 F9                MOV      R1,A
000C9A 120213            LCALL    ?C?ILDPTR
000C9D FF                MOV      R7,A
000C9E AEF0              MOV      R6,B
000CA0 E4                CLR      A
000CA1 FC                MOV      R4,A
000CA2 FD                MOV      R5,A
000CA3 7B50              MOV      R3,#050H
000CA5 7AC3              MOV      R2,#0C3H
000CA7 F9                MOV      R1,A
000CA8 F8                MOV      R0,A
000CA9 C3                CLR      C
000CAA 12032B            LCALL    ?C?SLCMP
000CAD 5002              JNC      ?C0059?HWA_MIFARE
  214: 		{
  215: 			return FALSE;
000CAF C3                CLR      C
000CB0 22                RET      
  216: 		}
000CB1         ?C0059?HWA_MIFARE:
  217: 		return TRUE;
000CB1 D3                SETB     C
000CB2 22                RET      
  218: 	}
000CB3         ?C0044?HWA_MIFARE:
  219: 	return FALSE;
000CB3 C3                CLR      C
  220: }
000CB4 22                RET      
----- FUNCTION _hwa_mifareReadSector (END) -------


----- FUNCTION ?L?COM0020 (BEGIN) -----
000CB5 EF                MOV      A,R7
000CB6 F0                MOVX     @DPTR,A
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 36


000CB7         ?L?COM0021:
000CB7 7B01              MOV      R3,#01H
000CB9 7A00              MOV      R2,#HIGH s_NormalBuff
000CBB 7950              MOV      R1,#LOW s_NormalBuff
000CBD 22                RET      
----- FUNCTION ?L?COM0020 (END) -------


----- FUNCTION ?L?COM002E (BEGIN) -----
000CBE AB08              MOV      R3,pMoney
000CC0 AA09              MOV      R2,pMoney+01H
000CC2 A90A              MOV      R1,pMoney+02H
000CC4 020213            LJMP     ?C?ILDPTR
----- FUNCTION ?L?COM002E (END) -------


----- FUNCTION hwa_mifareCheckBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  107: void hwa_mifareCheckBlock(void)
  108: {
  109: 	UINT16 crc, crcBak;
  110: 	hwa_mifareDecrypt((UINT8*)&s_NormalBuff);
000CC7 91B7              ACALL    ?L?COM0021
000CC9 D1A9              ACALL    _hwa_mifareDecrypt
  111: 	crc = hwa_mifareCheckOut((UINT8*)&s_NormalBuff, USE_DATA_BLOCK_LEN);
000CCB 91B7              ACALL    ?L?COM0021
;---- Variable 'crc' assigned to Register 'R4/R5' ----
000CCD D144              ACALL    ?L?COM002D
000CCF AC06              MOV      R4,AR6
  112: 	if (crc == (s_NormalBuff.crc[0] << 8 | s_NormalBuff.crc[1]))
000CD1 900052            MOV      DPTR,#s_NormalBuff+02H
000CD4 E0                MOVX     A,@DPTR
000CD5 FE                MOV      R6,A
000CD6 A3                INC      DPTR
000CD7 E0                MOVX     A,@DPTR
000CD8 FB                MOV      R3,A
000CD9 EB                MOV      A,R3
000CDA B50508            CJNE     A,AR5,?C0036?HWA_MIFARE
000CDD EE                MOV      A,R6
000CDE B50404            CJNE     A,AR4,?C0036?HWA_MIFARE
  113: 	{
  114: 		NormalErrorFlag = FALSE;
000CE1 C205              CLR      NormalErrorFlag
  115: 	}
000CE3 8002              SJMP     ?C0037?HWA_MIFARE
000CE5         ?C0036?HWA_MIFARE:
  116: 	else
  117: 	{
  118: 		NormalErrorFlag = TRUE;
000CE5 D205              SETB     NormalErrorFlag
  119: 	}
000CE7         ?C0037?HWA_MIFARE:
  120: 	hwa_mifareDecrypt((UINT8*)&s_BackupBuff);
000CE7 7B01              MOV      R3,#01H
000CE9 7A00              MOV      R2,#HIGH s_BackupBuff
000CEB 7940              MOV      R1,#LOW s_BackupBuff
000CED D1A9              ACALL    _hwa_mifareDecrypt
  121: 	crcBak = hwa_mifareCheckOut((UINT8*)&s_BackupBuff, USE_DATA_BLOCK_LEN);
000CEF 7B01              MOV      R3,#01H
000CF1 7A00              MOV      R2,#HIGH s_BackupBuff
000CF3 7940              MOV      R1,#LOW s_BackupBuff
;---- Variable 'crcBak' assigned to Register 'R4/R5' ----
000CF5 D144              ACALL    ?L?COM002D
000CF7 AC06              MOV      R4,AR6
  122: 	if (crcBak == (s_BackupBuff.crc[0] << 8 | s_BackupBuff.crc[1]))
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 37


000CF9 900042            MOV      DPTR,#s_BackupBuff+02H
000CFC E0                MOVX     A,@DPTR
000CFD FE                MOV      R6,A
000CFE A3                INC      DPTR
000CFF E0                MOVX     A,@DPTR
000D00 FB                MOV      R3,A
000D01 EB                MOV      A,R3
000D02 B50507            CJNE     A,AR5,?C0038?HWA_MIFARE
000D05 EE                MOV      A,R6
000D06 B50403            CJNE     A,AR4,?C0038?HWA_MIFARE
  123: 	{
  124: 		BackupErrorFlag = FALSE;
000D09 C204              CLR      BackupErrorFlag
  125: 	}
000D0B 22                RET      
000D0C         ?C0038?HWA_MIFARE:
  126: 	else
  127: 	{
  128: 		BackupErrorFlag = TRUE;
000D0C D204              SETB     BackupErrorFlag
  129: 	}
  130: }
000D0E 22                RET      
----- FUNCTION hwa_mifareCheckBlock (END) -------


----- FUNCTION _hwa_mifareRecoveryOldCard (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  132: static void hwa_mifareRecoveryOldCard(UINT8 sector)
  133: {
000D0F 900076            MOV      DPTR,#sector
000D12 91B5              ACALL    ?L?COM0020
000D14 B17A              ACALL    _hwa_mifareEncrypt
  134: 	UINT8 money;
  135: 	hwa_mifareEncrypt((UINT8*)&s_NormalBuff);
  136: 	money = *(UINT8*)&s_NormalBuff;
000D16 900050            MOV      DPTR,#s_NormalBuff
000D19 E0                MOVX     A,@DPTR
000D1A 900077            MOV      DPTR,#money
000D1D F0                MOVX     @DPTR,A
  137: 	if (money != 0xFF && money <= 200
000D1E F4                CPL      A
000D1F 601D              JZ       ?C0041?HWA_MIFARE
000D21 E0                MOVX     A,@DPTR
000D22 FF                MOV      R7,A
000D23 D3                SETB     C
000D24 94C8              SUBB     A,#0C8H
000D26 5016              JNC      ?C0041?HWA_MIFARE
000D28 900052            MOV      DPTR,#s_NormalBuff+02H
000D2B E0                MOVX     A,@DPTR
000D2C 7010              JNZ      ?C0041?HWA_MIFARE
000D2E A3                INC      DPTR
000D2F E0                MOVX     A,@DPTR
000D30 700C              JNZ      ?C0041?HWA_MIFARE
  138: 		&& s_NormalBuff.crc[0] == 0
  139: 		&& s_NormalBuff.crc[1] == 0
  140: 		)
  141: 	{
  142: 		s_NormalBuff.money = (UINT16)money * 100;
000D32 F15A              ACALL    ?L?COM004B
000D34 900050            MOV      DPTR,#s_NormalBuff
000D37 EE                MOV      A,R6
000D38 F0                MOVX     @DPTR,A
000D39 A3                INC      DPTR
000D3A 91B5              ACALL    ?L?COM0020
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 38


000D3C 802E              SJMP     ?C0072?HWA_MIFARE
  143: 		hwa_mifareWriteSector((UINT8*)&s_NormalBuff, sector);
  144: 		return;
  145: 	}
000D3E         ?C0041?HWA_MIFARE:
  146: 	hwa_mifareEncrypt((UINT8*)&s_BackupBuff);
000D3E B174              ACALL    ?L?COM0042
  147: 	money = *(UINT8*)&s_BackupBuff;
000D40 900040            MOV      DPTR,#s_BackupBuff
000D43 E0                MOVX     A,@DPTR
000D44 900077            MOV      DPTR,#money
000D47 F0                MOVX     @DPTR,A
  148: 	if (money != 0xFF && money <= 200
000D48 F4                CPL      A
000D49 6028              JZ       ?C0042?HWA_MIFARE
000D4B E0                MOVX     A,@DPTR
000D4C FF                MOV      R7,A
000D4D D3                SETB     C
000D4E 94C8              SUBB     A,#0C8H
000D50 5021              JNC      ?C0042?HWA_MIFARE
000D52 900042            MOV      DPTR,#s_BackupBuff+02H
000D55 E0                MOVX     A,@DPTR
000D56 701B              JNZ      ?C0042?HWA_MIFARE
000D58 A3                INC      DPTR
000D59 E0                MOVX     A,@DPTR
000D5A 7017              JNZ      ?C0042?HWA_MIFARE
  149: 		&& s_BackupBuff.crc[0] == 0
  150: 		&& s_BackupBuff.crc[1] == 0
  151: 		)
  152: 	{
  153: 		s_BackupBuff.money = (UINT16)money * 100;
000D5C F15A              ACALL    ?L?COM004B
000D5E 900040            MOV      DPTR,#s_BackupBuff
000D61 EE                MOV      A,R6
000D62 F0                MOVX     @DPTR,A
000D63 A3                INC      DPTR
000D64 EF                MOV      A,R7
000D65 F0                MOVX     @DPTR,A
  154: 		hwa_mifareWriteSector((UINT8*)&s_BackupBuff, sector);
000D66 7B01              MOV      R3,#01H
000D68 7A00              MOV      R2,#HIGH s_BackupBuff
000D6A 7940              MOV      R1,#LOW s_BackupBuff
000D6C         
000D6C 900076            MOV      DPTR,#sector
000D6F E0                MOVX     A,@DPTR
000D70 FD                MOV      R5,A
000D71 B1E2              ACALL    _hwa_mifareWriteSector
  155: 		return;
  156: 	}
  157: }
000D73         ?C0042?HWA_MIFARE:
000D73 22                RET      
----- FUNCTION _hwa_mifareRecoveryOldCard (END) -------


----- FUNCTION ?L?COM0042 (BEGIN) -----
000D74 7B01              MOV      R3,#01H
000D76 7A00              MOV      R2,#HIGH s_BackupBuff
000D78 7940              MOV      R1,#LOW s_BackupBuff
----- FUNCTION _hwa_mifareEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   29: void hwa_mifareEncrypt(UINT8 *pData)        //利用卡ID加密
   30: {
000D7A D19D              ACALL    ?L?COM0003
   31: 	UINT8 i, j;
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 39


   32: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
000D7C E4                CLR      A
000D7D FE                MOV      R6,A
000D7E         ?C0004?HWA_MIFARE:
   33: 	{
   34: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
000D7E 7D04              MOV      R5,#04H
000D80         ?C0007?HWA_MIFARE:
   35: 		{
   36: 			pData[i] ^= gCard_UID[i % 5];
000D80 1207F0            LCALL    ?L?COM0001
000D83 1211D7            LCALL    ?L?COM000E
000D86 E0                MOVX     A,@DPTR
000D87 6F                XRL      A,R7
000D88 120162            LCALL    ?C?CSTPTR
   37: 			pData[i] = _cror_(pData[i], 1);
000D8B 1207F0            LCALL    ?L?COM0001
000D8E F9                MOV      R1,A
000D8F 8E82              MOV      DPL,R6
000D91 D1DC              ACALL    ?L?COM0018
000D93 FF                MOV      R7,A
000D94 7801              MOV      R0,#01H
000D96 08                INC      R0
000D97 8001              SJMP     ?C0065?HWA_MIFARE
000D99         ?C0064?HWA_MIFARE:
000D99 03                RR       A
000D9A         ?C0065?HWA_MIFARE:
000D9A D8FD              DJNZ     R0,?C0064?HWA_MIFARE
000D9C F1CF              ACALL    ?L?COM0045
   38: 		}
000D9E DDE0              DJNZ     R5,?C0007?HWA_MIFARE
   39: 	}
000DA0         ?C0006?HWA_MIFARE:
000DA0 0E                INC      R6
000DA1 EE                MOV      A,R6
000DA2 B404D9            CJNE     A,#04H,?C0004?HWA_MIFARE
   40: }
000DA5 22                RET      
----- FUNCTION _hwa_mifareEncrypt (END) -------


----- FUNCTION _hwa_mifareWriteBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   74: BOOL hwa_mifareWriteBlock(UINT8 *buff, UINT8 block)
   75: {
000DA6 90007D            MOV      DPTR,#block
000DA9 ED                MOV      A,R5
000DAA F0                MOVX     @DPTR,A
;---- Variable 'buff' assigned to Register 'R1/R2/R3' ----
   76: 	UINT8 u8_ReadErrCount;
   77: 	UINT8 u8_Result;
   78:     memcpy((UINT8*)&s_TempBuff, buff, 16);
000DAB 7860              MOV      R0,#LOW s_TempBuff
000DAD 7C00              MOV      R4,#HIGH s_TempBuff
000DAF 7D01              MOV      R5,#01H
000DB1 F153              ACALL    ?L?COM0037
   79:     hwa_mifareEncrypt((UINT8*)&s_TempBuff);
000DB3 7B01              MOV      R3,#01H
000DB5 7A00              MOV      R2,#HIGH s_TempBuff
000DB7 7960              MOV      R1,#LOW s_TempBuff
000DB9 B17A              ACALL    _hwa_mifareEncrypt
   80: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
000DBB E4                CLR      A
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 40


000DBC 90007E            MOV      DPTR,#u8_ReadErrCount
000DBF F0                MOVX     @DPTR,A
000DC0         ?C0025?HWA_MIFARE:
   81: 	{
   82: 		u8_Result = Write_Block((UINT8*)&s_TempBuff, block);
000DC0 7B01              MOV      R3,#01H
000DC2 7A00              MOV      R2,#HIGH s_TempBuff
000DC4 7960              MOV      R1,#LOW s_TempBuff
000DC6 90007D            MOV      DPTR,#block
000DC9 E0                MOVX     A,@DPTR
000DCA FD                MOV      R5,A
000DCB 121783            LCALL    _Write_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   83: 		if (u8_Result == FM1702_OK)
000DCE EF                MOV      A,R7
000DCF 7002              JNZ      ?C0028?HWA_MIFARE
   84: 		{
   85: 			return TRUE;
000DD1 D3                SETB     C
000DD2 22                RET      
   86: 		}
000DD3         ?C0028?HWA_MIFARE:
   87: 		else if (u8_Result == FM1702_NOTAGERR)
000DD3 EF                MOV      A,R7
000DD4 B40102            CJNE     A,#01H,?C0027?HWA_MIFARE
   88: 		{
   89: 			return FALSE;
000DD7 C3                CLR      C
000DD8 22                RET      
   90: 		}
   91: 	}
000DD9         ?C0027?HWA_MIFARE:
000DD9 90007E            MOV      DPTR,#u8_ReadErrCount
000DDC F1D7              ACALL    ?L?COM004C
000DDE 40E0              JC       ?C0025?HWA_MIFARE
000DE0         ?C0026?HWA_MIFARE:
   92: 	return FALSE;
000DE0 C3                CLR      C
   93: }
000DE1 22                RET      
----- FUNCTION _hwa_mifareWriteBlock (END) -------


----- FUNCTION _hwa_mifareWriteSector (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  222: BOOL hwa_mifareWriteSector(UINT8 *dat, UINT8 sector)
  223: {
000DE2 900078            MOV      DPTR,#dat
000DE5 D1A0              ACALL    ?L?COM0004
;---- Variable 'sector' assigned to Register 'R5' ----
  224: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  225: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
000DE7 ED                MOV      A,R5
000DE8 121821            LCALL    ?L?COM0032
  226: 	UINT16 crc;
  227:     BOOL falg = FALSE;
000DEB C200              CLR      falg
  228: 	if (dat != NULL && sector > 0 && sector < 16)
000DED 900078            MOV      DPTR,#dat
000DF0 1207F3            LCALL    ?L?COM0002
000DF3 4A                ORL      A,R2
000DF4 4B                ORL      A,R3
000DF5 604A              JZ       ?C0060?HWA_MIFARE
000DF7 ED                MOV      A,R5
000DF8 D3                SETB     C
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 41


000DF9 9400              SUBB     A,#00H
000DFB 4044              JC       ?C0060?HWA_MIFARE
000DFD ED                MOV      A,R5
000DFE 9410              SUBB     A,#010H
000E00 503F              JNC      ?C0060?HWA_MIFARE
  229: 	{
  230: 		crc = hwa_mifareCheckOut(dat, USE_DATA_BLOCK_LEN);
000E02 900078            MOV      DPTR,#dat
000E05 A3                INC      DPTR
000E06 A3                INC      DPTR
000E07 E0                MOVX     A,@DPTR
000E08 F9                MOV      R1,A
;---- Variable 'crc' assigned to Register 'R4/R5' ----
000E09 D144              ACALL    ?L?COM002D
000E0B AC06              MOV      R4,AR6
  231: 		dat[USE_DATA_BLOCK_LEN] = (UINT8)(crc >> 8);
000E0D EC                MOV      A,R4
000E0E FF                MOV      R7,A
000E0F 900078            MOV      DPTR,#dat
000E12 1207F3            LCALL    ?L?COM0002
000E15 F9                MOV      R1,A
000E16 900002            MOV      DPTR,#02H
000E19 EF                MOV      A,R7
000E1A 120174            LCALL    ?C?CSTOPTR
  232: 		dat[USE_DATA_BLOCK_LEN + 1] = (UINT8)(crc & 0xFF);
000E1D ED                MOV      A,R5
000E1E 900003            MOV      DPTR,#03H
000E21 120174            LCALL    ?C?CSTOPTR
  233: 		if (hwa_mifareWriteBlock(dat, block))
000E24 90007B            MOV      DPTR,#block
000E27 E0                MOVX     A,@DPTR
000E28 FD                MOV      R5,A
000E29 B1A6              ACALL    _hwa_mifareWriteBlock
000E2B 5002              JNC      ?C0061?HWA_MIFARE
  234: 		{
  235: 			falg = TRUE;
000E2D D200              SETB     falg
  236: 		}
000E2F         ?C0061?HWA_MIFARE:
  237: 		if (hwa_mifareWriteBlock(dat, blockBak))
000E2F 900078            MOV      DPTR,#dat
000E32 1207F3            LCALL    ?L?COM0002
000E35 F9                MOV      R1,A
000E36 90007C            MOV      DPTR,#blockBak
000E39 E0                MOVX     A,@DPTR
000E3A FD                MOV      R5,A
000E3B B1A6              ACALL    _hwa_mifareWriteBlock
000E3D 5002              JNC      ?C0060?HWA_MIFARE
  238: 		{
  239: 			falg = TRUE;
000E3F D200              SETB     falg
  240: 		}
  241: 	}
000E41         ?C0060?HWA_MIFARE:
  242:     return falg;
000E41 A200              MOV      C,falg
  243: }
000E43 22                RET      
----- FUNCTION _hwa_mifareWriteSector (END) -------


----- FUNCTION ?L?COM002D (BEGIN) -----
000E44 7D02              MOV      R5,#02H
000E46 7C00              MOV      R4,#00H
000E48 D14D              ACALL    _hwa_mifareCheckOut
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 42


000E4A AD07              MOV      R5,AR7
000E4C 22                RET      
----- FUNCTION ?L?COM002D (END) -------


----- FUNCTION _hwa_mifareCheckOut (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   95: UINT16 hwa_mifareCheckOut(UINT8 *dat, UINT16 len)
   96: {
000E4D 90008F            MOV      DPTR,#dat
000E50 D1A0              ACALL    ?L?COM0004
;---- Variable 'len' assigned to Register 'R4/R5' ----
   97: 	UINT16 Sum = 0;
   98: 	UINT8 i;
000E52 E4                CLR      A
000E53 A3                INC      DPTR
000E54 F0                MOVX     @DPTR,A
000E55 A3                INC      DPTR
000E56 F0                MOVX     @DPTR,A
   99: 	for (i = 0; i < len; i++)
000E57 A3                INC      DPTR
000E58 F0                MOVX     @DPTR,A
000E59         ?C0032?HWA_MIFARE:
000E59 900094            MOV      DPTR,#i
000E5C E0                MOVX     A,@DPTR
000E5D C3                CLR      C
000E5E 9D                SUBB     A,R5
000E5F E4                CLR      A
000E60 9C                SUBB     A,R4
000E61 5025              JNC      ?C0033?HWA_MIFARE
  100: 	{
  101: 		Sum += dat[i];
000E63 90008F            MOV      DPTR,#dat
000E66 1207F3            LCALL    ?L?COM0002
000E69 F9                MOV      R1,A
000E6A 900094            MOV      DPTR,#i
000E6D E0                MOVX     A,@DPTR
000E6E F582              MOV      DPL,A
000E70 D1DC              ACALL    ?L?COM0018
000E72 FF                MOV      R7,A
000E73 900093            MOV      DPTR,#Sum+01H
000E76 E0                MOVX     A,@DPTR
000E77 2F                ADD      A,R7
000E78 F0                MOVX     @DPTR,A
000E79 900092            MOV      DPTR,#Sum
000E7C E0                MOVX     A,@DPTR
000E7D 3400              ADDC     A,#00H
000E7F F0                MOVX     @DPTR,A
  102: 	}
000E80 900094            MOV      DPTR,#i
000E83 E0                MOVX     A,@DPTR
000E84 04                INC      A
000E85 F0                MOVX     @DPTR,A
000E86 80D1              SJMP     ?C0032?HWA_MIFARE
000E88         ?C0033?HWA_MIFARE:
  103: 	Sum ^= 0xABCD;
000E88 900092            MOV      DPTR,#Sum
000E8B E0                MOVX     A,@DPTR
000E8C 64AB              XRL      A,#0ABH
000E8E FE                MOV      R6,A
000E8F A3                INC      DPTR
000E90 E0                MOVX     A,@DPTR
000E91 64CD              XRL      A,#0CDH
000E93 FF                MOV      R7,A
000E94 900092            MOV      DPTR,#Sum
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 43


000E97 EE                MOV      A,R6
000E98 F0                MOVX     @DPTR,A
000E99 A3                INC      DPTR
000E9A EF                MOV      A,R7
000E9B F0                MOVX     @DPTR,A
  104: 	return Sum;
  105: }
000E9C 22                RET      
----- FUNCTION _hwa_mifareCheckOut (END) -------


----- FUNCTION ?L?COM0003 (BEGIN) -----
000E9D 90007F            MOV      DPTR,#buff
000EA0         ?L?COM0004:
000EA0 EB                MOV      A,R3
000EA1 F0                MOVX     @DPTR,A
000EA2 A3                INC      DPTR
000EA3 EA                MOV      A,R2
000EA4 F0                MOVX     @DPTR,A
000EA5 A3                INC      DPTR
000EA6 E9                MOV      A,R1
000EA7 F0                MOVX     @DPTR,A
000EA8 22                RET      
----- FUNCTION ?L?COM0003 (END) -------


----- FUNCTION _hwa_mifareDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   42: void hwa_mifareDecrypt(UINT8 *pData)        //利用卡ID解密
   43: {
000EA9 900076            MOV      DPTR,#pData
000EAC D1A0              ACALL    ?L?COM0004
   44: 	UINT8 i, j;
   45: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
000EAE E4                CLR      A
000EAF FE                MOV      R6,A
000EB0         ?C0011?HWA_MIFARE:
   46: 	{
   47: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
000EB0 7D04              MOV      R5,#04H
000EB2         ?C0014?HWA_MIFARE:
   48: 		{
   49: 			pData[i] = _crol_(pData[i], 1);
000EB2 900076            MOV      DPTR,#pData
000EB5 1207F3            LCALL    ?L?COM0002
000EB8 F9                MOV      R1,A
000EB9 8E82              MOV      DPL,R6
000EBB D1DC              ACALL    ?L?COM0018
000EBD FF                MOV      R7,A
000EBE 7801              MOV      R0,#01H
000EC0 08                INC      R0
000EC1 8001              SJMP     ?C0067?HWA_MIFARE
000EC3         ?C0066?HWA_MIFARE:
000EC3 23                RL       A
000EC4         ?C0067?HWA_MIFARE:
000EC4 D8FD              DJNZ     R0,?C0066?HWA_MIFARE
000EC6 F1CF              ACALL    ?L?COM0045
   50: 			pData[i] ^= gCard_UID[i % 5];
000EC8 E9                MOV      A,R1
000EC9 1211D7            LCALL    ?L?COM000E
000ECC E0                MOVX     A,@DPTR
000ECD 6F                XRL      A,R7
000ECE 120162            LCALL    ?C?CSTPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 44


   51: 		}
000ED1 DDDF              DJNZ     R5,?C0014?HWA_MIFARE
   52: 	}
000ED3         ?C0013?HWA_MIFARE:
000ED3 0E                INC      R6
000ED4 EE                MOV      A,R6
000ED5 B404D8            CJNE     A,#04H,?C0011?HWA_MIFARE
   53: }
000ED8 22                RET      
----- FUNCTION _hwa_mifareDecrypt (END) -------


----- FUNCTION ?L?COM0016 (BEGIN) -----
000ED9 F9                MOV      R1,A
000EDA         ?L?COM0017:
000EDA 8F82              MOV      DPL,R7
000EDC         ?L?COM0018:
000EDC 758300            MOV      DPH,#00H
000EDF 020135            LJMP     ?C?CLDOPTR
----- FUNCTION ?L?COM0016 (END) -------


----- FUNCTION _Load_Key (BEGIN) -----
 FILE: 'Driver\mifare.c'
  406: uchar Load_Key(uchar *ramadr)
  407: {
000EE2 900073            MOV      DPTR,#ramadr
000EE5 D1A0              ACALL    ?L?COM0004
  408: 	uchar acktemp,temp[1],i;
  409: 	uchar ucBuff[12];
  410: 	for (i=0;i<6;i++)
;---- Variable 'i' assigned to Register 'R7' ----
000EE7 E4                CLR      A
000EE8 FF                MOV      R7,A
000EE9         ?C0089?MIFARE:
  411: 	{
  412: 		temp[0]=ramadr[i];
000EE9 900073            MOV      DPTR,#ramadr
000EEC 1207F3            LCALL    ?L?COM0002
000EEF D1D9              ACALL    ?L?COM0016
000EF1 900077            MOV      DPTR,#temp
000EF4 F0                MOVX     @DPTR,A
000EF5 FD                MOV      R5,A
  413: 		ucBuff[2*i]=(((ramadr[i]&0xf0)>>4)|((~ramadr[i])&0xf0));
000EF6 54F0              ANL      A,#0F0H
000EF8 C4                SWAP     A
000EF9 540F              ANL      A,#0FH
000EFB FE                MOV      R6,A
000EFC D1DA              ACALL    ?L?COM0017
000EFE F4                CPL      A
000EFF F161              ACALL    ?L?COM004A
000F01 2478              ADD      A,#LOW ucBuff
000F03 F582              MOV      DPL,A
000F05 E4                CLR      A
000F06 3400              ADDC     A,#HIGH ucBuff
000F08 F583              MOV      DPH,A
000F0A EE                MOV      A,R6
000F0B F0                MOVX     @DPTR,A
  414: 		ucBuff[2*i+1]=((temp[0]&0xf)|(~(temp[0]&0xf)<<4));
000F0C ED                MOV      A,R5
000F0D 540F              ANL      A,#0FH
000F0F FE                MOV      R6,A
000F10 F4                CPL      A
000F11 FD                MOV      R5,A
000F12 C4                SWAP     A
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 45


000F13 F161              ACALL    ?L?COM004A
000F15 2479              ADD      A,#LOW ucBuff+01H
000F17 F582              MOV      DPL,A
000F19 E4                CLR      A
000F1A 3400              ADDC     A,#HIGH ucBuff+01H
000F1C F1F3              ACALL    ?L?COM0026
000F1E B406C8            CJNE     A,#06H,?C0089?MIFARE
000F21         ?C0090?MIFARE:
  415: 	}
  416: 	acktemp=Command_Send(LOAD_KEY, ucBuff, 12);
000F21 7B01              MOV      R3,#01H
000F23 7A00              MOV      R2,#HIGH ucBuff
000F25 7978              MOV      R1,#LOW ucBuff
000F27 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
000F2A 740C              MOV      A,#0CH
000F2C F0                MOVX     @DPTR,A
000F2D 7F19              MOV      R7,#019H
000F2F 120595            LCALL    _Command_Send
000F32 900076            MOV      DPTR,#acktemp
000F35 EF                MOV      A,R7
000F36 F0                MOVX     @DPTR,A
  417: 	temp[0] = SPIReadOne(SecondaryStatus_Reg);
000F37 7F05              MOV      R7,#05H
000F39 1204FD            LCALL    _SPIReadOne
000F3C A3                INC      DPTR
000F3D EF                MOV      A,R7
000F3E F0                MOVX     @DPTR,A
  418: 	if (temp[0]&0x40)
000F3F 30E607            JNB      ACC.6,?C0092?MIFARE
  419: 	{
  420: 		temp[0]=0x0;
000F42 E4                CLR      A
000F43 1204C4            LCALL    ?L?COM0031
  421: 		SPIWriteOne(Command_Reg,temp[0]);
  422: 		return(0);
000F46 7F00              MOV      R7,#00H
000F48 22                RET      
  423: 	}
000F49         ?C0092?MIFARE:
  424: 	temp[0]=0x0;
000F49 E4                CLR      A
000F4A 900077            MOV      DPTR,#temp
000F4D 1204C4            LCALL    ?L?COM0031
  425: 	SPIWriteOne(Command_Reg,temp[0]);
  426: 	return(1);
000F50 7F01              MOV      R7,#01H
  427: }
000F52 22                RET      
----- FUNCTION _Load_Key (END) -------


----- FUNCTION ?L?COM0037 (BEGIN) -----
000F53 7E00              MOV      R6,#00H
000F55 7F10              MOV      R7,#010H
000F57 0200F6            LJMP     ?C?COPY
----- FUNCTION ?L?COM0037 (END) -------


----- FUNCTION ?L?COM004B (BEGIN) -----
000F5A FE                MOV      R6,A
000F5B FC                MOV      R4,A
000F5C 7D64              MOV      R5,#064H
000F5E 020196            LJMP     ?C?IMUL
----- FUNCTION ?L?COM004B (END) -------

LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 46



----- FUNCTION ?L?COM004A (BEGIN) -----
000F61 54F0              ANL      A,#0F0H
000F63 4E                ORL      A,R6
000F64 FE                MOV      R6,A
000F65 EF                MOV      A,R7
000F66 25E0              ADD      A,ACC
000F68 22                RET      
----- FUNCTION ?L?COM004A (END) -------


----- FUNCTION ?L?COM0044 (BEGIN) -----
000F69 900070            MOV      DPTR,#L_num
000F6C E0                MOVX     A,@DPTR
000F6D FE                MOV      R6,A
000F6E A3                INC      DPTR
000F6F E0                MOVX     A,@DPTR
000F70 FF                MOV      R7,A
000F71 22                RET      
----- FUNCTION ?L?COM0044 (END) -------


----- FUNCTION ?L?COM0038 (BEGIN) -----
000F72 7B01              MOV      R3,#01H
000F74 7A00              MOV      R2,#HIGH s_BackupBuff
000F76 7940              MOV      R1,#LOW s_BackupBuff
000F78 900074            MOV      DPTR,#block
000F7B E0                MOVX     A,@DPTR
000F7C FD                MOV      R5,A
000F7D 22                RET      
----- FUNCTION ?L?COM0038 (END) -------


----- FUNCTION _app_configRead (BEGIN) -----
 FILE: 'App\app_config.c'
   90: BOOL app_configRead(UINT8 Sector)
   91: {
;---- Variable 'Sector' assigned to Register 'R7' ----
   92:     BOOL state;
   93:     if(Sector == SYSTEM_SETTING_SECTOR)
000F7E EF                MOV      A,R7
000F7F 7B01              MOV      R3,#01H
000F81 7007              JNZ      ?C0010?APP_CONFIG
   94:     {
   95:         state = hwa_eepromReadSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
000F83 7A00              MOV      R2,#HIGH s_System
000F85 79A1              MOV      R1,#LOW s_System
000F87 FD                MOV      R5,A
   96:     }
000F88 8006              SJMP     ?C0017?APP_CONFIG
000F8A         ?C0010?APP_CONFIG:
   97:     else
   98:     {
   99:         state = hwa_eepromReadSector((UINT8*)&MoneySum, MONEY_SECTOR);
000F8A 7A00              MOV      R2,#HIGH MoneySum
000F8C 799D              MOV      R1,#LOW MoneySum
000F8E 7D01              MOV      R5,#01H
000F90         
000F90 12129E            LCALL    _hwa_eepromReadSector
000F93 9201              MOV      state,C
  100:     }
000F95         ?C0011?APP_CONFIG:
  101:     return state;
000F95 A201              MOV      C,state
  102: }
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 47


000F97 22                RET      
----- FUNCTION _app_configRead (END) -------


----- FUNCTION sys_taskInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   27: void sys_taskInit(void)
   28: {
   29:     WDT_CONTR = 0x33;
   30:     app_pulseInit();
000F98 75C133            MOV      WDT_CONTR,#033H
   31:     len_Init();
000F9B 1216D6            LCALL    app_pulseInit
   32:     sys_gpioInit();
000F9E 1216F2            LCALL    len_Init
   33:     buzzer_Init();
000FA1 120009            LCALL    sys_gpioInit
   34:     sys_uartInit();
000FA4 1216E8            LCALL    buzzer_Init
   35:     sys_tim0Init();
000FA7 1211F1            LCALL    sys_uartInit
   36: 	app_Show();
000FAA F1FA              ACALL    sys_tim0Init
   37:     app_configInit();
000FAC 1122              ACALL    app_Show
   38:     app_brushInit();
000FAE 7117              ACALL    app_configInit
;----                  JMP      app_brushInit
----- FUNCTION sys_taskInit (END) -------


----- FUNCTION app_brushInit (BEGIN) -----
 FILE: 'App\app_brush.c'
   31: void app_brushInit(void)
   32: {
   33: 	Init_FM1702();
   34: }
000FB0 02046E            LJMP     Init_FM1702
----- FUNCTION app_brushInit (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: 'System\sys_task.c'
   79: void main(void)
   80: {
   81:     sys_taskInit();
   82:     buzzer_SoundNumber(1);
000FB3 F198              ACALL    sys_taskInit
   83:     while(1)
000FB5 7F01              MOV      R7,#01H
000FB7 51AA              ACALL    _buzzer_SoundNumber
000FB9         ?C0010?SYS_TASK:
   84:     {
   85:         WDT_CONTR = 0x33;          //reset watch dog      SyttemClk is 11.0592M Over Time 568.8ms
   86:         if(taskCycle1sFlag == TRUE)
000FB9 75C133            MOV      WDT_CONTR,#033H
   87:         {
000FBC 3006FA            JNB      taskCycle1sFlag,?C0010?SYS_TASK
   88:         	taskCycle1sFlag = FALSE;
   89:             app_confingHandler1s();
000FBF C206              CLR      taskCycle1sFlag
   90:             app_brushCycle1s();
000FC1 F1C7              ACALL    app_confingHandler1s
   91:         }
000FC3 1167              ACALL    app_brushCycle1s
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 48


   92:     }
   93: }
000FC5 80F2              SJMP     ?C0010?SYS_TASK
----- FUNCTION main (END) -------


----- FUNCTION app_confingHandler1s (BEGIN) -----
 FILE: 'App\app_config.c'
  118: void app_confingHandler1s(void)
  119: {
  120:     led_Switch(OFF);
  121: //    hwa_eepromReadSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
000FC7 C201              CLR      ?led_Switch?BIT
000FC9 710A              ACALL    led_Switch
  122: //    sys_uartSendData((UINT8*)&USER_Card_ID, 5);
  123: //    USER_Card_ID[0][0]++;
  124: //    hwa_eepromWriteSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
  125:     led_Switch(ON);
000FCB D201              SETB     ?led_Switch?BIT
000FCD 610A              AJMP     led_Switch
----- FUNCTION app_confingHandler1s (END) -------


----- FUNCTION ?L?COM0045 (BEGIN) -----
000FCF 8E82              MOV      DPL,R6
000FD1 758300            MOV      DPH,#00H
000FD4 020174            LJMP     ?C?CSTOPTR
----- FUNCTION ?L?COM0045 (END) -------


----- FUNCTION ?L?COM004C (BEGIN) -----
000FD7 E0                MOVX     A,@DPTR
000FD8 04                INC      A
000FD9 F0                MOVX     @DPTR,A
000FDA E0                MOVX     A,@DPTR
000FDB C3                CLR      C
000FDC 9403              SUBB     A,#03H
000FDE 22                RET      
----- FUNCTION ?L?COM004C (END) -------


----- FUNCTION ?L?COM003F (BEGIN) -----
000FDF 9000C9            MOV      DPTR,#gLedBuf
000FE2 740C              MOV      A,#0CH
000FE4 F0                MOVX     @DPTR,A
000FE5 A3                INC      DPTR
000FE6 F0                MOVX     @DPTR,A
000FE7 A3                INC      DPTR
000FE8 F0                MOVX     @DPTR,A
000FE9 22                RET      
----- FUNCTION ?L?COM003F (END) -------


----- FUNCTION ?L?COM0025 (BEGIN) -----
000FEA FE                MOV      R6,A
000FEB 74BB              MOV      A,#LOW gBuff+02H
000FED 2F                ADD      A,R7
000FEE F582              MOV      DPL,A
000FF0 E4                CLR      A
000FF1 3400              ADDC     A,#HIGH gBuff+02H
000FF3         ?L?COM0026:
000FF3 F583              MOV      DPH,A
000FF5 EE                MOV      A,R6
000FF6 F0                MOVX     @DPTR,A
000FF7 0F                INC      R7
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 49


000FF8 EF                MOV      A,R7
000FF9 22                RET      
----- FUNCTION ?L?COM0025 (END) -------


----- FUNCTION sys_tim0Init (BEGIN) -----
 FILE: 'System\sys_tim.c'
  101: void sys_tim0Init(void)
  102: {
  103: 	TMOD &= 0xF0;
  104: 	TH0 = (UINT8)(T1MS>>8);
000FFA 5389F0            ANL      TMOD,#0F0H
  105: 	TL0 = (UINT8)T1MS;
000FFD 758CF8            MOV      TH0,#0F8H
  106: 	ET0 = 1;
001000 758ACD            MOV      TL0,#0CDH
  107: 	TR0 = 1;
001003 D2A9              SETB     ET0
  108: //	PT1 = 1;
001005 D28C              SETB     TR0
  109:     EA = 1;
001007 D2AF              SETB     EA
  110: }
001009 22                RET      
----- FUNCTION sys_tim0Init (END) -------


----- FUNCTION sys_tim0Isr (BEGIN) -----
 FILE: 'System\sys_task.c'
   41: void sys_tim0Isr(void) interrupt 1      //1ms interrupt task
00100A C0E0              PUSH     ACC
00100C C0F0              PUSH     B
00100E C083              PUSH     DPH
001010 C082              PUSH     DPL
001012 C0D0              PUSH     PSW
001014 75D000            MOV      PSW,#00H
001017 C000              PUSH     AR0
001019 C001              PUSH     AR1
00101B C002              PUSH     AR2
00101D C003              PUSH     AR3
00101F C004              PUSH     AR4
001021 C005              PUSH     AR5
001023 C006              PUSH     AR6
001025 C007              PUSH     AR7
   42: {
   43:     led_Handler1ms();
001027 11D0              ACALL    led_Handler1ms
   44:     app_pulseHandler1ms();
001029 1191              ACALL    app_pulseHandler1ms
   45: 	taskHandlerCnt10ms++;
00102B 9000D7            MOV      DPTR,#taskHandlerCnt10ms
00102E E0                MOVX     A,@DPTR
00102F 04                INC      A
001030 F0                MOVX     @DPTR,A
   46:     if(taskHandlerCnt10ms>=10)
001031 E0                MOVX     A,@DPTR
001032 C3                CLR      C
001033 940A              SUBB     A,#0AH
001035 400B              JC       ?C0003?SYS_TASK
   47:     {
   48:         taskHandlerCnt10ms = 0;
001037 E4                CLR      A
001038 F0                MOVX     @DPTR,A
   49:         sys_taskHandler10ms();
001039 12000A            LCALL    sys_taskHandler10ms
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 50


   50:         taskHandlerCnt100ms++;
00103C 9000D5            MOV      DPTR,#taskHandlerCnt100ms
00103F E0                MOVX     A,@DPTR
001040 04                INC      A
001041 F0                MOVX     @DPTR,A
   51:     }
001042         ?C0003?SYS_TASK:
   52:     if(taskHandlerCnt100ms>=10)
001042 9000D5            MOV      DPTR,#taskHandlerCnt100ms
001045 E0                MOVX     A,@DPTR
001046 C3                CLR      C
001047 940A              SUBB     A,#0AH
001049 400A              JC       ?C0004?SYS_TASK
   53:     {
   54:         taskHandlerCnt100ms = 0;
00104B E4                CLR      A
00104C F0                MOVX     @DPTR,A
   55:         sys_taskHandler100ms();
00104D 1180              ACALL    sys_taskHandler100ms
   56:         taskHandlerCnt1s++;
00104F 9000D6            MOV      DPTR,#taskHandlerCnt1s
001052 E0                MOVX     A,@DPTR
001053 04                INC      A
001054 F0                MOVX     @DPTR,A
   57:     }
001055         ?C0004?SYS_TASK:
   58:     if(taskHandlerCnt1s>=10)
001055 9000D6            MOV      DPTR,#taskHandlerCnt1s
001058 E0                MOVX     A,@DPTR
001059 C3                CLR      C
00105A 940A              SUBB     A,#0AH
00105C 4007              JC       ?C0006?SYS_TASK
   59:     {
   60:         taskHandlerCnt1s = 0;
00105E E4                CLR      A
00105F F0                MOVX     @DPTR,A
   61:         sys_taskHandler1s();
001060 120021            LCALL    sys_taskHandler1s
   62:         taskCycle1sFlag = TRUE;
001063 D206              SETB     taskCycle1sFlag
   63:     }
   64: }
001065         ?C0006?SYS_TASK:
001065 D007              POP      AR7
001067 D006              POP      AR6
001069 D005              POP      AR5
00106B D004              POP      AR4
00106D D003              POP      AR3
00106F D002              POP      AR2
001071 D001              POP      AR1
001073 D000              POP      AR0
001075 D0D0              POP      PSW
001077 D082              POP      DPL
001079 D083              POP      DPH
00107B D0F0              POP      B
00107D D0E0              POP      ACC
00107F 32                RETI     
----- FUNCTION sys_tim0Isr (END) -------


----- FUNCTION sys_taskHandler100ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   70: void sys_taskHandler100ms(void)           //100ms interrupt task
;----                  JMP      buzzer_Handler100ms
   71: {
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 51


----- FUNCTION sys_taskHandler100ms (END) -------


----- FUNCTION buzzer_Handler100ms (BEGIN) -----
 FILE: 'Driver\buzzer.c'
   15: void buzzer_Handler100ms(void)
   16: {
   17:     if(Buzzer)
   18: 	{
001080 30B503            JNB      Buzzer,?C0002?BUZZER
   19: 		Buzzer = 0;
   20: 	}
001083 C2B5              CLR      Buzzer
   21: 	else if(SoundNumberCount)
001085 22                RET      
001086         ?C0002?BUZZER:
   22: 	{
001086 9000DB            MOV      DPTR,#SoundNumberCount
001089 E0                MOVX     A,@DPTR
00108A 6004              JZ       ?C0005?BUZZER
   23: 		Buzzer = 1;
   24: 		SoundNumberCount--;
00108C D2B5              SETB     Buzzer
   25: 	}
00108E 14                DEC      A
00108F F0                MOVX     @DPTR,A
   26: }
   27: 
001090         ?C0005?BUZZER:
001090 22                RET      
----- FUNCTION buzzer_Handler100ms (END) -------


----- FUNCTION app_pulseHandler1ms (BEGIN) -----
 FILE: 'App\app_pulse.c'
   19: void app_pulseHandler1ms(void)
   20: {
   21:     if(u8_pulse)
   22:     {
001091 9000D2            MOV      DPTR,#u8_pulse
001094 E0                MOVX     A,@DPTR
001095 6038              JZ       ?C0007?APP_PULSE
   23:         u16_count++;
   24:         if(u16_count<=u8_width)
001097 9000D4            MOV      DPTR,#u16_count+01H
00109A E0                MOVX     A,@DPTR
00109B 04                INC      A
00109C F0                MOVX     @DPTR,A
00109D 7006              JNZ      ?C0009?APP_PULSE
00109F 9000D3            MOV      DPTR,#u16_count
0010A2 E0                MOVX     A,@DPTR
0010A3 04                INC      A
0010A4 F0                MOVX     @DPTR,A
0010A5         ?C0009?APP_PULSE:
   25:         {
0010A5 9000D1            MOV      DPTR,#u8_width
0010A8 E0                MOVX     A,@DPTR
0010A9 FF                MOV      R7,A
0010AA 9000D3            MOV      DPTR,#u16_count
0010AD 510B              ACALL    ?L?COM0047
0010AF 9400              SUBB     A,#00H
0010B1 5003              JNC      ?C0003?APP_PULSE
   26:             pulse = 1;
   27:         }
0010B3 D2B7              SETB     pulse
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 52


   28:         else if(u16_count<=PULSE_Interval)
0010B5 22                RET      
0010B6         ?C0003?APP_PULSE:
   29:         {
0010B6 D3                SETB     C
0010B7 ED                MOV      A,R5
0010B8 942C              SUBB     A,#02CH
0010BA EC                MOV      A,R4
0010BB 9401              SUBB     A,#01H
0010BD 5003              JNC      ?C0005?APP_PULSE
   30:             pulse = 0;
   31:         }
0010BF C2B7              CLR      pulse
   32:         else
0010C1 22                RET      
0010C2         ?C0005?APP_PULSE:
   33:         {
   34:             u16_count = 0;
0010C2 E4                CLR      A
0010C3 9000D3            MOV      DPTR,#u16_count
0010C6 F0                MOVX     @DPTR,A
0010C7 A3                INC      DPTR
0010C8 F0                MOVX     @DPTR,A
   35:             u8_pulse--;
0010C9 9000D2            MOV      DPTR,#u8_pulse
0010CC E0                MOVX     A,@DPTR
0010CD 14                DEC      A
0010CE F0                MOVX     @DPTR,A
   36:         }
   37:     }
   38: }
0010CF         ?C0007?APP_PULSE:
0010CF 22                RET      
----- FUNCTION app_pulseHandler1ms (END) -------


----- FUNCTION led_Handler1ms (BEGIN) -----
 FILE: 'Driver\LED.c'
   30: void led_Handler1ms(void)
   31: {
   32:     if(ledsw)
   33:     {
0010D0 200802            JB       ledsw,$ + 5H
0010D3 21D6              AJMP     ?C0033?LED
   34:     	if (gCurLed<5)
   35:     		gCurLed++;
0010D5 9000CF            MOV      DPTR,#gCurLed
0010D8 E0                MOVX     A,@DPTR
0010D9 C3                CLR      C
0010DA 9405              SUBB     A,#05H
0010DC 5005              JNC      ?C0003?LED
   36:     	else
0010DE E0                MOVX     A,@DPTR
0010DF 04                INC      A
0010E0 F0                MOVX     @DPTR,A
0010E1 8005              SJMP     ?C0004?LED
0010E3         ?C0003?LED:
   37:     		gCurLed=0;
0010E3 E4                CLR      A
0010E4 9000CF            MOV      DPTR,#gCurLed
0010E7 F0                MOVX     @DPTR,A
0010E8         ?C0004?LED:
   38:     	LED_CS0 = 1;
0010E8 5114              ACALL    ?L?COM003E
   39:     	LED_CS1 = 1;
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 53


   40:     	LED_CS2 = 1;
   41:     	LED_CS3 = 1;
   42:     	LED_CS4 = 1;
   43:     	LED_CS5 = 1;
0010EA D2B6              SETB     LED_CS5
   44:     	switch ( gLedBuf[gCurLed])		 //switch case 语句中 switch中的条件case都不满足就执行default
0010EC 9000CF            MOV      DPTR,#gCurLed
0010EF E0                MOVX     A,@DPTR
0010F0 FF                MOV      R7,A
0010F1 24C9              ADD      A,#LOW gLedBuf
0010F3 F582              MOV      DPL,A
0010F5 E4                CLR      A
0010F6 3400              ADDC     A,#HIGH gLedBuf
0010F8 F583              MOV      DPH,A
0010FA E0                MOVX     A,@DPTR
0010FB B41100            CJNE     A,#011H,?C0040?LED
0010FE         ?C0040?LED:
0010FE 4002              JC       $ + 4H
001100 218E              AJMP     ?C0023?LED
001102 901109            MOV      DPTR,#01109H
001105 F8                MOV      R0,A
001106 28                ADD      A,R0
001107 28                ADD      A,R0
001108 73                JMP      @A+DPTR
001109         ?C0041?LED:
001109 02113C            LJMP     ?C0006?LED
00110C 021141            LJMP     ?C0007?LED
00110F 021146            LJMP     ?C0008?LED
001112 02114B            LJMP     ?C0009?LED
001115 021150            LJMP     ?C0010?LED
001118 021155            LJMP     ?C0011?LED
00111B 02115A            LJMP     ?C0012?LED
00111E 02115F            LJMP     ?C0013?LED
001121 021164            LJMP     ?C0014?LED
001124 021169            LJMP     ?C0015?LED
001127 02116E            LJMP     ?C0016?LED
00112A 021173            LJMP     ?C0017?LED
00112D 021178            LJMP     ?C0018?LED
001130 02117A            LJMP     ?C0019?LED
001133 02117F            LJMP     ?C0020?LED
001136 021184            LJMP     ?C0021?LED
001139 021189            LJMP     ?C0022?LED
   45:     	{
   46:     	    case 0:	P1 = 0xeb; break;//0X88
00113C         ?C0006?LED:
00113C 7590EB            MOV      P1,#0EBH
00113F 8050              SJMP     ?C0005?LED
   47:     		case 1:	P1 = 0x88; break;//0XEB
001141         ?C0007?LED:
001141 759088            MOV      P1,#088H
001144 804B              SJMP     ?C0005?LED
   48:     		case 2:	P1 = 0xB3; break;//0X92
001146         ?C0008?LED:
001146 7590B3            MOV      P1,#0B3H
001149 8046              SJMP     ?C0005?LED
   49:     		case 3:	P1 = 0xba; break;//0XC2
00114B         ?C0009?LED:
00114B 7590BA            MOV      P1,#0BAH
00114E 8041              SJMP     ?C0005?LED
   50:     		case 4:	P1 = 0xd8; break;//0XE1
001150         ?C0010?LED:
001150 7590D8            MOV      P1,#0D8H
001153 803C              SJMP     ?C0005?LED
   51:     		case 5:	P1 = 0x7a; break;//0XC4
001155         ?C0011?LED:
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 54


001155 75907A            MOV      P1,#07AH
001158 8037              SJMP     ?C0005?LED
   52:     		case 6:	P1 = 0x7b; break;//0X84
00115A         ?C0012?LED:
00115A 75907B            MOV      P1,#07BH
00115D 8032              SJMP     ?C0005?LED
   53:     		case 7:	P1 = 0xa8; break;//0XEA
00115F         ?C0013?LED:
00115F 7590A8            MOV      P1,#0A8H
001162 802D              SJMP     ?C0005?LED
   54:     		case 8:	P1 = 0xfb; break;//0X80
001164         ?C0014?LED:
001164 7590FB            MOV      P1,#0FBH
001167 8028              SJMP     ?C0005?LED
   55:     		case 9:	P1 = 0xfa; break;//0XC0
001169         ?C0015?LED:
001169 7590FA            MOV      P1,#0FAH
00116C 8023              SJMP     ?C0005?LED
   56:     		case 10:P1 = 0xcb; break;//0XC0 U
00116E         ?C0016?LED:
00116E 7590CB            MOV      P1,#0CBH
001171 801E              SJMP     ?C0005?LED
   57:     		case 11:P1 = 0xbe; break;//3.
001173         ?C0017?LED:
001173 7590BE            MOV      P1,#0BEH
001176 8019              SJMP     ?C0005?LED
   58:     		case 12:P1 = 0x00; break;//空
001178         ?C0018?LED:
001178 8014              SJMP     ?C0044?LED
   59:     		case 13:P1 = 0x7e; break;//5.
00117A         ?C0019?LED:
00117A 75907E            MOV      P1,#07EH
00117D 8012              SJMP     ?C0005?LED
   60:             case 14:P1 = 0xf1;break;//P
00117F         ?C0020?LED:
00117F 7590F1            MOV      P1,#0F1H
001182 800D              SJMP     ?C0005?LED
   61:             case 15:P1 = 0x10;break;//-
001184         ?C0021?LED:
001184 759010            MOV      P1,#010H
001187 8008              SJMP     ?C0005?LED
   62:             case 16:P1 = 0xf9;break;//-
001189         ?C0022?LED:
001189 7590F9            MOV      P1,#0F9H
00118C 8003              SJMP     ?C0005?LED
   63:     		default:P1 = 0x00; break;
00118E         ?C0023?LED:
00118E         
00118E E4                CLR      A
00118F F590              MOV      P1,A
   64:     	}
001191         ?C0005?LED:
   65:         if(gShowDot & (1<<gCurLed))//show dot
001191 7401              MOV      A,#01H
001193 7E00              MOV      R6,#00H
001195 A807              MOV      R0,AR7
001197 08                INC      R0
001198 8005              SJMP     ?C0043?LED
00119A         ?C0042?LED:
00119A C3                CLR      C
00119B 33                RLC      A
00119C CE                XCH      A,R6
00119D 33                RLC      A
00119E CE                XCH      A,R6
00119F         ?C0043?LED:
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 55


00119F D8F9              DJNZ     R0,?C0042?LED
0011A1 FF                MOV      R7,A
0011A2 9000D0            MOV      DPTR,#gShowDot
0011A5 E0                MOVX     A,@DPTR
0011A6 FD                MOV      R5,A
0011A7 EF                MOV      A,R7
0011A8 5D                ANL      A,R5
0011A9 6003              JZ       ?C0024?LED
   66:         {
   67:      		P1 |= 0X04;
0011AB 439004            ORL      P1,#04H
   68:         }
0011AE         ?C0024?LED:
   69:     	switch (gCurLed)
0011AE 9000CF            MOV      DPTR,#gCurLed
0011B1 E0                MOVX     A,@DPTR
0011B2 14                DEC      A
0011B3 6013              JZ       ?C0027?LED
0011B5 14                DEC      A
0011B6 6013              JZ       ?C0028?LED
0011B8 14                DEC      A
0011B9 6013              JZ       ?C0029?LED
0011BB 14                DEC      A
0011BC 6013              JZ       ?C0030?LED
0011BE 14                DEC      A
0011BF 6013              JZ       ?C0031?LED
0011C1 2405              ADD      A,#05H
0011C3 7011              JNZ      ?C0033?LED
   70:     	{
   71:     		case 0:
0011C5         ?C0026?LED:
   72:     			LED_CS0 = 0;
0011C5 C2A6              CLR      LED_CS0
   73:     			break;
0011C7 22                RET      
   74:     		case 1:
0011C8         ?C0027?LED:
   75:     			LED_CS1 = 0;
0011C8 C2A7              CLR      LED_CS1
   76:     			break;
0011CA 22                RET      
   77:     		case 2:
0011CB         ?C0028?LED:
   78:     			LED_CS2 = 0;
0011CB C2A0              CLR      LED_CS2
   79:     			break;
0011CD 22                RET      
   80:     		case 3:
0011CE         ?C0029?LED:
   81:     			LED_CS3 = 0;
0011CE C2CD              CLR      LED_CS3
   82:     			break;
0011D0 22                RET      
   83:     		case 4:
0011D1         ?C0030?LED:
   84:     			LED_CS4 = 0;
0011D1 C2CC              CLR      LED_CS4
   85:     			break;
0011D3 22                RET      
   86:     		case 5:
0011D4         ?C0031?LED:
   87:     			LED_CS5 = 0;
0011D4 C2B6              CLR      LED_CS5
   88:     			break;
   89:     		default:
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 56


   90:     			break;
   91:     	}
   92:     }
   93: }
0011D6         ?C0033?LED:
0011D6 22                RET      
----- FUNCTION led_Handler1ms (END) -------


----- FUNCTION ?L?COM000E (BEGIN) -----
0011D7 2E                ADD      A,R6
0011D8 F9                MOV      R1,A
0011D9 E4                CLR      A
0011DA 3A                ADDC     A,R2
0011DB FA                MOV      R2,A
0011DC 12011C            LCALL    ?C?CLDPTR
0011DF FF                MOV      R7,A
0011E0 EE                MOV      A,R6
0011E1 75F005            MOV      B,#05H
0011E4 84                DIV      AB
0011E5 74B4              MOV      A,#LOW gCard_UID
0011E7 25F0              ADD      A,B
0011E9         ?L?COM000F:
0011E9 F582              MOV      DPL,A
0011EB E4                CLR      A
0011EC 3400              ADDC     A,#HIGH gCard_UID
0011EE F583              MOV      DPH,A
0011F0 22                RET      
----- FUNCTION ?L?COM000E (END) -------


----- FUNCTION sys_uartInit (BEGIN) -----
 FILE: 'System\sys_uart.c'
   13: void sys_uartInit(void)
   14: {
   15:     ACC = P_SW1;
   16:     ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
0011F1 E5A2              MOV      A,P_SW1
   17:     P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
0011F3 543F              ANL      A,#03FH
   18:     SCON = 0x50;                //8位可变波特率
0011F5 F5A2              MOV      P_SW1,A
   19:     T2L = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
0011F7 759850            MOV      SCON,#050H
   20:     T2H = (65536 - (FOSC/4/BAUD))>>8;
0011FA 75D7E0            MOV      T2L,#0E0H
   21:     AUXR |= 0x14;                //T2为1T模式, 并启动定时器2
0011FD 75D6FE            MOV      T2H,#0FEH
   22:     AUXR |= 0x01;               //选择定时器2为串口1的波特率发生器
001200 438E14            ORL      AUXR,#014H
   23:     ES = 1;                     //使能串口1中断
001203 438E01            ORL      AUXR,#01H
   24:     EA = 1;
001206 D2AC              SETB     ES
   25: }
001208 D2AF              SETB     EA
   26: 
00120A 22                RET      
----- FUNCTION sys_uartInit (END) -------


----- FUNCTION ?L?COM0047 (BEGIN) -----
00120B E0                MOVX     A,@DPTR
00120C FC                MOV      R4,A
00120D A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 57


00120E E0                MOVX     A,@DPTR
00120F FD                MOV      R5,A
001210 D3                SETB     C
001211 9F                SUBB     A,R7
001212 EC                MOV      A,R4
001213 22                RET      
----- FUNCTION ?L?COM0047 (END) -------


----- FUNCTION ?L?COM003E (BEGIN) -----
001214 D2A6              SETB     LED_CS0
001216 D2A7              SETB     LED_CS1
001218 D2A0              SETB     LED_CS2
00121A D2CD              SETB     LED_CS3
00121C D2CC              SETB     LED_CS4
00121E 22                RET      
----- FUNCTION ?L?COM003E (END) -------


----- FUNCTION sys_uartInterrupt (BEGIN) -----
 FILE: 'System\sys_uart.c'
   27: void sys_uartInterrupt() interrupt 4
00121F C0E0              PUSH     ACC
001221 C0F0              PUSH     B
001223 C083              PUSH     DPH
001225 C082              PUSH     DPL
001227 C0D0              PUSH     PSW
001229 75D000            MOV      PSW,#00H
00122C C000              PUSH     AR0
00122E C001              PUSH     AR1
001230 C002              PUSH     AR2
001232 C003              PUSH     AR3
001234 C004              PUSH     AR4
001236 C005              PUSH     AR5
001238 C006              PUSH     AR6
00123A C007              PUSH     AR7
   28: {
   29:     if(RI)
00123C 309804            JNB      RI,?C0002?SYS_UART
   30:     {
   31:         RI = 0;
00123F C298              CLR      RI
   32:         sys_uartRxHandler();
001241 5163              ACALL    sys_uartRxHandler
   33:     }
001243         ?C0002?SYS_UART:
   34:     if(TI)
001243 309902            JNB      TI,?C0004?SYS_UART
   35:     {
   36:         TI = 0;
001246 C299              CLR      TI
   37:     }
   38: }
001248         ?C0004?SYS_UART:
001248 D007              POP      AR7
00124A D006              POP      AR6
00124C D005              POP      AR5
00124E D004              POP      AR4
001250 D003              POP      AR3
001252 D002              POP      AR2
001254 D001              POP      AR1
001256 D000              POP      AR0
001258 D0D0              POP      PSW
00125A D082              POP      DPL
00125C D083              POP      DPH
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 58


00125E D0F0              POP      B
001260 D0E0              POP      ACC
001262 32                RETI     
----- FUNCTION sys_uartInterrupt (END) -------


----- FUNCTION sys_uartRxHandler (BEGIN) -----
 FILE: 'System\sys_uart.c'
   41: void sys_uartRxHandler(void)
   42: {
   43:     if(SBUF == 0x7F)        //0x7F auto download     boud 2400 0x7F at boud 9600 is 0xF8
   44:     {
001263 E599              MOV      A,SBUF
001265 B47F10            CJNE     A,#07FH,?C0005?SYS_UART
   45:         RxNum++;
   46:         if(RxNum >= 40)
001268 9000DA            MOV      DPTR,#RxNum
00126B E0                MOVX     A,@DPTR
00126C 04                INC      A
00126D F0                MOVX     @DPTR,A
   47:         {
00126E E0                MOVX     A,@DPTR
00126F C3                CLR      C
001270 9428              SUBB     A,#028H
001272 4009              JC       ?C0008?SYS_UART
   48:             IAP_CONTR = 0x60;
   49:         }
001274 75C760            MOV      IAP_CONTR,#060H
   50:     }
   51:     else
001277 22                RET      
001278         ?C0005?SYS_UART:
   52:     {
   53:         RxNum = 0;
001278 E4                CLR      A
001279 9000DA            MOV      DPTR,#RxNum
00127C F0                MOVX     @DPTR,A
   54:     }
   55: }
00127D         ?C0008?SYS_UART:
00127D 22                RET      
----- FUNCTION sys_uartRxHandler (END) -------


----- FUNCTION IapIdle (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   24: void IapIdle(void)
   25: {
   26:     IAP_CONTR = 0;                  //关闭IAP功能
   27:     IAP_CMD = 0;                    //清除命令寄存器
00127E E4                CLR      A
00127F F5C7              MOV      IAP_CONTR,A
   28:     IAP_TRIG = 0;                   //清除触发寄存器
001281 F5C5              MOV      IAP_CMD,A
   29:     IAP_ADDRH = 0x80;               //将地址设置到非IAP区域
001283 F5C6              MOV      IAP_TRIG,A
   30:     IAP_ADDRL = 0;
001285 75C380            MOV      IAP_ADDRH,#080H
   31: }
001288 F5C4              MOV      IAP_ADDRL,A
   32: 
00128A 22                RET      
----- FUNCTION IapIdle (END) -------


LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 59


----- FUNCTION ?L?COM0027 (BEGIN) -----
00128B E0                MOVX     A,@DPTR
00128C FE                MOV      R6,A
00128D A3                INC      DPTR
00128E E0                MOVX     A,@DPTR
00128F FF                MOV      R7,A
----- FUNCTION _sys_eepromEraseSector (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   72: void sys_eepromEraseSector(UINT16 addr)
   73: {
;---- Variable 'addr' assigned to Register 'R6/R7' ----
   74:     IAP_CONTR = ENABLE_IAP;         //使能IAP
   75:     IAP_CMD = CMD_ERASE;            //设置IAP命令
001290 75C780            MOV      IAP_CONTR,#080H
   76:     IAP_ADDRL = addr;               //设置IAP低地址
001293 75C503            MOV      IAP_CMD,#03H
   77:     IAP_ADDRH = addr >> 8;          //设置IAP高地址
001296 8FC4              MOV      IAP_ADDRL,R7
   78:     IAP_TRIG = 0x5a;                //写触发命令(0x5a)
001298 EE                MOV      A,R6
001299 B15A              ACALL    ?L?COM003B
   79:     IAP_TRIG = 0xa5;                //写触发命令(0xa5)
   80:     _nop_();                        //等待ISP/IAP/EEPROM操作完成
00129B 00                NOP      
   81:     IapIdle();
00129C 80E0              SJMP     IapIdle
----- FUNCTION _sys_eepromEraseSector (END) -------


----- FUNCTION _hwa_eepromReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   37: BOOL hwa_eepromReadSector(UINT8 *dat, UINT8 sector)
   38: {
00129E 120E9D            LCALL    ?L?COM0003
0012A1 A3                INC      DPTR
0012A2 ED                MOV      A,R5
0012A3 F0                MOVX     @DPTR,A
   39: 	BOOL e2_error = FALSE, e2_bak_error = FALSE;
   40: 	UINT16 e2_addr, e2_bak_addr;
0012A4 C202              CLR      e2_error
0012A6 C203              CLR      e2_bak_error
   41: 	UINT16 e2_check_sum, e2_bak_check_sum;
   42: 	UINT16 Size, SectorSize;
   43: 
   44: 	if (sector >= c_u8_eepromSectorNum)
0012A8 B1B7              ACALL    ?L?COM0043
0012AA 4001              JC       ?C0002?HWA_EEPROM
   45: 	{
   46: 		return FALSE;
0012AC 22                RET      
   47: 	}
0012AD         ?C0002?HWA_EEPROM:
   48: 	Size = c_s_eepromConfig[sector].UseSize;
0012AD 900082            MOV      DPTR,#sector
0012B0 B1CD              ACALL    ?L?COM0028
0012B2 FC                MOV      R4,A
0012B3 7401              MOV      A,#01H
0012B5 93                MOVC     A,@A+DPTR
0012B6 FD                MOV      R5,A
0012B7 90008B            MOV      DPTR,#Size
0012BA 91C8              ACALL    ?L?COM0005
0012BC 900083            MOV      DPTR,#e2_addr
0012BF B19D              ACALL    ?L?COM004D
0012C1 91EF              ACALL    ?L?COM0006
0012C3 900085            MOV      DPTR,#e2_bak_addr
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 60


0012C6 F0                MOVX     @DPTR,A
0012C7 A3                INC      DPTR
0012C8 CE                XCH      A,R6
0012C9 F0                MOVX     @DPTR,A
   49: 	SectorSize = Size + 2;
   50: 
   51: 	e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
   52: 	e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
   53: 
   54: 	sys_eepromRead(e2_addr, e2_data, SectorSize);
0012CA 71C3              ACALL    ?L?COM0010
0012CC 90008D            MOV      DPTR,#SectorSize
0012CF 9194              ACALL    ?L?COM0008
0012D1 B107              ACALL    ?L?COM000B
0012D3 6006              JZ       ?C0004?HWA_EEPROM
   55: 	if (c_s_eepromConfig[sector].Encrypt)
   56: 	{
   57: 		hwa_eepromDecrypt(e2_data, Size);
0012D5 71CB              ACALL    ?L?COM0011
0012D7 71D8              ACALL    ?L?COM0015
0012D9 B16C              ACALL    _hwa_eepromDecrypt
   58: 	}
0012DB         ?C0004?HWA_EEPROM:
   59: 	e2_check_sum = e2_data[Size] << 8 | e2_data[Size + 1];
0012DB 71D8              ACALL    ?L?COM0015
0012DD 2400              ADD      A,#LOW e2_data
0012DF F582              MOV      DPL,A
0012E1 7400              MOV      A,#HIGH e2_data
0012E3 3C                ADDC     A,R4
0012E4 F583              MOV      DPH,A
0012E6 E0                MOVX     A,@DPTR
0012E7 FE                MOV      R6,A
0012E8 7401              MOV      A,#LOW e2_data+01H
0012EA 2D                ADD      A,R5
0012EB F582              MOV      DPL,A
0012ED 7400              MOV      A,#HIGH e2_data+01H
0012EF B152              ACALL    ?L?COM004E
0012F1 900087            MOV      DPTR,#e2_check_sum
0012F4 EE                MOV      A,R6
0012F5 F0                MOVX     @DPTR,A
0012F6 A3                INC      DPTR
0012F7 EF                MOV      A,R7
0012F8 F0                MOVX     @DPTR,A
   60: 
   61: 	sys_eepromRead(e2_bak_addr, e2_data_bak, SectorSize);
0012F9 91F8              ACALL    ?L?COM002A
0012FB 90008D            MOV      DPTR,#SectorSize
0012FE 9194              ACALL    ?L?COM0008
001300 B107              ACALL    ?L?COM000B
001302 6004              JZ       ?C0005?HWA_EEPROM
   62: 	if (c_s_eepromConfig[sector].Encrypt)
   63: 	{
   64: 		hwa_eepromDecrypt(e2_data_bak, Size);
001304 71D2              ACALL    ?L?COM0014
001306 B16C              ACALL    _hwa_eepromDecrypt
   65: 	}
001308         ?C0005?HWA_EEPROM:
   66: 	e2_bak_check_sum = e2_data_bak[Size] << 8 | e2_data_bak[Size + 1];
001308 71D8              ACALL    ?L?COM0015
00130A 2420              ADD      A,#LOW e2_data_bak
00130C F582              MOV      DPL,A
00130E 7400              MOV      A,#HIGH e2_data_bak
001310 3C                ADDC     A,R4
001311 F583              MOV      DPH,A
001313 E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 61


001314 FE                MOV      R6,A
001315 7421              MOV      A,#LOW e2_data_bak+01H
001317 2D                ADD      A,R5
001318 F582              MOV      DPL,A
00131A 7400              MOV      A,#HIGH e2_data_bak+01H
00131C B152              ACALL    ?L?COM004E
00131E 900089            MOV      DPTR,#e2_bak_check_sum
001321 EE                MOV      A,R6
001322 F0                MOVX     @DPTR,A
001323 A3                INC      DPTR
001324 EF                MOV      A,R7
001325 F0                MOVX     @DPTR,A
   67: 
   68: 	if (e2_check_sum != hwa_mifareCheckOut(e2_data, Size))
001326 71CB              ACALL    ?L?COM0011
001328 A3                INC      DPTR
001329 A3                INC      DPTR
00132A E0                MOVX     A,@DPTR
00132B FD                MOV      R5,A
00132C 120E4D            LCALL    _hwa_mifareCheckOut
00132F 900087            MOV      DPTR,#e2_check_sum
001332 E0                MOVX     A,@DPTR
001333 6E                XRL      A,R6
001334 7003              JNZ      ?C0017?HWA_EEPROM
001336 A3                INC      DPTR
001337 E0                MOVX     A,@DPTR
001338 6F                XRL      A,R7
001339         ?C0017?HWA_EEPROM:
001339 6002              JZ       ?C0006?HWA_EEPROM
   69: 	{
   70: 		e2_error = TRUE;
00133B D202              SETB     e2_error
   71: 	}
00133D         ?C0006?HWA_EEPROM:
   72: 	if (e2_bak_check_sum != hwa_mifareCheckOut(e2_data_bak, Size))
00133D 71D2              ACALL    ?L?COM0014
00133F 120E4D            LCALL    _hwa_mifareCheckOut
001342 900089            MOV      DPTR,#e2_bak_check_sum
001345 E0                MOVX     A,@DPTR
001346 6E                XRL      A,R6
001347 7003              JNZ      ?C0018?HWA_EEPROM
001349 A3                INC      DPTR
00134A E0                MOVX     A,@DPTR
00134B 6F                XRL      A,R7
00134C         ?C0018?HWA_EEPROM:
00134C 6002              JZ       ?C0007?HWA_EEPROM
   73: 	{
   74: 		e2_bak_error = TRUE;
00134E D203              SETB     e2_bak_error
   75: 	}
001350         ?C0007?HWA_EEPROM:
   76: 
   77: 	if (e2_error && e2_bak_error)    //~1~备份块和正常块都校验错误，返回错误
001350 300205            JNB      e2_error,?C0008?HWA_EEPROM
001353 300302            JNB      e2_bak_error,?C0008?HWA_EEPROM
   78: 	{
   79: 		return FALSE;
001356 C3                CLR      C
001357 22                RET      
   80: 	}
001358         ?C0008?HWA_EEPROM:
   81: 	else if (e2_error)                                 //~2~备份块校验错误，恢复正常块
001358 300213            JNB      e2_error,?C0010?HWA_EEPROM
   82: 	{
   83: 		memcpy(e2_data, e2_data_bak, SectorSize);
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 62


00135B 90008D            MOV      DPTR,#SectorSize
00135E B1C1              ACALL    ?L?COM0039
001360 B100              ACALL    ?L?COM002B
001362 1200F6            LCALL    ?C?COPY
   84: 		sys_eepromEraseSector(e2_addr);
001365 900083            MOV      DPTR,#e2_addr
001368 518B              ACALL    ?L?COM0027
   85: 		sys_eepromWrite(e2_addr, e2_data, SectorSize);
00136A 71C3              ACALL    ?L?COM0010
   86: 	}
00136C 8037              SJMP     ?C0020?HWA_EEPROM
00136E         ?C0010?HWA_EEPROM:
   87: 	else if (e2_bak_error ||                          //~3~正常块校验错误，恢复备份块
00136E 20031A            JB       e2_bak_error,?C0013?HWA_EEPROM
001371 200238            JB       e2_error,?C0009?HWA_EEPROM
001374 200335            JB       e2_bak_error,?C0009?HWA_EEPROM
001377 900089            MOV      DPTR,#e2_bak_check_sum
00137A E0                MOVX     A,@DPTR
00137B FE                MOV      R6,A
00137C A3                INC      DPTR
00137D E0                MOVX     A,@DPTR
00137E FF                MOV      R7,A
00137F 900087            MOV      DPTR,#e2_check_sum
001382 E0                MOVX     A,@DPTR
001383 6E                XRL      A,R6
001384 7003              JNZ      ?C0019?HWA_EEPROM
001386 A3                INC      DPTR
001387 E0                MOVX     A,@DPTR
001388 6F                XRL      A,R7
001389         ?C0019?HWA_EEPROM:
001389 6021              JZ       ?C0009?HWA_EEPROM
00138B         ?C0013?HWA_EEPROM:
   88: 		(e2_error == FALSE                                //~4~正常块、备份块都检验正确，但数据不同，则以
   89: 		&& e2_bak_error == FALSE                         //   最新写入的正常块覆盖备份块
   90: 		&& e2_check_sum != e2_bak_check_sum)
   91: 		)
   92: 	{
   93: 		memcpy(e2_data_bak, e2_data, SectorSize);
00138B 90008D            MOV      DPTR,#SectorSize
00138E E0                MOVX     A,@DPTR
00138F FE                MOV      R6,A
001390 A3                INC      DPTR
001391 E0                MOVX     A,@DPTR
001392 FF                MOV      R7,A
001393 7820              MOV      R0,#LOW e2_data_bak
001395 7C00              MOV      R4,#HIGH e2_data_bak
001397 7D01              MOV      R5,#01H
001399 71CB              ACALL    ?L?COM0011
00139B 1200F6            LCALL    ?C?COPY
   94: 		sys_eepromEraseSector(e2_bak_addr);
00139E 900085            MOV      DPTR,#e2_bak_addr
0013A1 518B              ACALL    ?L?COM0027
   95: 		sys_eepromWrite(e2_bak_addr, e2_data_bak, SectorSize);
0013A3 91F8              ACALL    ?L?COM002A
0013A5         
0013A5 90008D            MOV      DPTR,#SectorSize
0013A8 9194              ACALL    ?L?COM0008
0013AA 91A1              ACALL    _sys_eepromWrite
   96: 	}
0013AC         ?C0009?HWA_EEPROM:
   97: 	memcpy(dat, e2_data, Size);
0013AC 90008B            MOV      DPTR,#Size
0013AF E0                MOVX     A,@DPTR
0013B0 FE                MOV      R6,A
0013B1 A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 63


0013B2 E0                MOVX     A,@DPTR
0013B3 FF                MOV      R7,A
0013B4 1207F0            LCALL    ?L?COM0001
0013B7 F8                MOV      R0,A
0013B8 AC02              MOV      R4,AR2
0013BA AD03              MOV      R5,AR3
0013BC 71CB              ACALL    ?L?COM0011
0013BE 1200F6            LCALL    ?C?COPY
   98: 	return TRUE;
0013C1 D3                SETB     C
   99: }
0013C2 22                RET      
----- FUNCTION _hwa_eepromReadSector (END) -------


----- FUNCTION ?L?COM0010 (BEGIN) -----
0013C3 900083            MOV      DPTR,#e2_addr
0013C6 E0                MOVX     A,@DPTR
0013C7 FE                MOV      R6,A
0013C8 A3                INC      DPTR
0013C9 E0                MOVX     A,@DPTR
0013CA FF                MOV      R7,A
0013CB         ?L?COM0011:
0013CB 7B01              MOV      R3,#01H
0013CD 7A00              MOV      R2,#HIGH e2_data
0013CF 7900              MOV      R1,#LOW e2_data
0013D1 22                RET      
----- FUNCTION ?L?COM0010 (END) -------


----- FUNCTION ?L?COM0014 (BEGIN) -----
0013D2 7B01              MOV      R3,#01H
0013D4 7A00              MOV      R2,#HIGH e2_data_bak
0013D6 7920              MOV      R1,#LOW e2_data_bak
0013D8         ?L?COM0015:
0013D8 90008B            MOV      DPTR,#Size
0013DB E0                MOVX     A,@DPTR
0013DC FC                MOV      R4,A
0013DD A3                INC      DPTR
0013DE E0                MOVX     A,@DPTR
0013DF FD                MOV      R5,A
0013E0 22                RET      
----- FUNCTION ?L?COM0014 (END) -------


----- FUNCTION _hwa_eepromWriteSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
  101: BOOL hwa_eepromWriteSector(UINT8 *dat, UINT8 sector)
  102: {
0013E1 900071            MOV      DPTR,#dat
0013E4 120EA0            LCALL    ?L?COM0004
0013E7 A3                INC      DPTR
0013E8 ED                MOV      A,R5
0013E9 F0                MOVX     @DPTR,A
  103: 	UINT16 e2_addr, e2_bak_addr;
  104: 	UINT16 e2_check_sum;
  105: 
  106: 	UINT16 Size, SectorSize;
  107: 
  108: 	if (sector >= c_u8_eepromSectorNum)
0013EA B1B7              ACALL    ?L?COM0043
0013EC 4001              JC       ?C0014?HWA_EEPROM
  109: 	{
  110: 		return FALSE;
0013EE 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 64


  111: 	}
0013EF         ?C0014?HWA_EEPROM:
  112: 	Size = c_s_eepromConfig[sector].UseSize;
0013EF 900074            MOV      DPTR,#sector
0013F2 B1CD              ACALL    ?L?COM0028
0013F4 FC                MOV      R4,A
0013F5 7401              MOV      A,#01H
0013F7 93                MOVC     A,@A+DPTR
0013F8 FD                MOV      R5,A
0013F9 90007B            MOV      DPTR,#Size
0013FC 91C8              ACALL    ?L?COM0005
0013FE 900075            MOV      DPTR,#e2_addr
001401 B19D              ACALL    ?L?COM004D
001403 91EF              ACALL    ?L?COM0006
001405 900077            MOV      DPTR,#e2_bak_addr
001408 F0                MOVX     @DPTR,A
001409 A3                INC      DPTR
00140A CE                XCH      A,R6
00140B F0                MOVX     @DPTR,A
  113: 	SectorSize = Size + 2;
  114: 
  115: 	e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
  116: 	e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
  117: 	e2_check_sum = hwa_mifareCheckOut(dat, Size);
00140C 900071            MOV      DPTR,#dat
00140F 1207F3            LCALL    ?L?COM0002
001412 F9                MOV      R1,A
001413 B163              ACALL    ?L?COM0046
001415 120E4D            LCALL    _hwa_mifareCheckOut
001418 900079            MOV      DPTR,#e2_check_sum
00141B EE                MOV      A,R6
00141C F0                MOVX     @DPTR,A
00141D A3                INC      DPTR
00141E EF                MOV      A,R7
00141F F0                MOVX     @DPTR,A
  118: 
  119: 	hwa_eepromReadSector(e2_data, sector);                                  //  写入之前，如果有错误块，先恢复
001420 71CB              ACALL    ?L?COM0011
001422 900074            MOV      DPTR,#sector
001425 E0                MOVX     A,@DPTR
001426 FD                MOV      R5,A
001427 519E              ACALL    _hwa_eepromReadSector
  120: 
  121: 	memcpy(e2_data, dat, Size);
001429 90007B            MOV      DPTR,#Size
00142C B1C1              ACALL    ?L?COM0039
00142E 900071            MOV      DPTR,#dat
001431 1207F3            LCALL    ?L?COM0002
001434 F9                MOV      R1,A
001435 1200F6            LCALL    ?C?COPY
  122: 
  123: 	if (c_s_eepromConfig[sector].Encrypt)
001438 900074            MOV      DPTR,#sector
00143B B10C              ACALL    ?L?COM000C
00143D 6006              JZ       ?C0016?HWA_EEPROM
  124: 	{
  125: 		hwa_eepromEncrypt(e2_data, Size);
00143F 71CB              ACALL    ?L?COM0011
001441 B163              ACALL    ?L?COM0046
001443 B1E0              ACALL    _hwa_eepromEncrypt
  126: 	}
001445         ?C0016?HWA_EEPROM:
  127: 	e2_data[Size] = (UINT8)(e2_check_sum >> 8);
001445 900079            MOV      DPTR,#e2_check_sum
001448 E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 65


001449 FC                MOV      R4,A
00144A A3                INC      DPTR
00144B E0                MOVX     A,@DPTR
00144C FD                MOV      R5,A
00144D EC                MOV      A,R4
00144E FF                MOV      R7,A
00144F A3                INC      DPTR
001450 E0                MOVX     A,@DPTR
001451 FA                MOV      R2,A
001452 A3                INC      DPTR
001453 E0                MOVX     A,@DPTR
001454 FB                MOV      R3,A
001455 2400              ADD      A,#LOW e2_data
001457 F582              MOV      DPL,A
001459 7400              MOV      A,#HIGH e2_data
00145B 3A                ADDC     A,R2
00145C F583              MOV      DPH,A
00145E EF                MOV      A,R7
00145F F0                MOVX     @DPTR,A
  128: 	e2_data[Size + 1] = (UINT8)(e2_check_sum & 0xFF);
001460 7401              MOV      A,#LOW e2_data+01H
001462 2B                ADD      A,R3
001463 F582              MOV      DPL,A
001465 7400              MOV      A,#HIGH e2_data+01H
001467 3A                ADDC     A,R2
001468 F583              MOV      DPH,A
00146A ED                MOV      A,R5
00146B F0                MOVX     @DPTR,A
  129: 	sys_eepromEraseSector(e2_addr);
00146C 900075            MOV      DPTR,#e2_addr
00146F 518B              ACALL    ?L?COM0027
  130: 	sys_eepromWrite(e2_addr, e2_data, SectorSize);
001471 900075            MOV      DPTR,#e2_addr
001474 9186              ACALL    ?L?COM0007
001476 91A1              ACALL    _sys_eepromWrite
  131: 
  132: 	//    memcpy(e2_data_bak, e2_data, SectorSize);
  133: 	sys_eepromEraseSector(e2_bak_addr);
001478 900077            MOV      DPTR,#e2_bak_addr
00147B 518B              ACALL    ?L?COM0027
  134: 	sys_eepromWrite(e2_bak_addr, e2_data, SectorSize);
00147D 900077            MOV      DPTR,#e2_bak_addr
001480 9186              ACALL    ?L?COM0007
001482 91A1              ACALL    _sys_eepromWrite
  135: 	return TRUE;
001484 D3                SETB     C
  136: }
001485 22                RET      
----- FUNCTION _hwa_eepromWriteSector (END) -------


----- FUNCTION ?L?COM0007 (BEGIN) -----
001486 E0                MOVX     A,@DPTR
001487 FE                MOV      R6,A
001488 A3                INC      DPTR
001489 E0                MOVX     A,@DPTR
00148A FF                MOV      R7,A
00148B 7B01              MOV      R3,#01H
00148D 7A00              MOV      R2,#HIGH e2_data
00148F 7900              MOV      R1,#LOW e2_data
001491 90007D            MOV      DPTR,#SectorSize
001494         ?L?COM0008:
001494 E0                MOVX     A,@DPTR
001495 FD                MOV      R5,A
001496 A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 66


001497 E0                MOVX     A,@DPTR
001498 900094            MOV      DPTR,#?_sys_eepromWrite?BYTE+05H
00149B CD                XCH      A,R5
00149C F0                MOVX     @DPTR,A
00149D A3                INC      DPTR
00149E ED                MOV      A,R5
00149F F0                MOVX     @DPTR,A
0014A0 22                RET      
----- FUNCTION ?L?COM0007 (END) -------


----- FUNCTION _sys_eepromWrite (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
  100: void sys_eepromWrite(UINT16 addr, UINT8 *Data, UINT16 num)
  101: {
;---- Variable 'Data' assigned to Register 'R1/R2/R3' ----
;---- Variable 'addr' assigned to Register 'R4/R5' ----
0014A1 B1A5              ACALL    ?L?COM004F
  102:     IAP_CONTR = ENABLE_IAP;
  103:     IAP_CMD = CMD_PROGRAM;
0014A3 75C502            MOV      IAP_CMD,#02H
0014A6         ?C0006?SYS_EEPROM:
  104:     while(num--)
0014A6 B1AD              ACALL    ?L?COM0040
0014A8 45F0              ORL      A,B
0014AA 601A              JZ       ?C0007?SYS_EEPROM
  105:     {
  106:         IAP_ADDRL = addr;
0014AC 8DC4              MOV      IAP_ADDRL,R5
  107:         IAP_ADDRH = addr >> 8;
0014AE EC                MOV      A,R4
0014AF F5C3              MOV      IAP_ADDRH,A
  108:         IAP_DATA = *Data;
0014B1 12011C            LCALL    ?C?CLDPTR
0014B4 F5C2              MOV      IAP_DATA,A
  109:         IAP_TRIG = 0x5a;
0014B6 B15C              ACALL    ?L?COM003C
  110:         IAP_TRIG = 0xa5;
  111:         addr++;
0014B8 0D                INC      R5
0014B9 BD0001            CJNE     R5,#00H,?C0010?SYS_EEPROM
0014BC 0C                INC      R4
0014BD         ?C0010?SYS_EEPROM:
  112:         Data++;
0014BD 7401              MOV      A,#01H
0014BF 29                ADD      A,R1
0014C0 F9                MOV      R1,A
0014C1 E4                CLR      A
0014C2 3A                ADDC     A,R2
0014C3 FA                MOV      R2,A
  113:     }
0014C4 80E0              SJMP     ?C0006?SYS_EEPROM
0014C6         ?C0007?SYS_EEPROM:
  114:     IapIdle();
0014C6 417E              AJMP     IapIdle
----- FUNCTION _sys_eepromWrite (END) -------


----- FUNCTION ?L?COM0005 (BEGIN) -----
0014C8 EC                MOV      A,R4
0014C9 F0                MOVX     @DPTR,A
0014CA A3                INC      DPTR
0014CB ED                MOV      A,R5
0014CC F0                MOVX     @DPTR,A
0014CD 2402              ADD      A,#02H
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 67


0014CF FE                MOV      R6,A
0014D0 E4                CLR      A
0014D1 3C                ADDC     A,R4
0014D2 A3                INC      DPTR
0014D3 F0                MOVX     @DPTR,A
0014D4 A3                INC      DPTR
0014D5 CE                XCH      A,R6
0014D6 F0                MOVX     @DPTR,A
0014D7 EB                MOV      A,R3
0014D8 FF                MOV      R7,A
0014D9 7E00              MOV      R6,#00H
0014DB 90045D            MOV      DPTR,#c_u16_eepromSectorSize
0014DE E4                CLR      A
0014DF 93                MOVC     A,@A+DPTR
0014E0 FC                MOV      R4,A
0014E1 7401              MOV      A,#01H
0014E3 93                MOVC     A,@A+DPTR
0014E4 FD                MOV      R5,A
0014E5 120196            LCALL    ?C?IMUL
0014E8 AA06              MOV      R2,AR6
0014EA AB07              MOV      R3,AR7
0014EC 90045F            MOV      DPTR,#c_u16_eepromSectorAddr
0014EF         ?L?COM0006:
0014EF 7401              MOV      A,#01H
0014F1 93                MOVC     A,@A+DPTR
0014F2 2B                ADD      A,R3
0014F3 FE                MOV      R6,A
0014F4 E4                CLR      A
0014F5 93                MOVC     A,@A+DPTR
0014F6 3A                ADDC     A,R2
0014F7 22                RET      
----- FUNCTION ?L?COM0005 (END) -------


----- FUNCTION ?L?COM002A (BEGIN) -----
0014F8 900085            MOV      DPTR,#e2_bak_addr
0014FB E0                MOVX     A,@DPTR
0014FC FE                MOV      R6,A
0014FD A3                INC      DPTR
0014FE E0                MOVX     A,@DPTR
0014FF FF                MOV      R7,A
001500         ?L?COM002B:
001500 7B01              MOV      R3,#01H
001502 7A00              MOV      R2,#HIGH e2_data_bak
001504 7920              MOV      R1,#LOW e2_data_bak
001506 22                RET      
----- FUNCTION ?L?COM002A (END) -------


----- FUNCTION ?L?COM000B (BEGIN) -----
001507 B11E              ACALL    _sys_eepromRead
001509 900082            MOV      DPTR,#sector
00150C         ?L?COM000C:
00150C E0                MOVX     A,@DPTR
00150D 75F003            MOV      B,#03H
001510 A4                MUL      AB
001511 2459              ADD      A,#LOW c_s_eepromConfig+02H
001513 F582              MOV      DPL,A
001515 E5F0              MOV      A,B
001517 3404              ADDC     A,#HIGH c_s_eepromConfig+02H
001519 F583              MOV      DPH,A
00151B E4                CLR      A
00151C 93                MOVC     A,@A+DPTR
00151D 22                RET      
----- FUNCTION ?L?COM000B (END) -------
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 68




----- FUNCTION _sys_eepromRead (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   84: void sys_eepromRead(UINT16 addr, UINT8 *Data, UINT16 num)
   85: {
00151E 900091            MOV      DPTR,#Data
001521 120EA0            LCALL    ?L?COM0004
;---- Variable 'addr' assigned to Register 'R4/R5' ----
001524 B1A5              ACALL    ?L?COM004F
   86:     IAP_CONTR = ENABLE_IAP;
   87:     IAP_CMD = CMD_READ;
001526 75C501            MOV      IAP_CMD,#01H
001529         ?C0003?SYS_EEPROM:
   88:     while(num--)
001529 B1AD              ACALL    ?L?COM0040
00152B 45F0              ORL      A,B
00152D 6021              JZ       ?C0004?SYS_EEPROM
   89:     {
   90:         IAP_ADDRL = addr;
00152F 8DC4              MOV      IAP_ADDRL,R5
   91:         IAP_ADDRH = addr >> 8;
001531 EC                MOV      A,R4
001532 B15A              ACALL    ?L?COM003B
   92:         IAP_TRIG = 0x5a;
   93:         IAP_TRIG = 0xa5;
   94:         addr++;
001534 0D                INC      R5
001535 BD0001            CJNE     R5,#00H,?C0009?SYS_EEPROM
001538 0C                INC      R4
001539         ?C0009?SYS_EEPROM:
   95:         *Data++ = IAP_DATA;
001539 900091            MOV      DPTR,#Data
00153C E0                MOVX     A,@DPTR
00153D FB                MOV      R3,A
00153E A3                INC      DPTR
00153F E4                CLR      A
001540 75F001            MOV      B,#01H
001543 1201FD            LCALL    ?C?ILDIX
001546 A9F0              MOV      R1,B
001548 FA                MOV      R2,A
001549 E5C2              MOV      A,IAP_DATA
00154B 120162            LCALL    ?C?CSTPTR
   96:     }
00154E 80D9              SJMP     ?C0003?SYS_EEPROM
001550         ?C0004?SYS_EEPROM:
   97:     IapIdle();
001550 417E              AJMP     IapIdle
----- FUNCTION _sys_eepromRead (END) -------


----- FUNCTION ?L?COM004E (BEGIN) -----
001552 3C                ADDC     A,R4
001553 F583              MOV      DPH,A
001555 E0                MOVX     A,@DPTR
001556 FD                MOV      R5,A
001557 ED                MOV      A,R5
001558 FF                MOV      R7,A
001559 22                RET      
----- FUNCTION ?L?COM004E (END) -------


----- FUNCTION ?L?COM003B (BEGIN) -----
00155A F5C3              MOV      IAP_ADDRH,A
00155C         ?L?COM003C:
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 69


00155C 75C65A            MOV      IAP_TRIG,#05AH
00155F 75C6A5            MOV      IAP_TRIG,#0A5H
001562 22                RET      
----- FUNCTION ?L?COM003B (END) -------


----- FUNCTION ?L?COM0046 (BEGIN) -----
001563 90007B            MOV      DPTR,#Size
001566 E0                MOVX     A,@DPTR
001567 FC                MOV      R4,A
001568 A3                INC      DPTR
001569 E0                MOVX     A,@DPTR
00156A FD                MOV      R5,A
00156B 22                RET      
----- FUNCTION ?L?COM0046 (END) -------


----- FUNCTION _hwa_eepromDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   51: void hwa_eepromDecrypt(UINT8 *dat, UINT16 size)        //解密
   52: {
00156C 90008F            MOV      DPTR,#dat
00156F 120EA0            LCALL    ?L?COM0004
;---- Variable 'i' assigned to Register 'R6/R7' ----
001572 D10B              ACALL    ?L?COM0041
001574         ?C0005?HWA_EEPROM_CFG:
001574 D3                SETB     C
001575 900093            MOV      DPTR,#size+01H
001578 E0                MOVX     A,@DPTR
001579 9F                SUBB     A,R7
00157A 900092            MOV      DPTR,#size
00157D E0                MOVX     A,@DPTR
00157E 9E                SUBB     A,R6
00157F 401B              JC       ?C0008?HWA_EEPROM_CFG
   53: 	UINT16 i;
   54: 	UINT8 tmp;
   55: 	for (i = 0; i<size; i++)
   56: 	{
   57: 		tmp = dat[i];
001581 90008F            MOV      DPTR,#dat
001584 1207F3            LCALL    ?L?COM0002
;---- Variable 'tmp' assigned to Register 'R5' ----
001587 D120              ACALL    ?L?COM0033
   58: 		tmp ^= SecretKey;
   59: 		tmp = (tmp << 1) | (tmp >> 7);
001589 25E0              ADD      A,ACC
00158B FC                MOV      R4,A
00158C ED                MOV      A,R5
00158D C4                SWAP     A
00158E 13                RRC      A
00158F 13                RRC      A
001590 13                RRC      A
001591 5401              ANL      A,#01H
001593 D115              ACALL    ?L?COM0036
   60: 		tmp ^= SecretKey;
   61: 		dat[i] = tmp;
   62: 	}
001595 0F                INC      R7
001596 BF0001            CJNE     R7,#00H,?C0010?HWA_EEPROM_CFG
001599 0E                INC      R6
00159A         ?C0010?HWA_EEPROM_CFG:
00159A 80D8              SJMP     ?C0005?HWA_EEPROM_CFG
   63: }
00159C         ?C0008?HWA_EEPROM_CFG:
00159C 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 70


----- FUNCTION _hwa_eepromDecrypt (END) -------


----- FUNCTION ?L?COM004D (BEGIN) -----
00159D F0                MOVX     @DPTR,A
00159E A3                INC      DPTR
00159F CE                XCH      A,R6
0015A0 F0                MOVX     @DPTR,A
0015A1 900461            MOV      DPTR,#c_u16_eepromSectorBakAddr
0015A4 22                RET      
----- FUNCTION ?L?COM004D (END) -------


----- FUNCTION ?L?COM004F (BEGIN) -----
0015A5 AD07              MOV      R5,AR7
0015A7 AC06              MOV      R4,AR6
0015A9 75C780            MOV      IAP_CONTR,#080H
0015AC 22                RET      
----- FUNCTION ?L?COM004F (END) -------


----- FUNCTION ?L?COM0040 (BEGIN) -----
0015AD 900094            MOV      DPTR,#num
0015B0 74FF              MOV      A,#0FFH
0015B2 F5F0              MOV      B,A
0015B4 0201FD            LJMP     ?C?ILDIX
----- FUNCTION ?L?COM0040 (END) -------


----- FUNCTION ?L?COM0043 (BEGIN) -----
0015B7 900456            MOV      DPTR,#c_u8_eepromSectorNum
0015BA E4                CLR      A
0015BB 93                MOVC     A,@A+DPTR
0015BC FF                MOV      R7,A
0015BD ED                MOV      A,R5
0015BE C3                CLR      C
0015BF 9F                SUBB     A,R7
0015C0 22                RET      
----- FUNCTION ?L?COM0043 (END) -------


----- FUNCTION ?L?COM0039 (BEGIN) -----
0015C1 E0                MOVX     A,@DPTR
0015C2 FE                MOV      R6,A
0015C3 A3                INC      DPTR
0015C4 E0                MOVX     A,@DPTR
0015C5 FF                MOV      R7,A
0015C6 7800              MOV      R0,#LOW e2_data
0015C8 7C00              MOV      R4,#HIGH e2_data
0015CA 7D01              MOV      R5,#01H
0015CC 22                RET      
----- FUNCTION ?L?COM0039 (END) -------


----- FUNCTION ?L?COM0028 (BEGIN) -----
0015CD E0                MOVX     A,@DPTR
0015CE FB                MOV      R3,A
0015CF 75F003            MOV      B,#03H
0015D2 A4                MUL      AB
0015D3 2457              ADD      A,#LOW c_s_eepromConfig
0015D5 F582              MOV      DPL,A
0015D7 E5F0              MOV      A,B
0015D9 3404              ADDC     A,#HIGH c_s_eepromConfig
0015DB F583              MOV      DPH,A
0015DD E4                CLR      A
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 71


0015DE 93                MOVC     A,@A+DPTR
0015DF 22                RET      
----- FUNCTION ?L?COM0028 (END) -------


----- FUNCTION _hwa_eepromEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   37: void hwa_eepromEncrypt(UINT8 *dat, UINT16 size)        //加密
   38: {
0015E0 120E9D            LCALL    ?L?COM0003
;---- Variable 'i' assigned to Register 'R6/R7' ----
0015E3 D10B              ACALL    ?L?COM0041
0015E5         ?C0001?HWA_EEPROM_CFG:
0015E5 D3                SETB     C
0015E6 900083            MOV      DPTR,#size+01H
0015E9 E0                MOVX     A,@DPTR
0015EA 9F                SUBB     A,R7
0015EB 900082            MOV      DPTR,#size
0015EE E0                MOVX     A,@DPTR
0015EF 9E                SUBB     A,R6
0015F0 4018              JC       ?C0004?HWA_EEPROM_CFG
   39: 	UINT16 i;
   40: 	UINT8 tmp;
   41: 	for (i = 0; i<size; i++)
   42: 	{
   43: 		tmp = dat[i];
0015F2 1207F0            LCALL    ?L?COM0001
;---- Variable 'tmp' assigned to Register 'R5' ----
0015F5 D120              ACALL    ?L?COM0033
   44: 		tmp ^= SecretKey;
   45: 		tmp = (tmp >> 1) | (tmp << 7);
0015F7 C4                SWAP     A
0015F8 33                RLC      A
0015F9 33                RLC      A
0015FA 33                RLC      A
0015FB 5480              ANL      A,#080H
0015FD FC                MOV      R4,A
0015FE ED                MOV      A,R5
0015FF C3                CLR      C
001600 13                RRC      A
001601 D115              ACALL    ?L?COM0036
   46: 		tmp ^= SecretKey;
   47: 		dat[i] = tmp;
   48: 	}
001603 0F                INC      R7
001604 BF0001            CJNE     R7,#00H,?C0009?HWA_EEPROM_CFG
001607 0E                INC      R6
001608         ?C0009?HWA_EEPROM_CFG:
001608 80DB              SJMP     ?C0001?HWA_EEPROM_CFG
   49: }
00160A         ?C0004?HWA_EEPROM_CFG:
00160A 22                RET      
----- FUNCTION _hwa_eepromEncrypt (END) -------


----- FUNCTION ?L?COM0041 (BEGIN) -----
00160B A3                INC      DPTR
00160C EC                MOV      A,R4
00160D F0                MOVX     @DPTR,A
00160E A3                INC      DPTR
00160F ED                MOV      A,R5
001610 F0                MOVX     @DPTR,A
001611 E4                CLR      A
001612 FF                MOV      R7,A
001613 FE                MOV      R6,A
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 72


001614 22                RET      
----- FUNCTION ?L?COM0041 (END) -------


----- FUNCTION ?L?COM0036 (BEGIN) -----
001615 4C                ORL      A,R4
001616 64A5              XRL      A,#0A5H
001618 FD                MOV      R5,A
001619 8F82              MOV      DPL,R7
00161B 8E83              MOV      DPH,R6
00161D 020174            LJMP     ?C?CSTOPTR
----- FUNCTION ?L?COM0036 (END) -------


----- FUNCTION ?L?COM0033 (BEGIN) -----
001620 F9                MOV      R1,A
001621 8F82              MOV      DPL,R7
001623 8E83              MOV      DPH,R6
001625 120135            LCALL    ?C?CLDOPTR
001628 64A5              XRL      A,#0A5H
00162A FD                MOV      R5,A
00162B 22                RET      
----- FUNCTION ?L?COM0033 (END) -------


----- FUNCTION app_brushCard (BEGIN) -----
 FILE: 'App\app_brush.c'
   51: UINT8 app_brushCard(void)
   52: {
   53: 	UINT8 Sector;
   54: 	UINT8 CardIndex;
   55:     UINT8 i;
   56: 	for (CardIndex = MEM_CARD; CardIndex <= PWD_CARD; CardIndex++)
00162C 900071            MOV      DPTR,#CardIndex
00162F 7401              MOV      A,#01H
001631 F0                MOVX     @DPTR,A
001632         ?C0004?APP_BRUSH:
   57: 	{
   58: 		if (b_FactorySystem)
001632 300706            JNB      b_FactorySystem,?C0007?APP_BRUSH
   59: 		{
   60: 			CardIndex = PWD_CARD;
001635 900071            MOV      DPTR,#CardIndex
001638 7403              MOV      A,#03H
00163A F0                MOVX     @DPTR,A
   61: 		}
00163B         ?C0007?APP_BRUSH:
   62: 		if (CardIndex == MEM_CARD)
00163B 900071            MOV      DPTR,#CardIndex
00163E E0                MOVX     A,@DPTR
00163F B40108            CJNE     A,#01H,?C0008?APP_BRUSH
   63: 		{
   64: 			Load_Key(&s_System.MGM_Card);
001642 7B01              MOV      R3,#01H
001644 7A00              MOV      R2,#HIGH s_System
001646 79A1              MOV      R1,#LOW s_System
   65: 		}
001648 801C              SJMP     ?C0051?APP_BRUSH
00164A         ?C0008?APP_BRUSH:
   66: 		else if (CardIndex == USER_CARD)
00164A 900071            MOV      DPTR,#CardIndex
00164D E0                MOVX     A,@DPTR
00164E B40208            CJNE     A,#02H,?C0010?APP_BRUSH
   67: 		{
   68: 			Load_Key(&s_System.USER_Card);
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 73


001651 7B01              MOV      R3,#01H
001653 7A00              MOV      R2,#HIGH s_System+0AH
001655 79AB              MOV      R1,#LOW s_System+0AH
001657         
   69: 		}
001657 800D              SJMP     ?C0051?APP_BRUSH
001659         ?C0010?APP_BRUSH:
   70: 		else if (CardIndex == PWD_CARD)
001659 900071            MOV      DPTR,#CardIndex
00165C E0                MOVX     A,@DPTR
00165D B40309            CJNE     A,#03H,?C0009?APP_BRUSH
   71: 		{
   72: 			Load_Key(PWD_Card);
001660 7BFF              MOV      R3,#0FFH
001662 7A00              MOV      R2,#HIGH PWD_Card
001664 7903              MOV      R1,#LOW PWD_Card
001666         
001666 120EE2            LCALL    _Load_Key
   73: 		}
001669         ?C0009?APP_BRUSH:
   74: 		MIF_Halt();
001669 12072C            LCALL    MIF_Halt
   75: 		if (Request(RF_CMD_REQUEST_STD) != FM1702_OK)
00166C 7F26              MOV      R7,#026H
00166E 1205DA            LCALL    _Request
001671 EF                MOV      A,R7
001672 7051              JNZ      ?C0006?APP_BRUSH
   76: 		{
   77: 			continue;
   78: 		}
001674         ?C0013?APP_BRUSH:
   79:         for(i=0; i<2; i++)
001674 E4                CLR      A
001675 900072            MOV      DPTR,#i
001678 F0                MOVX     @DPTR,A
001679         ?C0014?APP_BRUSH:
   80:         {
   81:             if (AntiColl() == FM1702_OK && SelectCard() == FM1702_OK)
001679 12052D            LCALL    AntiColl
00167C EF                MOV      A,R7
00167D 703A              JNZ      ?C0016?APP_BRUSH
00167F 1206CE            LCALL    SelectCard
001682 EF                MOV      A,R7
001683 7034              JNZ      ?C0016?APP_BRUSH
   82:             {
   83:                 if (CardIndex == USER_CARD)     //用户卡验证钱所在扇区
001685 900071            MOV      DPTR,#CardIndex
001688 E0                MOVX     A,@DPTR
001689 B4020A            CJNE     A,#02H,?C0018?APP_BRUSH
   84:                 {
   85:                     Sector = s_System.Sector;
00168C 9000A7            MOV      DPTR,#s_System+06H
00168F E0                MOVX     A,@DPTR
001690 900070            MOV      DPTR,#Sector
001693 F0                MOVX     @DPTR,A
   86:                 }
001694 8006              SJMP     ?C0019?APP_BRUSH
001696         ?C0018?APP_BRUSH:
   87:                 else                            //管理和密码卡验证1扇区
   88:                 {
   89:                     Sector = 1;
001696 900070            MOV      DPTR,#Sector
001699 7401              MOV      A,#01H
00169B F0                MOVX     @DPTR,A
   90:                 }
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 74


00169C         ?C0019?APP_BRUSH:
   91:                 if (Authentication(gCard_UID, Sector, 0x60) == FM1702_OK)
00169C 7B01              MOV      R3,#01H
00169E 7A00              MOV      R2,#HIGH gCard_UID
0016A0 79B4              MOV      R1,#LOW gCard_UID
0016A2 900070            MOV      DPTR,#Sector
0016A5 E0                MOVX     A,@DPTR
0016A6 FD                MOV      R5,A
0016A7 900077            MOV      DPTR,#?_Authentication?BYTE+04H
0016AA 7460              MOV      A,#060H
0016AC F0                MOVX     @DPTR,A
0016AD 12063B            LCALL    _Authentication
0016B0 EF                MOV      A,R7
0016B1 7006              JNZ      ?C0016?APP_BRUSH
   92:                 {
   93:                     return CardIndex;
0016B3 900071            MOV      DPTR,#CardIndex
0016B6 E0                MOVX     A,@DPTR
0016B7 FF                MOV      R7,A
0016B8 22                RET      
   94:                 }
   95:             }
   96:         }
0016B9         ?C0016?APP_BRUSH:
0016B9 900072            MOV      DPTR,#i
0016BC E0                MOVX     A,@DPTR
0016BD 04                INC      A
0016BE F0                MOVX     @DPTR,A
0016BF E0                MOVX     A,@DPTR
0016C0 C3                CLR      C
0016C1 9402              SUBB     A,#02H
0016C3 40B4              JC       ?C0014?APP_BRUSH
   97: 	}
0016C5         ?C0006?APP_BRUSH:
0016C5 900071            MOV      DPTR,#CardIndex
0016C8 E0                MOVX     A,@DPTR
0016C9 04                INC      A
0016CA F0                MOVX     @DPTR,A
0016CB E0                MOVX     A,@DPTR
0016CC D3                SETB     C
0016CD 9403              SUBB     A,#03H
0016CF 5002              JNC      $ + 4H
0016D1 C132              AJMP     ?C0004?APP_BRUSH
0016D3         ?C0005?APP_BRUSH:
   98: 	return NONE_CARD;
0016D3 7F00              MOV      R7,#00H
   99: }
0016D5 22                RET      
----- FUNCTION app_brushCard (END) -------


----- FUNCTION app_pulseInit (BEGIN) -----
 FILE: 'App\app_pulse.c'
   12: void app_pulseInit(void)
   13: {
   14:     P3M1 &= ~0x80;      //推挽输出
   15:     P3M0 |= 0x80;
0016D6 53B17F            ANL      P3M1,#07FH
   16:     pulse = 0;
0016D9 43B280            ORL      P3M0,#080H
   17: }
0016DC C2B7              CLR      pulse
   18: 
0016DE 22                RET      
----- FUNCTION app_pulseInit (END) -------
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 75




----- FUNCTION _app_pulseSendPulse (BEGIN) -----
 FILE: 'App\app_pulse.c'
   40: void app_pulseSendPulse(UINT8 width, UINT8 n)
   41: {
;---- Variable 'n' assigned to Register 'R5' ----
;---- Variable 'width' assigned to Register 'R7' ----
   42:     u8_width = width;
   43:     u8_pulse = n;
0016DF 9000D1            MOV      DPTR,#u8_width
0016E2 EF                MOV      A,R7
0016E3 F0                MOVX     @DPTR,A
   44: }
0016E4 A3                INC      DPTR
0016E5 ED                MOV      A,R5
0016E6 F0                MOVX     @DPTR,A
   45: 
0016E7 22                RET      
----- FUNCTION _app_pulseSendPulse (END) -------


----- FUNCTION buzzer_Init (BEGIN) -----
 FILE: 'Driver\buzzer.c'
    8: void buzzer_Init(void)
    9: {
   10:     P3M1 &= ~0x20;      //推挽输出
   11:     P3M0 |= 0x20;
0016E8 53B1DF            ANL      P3M1,#0DFH
   12:     P3 &= ~0x20;
0016EB 43B220            ORL      P3M0,#020H
   13: }
0016EE 53B0DF            ANL      P3,#0DFH
   14: 
0016F1 22                RET      
----- FUNCTION buzzer_Init (END) -------


----- FUNCTION len_Init (BEGIN) -----
 FILE: 'Driver\LED.c'
   17: void len_Init(void)
   18: {
   19:     P1M1 &= ~0xFF;      //推挽输出
   20:     P1M0 |= 0xFF;
0016F2 759100            MOV      P1M1,#00H
   21:     P2M1 &= ~0xC1;      //推挽输出
0016F5 7592FF            MOV      P1M0,#0FFH
   22:     P2M0 |= 0xC1;
0016F8 53953E            ANL      P2M1,#03EH
   23:     P5M1 &= ~0x30;      //推挽输出
0016FB 4396C1            ORL      P2M0,#0C1H
   24:     P5M0 |= 0x30;
0016FE 53C9CF            ANL      P5M1,#0CFH
   25:     P3M1 &= ~0x40;      //推挽输出
001701 43CA30            ORL      P5M0,#030H
   26:     P3M0 |= 0x40;
001704 53B1BF            ANL      P3M1,#0BFH
   27: }
001707 43B240            ORL      P3M0,#040H
   28: 
00170A 22                RET      
----- FUNCTION len_Init (END) -------


----- FUNCTION _Write_FIFO (BEGIN) -----
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 76


 FILE: 'Driver\mifare.c'
  212: void Write_FIFO(uchar *buff,uchar count)
  213: {
00170B 900099            MOV      DPTR,#buff
00170E 120EA0            LCALL    ?L?COM0004
001711 A3                INC      DPTR
001712 ED                MOV      A,R5
001713 F0                MOVX     @DPTR,A
  214: 	uchar i;
  215: 	if(count == 0)
001714 6021              JZ       ?C0045?MIFARE
001716         ?C0044?MIFARE:
  216:         return;
  217: 	for(i=0;i<count;i++)
;---- Variable 'i' assigned to Register 'R4' ----
001716 E4                CLR      A
001717 FC                MOV      R4,A
001718         ?C0046?MIFARE:
001718 90009C            MOV      DPTR,#count
00171B E0                MOVX     A,@DPTR
00171C FF                MOV      R7,A
00171D EC                MOV      A,R4
00171E C3                CLR      C
00171F 9F                SUBB     A,R7
001720 5015              JNC      ?C0045?MIFARE
  218: 		SPIWriteOne(FIFO_Reg,buff[i]);
001722 900099            MOV      DPTR,#buff
001725 1207F3            LCALL    ?L?COM0002
001728 F9                MOV      R1,A
001729 8C82              MOV      DPL,R4
00172B 120EDC            LCALL    ?L?COM0018
00172E FD                MOV      R5,A
00172F 7F02              MOV      R7,#02H
001731 1204C8            LCALL    _SPIWriteOne
001734 0C                INC      R4
001735 80E1              SJMP     ?C0046?MIFARE
  219: //		SPIWrite(FIFO_Reg,buff,count);
  220: }
001737         ?C0045?MIFARE:
001737 22                RET      
----- FUNCTION _Write_FIFO (END) -------


----- FUNCTION _Read_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  532: uchar Read_Block(uchar *buff,uchar index)
  533: {
001738 90007B            MOV      DPTR,#buff
00173B 120EA0            LCALL    ?L?COM0004
;---- Variable 'index' assigned to Register 'R4' ----
00173E AC05              MOV      R4,AR5
  534:     uchar ucCmdLine[2],ucResult;
  535:     SPIWriteOne(ChannelRedundancy_Reg,0x0F);
001740 1207EA            LCALL    ?L?COM0048
  536:     ucCmdLine[0] = RF_CMD_READ;
001743 A3                INC      DPTR
001744 7430              MOV      A,#030H
001746 F0                MOVX     @DPTR,A
  537:     ucCmdLine[1] = index;
001747 A3                INC      DPTR
001748 EC                MOV      A,R4
001749 F0                MOVX     @DPTR,A
  538:     ucResult = Command_Send(Transceive,ucCmdLine,2);
00174A 7B01              MOV      R3,#01H
00174C 7A00              MOV      R2,#HIGH ucCmdLine
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 77


00174E 797E              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
001750 1207A7            LCALL    ?L?COM001E
001753 7003              JNZ      ?C0108?MIFARE
  539:     if(ucResult == FALSE)
  540:         return FM1702_NOTAGERR;   //无卡
001755 7F01              MOV      R7,#01H
001757 22                RET      
001758         ?C0108?MIFARE:
  541:     ucResult = SPIReadOne(ErrorFlag_Reg);
001758 120757            LCALL    ?L?COM0024
00175B 30E103            JNB      ACC.1,?C0110?MIFARE
00175E 7F05              MOV      R7,#05H
001760 22                RET      
001761         ?C0110?MIFARE:
  542: 	if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
  543: 	if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
001761 EF                MOV      A,R7
001762 30E203            JNB      ACC.2,?C0111?MIFARE
001765 7F14              MOV      R7,#014H
001767 22                RET      
001768         ?C0111?MIFARE:
  544: 	if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
001768 EF                MOV      A,R7
001769 30E303            JNB      ACC.3,?C0112?MIFARE
00176C 7F02              MOV      R7,#02H
00176E 22                RET      
00176F         ?C0112?MIFARE:
  545:     ucResult = Read_FIFO(buff);
00176F 90007B            MOV      DPTR,#buff
001772 1207F3            LCALL    ?L?COM0002
001775 F9                MOV      R1,A
001776 1207B3            LCALL    _Read_FIFO
  546:     if(ucResult!=0x10)
001779 EF                MOV      A,R7
00177A 6410              XRL      A,#010H
00177C 7F00              MOV      R7,#00H
00177E 6002              JZ       ?C0113?MIFARE
  547:         return FM1702_BYTECOUNTERR;
001780 7F0C              MOV      R7,#0CH
001782         ?C0113?MIFARE:
  548:     else
  549:         return FM1702_OK;
  550: }
001782 22                RET      
----- FUNCTION _Read_Block (END) -------


----- FUNCTION _Write_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  566: uchar Write_Block(uchar *buff,uchar index)
  567: {
001783 120E9D            LCALL    ?L?COM0003
;---- Variable 'index' assigned to Register 'R4' ----
001786 AC05              MOV      R4,AR5
  568:     uchar ucCmdLine[2],ucResult,ucData[16];
  569:     SPIWriteOne(ChannelRedundancy_Reg,0x07);   /* Note: this line is for 1702, different from RC500*/
001788 7D07              MOV      R5,#07H
00178A 7F22              MOV      R7,#022H
00178C 1204C8            LCALL    _SPIWriteOne
  570:     ucCmdLine[0] = RF_CMD_WRITE;
00178F A3                INC      DPTR
001790 74A0              MOV      A,#0A0H
001792 F0                MOVX     @DPTR,A
  571:     ucCmdLine[1] = index;
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 78


001793 A3                INC      DPTR
001794 EC                MOV      A,R4
001795 F0                MOVX     @DPTR,A
  572:     ucResult = Command_Send(Transceive,ucCmdLine,2);
001796 7B01              MOV      R3,#01H
001798 7A00              MOV      R2,#HIGH ucCmdLine
00179A 7982              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
00179C 1207A7            LCALL    ?L?COM001E
00179F 7003              JNZ      ?C0115?MIFARE
  573:     if(ucResult == FALSE)
  574:         return FM1702_NOTAGERR;
0017A1 7F01              MOV      R7,#01H
0017A3 22                RET      
0017A4         ?C0115?MIFARE:
  575:     ucResult = Read_FIFO(ucData);
0017A4 7B01              MOV      R3,#01H
0017A6 7A00              MOV      R2,#HIGH ucData
0017A8 7984              MOV      R1,#LOW ucData
0017AA 1207B3            LCALL    _Read_FIFO
  576:     if(ucResult == 0)
0017AD EF                MOV      A,R7
0017AE 7003              JNZ      ?C0117?MIFARE
  577:         return FM1702_BYTECOUNTERR;
0017B0 7F0C              MOV      R7,#0CH
0017B2 22                RET      
0017B3         ?C0117?MIFARE:
  578:     switch(ucData[0])
0017B3 900084            MOV      DPTR,#ucData
0017B6 E0                MOVX     A,@DPTR
0017B7 14                DEC      A
0017B8 6015              JZ       ?C0122?MIFARE
0017BA 24FD              ADD      A,#0FDH
0017BC 600E              JZ       ?C0120?MIFARE
0017BE 14                DEC      A
0017BF 6011              JZ       ?C0123?MIFARE
0017C1 24FB              ADD      A,#0FBH
0017C3 6013              JZ       ?C0118?MIFARE
0017C5 240A              ADD      A,#0AH
0017C7 700C              JNZ      ?C0124?MIFARE
  579:     {
  580: 	    case 0x00:	return(FM1702_NOTAUTHERR);	
0017C9         ?C0119?MIFARE:
0017C9 7F0A              MOV      R7,#0AH
0017CB 22                RET      
  581: 	    case 0x04:	return(FM1702_EMPTY);
0017CC         ?C0120?MIFARE:
0017CC 7F03              MOV      R7,#03H
0017CE 22                RET      
  582: 	    case 0x0a:	break;                   //正常
  583: 	    case 0x01:	return(FM1702_CRCERR);
0017CF         ?C0122?MIFARE:
0017CF 7F02              MOV      R7,#02H
0017D1 22                RET      
  584: 	    case 0x05:	return(FM1702_PARITYERR); 
0017D2         ?C0123?MIFARE:
0017D2 7F05              MOV      R7,#05H
0017D4 22                RET      
  585: 	    default:	return(FM1702_WRITEERR);
0017D5         ?C0124?MIFARE:
0017D5 7F0F              MOV      R7,#0FH
0017D7 22                RET      
  586:     }
0017D8         ?C0118?MIFARE:
  587:     ucResult = Command_Send(Transceive,buff,16);
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 79


0017D8 1207F0            LCALL    ?L?COM0001
0017DB F9                MOV      R1,A
0017DC 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
0017DF 7410              MOV      A,#010H
0017E1 1207AC            LCALL    ?L?COM001F
0017E4 B40103            CJNE     A,#01H,?C0125?MIFARE
  588:     if(ucResult == TRUE)
  589:         return FM1702_OK;
0017E7 7F00              MOV      R7,#00H
0017E9 22                RET      
0017EA         ?C0125?MIFARE:
  590:     else
  591:     {
  592:         ucResult = SPIReadOne(ErrorFlag_Reg);
0017EA 120757            LCALL    ?L?COM0024
0017ED 30E103            JNB      ACC.1,?C0127?MIFARE
0017F0 7F05              MOV      R7,#05H
0017F2 22                RET      
0017F3         ?C0127?MIFARE:
  593: 	    if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
  594: 	    else if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
0017F3 EF                MOV      A,R7
0017F4 30E203            JNB      ACC.2,?C0129?MIFARE
0017F7 7F14              MOV      R7,#014H
0017F9 22                RET      
0017FA         ?C0129?MIFARE:
  595: 	    else if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
0017FA EF                MOV      A,R7
0017FB 7F0F              MOV      R7,#0FH
0017FD 30E302            JNB      ACC.3,?C0131?MIFARE
001800 7F02              MOV      R7,#02H
001802         ?C0131?MIFARE:
  596:         else return FM1702_WRITEERR;
  597:     }
  598: }
001802 22                RET      
----- FUNCTION _Write_Block (END) -------


----- FUNCTION ?L?COM000D (BEGIN) -----
001803 E4                CLR      A
001804 7B64              MOV      R3,#064H
001806 FA                MOV      R2,A
001807 F9                MOV      R1,A
001808 F8                MOV      R0,A
001809 90009D            MOV      DPTR,#MoneySum
00180C E0                MOVX     A,@DPTR
00180D FC                MOV      R4,A
00180E A3                INC      DPTR
00180F E0                MOVX     A,@DPTR
001810 FD                MOV      R5,A
001811 A3                INC      DPTR
001812 E0                MOVX     A,@DPTR
001813 FE                MOV      R6,A
001814 A3                INC      DPTR
001815 E0                MOVX     A,@DPTR
001816 FF                MOV      R7,A
001817 120299            LCALL    ?C?ULDIV
00181A E4                CLR      A
00181B 7B64              MOV      R3,#064H
00181D FA                MOV      R2,A
00181E F9                MOV      R1,A
00181F F8                MOV      R0,A
001820 22                RET      
----- FUNCTION ?L?COM000D (END) -------
LX51 LINKER/LOCATER V4.66.1.0                                                         12/12/2015  19:50:21  PAGE 80




----- FUNCTION ?L?COM0032 (BEGIN) -----
001821 25E0              ADD      A,ACC
001823 25E0              ADD      A,ACC
001825 FE                MOV      R6,A
001826 04                INC      A
001827 A3                INC      DPTR
001828 F0                MOVX     @DPTR,A
001829 EE                MOV      A,R6
00182A 2402              ADD      A,#02H
00182C A3                INC      DPTR
00182D F0                MOVX     @DPTR,A
00182E 22                RET      
----- FUNCTION ?L?COM0032 (END) -------


