LX51 LINKER/LOCATER V4.66.1.0                                                           01/21/2016  20:26:57  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  .\Debug\PP02_11_03 (SYS_DELAY)


----- FUNCTION hwa_eepromInit (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   29: void hwa_eepromInit(void)
   30: {
   31: }
   32: 
000009 22                RET      
----- FUNCTION hwa_eepromInit (END) -------


----- FUNCTION sys_gpioInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   23: void sys_gpioInit(void)
   24: {
   25: }
   26: 
00000A 22                RET      
----- FUNCTION sys_gpioInit (END) -------


00000B 021028            LJMP     01028H
----- FUNCTION sys_taskHandler10ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   64: void sys_taskHandler10ms(void)            //10ms interrupt task
   65: {
   66: }
   67: 
000021 22                RET      
----- FUNCTION sys_taskHandler10ms (END) -------


----- FUNCTION sys_taskHandler1s (BEGIN) -----
 FILE: 'System\sys_task.c'
   73: void sys_taskHandler1s(void)              //1s interrupt task
   74: {
   75: }
   76: 
000022 22                RET      
----- FUNCTION sys_taskHandler1s (END) -------


000023 021216            LJMP     01216H
----- FUNCTION _sys_delayus (BEGIN) -----
 FILE: 'System\sys_delay.c'
    5: void sys_delayus(UINT16 xus)
    6: {
;---- Variable 'xus' assigned to Register 'R6/R7' ----
    7:     while(xus--);
000659         ?C0001?SYS_DELAY:
    8: }
000659 EF                MOV      A,R7
00065A 1F                DEC      R7
00065B AC06              MOV      R4,AR6
00065D 7001              JNZ      ?C0012?SYS_DELAY
00065F 1E                DEC      R6
000660         ?C0012?SYS_DELAY:
000660 4C                ORL      A,R4
000661 70F6              JNZ      ?C0001?SYS_DELAY
    9: 
000663 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 2


----- FUNCTION _sys_delayus (END) -------


----- FUNCTION Init_FM1702 (BEGIN) -----
 FILE: 'Driver\mifare.c'
  104: void Init_FM1702(void)
  105: {
  106: 	uchar temp;
  107: 	uint i;
  108: 	RC500SCK = 0;
000664 C2A1              CLR      RC500SCK
  109: 	RC500SO = 1;
000666 D2A2              SETB     RC500SO
  110: 	RC500SI = 1;
000668 D2A4              SETB     RC500SI
  111: 	RC500RST = 1;	// FM1702复位 
00066A D2A5              SETB     RC500RST
  112: 	sys_delayms(2);
00066C 7F02              MOV      R7,#02H
00066E 7E00              MOV      R6,#00H
000670 120806            LCALL    _sys_delayms
  113: 	RC500RST = 0;	
000673 C2A5              CLR      RC500RST
  114: 	//进入复位阶段，需要512个FM1702SL的时钟周期，约38us
  115: 	sys_delayus(100); 
000675 7F64              MOV      R7,#064H
000677 7E00              MOV      R6,#00H
000679 D159              ACALL    _sys_delayus
00067B         ?C0024?MIFARE:
  116: 	//进入初始化阶段，需要128个时钟周期，约10us
  117: 	do{ 		// 等待Command = 0,FM1702复位成功
  118: 		temp = SPIReadOne(Command_Reg);	 //(Command_Reg<<1)|0x80 = 0x82
;---- Variable 'temp' assigned to Register 'R4' ----
00067B F1FA              ACALL    ?L?COM003A
00067D 70FC              JNZ      ?C0024?MIFARE
  119: 	}while(temp!=0);
  120: ///////////////////////////////////////////////////////////////////////////////////
  121: 	SPIWriteOne(Page_Reg,0x80);	//初始化SPI接口
00067F 7D80              MOV      R5,#080H
000681 FF                MOV      R7,A
000682 D1BE              ACALL    _SPIWriteOne
  122: 	for(i = 0; i < 0x1fff; i++) // 延时
;---- Variable 'i' assigned to Register 'R2/R3' ----
000684 E4                CLR      A
000685 FB                MOV      R3,A
000686 FA                MOV      R2,A
000687         ?C0025?MIFARE:
  123: 	{
  124: 		temp = SPIReadOne(Command_Reg);
000687 F1FA              ACALL    ?L?COM003A
000689 7006              JNZ      ?C0027?MIFARE
  125: 		if(temp == 0x00)	//SPI初始化成功
  126: 		{
  127: 			SPIWriteOne(Page_Reg,0);//可以使用SPI接口
00068B FD                MOV      R5,A
00068C FF                MOV      R7,A
00068D D1BE              ACALL    _SPIWriteOne
  128: 			break;
00068F 800B              SJMP     ?C0026?MIFARE
  129: 		}
  130: 	}
000691         ?C0027?MIFARE:
000691 0B                INC      R3
000692 BB0001            CJNE     R3,#00H,?C0138?MIFARE
000695 0A                INC      R2
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 3


000696         ?C0138?MIFARE:
000696 BA1FEE            CJNE     R2,#01FH,?C0025?MIFARE
000699 BBFFEB            CJNE     R3,#0FFH,?C0025?MIFARE
00069C         ?C0026?MIFARE:
  131: ////////////////////////////////////////////////////////////////////////////////////
  132: 	SPIWriteOne(InterruptEn_Reg,0x7F);	//  禁止所有中断请求（最高位置0）
00069C 7D7F              MOV      R5,#07FH
00069E 7F06              MOV      R7,#06H
0006A0 D1BE              ACALL    _SPIWriteOne
  133: 	SPIWriteOne(InterruptRq_Reg,0x7F);	// 禁止所有中断请求标识置0（最高位置0）
0006A2 7D7F              MOV      R5,#07FH
0006A4 7F07              MOV      R7,#07H
0006A6 D1BE              ACALL    _SPIWriteOne
  134: 	
  135: 	//设置调制器的输入源为内部编码器, 并且设置TX1和TX2
  136: 	SPIWriteOne(TxControl_Reg,0x5B); 		// 发送控制寄存器 
0006A8 7D5B              MOV      R5,#05BH
0006AA 7F11              MOV      R7,#011H
0006AC D1BE              ACALL    _SPIWriteOne
  137: 	SPIWriteOne(RxControl2_Reg,0x01);
0006AE 7D01              MOV      R5,#01H
0006B0 7F1E              MOV      R7,#01EH
0006B2 D1BE              ACALL    _SPIWriteOne
  138: 	SPIWriteOne(RxWait_Reg,5);
0006B4 7D05              MOV      R5,#05H
0006B6 7F21              MOV      R7,#021H
0006B8 8004              SJMP     _SPIWriteOne
----- FUNCTION Init_FM1702 (END) -------


----- FUNCTION ?L?COM003D (BEGIN) -----
0006BA F0                MOVX     @DPTR,A
0006BB FD                MOV      R5,A
0006BC 7F01              MOV      R7,#01H
----- FUNCTION _SPIWriteOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   65: void SPIWriteOne(uchar SpiAddress,uchar wData)
   66: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
;---- Variable 'wData' assigned to Register 'R5' ----
   67: 	uchar i;
   68: 	SpiAddress = SpiAddress<<1;
0006BE EF                MOV      A,R7
0006BF 25E0              ADD      A,ACC
   69: 	SpiAddress = SpiAddress & 0x7E;
0006C1 547E              ANL      A,#07EH
0006C3 FF                MOV      R7,A
   70: 
   71: 	//传输地址 从高位到低位传输
   72: 	RC500CS = 0;
0006C4 C2A3              CLR      RC500CS
   73: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
0006C6 E4                CLR      A
0006C7 FE                MOV      R6,A
0006C8         ?C0011?MIFARE:
   74: 	{
   75: 		if(SpiAddress&0x80)
0006C8 EF                MOV      A,R7
0006C9 30E704            JNB      ACC.7,?C0014?MIFARE
   76: 			RC500SO = 1;
0006CC D2A2              SETB     RC500SO
0006CE 8002              SJMP     ?C0015?MIFARE
0006D0         ?C0014?MIFARE:
   77: 		else
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 4


   78: 			RC500SO = 0;
0006D0 C2A2              CLR      RC500SO
0006D2         ?C0015?MIFARE:
   79: 		RC500SCK = 1;
0006D2 120FF6            LCALL    ?L?COM004D
0006D5 B408F0            CJNE     A,#08H,?C0011?MIFARE
0006D8         ?C0012?MIFARE:
   80: 		SpiAddress = SpiAddress<<1;
   81: 		RC500SCK = 0;
   82: 	}
   83: 	//传输数据，从高位开始
   84: 	for (i=0;i<8;i++)
0006D8 E4                CLR      A
0006D9 FE                MOV      R6,A
0006DA         ?C0016?MIFARE:
   85: 	{
   86: 		if(wData & 0x80)
0006DA ED                MOV      A,R5
0006DB 30E704            JNB      ACC.7,?C0019?MIFARE
   87: 			RC500SO = 1;
0006DE D2A2              SETB     RC500SO
0006E0 8002              SJMP     ?C0020?MIFARE
0006E2         ?C0019?MIFARE:
   88: 		else
   89: 			RC500SO = 0;
0006E2 C2A2              CLR      RC500SO
0006E4         ?C0020?MIFARE:
   90: 		RC500SCK = 1;
0006E4 D2A1              SETB     RC500SCK
   91: 		wData = wData<<1;
0006E6 ED                MOV      A,R5
0006E7 25E0              ADD      A,ACC
0006E9 FD                MOV      R5,A
   92: 		RC500SCK = 0;
0006EA C2A1              CLR      RC500SCK
   93: 	}
0006EC 0E                INC      R6
0006ED EE                MOV      A,R6
0006EE B408E9            CJNE     A,#08H,?C0016?MIFARE
0006F1         ?C0017?MIFARE:
   94: 	RC500CS = 1;
0006F1 D2A3              SETB     RC500CS
   95: }
0006F3 22                RET      
----- FUNCTION _SPIWriteOne (END) -------


----- FUNCTION _SPIReadOne (BEGIN) -----
 FILE: 'Driver\mifare.c'
   24: uchar SPIReadOne(uchar SpiAddress)
   25: {
;---- Variable 'SpiAddress' assigned to Register 'R7' ----
   26: 	uchar i,rdata; 
   27: 	//地址字节最高位置1，表示为读数据，最低位固定为0，中间6位为地址
   28: 	SpiAddress = SpiAddress<<1;
0006F4 EF                MOV      A,R7
0006F5 25E0              ADD      A,ACC
   29: 	SpiAddress = SpiAddress | 0x80;
0006F7 4480              ORL      A,#080H
0006F9 FF                MOV      R7,A
   30: 	//传输地址 从高位到低位传输
   31: 	RC500CS = 0;
0006FA C2A3              CLR      RC500CS
   32: 	for (i=0;i<8;i++)
;---- Variable 'i' assigned to Register 'R6' ----
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 5


0006FC E4                CLR      A
0006FD FE                MOV      R6,A
0006FE         ?C0001?MIFARE:
   33: 	{
   34: 		if(SpiAddress&0x80)
0006FE EF                MOV      A,R7
0006FF 30E704            JNB      ACC.7,?C0004?MIFARE
   35: 			RC500SO = 1;
000702 D2A2              SETB     RC500SO
000704 8002              SJMP     ?C0005?MIFARE
000706         ?C0004?MIFARE:
   36: 		else
   37: 			RC500SO = 0;
000706 C2A2              CLR      RC500SO
000708         ?C0005?MIFARE:
   38: 		RC500SCK = 1;
000708 120FF6            LCALL    ?L?COM004D
00070B B408F0            CJNE     A,#08H,?C0001?MIFARE
00070E         ?C0002?MIFARE:
   39: 		SpiAddress = SpiAddress<<1;
   40: 		RC500SCK = 0;
   41: 	}
   42: 	
   43: 	//接收数据
   44: 	rdata = 0;
;---- Variable 'rdata' assigned to Register 'R7' ----
00070E E4                CLR      A
00070F FF                MOV      R7,A
   45: 	for (i=0;i<8;i++)
000710 FE                MOV      R6,A
000711         ?C0006?MIFARE:
   46: 	{
   47: 		RC500SCK = 1;
000711 D2A1              SETB     RC500SCK
   48: 		rdata = rdata<<1;
000713 EF                MOV      A,R7
000714 25E0              ADD      A,ACC
000716 FF                MOV      R7,A
   49: 		if (RC500SI)
000717 30A401            JNB      RC500SI,?C0009?MIFARE
   50: 			rdata+= 1;
00071A 0F                INC      R7
00071B         ?C0009?MIFARE:
   51: 		RC500SCK = 0;
00071B C2A1              CLR      RC500SCK
   52: 	}
00071D 0E                INC      R6
00071E EE                MOV      A,R6
00071F B408EF            CJNE     A,#08H,?C0006?MIFARE
000722         ?C0007?MIFARE:
   53: 	RC500CS=1;
000722 D2A3              SETB     RC500CS
   54: 	return (rdata);
   55: }
000724 22                RET      
----- FUNCTION _SPIReadOne (END) -------


----- FUNCTION AntiColl (BEGIN) -----
 FILE: 'Driver\mifare.c'
  278: uchar AntiColl(void)
  279: {
  280: 	
  281: 	uchar	temp,i;
  282: 
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 6


  283: 	//选择TX1、TX2的发射天线阻抗
  284: 	SPIWriteOne(CwConductance_Reg,0x3f);
000725 121556            LCALL    ?L?COM0020
000728 7493              MOV      A,#093H
00072A F0                MOVX     @DPTR,A
  285: 	//选择数据校验种类和模式
  286: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  287: 	
  288: 	gBuff[0] = RF_CMD_ANTICOL;
  289: 	gBuff[1] = 0x20;
00072B A3                INC      DPTR
00072C 7420              MOV      A,#020H
00072E 120B2C            LCALL    ?L?COM0010
000731 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
000734 7402              MOV      A,#02H
000736 F0                MOVX     @DPTR,A
000737 7F1E              MOV      R7,#01EH
000739 F194              ACALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R5' ----
00073B AD07              MOV      R5,AR7
  290: 	temp = Command_Send(Transceive,gBuff,2);
  291: 	if (temp==0)
00073D ED                MOV      A,R5
00073E 7003              JNZ      ?C0062?MIFARE
  292: 	{
  293: 		return(FM1702_NOTAGERR);
000740 7F01              MOV      R7,#01H
000742 22                RET      
  294: 	}
000743         ?C0062?MIFARE:
  295: 
  296: 	temp = SPIReadOne(FIFOLength_Reg);
000743 121620            LCALL    ?L?COM0046
000746 7003              JNZ      ?C0064?MIFARE
  297: 	if (temp == 0)
  298: 	{
  299: 		return FM1702_BYTECOUNTERR;
000748 7F0C              MOV      R7,#0CH
00074A 22                RET      
  300: 	}
00074B         ?C0064?MIFARE:
  301: 
  302: 	for(i=0;i<temp;i++)
;---- Variable 'i' assigned to Register 'R4' ----
00074B E4                CLR      A
00074C FC                MOV      R4,A
00074D         ?C0065?MIFARE:
00074D EC                MOV      A,R4
00074E C3                CLR      C
00074F 9D                SUBB     A,R5
000750 500C              JNC      ?C0066?MIFARE
  303: 	{
  304: 		gBuff[i] = SPIReadOne(FIFO_Reg);
000752 7F02              MOV      R7,#02H
000754 D1F4              ACALL    _SPIReadOne
000756 121ADA            LCALL    ?L?COM0038
000759 EF                MOV      A,R7
00075A F0                MOVX     @DPTR,A
  305: 	}
00075B 0C                INC      R4
00075C 80EF              SJMP     ?C0065?MIFARE
00075E         ?C0066?MIFARE:
  306: 	temp = SPIReadOne(ErrorFlag_Reg);	// 判断接数据是否有冲突位
00075E 7F0A              MOV      R7,#0AH
000760 121622            LCALL    ?L?COM0047
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 7


000763 5401              ANL      A,#01H
000765 FD                MOV      R5,A
  307: 	temp = temp & 0x01;
  308: 	if (temp == 0x00)
000766 7029              JNZ      ?C0068?MIFARE
  309: 	{
  310: 		for (i=0;i<5;i++)
000768 FC                MOV      R4,A
000769         ?C0069?MIFARE:
  311: 			temp^=gBuff[i];
000769 121ADA            LCALL    ?L?COM0038
00076C E0                MOVX     A,@DPTR
00076D 6D                XRL      A,R5
00076E FD                MOV      R5,A
00076F 0C                INC      R4
000770 EC                MOV      A,R4
000771 B405F5            CJNE     A,#05H,?C0069?MIFARE
000774         ?C0070?MIFARE:
  312: 		if (temp)
000774 ED                MOV      A,R5
000775 6003              JZ       ?C0072?MIFARE
  313: 			return(FM1702_SERNRERR);
000777 7F08              MOV      R7,#08H
000779 22                RET      
00077A         ?C0072?MIFARE:
  314:         for (i=0;i<5;i++)
00077A E4                CLR      A
00077B FC                MOV      R4,A
00077C         ?C0073?MIFARE:
  315:         {
  316:             gCard_UID[i]=gBuff[i];
00077C 121ADA            LCALL    ?L?COM0038
00077F E0                MOVX     A,@DPTR
000780 FF                MOV      R7,A
000781 74B4              MOV      A,#LOW gCard_UID
000783 2C                ADD      A,R4
000784 121B5E            LCALL    ?L?COM005A
000787 EF                MOV      A,R7
000788 F0                MOVX     @DPTR,A
  317:         }
000789 0C                INC      R4
00078A EC                MOV      A,R4
00078B B405EE            CJNE     A,#05H,?C0073?MIFARE
00078E         ?C0074?MIFARE:
  318: 		return(FM1702_OK);
00078E 7F00              MOV      R7,#00H
000790 22                RET      
  319: 	}
000791         ?C0068?MIFARE:
  320: 	else //有冲突位
  321: 		return FM1702_SERNRERR;
000791 7F08              MOV      R7,#08H
  322: }
000793 22                RET      
----- FUNCTION AntiColl (END) -------


----- FUNCTION _Command_Send (BEGIN) -----
 FILE: 'Driver\mifare.c'
  251: uchar Command_Send(uchar Comm_Set,uchar *buff, uchar count)
  252: {
000794 900094            MOV      DPTR,#Comm_Set
000797 EF                MOV      A,R7
000798 F0                MOVX     @DPTR,A
;---- Variable 'buff' assigned to Register 'R1/R2/R3' ----
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 8


  253:     uchar ucResult1,ucResult2,i;
  254:     SPIWriteOne(Command_Reg,0x00);
000799 E4                CLR      A
00079A FD                MOV      R5,A
00079B 7F01              MOV      R7,#01H
00079D D1BE              ACALL    _SPIWriteOne
  255:     if(Clear_FIFO()==FALSE)
00079F F1D9              ACALL    Clear_FIFO
0007A1 EF                MOV      A,R7
0007A2 7002              JNZ      ?C0055?MIFARE
  256:         return FALSE;
0007A4 FF                MOV      R7,A
0007A5 22                RET      
0007A6         ?C0055?MIFARE:
  257:     Write_FIFO(buff,count);
0007A6 900098            MOV      DPTR,#count
0007A9 E0                MOVX     A,@DPTR
0007AA FD                MOV      R5,A
0007AB 121A12            LCALL    _Write_FIFO
  258: 	SPIWriteOne(Command_Reg,Comm_Set);
0007AE 900094            MOV      DPTR,#Comm_Set
0007B1 E0                MOVX     A,@DPTR
0007B2 FD                MOV      R5,A
0007B3 7F01              MOV      R7,#01H
0007B5 D1BE              ACALL    _SPIWriteOne
  259: 	for (i=0;i<0xA0;i++)
;---- Variable 'i' assigned to Register 'R5' ----
0007B7 E4                CLR      A
0007B8 FD                MOV      R5,A
0007B9         ?C0057?MIFARE:
  260: 	{
  261:         ucResult1 = SPIReadOne(Command_Reg);
0007B9 7F01              MOV      R7,#01H
0007BB D1F4              ACALL    _SPIReadOne
;---- Variable 'ucResult1' assigned to Register 'R4' ----
0007BD AC07              MOV      R4,AR7
  262:         ucResult2 = SPIReadOne(InterruptRq_Reg) & 0x80;
0007BF 7F07              MOV      R7,#07H
0007C1 D1F4              ACALL    _SPIReadOne
0007C3 EF                MOV      A,R7
0007C4 5480              ANL      A,#080H
0007C6 FF                MOV      R7,A
;---- Variable 'ucResult2' assigned to Register 'R7' ----
  263:         if(ucResult1 == 0 || ucResult2 ==0x80)
0007C7 EC                MOV      A,R4
0007C8 6004              JZ       ?C0061?MIFARE
0007CA EF                MOV      A,R7
0007CB B48003            CJNE     A,#080H,?C0059?MIFARE
0007CE         ?C0061?MIFARE:
  264:             return TRUE;
0007CE 7F01              MOV      R7,#01H
0007D0 22                RET      
  265: 	}
0007D1         ?C0059?MIFARE:
0007D1 0D                INC      R5
0007D2 ED                MOV      A,R5
0007D3 B4A0E3            CJNE     A,#0A0H,?C0057?MIFARE
0007D6         ?C0058?MIFARE:
  266: 	return FALSE;
0007D6 7F00              MOV      R7,#00H
  267: }
0007D8 22                RET      
----- FUNCTION _Command_Send (END) -------


LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 9


----- FUNCTION Clear_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  190: uchar Clear_FIFO(void)
  191: {
  192:     uchar ucResult,i;
  193:     ucResult = SPIReadOne(Control_Reg);
0007D9 7F09              MOV      R7,#09H
;---- Variable 'ucResult' assigned to Register 'R4' ----
0007DB F1FC              ACALL    ?L?COM003B
0007DD 4401              ORL      A,#01H
0007DF FC                MOV      R4,A
  194:     ucResult |=0x01;
  195:     SPIWriteOne(Control_Reg,ucResult);
0007E0 FD                MOV      R5,A
0007E1 7F09              MOV      R7,#09H
0007E3 D1BE              ACALL    _SPIWriteOne
  196:     for(i=0;i<0xA0;i++)
;---- Variable 'i' assigned to Register 'R5' ----
0007E5 E4                CLR      A
0007E6 FD                MOV      R5,A
0007E7         ?C0039?MIFARE:
  197:     {
  198:         ucResult = SPIReadOne(FIFOLength_Reg);
0007E7 7F04              MOV      R7,#04H
0007E9 F1FC              ACALL    ?L?COM003B
0007EB 7003              JNZ      ?C0041?MIFARE
  199:         if(ucResult == 0)
  200:             return TRUE;
0007ED 7F01              MOV      R7,#01H
0007EF 22                RET      
  201:     }
0007F0         ?C0041?MIFARE:
0007F0 0D                INC      R5
0007F1 ED                MOV      A,R5
0007F2 B4A0F2            CJNE     A,#0A0H,?C0039?MIFARE
0007F5         ?C0040?MIFARE:
  202:     return FALSE;
0007F5 7F00              MOV      R7,#00H
  203: }
0007F7 22                RET      
----- FUNCTION Clear_FIFO (END) -------


----- FUNCTION app_brushInit (BEGIN) -----
 FILE: 'App\app_brush.c'
   38: void app_brushInit(void)
   39: {
   40: 	Init_FM1702();
   41: }
0007F8 C164              AJMP     Init_FM1702
----- FUNCTION app_brushInit (END) -------


----- FUNCTION ?L?COM003A (BEGIN) -----
0007FA 7F01              MOV      R7,#01H
0007FC         ?L?COM003B:
0007FC D1F4              ACALL    _SPIReadOne
0007FE AC07              MOV      R4,AR7
000800 EC                MOV      A,R4
000801 22                RET      
----- FUNCTION ?L?COM003A (END) -------


----- FUNCTION ?L?COM004A (BEGIN) -----
000802 7FE8              MOV      R7,#0E8H
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 10


000804 7E03              MOV      R6,#03H
----- FUNCTION _sys_delayms (BEGIN) -----
 FILE: 'System\sys_delay.c'
   10: void sys_delayms(UINT16 xms)
   11: {   
;---- Variable 'xms' assigned to Register 'R6/R7' ----
   12:     UINT8 i, j;
000806         ?C0004?SYS_DELAY:
   13: 	while(xms--)
000806 EF                MOV      A,R7
000807 1F                DEC      R7
000808 AC06              MOV      R4,AR6
00080A 7001              JNZ      ?C0013?SYS_DELAY
00080C 1E                DEC      R6
00080D         ?C0013?SYS_DELAY:
00080D 4C                ORL      A,R4
00080E 600D              JZ       ?C0011?SYS_DELAY
   14:     {
   15:     	WDT_CONTR |= 0x35;
000810 43C135            ORL      WDT_CONTR,#035H
   16:         i = 22;
;---- Variable 'i' assigned to Register 'R5' ----
000813 7D16              MOV      R5,#016H
   17:         j = 128;
;---- Variable 'j' assigned to Register 'R4' ----
000815 7C80              MOV      R4,#080H
   18:         do
   19:         {
000817         ?C0009?SYS_DELAY:
   20:             while (--j);
000817 DCFE              DJNZ     R4,?C0009?SYS_DELAY
000819         ?C0010?SYS_DELAY:
   21:         } while (--i);
000819         ?C0006?SYS_DELAY:
000819 DDFC              DJNZ     R5,?C0009?SYS_DELAY
   22:     }
00081B 80E9              SJMP     ?C0004?SYS_DELAY
   22: }
00081D         ?C0011?SYS_DELAY:
00081D 22                RET      
----- FUNCTION _sys_delayms (END) -------


----- FUNCTION app_Show (BEGIN) -----
 FILE: 'App\app_brush.c'
   20: void app_Show(void)
   21: {
   22:     if(!b_FactorySystem)
   23:     {
00081E 20091D            JB       b_FactorySystem,?C0002?APP_BRUSH
   24:         sys_delayms(1000);
   25:         led_ShowNumber(MoneySum/100, MoneySum%100, 0);
000821 1102              ACALL    ?L?COM004A
   26:         sys_delayms(1000);
000823 113F              ACALL    ?L?COM002B
000825 C006              PUSH     AR6
000827 C007              PUSH     AR7
000829 113F              ACALL    ?L?COM002B
00082B AF03              MOV      R7,AR3
00082D AD07              MOV      R5,AR7
00082F D007              POP      AR7
000831 D006              POP      AR6
000833 E4                CLR      A
000834 FB                MOV      R3,A
000835 1156              ACALL    _led_ShowNumber
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 11


   27:         gLedBuf[0] = 12;
000837 1102              ACALL    ?L?COM004A
   28:         gLedBuf[1] = 15;
000839 121AAC            LCALL    ?L?COM0023
   29:         gLedBuf[2] = 15;
   30:         gLedBuf[3] = 15;
   31:         gLedBuf[4] = 15;
   32:         gLedBuf[5] = 12;
   33:         gShowDot = 0;
   34:         sys_delayms(1000);
00083C 1102              ACALL    ?L?COM004A
   35:     }
   36: }
00083E         ?C0002?APP_BRUSH:
00083E 22                RET      
----- FUNCTION app_Show (END) -------


----- FUNCTION ?L?COM002B (BEGIN) -----
00083F E4                CLR      A
000840 7B64              MOV      R3,#064H
000842 FA                MOV      R2,A
000843 F9                MOV      R1,A
000844 F8                MOV      R0,A
000845 90009D            MOV      DPTR,#MoneySum
000848 E0                MOVX     A,@DPTR
000849 FC                MOV      R4,A
00084A A3                INC      DPTR
00084B E0                MOVX     A,@DPTR
00084C FD                MOV      R5,A
00084D A3                INC      DPTR
00084E E0                MOVX     A,@DPTR
00084F FE                MOV      R6,A
000850 A3                INC      DPTR
000851 E0                MOVX     A,@DPTR
000852 FF                MOV      R7,A
000853 0202D1            LJMP     ?C?ULDIV
----- FUNCTION ?L?COM002B (END) -------


----- FUNCTION _led_ShowNumber (BEGIN) -----
 FILE: 'Driver\LED.c'
   99: void led_ShowNumber(UINT16 L_num, UINT8 R_num, UINT8 DotPlace)
  100: {
000856 121B32            LCALL    ?L?COM0050
;---- Variable 'R_num' assigned to Register 'R2' ----
000859 AA05              MOV      R2,AR5
;---- Variable 'DotPlace' assigned to Register 'R3' ----
  101:     if(L_num>9999)
  102:     {
00085B D3                SETB     C
00085C E0                MOVX     A,@DPTR
00085D 940F              SUBB     A,#0FH
00085F 900070            MOV      DPTR,#L_num
000862 E0                MOVX     A,@DPTR
000863 9427              SUBB     A,#027H
000865 4007              JC       ?C0034?LED
  103:         L_num = 9999;
  104:     }
000867 7427              MOV      A,#027H
000869 F0                MOVX     @DPTR,A
00086A A3                INC      DPTR
00086B 740F              MOV      A,#0FH
00086D F0                MOVX     @DPTR,A
  105:     if(R_num>99)
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 12


00086E         ?C0034?LED:
  106:     {
00086E EA                MOV      A,R2
00086F D3                SETB     C
000870 9463              SUBB     A,#063H
000872 4002              JC       ?C0035?LED
  107:         R_num = 99;
  108:     }
000874 7A63              MOV      R2,#063H
  109:     gLedBuf[0] = L_num/1000;
000876         ?C0035?LED:
  110:     gLedBuf[1] = L_num/100%10;
000876 900070            MOV      DPTR,#L_num
000879 E0                MOVX     A,@DPTR
00087A FE                MOV      R6,A
00087B A3                INC      DPTR
00087C E0                MOVX     A,@DPTR
00087D FF                MOV      R7,A
00087E 7C03              MOV      R4,#03H
000880 7DE8              MOV      R5,#0E8H
000882 1201A8            LCALL    ?C?UIDIV
000885 9000E4            MOV      DPTR,#gLedBuf
000888 EF                MOV      A,R7
000889 713A              ACALL    ?L?COM001A
00088B 7D64              MOV      R5,#064H
00088D 11AD              ACALL    ?L?COM0005
00088F 11C4              ACALL    ?L?COM0008
000891 9000E6            MOV      DPTR,#gLedBuf+02H
000894 11BA              ACALL    ?L?COM0006
000896 9000E7            MOV      DPTR,#gLedBuf+03H
000899 ED                MOV      A,R5
00089A F0                MOVX     @DPTR,A
  111:     gLedBuf[2] = L_num/10%10;
  112:     gLedBuf[3] = L_num%10;
  113:     gLedBuf[4] = R_num/10%10;
00089B EA                MOV      A,R2
00089C 75F00A            MOV      B,#0AH
00089F 84                DIV      AB
0008A0 121B3B            LCALL    ?L?COM0051
  114:     gLedBuf[5] = R_num%10;
0008A3 EA                MOV      A,R2
0008A4 121B3B            LCALL    ?L?COM0051
  115:     gShowDot = DotPlace;
0008A7 9000EB            MOV      DPTR,#gShowDot
0008AA EB                MOV      A,R3
0008AB F0                MOVX     @DPTR,A
  116: }
0008AC 22                RET      
----- FUNCTION _led_ShowNumber (END) -------


----- FUNCTION ?L?COM0005 (BEGIN) -----
0008AD 1201A8            LCALL    ?C?UIDIV
0008B0 7C00              MOV      R4,#00H
0008B2 7D0A              MOV      R5,#0AH
0008B4 1201A8            LCALL    ?C?UIDIV
0008B7 9000E5            MOV      DPTR,#gLedBuf+01H
0008BA         ?L?COM0006:
0008BA ED                MOV      A,R5
0008BB F0                MOVX     @DPTR,A
0008BC 900070            MOV      DPTR,#L_num
0008BF         ?L?COM0007:
0008BF E0                MOVX     A,@DPTR
0008C0 FE                MOV      R6,A
0008C1 A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 13


0008C2 E0                MOVX     A,@DPTR
0008C3 FF                MOV      R7,A
0008C4         ?L?COM0008:
0008C4 7C00              MOV      R4,#00H
0008C6 7D0A              MOV      R5,#0AH
0008C8 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM0005 (END) -------


----- FUNCTION _led_ShowNumber1 (BEGIN) -----
 FILE: 'Driver\LED.c'
  118: void led_ShowNumber1(UINT16 L_num, UINT16 R_num, UINT8 DotPlace)
  119: {
0008CB 900072            MOV      DPTR,#R_num
0008CE EC                MOV      A,R4
0008CF F0                MOVX     @DPTR,A
0008D0 A3                INC      DPTR
0008D1 ED                MOV      A,R5
0008D2 F0                MOVX     @DPTR,A
0008D3 121B32            LCALL    ?L?COM0050
;---- Variable 'DotPlace' assigned to Register 'R3' ----
  120:     if(L_num>999)
  121:     {
0008D6 D3                SETB     C
0008D7 94E7              SUBB     A,#0E7H
0008D9 EE                MOV      A,R6
0008DA 9403              SUBB     A,#03H
0008DC 4005              JC       ?C0037?LED
  122:         L_num = 999;
  123:     }
0008DE 900070            MOV      DPTR,#L_num
0008E1 F1E6              ACALL    ?L?COM005E
  124:     if(R_num>999)
0008E3         ?C0037?LED:
  125:     {
0008E3 D3                SETB     C
0008E4 900073            MOV      DPTR,#R_num+01H
0008E7 E0                MOVX     A,@DPTR
0008E8 94E7              SUBB     A,#0E7H
0008EA 900072            MOV      DPTR,#R_num
0008ED E0                MOVX     A,@DPTR
0008EE 9403              SUBB     A,#03H
0008F0 4002              JC       ?C0038?LED
  126:         R_num = 999;
  127:     }
0008F2 F1E6              ACALL    ?L?COM005E
  128:     gLedBuf[0] = L_num/100%10;
0008F4         ?C0038?LED:
  129:     gLedBuf[1] = L_num/10%10;
0008F4 713B              ACALL    ?L?COM001B
0008F6 7D64              MOV      R5,#064H
0008F8 1201A8            LCALL    ?C?UIDIV
0008FB 11C4              ACALL    ?L?COM0008
0008FD 9000E4            MOV      DPTR,#gLedBuf
000900 ED                MOV      A,R5
000901 713A              ACALL    ?L?COM001A
000903 7D0A              MOV      R5,#0AH
000905 11AD              ACALL    ?L?COM0005
000907 9000E6            MOV      DPTR,#gLedBuf+02H
00090A ED                MOV      A,R5
00090B F0                MOVX     @DPTR,A
  130:     gLedBuf[2] = L_num%10;
  131:     gLedBuf[3] = R_num/100;
00090C 900072            MOV      DPTR,#R_num
00090F 713E              ACALL    ?L?COM001C
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 14


000911 7D64              MOV      R5,#064H
000913 1201A8            LCALL    ?C?UIDIV
000916 9000E7            MOV      DPTR,#gLedBuf+03H
000919 EF                MOV      A,R7
00091A F0                MOVX     @DPTR,A
  132:     if(gLedBuf[3] == 0)
00091B 7003              JNZ      ?C0039?LED
  133:     {
  134:         gLedBuf[3] = 12;
00091D 740C              MOV      A,#0CH
00091F F0                MOVX     @DPTR,A
  135:     }
000920         ?C0039?LED:
  136:     gLedBuf[4] = R_num/10%10;
000920 900072            MOV      DPTR,#R_num
000923 11BF              ACALL    ?L?COM0007
000925 11C4              ACALL    ?L?COM0008
000927 AF05              MOV      R7,AR5
000929 9000E8            MOV      DPTR,#gLedBuf+04H
00092C EF                MOV      A,R7
00092D F0                MOVX     @DPTR,A
  137:     if(gLedBuf[4] == 0)
00092E 7003              JNZ      ?C0040?LED
  138:     {
  139:         gLedBuf[4] = 12;
000930 740C              MOV      A,#0CH
000932 F0                MOVX     @DPTR,A
  140:     }
000933         ?C0040?LED:
  141:     gLedBuf[5] = R_num%10;
000933 900072            MOV      DPTR,#R_num
000936 11BF              ACALL    ?L?COM0007
000938 9000E9            MOV      DPTR,#gLedBuf+05H
00093B ED                MOV      A,R5
00093C F0                MOVX     @DPTR,A
  142:     gShowDot = DotPlace;
00093D 9000EB            MOV      DPTR,#gShowDot
000940 EB                MOV      A,R3
000941 F0                MOVX     @DPTR,A
  143: }
000942 22                RET      
----- FUNCTION _led_ShowNumber1 (END) -------


----- FUNCTION app_brushCycle1s (BEGIN) -----
 FILE: 'App\app_brush.c'
  114: void app_brushCycle1s(void)
  115: {
  116:     switch (app_brushCard())
  117:     {
000943 1213B7            LCALL    app_brushCard
000946 EF                MOV      A,R7
000947 24FE              ADD      A,#0FEH
000949 7002              JNZ      $ + 4H
00094B 4131              AJMP     ?C0039?APP_BRUSH
00094D 14                DEC      A
00094E 7002              JNZ      $ + 4H
000950 21EE              AJMP     ?C0033?APP_BRUSH
000952 2402              ADD      A,#02H
000954 6002              JZ       $ + 4H
000956 6112              AJMP     ?C0023?APP_BRUSH
  118:         case MEM_CARD:
  119:             if(hwa_mifareReadBlock(gBuff,4))
000958         ?C0024?APP_BRUSH:
  120:             {
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 15


000958 712D              ACALL    ?L?COM0011
00095A 7D04              MOV      R5,#04H
00095C 716D              ACALL    _hwa_mifareReadBlock
00095E 4002              JC       $ + 4H
000960 6112              AJMP     ?C0023?APP_BRUSH
  121:                 if(u8_FirstBrushCardDly)
  122:                 {
000962 9000E3            MOV      DPTR,#u8_FirstBrushCardDly
000965 E0                MOVX     A,@DPTR
000966 6078              JZ       ?C0026?APP_BRUSH
  123:                     if(gBuff[0]==0x01 && gBuff[1]==0x0A)
  124:                     {
000968 9000B9            MOV      DPTR,#gBuff
00096B E0                MOVX     A,@DPTR
00096C 6401              XRL      A,#01H
00096E 7031              JNZ      ?C0027?APP_BRUSH
000970 A3                INC      DPTR
000971 E0                MOVX     A,@DPTR
000972 B40A2C            CJNE     A,#0AH,?C0027?APP_BRUSH
  125:                         s_System.Money += 1000;
  126: 						if (s_System.Money > 20000)
000975 9000B3            MOV      DPTR,#s_System+012H
000978 E0                MOVX     A,@DPTR
000979 24E8              ADD      A,#0E8H
00097B F0                MOVX     @DPTR,A
00097C 9000B2            MOV      DPTR,#s_System+011H
00097F E0                MOVX     A,@DPTR
000980 3403              ADDC     A,#03H
000982 F0                MOVX     @DPTR,A
  127: 						{
000983 D3                SETB     C
000984 A3                INC      DPTR
000985 916A              ACALL    ?L?COM0033
000987 4004              JC       ?C0028?APP_BRUSH
  128: 							s_System.Money = 0;
  129: 						}
000989 E4                CLR      A
00098A F0                MOVX     @DPTR,A
00098B A3                INC      DPTR
00098C F0                MOVX     @DPTR,A
  130:                         s_System.Money -= s_System.Money%1000;
00098D         ?C0028?APP_BRUSH:
  131:                     }
00098D 9000B2            MOV      DPTR,#s_System+011H
000990 71A0              ACALL    ?L?COM0034
000992 C3                CLR      C
000993 EB                MOV      A,R3
000994 9D                SUBB     A,R5
000995 FE                MOV      R6,A
000996 EA                MOV      A,R2
000997 9C                SUBB     A,R4
000998 9000B2            MOV      DPTR,#s_System+011H
00099B F0                MOVX     @DPTR,A
00099C A3                INC      DPTR
00099D CE                XCH      A,R6
00099E F0                MOVX     @DPTR,A
  132:                     else if(gBuff[0]==0xFA && gBuff[1]==0x01)
00099F 803F              SJMP     ?C0026?APP_BRUSH
0009A1         ?C0027?APP_BRUSH:
  133:                     {
0009A1 9000B9            MOV      DPTR,#gBuff
0009A4 E0                MOVX     A,@DPTR
0009A5 64FA              XRL      A,#0FAH
0009A7 7037              JNZ      ?C0026?APP_BRUSH
0009A9 A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 16


0009AA E0                MOVX     A,@DPTR
0009AB 6401              XRL      A,#01H
0009AD 7031              JNZ      ?C0026?APP_BRUSH
  134:                         if(s_System.Money<20000)
  135:                         {
0009AF C3                CLR      C
0009B0 9167              ACALL    ?L?COM0032
0009B2 502C              JNC      ?C0026?APP_BRUSH
  136:                             s_System.Money += 100;
  137:                             if (s_System.Money % 1000 == 0 && s_System.Money/1000>0)
0009B4 A3                INC      DPTR
0009B5 E0                MOVX     A,@DPTR
0009B6 2464              ADD      A,#064H
0009B8 F0                MOVX     @DPTR,A
0009B9 9000B2            MOV      DPTR,#s_System+011H
0009BC E0                MOVX     A,@DPTR
0009BD 3400              ADDC     A,#00H
0009BF F0                MOVX     @DPTR,A
  138:                             {
0009C0 71A0              ACALL    ?L?COM0034
0009C2 ED                MOV      A,R5
0009C3 4C                ORL      A,R4
0009C4 701A              JNZ      ?C0026?APP_BRUSH
0009C6 7C03              MOV      R4,#03H
0009C8 7DE8              MOV      R5,#0E8H
0009CA F1DF              ACALL    ?L?COM0064
0009CC D3                SETB     C
0009CD EF                MOV      A,R7
0009CE 9400              SUBB     A,#00H
0009D0 EE                MOV      A,R6
0009D1 9400              SUBB     A,#00H
0009D3 400B              JC       ?C0026?APP_BRUSH
  139:                                 s_System.Money -= 1000;
  140:                             }
0009D5 E0                MOVX     A,@DPTR
0009D6 2418              ADD      A,#018H
0009D8 F0                MOVX     @DPTR,A
0009D9 9000B2            MOV      DPTR,#s_System+011H
0009DC E0                MOVX     A,@DPTR
0009DD 34FC              ADDC     A,#0FCH
0009DF F0                MOVX     @DPTR,A
  141:                         }
  142:                     }
  143:                 }
  144:                 led_ShowNumber1(s_System.Money/100, u8_BrushNum, 0);
0009E0         ?C0026?APP_BRUSH:
  145:                 u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
0009E0 7197              ACALL    ?L?COM003C
0009E2 7152              ACALL    ?L?COM000C
0009E4 7164              ACALL    ?L?COM0040
  146:                 buzzer_SoundNumber(1);
0009E6 7F01              MOV      R7,#01H
0009E8 7134              ACALL    _buzzer_SoundNumber
  147:                 b_SettingChange = TRUE;
0009EA D208              SETB     b_SettingChange
  148:             }
  149:             break;
0009EC 6112              AJMP     ?C0023?APP_BRUSH
  150:             
  151:         case PWD_CARD:                                 //从初始卡中读取管理卡密码，并储存至E2
0009EE         ?C0033?APP_BRUSH:
  152:             if(hwa_mifareReadBlock(gBuff,4))       //读取管理卡密码
0009EE 712D              ACALL    ?L?COM0011
0009F0 7D04              MOV      R5,#04H
0009F2 716D              ACALL    _hwa_mifareReadBlock
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 17


0009F4 4002              JC       $ + 4H
0009F6 6112              AJMP     ?C0023?APP_BRUSH
  153:             {
  154:                 memcpy(&s_System, gBuff, 16);
0009F8 78A1              MOV      R0,#LOW s_System
0009FA 7C00              MOV      R4,#HIGH s_System
0009FC 7D01              MOV      R5,#01H
0009FE 712D              ACALL    ?L?COM0011
000A00 F1CA              ACALL    ?L?COM0048
  155:                 s_System.Money = 0;
000A02 E4                CLR      A
000A03 9000B2            MOV      DPTR,#s_System+011H
000A06 F0                MOVX     @DPTR,A
000A07 712B              ACALL    ?L?COM000F
000A09 7D05              MOV      R5,#05H
000A0B 716D              ACALL    _hwa_mifareReadBlock
000A0D 4002              JC       $ + 4H
000A0F 6112              AJMP     ?C0023?APP_BRUSH
  156: 
  157: 	            if (hwa_mifareReadBlock(gBuff, 5))			//读取管理卡和用户卡密码以及扇区
  158: 	            {
  159: 	                if(gBuff[0] == 0x01)
000A11 9000B9            MOV      DPTR,#gBuff
000A14 E0                MOVX     A,@DPTR
000A15 B40108            CJNE     A,#01H,?C0036?APP_BRUSH
  160: 	                {
  161: 	                    s_System.RecoveryOldCard = 1;
000A18 9000B1            MOV      DPTR,#s_System+010H
000A1B 7401              MOV      A,#01H
000A1D F0                MOVX     @DPTR,A
  162: 	                }
000A1E 8005              SJMP     ?C0038?APP_BRUSH
000A20         ?C0036?APP_BRUSH:
  163: 	                else
  164: 	                {
  165: 	                    s_System.RecoveryOldCard = 0;
000A20 E4                CLR      A
000A21 9000B1            MOV      DPTR,#s_System+010H
000A24 F0                MOVX     @DPTR,A
  166: 	                }
  167: 	            }
  168: 	            else
  169: 	            {
  170: 	                break;
  171: 	            }
000A25         ?C0038?APP_BRUSH:
  172:                 app_configWrite(SYSTEM_SETTING_SECTOR);
000A25 E4                CLR      A
000A26 FF                MOV      R7,A
000A27 71AF              ACALL    _app_configWrite
  173:                 buzzer_SoundNumber(1);
000A29 7F01              MOV      R7,#01H
000A2B 7134              ACALL    _buzzer_SoundNumber
  174:                 b_FactorySystem = FALSE;
000A2D C209              CLR      b_FactorySystem
  175:             }
  176:             break;
000A2F 6112              AJMP     ?C0023?APP_BRUSH
  177:             
  178:         case USER_CARD:
000A31         ?C0039?APP_BRUSH:
  179: //            pMoney->money = 1000;
  180: //            hwa_mifareWriteSector(gBuff, s_System.Sector);
  181: //            break;
  182:             if(hwa_mifareReadSector(gBuff, s_System.Sector))
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 18


000A31 712D              ACALL    ?L?COM0011
000A33 9000A7            MOV      DPTR,#s_System+06H
000A36 E0                MOVX     A,@DPTR
000A37 FD                MOV      R5,A
000A38 91E2              ACALL    _hwa_mifareReadSector
000A3A 4002              JC       $ + 4H
000A3C 6112              AJMP     ?C0023?APP_BRUSH
  183:             {
  184:                 if(b_SettingChange == FALSE)
000A3E 200826            JB       b_SettingChange,?C0041?APP_BRUSH
  185:                 {
  186:                     led_ShowNumber(pMoney->money/100, pMoney->money%100, 1<<3);
000A41 AB08              MOV      R3,pMoney
000A43 AA09              MOV      R2,pMoney+01H
000A45 A90A              MOV      R1,pMoney+02H
000A47 120213            LCALL    ?C?ILDPTR
000A4A FB                MOV      R3,A
000A4B AAF0              MOV      R2,B
000A4D 7C00              MOV      R4,#00H
000A4F 7D64              MOV      R5,#064H
000A51 71A9              ACALL    ?L?COM0035
000A53 C006              PUSH     AR6
000A55 C007              PUSH     AR7
000A57 7C00              MOV      R4,#00H
000A59 7D64              MOV      R5,#064H
000A5B F1DF              ACALL    ?L?COM0064
000A5D D007              POP      AR7
000A5F D006              POP      AR6
000A61 7B08              MOV      R3,#08H
000A63 1156              ACALL    _led_ShowNumber
  187:                     u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
  188:                     buzzer_SoundNumber(1);
  189:                 }
000A65 41FD              AJMP     ?C0065?APP_BRUSH
000A67         ?C0041?APP_BRUSH:
  190:                 else
  191:                 {
  192:                     if ((pMoney->money+s_System.Money <= 20000
000A67 121A8D            LCALL    ?L?COM0015
000A6A 5009              JNC      ?C0045?APP_BRUSH
000A6C 121AE5            LCALL    ?L?COM0039
000A6F 1204F5            LCALL    ?C?MEMCMP
000A72 EF                MOV      A,R7
000A73 700C              JNZ      ?C0044?APP_BRUSH
000A75         ?C0045?APP_BRUSH:
000A75 9000B2            MOV      DPTR,#s_System+011H
000A78 E0                MOVX     A,@DPTR
000A79 7002              JNZ      ?C0060?APP_BRUSH
000A7B A3                INC      DPTR
000A7C E0                MOVX     A,@DPTR
000A7D         ?C0060?APP_BRUSH:
000A7D 6002              JZ       $ + 4H
000A7F 6103              AJMP     ?C0043?APP_BRUSH
000A81         ?C0044?APP_BRUSH:
  193:                         && memcmp(LastCardId, gCard_UID, 5))
  194:                         || s_System.Money == 0)
  195:                     {
  196:                         if(s_System.Money == 0)
000A81 9000B2            MOV      DPTR,#s_System+011H
000A84 E0                MOVX     A,@DPTR
000A85 7002              JNZ      ?C0061?APP_BRUSH
000A87 A3                INC      DPTR
000A88 E0                MOVX     A,@DPTR
000A89         ?C0061?APP_BRUSH:
000A89 701B              JNZ      ?C0046?APP_BRUSH
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 19


  197:                         {
  198:                             pMoney->money = 0;
000A8B AB08              MOV      R3,pMoney
000A8D AA09              MOV      R2,pMoney+01H
000A8F A90A              MOV      R1,pMoney+02H
000A91 F5F0              MOV      B,A
000A93 120276            LCALL    ?C?ISTPTR
  199:                             if(hwa_mifareWriteSector(gBuff, s_System.Sector))
000A96 712D              ACALL    ?L?COM0011
000A98 9174              ACALL    ?L?COM004F
000A9A 506C              JNC      ?C0066?APP_BRUSH
  200:                             {
  201:                                 buzzer_SoundNumber(1);
000A9C 7F01              MOV      R7,#01H
000A9E 7134              ACALL    _buzzer_SoundNumber
  202:                                 led_ShowNumber1(pMoney->money/100, u8_BrushNum, 0);
000AA0 7146              ACALL    ?L?COM000B
000AA2 7164              ACALL    ?L?COM0040
  203:                                 u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
  204:                                 break;
000AA4 806C              SJMP     ?C0023?APP_BRUSH
  205:                             }
000AA6         ?C0046?APP_BRUSH:
  206:                             else
  207:                             {
  208:                                 buzzer_SoundNumber(2);
  209:                             }
  210:                         }
  211:                         else
  212:                         {
  213:                             pMoney->money += s_System.Money;
000AA6 7197              ACALL    ?L?COM003C
000AA8 AB08              MOV      R3,pMoney
000AAA AA09              MOV      R2,pMoney+01H
000AAC A90A              MOV      R1,pMoney+02H
000AAE EE                MOV      A,R6
000AAF 8FF0              MOV      B,R7
000AB1 12023E            LCALL    ?C?IILDPTR
  214:                             if(hwa_mifareWriteSector(gBuff, s_System.Sector))
000AB4 712D              ACALL    ?L?COM0011
000AB6 9174              ACALL    ?L?COM004F
000AB8 5052              JNC      ?C0042?APP_BRUSH
  215:                             {
  216:                                 MoneySum += s_System.Money/100;
000ABA 90009D            MOV      DPTR,#MoneySum
000ABD E0                MOVX     A,@DPTR
000ABE F8                MOV      R0,A
000ABF A3                INC      DPTR
000AC0 121B6E            LCALL    ?L?COM0063
000AC3 FB                MOV      R3,A
000AC4 C000              PUSH     AR0
000AC6 9000B2            MOV      DPTR,#s_System+011H
000AC9 713E              ACALL    ?L?COM001C
000ACB 7D64              MOV      R5,#064H
000ACD 1201A8            LCALL    ?C?UIDIV
000AD0 E4                CLR      A
000AD1 FC                MOV      R4,A
000AD2 FD                MOV      R5,A
000AD3 D000              POP      AR0
000AD5 EB                MOV      A,R3
000AD6 2F                ADD      A,R7
000AD7 FF                MOV      R7,A
000AD8 EA                MOV      A,R2
000AD9 3E                ADDC     A,R6
000ADA FE                MOV      R6,A
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 20


000ADB ED                MOV      A,R5
000ADC 39                ADDC     A,R1
000ADD FD                MOV      R5,A
000ADE EC                MOV      A,R4
000ADF 38                ADDC     A,R0
000AE0 FC                MOV      R4,A
000AE1 90009D            MOV      DPTR,#MoneySum
000AE4 120363            LCALL    ?C?LSTXDATA
  217:                                 u8_BrushNum++;
000AE7 9000E2            MOV      DPTR,#u8_BrushNum+01H
000AEA E0                MOVX     A,@DPTR
000AEB 04                INC      A
000AEC F0                MOVX     @DPTR,A
000AED 7006              JNZ      ?C0062?APP_BRUSH
000AEF 9000E1            MOV      DPTR,#u8_BrushNum
000AF2 E0                MOVX     A,@DPTR
000AF3 04                INC      A
000AF4 F0                MOVX     @DPTR,A
000AF5         ?C0062?APP_BRUSH:
  218:                                 app_configWrite(MONEY_SECTOR);
000AF5 7F01              MOV      R7,#01H
000AF7 71AF              ACALL    _app_configWrite
  219:                                 led_ShowNumber1(pMoney->money/100, u8_BrushNum, 0);
000AF9 7146              ACALL    ?L?COM000B
000AFB 11CB              ACALL    _led_ShowNumber1
  220:                                 u8_FirstBrushCardDly = u8_First_Brush_Card_Dly;
000AFD         
000AFD 7166              ACALL    ?L?COM0041
  221:                                 buzzer_SoundNumber(1);
000AFF 7F01              MOV      R7,#01H
  222:                             }
  223:                         }
  224:                     }
000B01 8007              SJMP     ?C0067?APP_BRUSH
000B03         ?C0043?APP_BRUSH:
  225:                     else if(pMoney->money+s_System.Money > 20000)
000B03 121A8D            LCALL    ?L?COM0015
000B06 4004              JC       ?C0042?APP_BRUSH
  226:                     {
  227:                         buzzer_SoundNumber(2);
000B08         
000B08 7F02              MOV      R7,#02H
000B0A         
000B0A 7134              ACALL    _buzzer_SoundNumber
  228:                     }
  229:                 }
000B0C         ?C0042?APP_BRUSH:
  230:                 memcpy(LastCardId, gCard_UID, 5);
000B0C 121AE5            LCALL    ?L?COM0039
000B0F 1200F6            LCALL    ?C?COPY
  231:             }
  232:             break;
  233:             
  234:         default:
  235:             break;
  236:     }
000B12         ?C0023?APP_BRUSH:
  237:     
  238:     if(u8_FirstBrushCardDly)
000B12 9000E3            MOV      DPTR,#u8_FirstBrushCardDly
000B15 E0                MOVX     A,@DPTR
000B16 6003              JZ       ?C0054?APP_BRUSH
  239:     {
  240:         u8_FirstBrushCardDly--;
000B18 14                DEC      A
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 21


000B19 F0                MOVX     @DPTR,A
  241:     }
000B1A 22                RET      
000B1B         ?C0054?APP_BRUSH:
  242:     else if(!b_FactorySystem)
000B1B 20090C            JB       b_FactorySystem,?C0059?APP_BRUSH
  243:     {
  244:         if(b_SettingChange)
000B1E 300806            JNB      b_SettingChange,?C0057?APP_BRUSH
  245:         {
  246:             led_ShowNumber1(s_System.Money/100, u8_BrushNum, 0);
000B21 7197              ACALL    ?L?COM003C
000B23 7152              ACALL    ?L?COM000C
000B25 01CB              AJMP     _led_ShowNumber1
  247:         }
000B27         ?C0057?APP_BRUSH:
  248:         else
  249:         {
  250:             gLedBuf[0] = 12;
000B27 121AAC            LCALL    ?L?COM0023
  251:             gLedBuf[1] = 15;
  252:             gLedBuf[2] = 15;
  253:             gLedBuf[3] = 15;
  254:             gLedBuf[4] = 15;
  255:             gLedBuf[5] = 12;
  256:             gShowDot = 0;
  257:         }
  258:     }
  259: }
000B2A         ?C0059?APP_BRUSH:
000B2A 22                RET      
----- FUNCTION app_brushCycle1s (END) -------


----- FUNCTION ?L?COM000F (BEGIN) -----
000B2B A3                INC      DPTR
000B2C         ?L?COM0010:
000B2C F0                MOVX     @DPTR,A
000B2D         ?L?COM0011:
000B2D 7B01              MOV      R3,#01H
000B2F 7A00              MOV      R2,#HIGH gBuff
000B31 79B9              MOV      R1,#LOW gBuff
000B33 22                RET      
----- FUNCTION ?L?COM000F (END) -------


----- FUNCTION _buzzer_SoundNumber (BEGIN) -----
 FILE: 'Driver\buzzer.c'
   28: void buzzer_SoundNumber(UINT8 num)
   29: {
;---- Variable 'num' assigned to Register 'R7' ----
   30:     SoundNumberCount = num;
   30: }
000B34 9000EF            MOV      DPTR,#SoundNumberCount
000B37 EF                MOV      A,R7
000B38 F0                MOVX     @DPTR,A
   30: 
000B39 22                RET      
----- FUNCTION _buzzer_SoundNumber (END) -------


----- FUNCTION ?L?COM001A (BEGIN) -----
000B3A F0                MOVX     @DPTR,A
000B3B         ?L?COM001B:
000B3B 900070            MOV      DPTR,#L_num
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 22


000B3E         ?L?COM001C:
000B3E E0                MOVX     A,@DPTR
000B3F FE                MOV      R6,A
000B40 A3                INC      DPTR
000B41 E0                MOVX     A,@DPTR
000B42 FF                MOV      R7,A
000B43 7C00              MOV      R4,#00H
000B45 22                RET      
----- FUNCTION ?L?COM001A (END) -------


----- FUNCTION ?L?COM000B (BEGIN) -----
000B46 AB08              MOV      R3,pMoney
000B48 AA09              MOV      R2,pMoney+01H
000B4A A90A              MOV      R1,pMoney+02H
000B4C 120213            LCALL    ?C?ILDPTR
000B4F FF                MOV      R7,A
000B50 AEF0              MOV      R6,B
000B52         ?L?COM000C:
000B52 7C00              MOV      R4,#00H
000B54 7D64              MOV      R5,#064H
000B56 1201A8            LCALL    ?C?UIDIV
000B59 9000E1            MOV      DPTR,#u8_BrushNum
000B5C E0                MOVX     A,@DPTR
000B5D FC                MOV      R4,A
000B5E A3                INC      DPTR
000B5F E0                MOVX     A,@DPTR
000B60 FD                MOV      R5,A
000B61 E4                CLR      A
000B62 FB                MOV      R3,A
000B63 22                RET      
----- FUNCTION ?L?COM000B (END) -------


----- FUNCTION ?L?COM0040 (BEGIN) -----
000B64 11CB              ACALL    _led_ShowNumber1
000B66         ?L?COM0041:
000B66 9000E3            MOV      DPTR,#u8_FirstBrushCardDly
000B69 7403              MOV      A,#03H
000B6B F0                MOVX     @DPTR,A
000B6C 22                RET      
----- FUNCTION ?L?COM0040 (END) -------


----- FUNCTION _hwa_mifareReadBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   57: BOOL hwa_mifareReadBlock(UINT8 *buff, UINT8 block)
   58: {
000B6D 900076            MOV      DPTR,#buff
000B70 B1FA              ACALL    ?L?COM0004
000B72 A3                INC      DPTR
000B73 ED                MOV      A,R5
000B74 F0                MOVX     @DPTR,A
   59: 	UINT8 u8_ReadErrCount;
   60: 	UINT8 u8_Result;
   61: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
000B75 E4                CLR      A
000B76 A3                INC      DPTR
000B77 F0                MOVX     @DPTR,A
000B78         ?C0018?HWA_MIFARE:
   62: 	{
   63: 		u8_Result = Read_Block(buff, block);
000B78 900076            MOV      DPTR,#buff
000B7B 91DA              ACALL    ?L?COM0002
000B7D F9                MOV      R1,A
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 23


000B7E A3                INC      DPTR
000B7F E0                MOVX     A,@DPTR
000B80 FD                MOV      R5,A
000B81 F175              ACALL    _Read_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   64: 		if (u8_Result == FM1702_OK)
000B83 EF                MOV      A,R7
000B84 7002              JNZ      ?C0021?HWA_MIFARE
   65: 		{
   66: 			return TRUE;
000B86 D3                SETB     C
000B87 22                RET      
   67: 		}
000B88         ?C0021?HWA_MIFARE:
   68: 		else if (u8_Result == FM1702_NOTAGERR)
000B88 EF                MOV      A,R7
000B89 B40102            CJNE     A,#01H,?C0020?HWA_MIFARE
   69: 		{
   70: 			return FALSE;
000B8C C3                CLR      C
000B8D 22                RET      
   71: 		}
   72: 	}
000B8E         ?C0020?HWA_MIFARE:
000B8E 90007A            MOV      DPTR,#u8_ReadErrCount
000B91 F1EE              ACALL    ?L?COM0060
000B93 40E3              JC       ?C0018?HWA_MIFARE
000B95         ?C0019?HWA_MIFARE:
   73: 	return FALSE;
000B95 C3                CLR      C
   74: }
000B96 22                RET      
----- FUNCTION _hwa_mifareReadBlock (END) -------


----- FUNCTION ?L?COM003C (BEGIN) -----
000B97 9000B2            MOV      DPTR,#s_System+011H
000B9A E0                MOVX     A,@DPTR
000B9B FE                MOV      R6,A
000B9C A3                INC      DPTR
000B9D E0                MOVX     A,@DPTR
000B9E FF                MOV      R7,A
000B9F 22                RET      
----- FUNCTION ?L?COM003C (END) -------


----- FUNCTION ?L?COM0034 (BEGIN) -----
000BA0 E0                MOVX     A,@DPTR
000BA1 FA                MOV      R2,A
000BA2 A3                INC      DPTR
000BA3 E0                MOVX     A,@DPTR
000BA4 FB                MOV      R3,A
000BA5 7C03              MOV      R4,#03H
000BA7 7DE8              MOV      R5,#0E8H
000BA9         ?L?COM0035:
000BA9 FF                MOV      R7,A
000BAA AE02              MOV      R6,AR2
000BAC 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM0034 (END) -------


----- FUNCTION _app_configWrite (BEGIN) -----
 FILE: 'App\app_config.c'
   99: void app_configWrite(UINT8 Sector)
  100: {
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 24


000BAF 900070            MOV      DPTR,#Sector
000BB2 EF                MOV      A,R7
000BB3 F0                MOVX     @DPTR,A
  101:     led_Switch(OFF);
  102:     if(Sector == SYSTEM_SETTING_SECTOR)
000BB4 C201              CLR      ?led_Switch?BIT
000BB6 71D1              ACALL    led_Switch
  103:     {
000BB8 900070            MOV      DPTR,#Sector
000BBB E0                MOVX     A,@DPTR
000BBC 7B01              MOV      R3,#01H
000BBE 7007              JNZ      ?C0012?APP_CONFIG
  104:         hwa_eepromWriteSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
  105:     }
000BC0 7A00              MOV      R2,#HIGH s_System
000BC2 79A1              MOV      R1,#LOW s_System
000BC4 FD                MOV      R5,A
  106:     else
000BC5 8006              SJMP     ?C0017?APP_CONFIG
000BC7         ?C0012?APP_CONFIG:
  107:     {
  108:         hwa_eepromWriteSector((UINT8*)&MoneySum, MONEY_SECTOR);
000BC7 7A00              MOV      R2,#HIGH MoneySum
000BC9 799D              MOV      R1,#LOW MoneySum
000BCB 7D01              MOV      R5,#01H
000BCD         
000BCD D198              ACALL    _hwa_eepromWriteSector
  109:     }
000BCF         ?C0013?APP_CONFIG:
  110:     led_Switch(ON);
000BCF D201              SETB     ?led_Switch?BIT
;----                  JMP      led_Switch
----- FUNCTION _app_configWrite (END) -------


----- FUNCTION led_Switch (BEGIN) -----
 FILE: 'Driver\LED.c'
  156: void led_Switch(bit sw)
  157: {
  158:     ledsw = sw;
  159:     if(ledsw==0)
000BD1 A201              MOV      C,sw
000BD3 920A              MOV      ledsw,C
  160:     {
000BD5 200A03            JB       ledsw,?C0044?LED
  161:     	LED_CS0 = 1;
  162:     	LED_CS1 = 1;
000BD8 1211DC            LCALL    ?L?COM0043
  163:     	LED_CS2 = 1;
  164:     	LED_CS3 = 1;
  165:     	LED_CS4 = 1;
  166:     	LED_CS5 = 1;
  167:     }
  168: }
000BDB         ?C0044?LED:
000BDB 22                RET      
----- FUNCTION led_Switch (END) -------


----- FUNCTION app_configInit (BEGIN) -----
 FILE: 'App\app_config.c'
   47: void app_configInit(void)
   48: {
   49:     BOOL state = FALSE;
   50:     led_Switch(OFF);
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 25


000BDC C200              CLR      state
   51:     hwa_eepromInit();
000BDE C201              CLR      ?led_Switch?BIT
000BE0 71D1              ACALL    led_Switch
   52:     if(app_configRead(SYSTEM_SETTING_SECTOR) == FALSE)
000BE2 120009            LCALL    hwa_eepromInit
   53:     {
000BE5 E4                CLR      A
000BE6 FF                MOV      R7,A
000BE7 121941            LCALL    _app_configRead
000BEA 4021              JC       ?C0001?APP_CONFIG
   54:         memcpy(&s_System, &s_FactorySystem, sizeof(s_System));
   55:         b_FactorySystem = TRUE;
000BEC 78A1              MOV      R0,#LOW s_System
000BEE 7C00              MOV      R4,#HIGH s_System
000BF0 7D01              MOV      R5,#01H
000BF2 7BFF              MOV      R3,#0FFH
000BF4 7A00              MOV      R2,#HIGH s_FactorySystem
000BF6 790E              MOV      R1,#LOW s_FactorySystem
000BF8 7E00              MOV      R6,#00H
000BFA 7F13              MOV      R7,#013H
000BFC 1200F6            LCALL    ?C?COPY
   56:         led_ShowNumber(8888,88,0xFF);
000BFF D209              SETB     b_FactorySystem
   57:     }
000C01 7BFF              MOV      R3,#0FFH
000C03 7D58              MOV      R5,#058H
000C05 7FB8              MOV      R7,#0B8H
000C07 7E22              MOV      R6,#022H
000C09 1156              ACALL    _led_ShowNumber
   58:     else
000C0B 803C              SJMP     ?C0002?APP_CONFIG
000C0D         ?C0001?APP_CONFIG:
   59:     {
   60:         if(s_System.Sector > 16 || s_System.Sector < 1)                 //钱包分区不在1~16
000C0D 9000A7            MOV      DPTR,#s_System+06H
000C10 E0                MOVX     A,@DPTR
000C11 FF                MOV      R7,A
000C12 D3                SETB     C
000C13 9410              SUBB     A,#010H
000C15 5006              JNC      ?C0004?APP_CONFIG
000C17 EF                MOV      A,R7
000C18 C3                CLR      C
000C19 9401              SUBB     A,#01H
000C1B 500B              JNC      ?C0003?APP_CONFIG
000C1D         ?C0004?APP_CONFIG:
   61:         {
   62:             s_System.Sector = s_FactorySystem.Sector;
000C1D 900014            MOV      DPTR,#s_FactorySystem+06H
000C20 E4                CLR      A
000C21 93                MOVC     A,@A+DPTR
000C22 9000A7            MOV      DPTR,#s_System+06H
000C25 F0                MOVX     @DPTR,A
   63:             state = TRUE;
000C26 D200              SETB     state
   64:         }
000C28         ?C0003?APP_CONFIG:
   65:         if(s_System.Money > 20000)                                        //金额大于200
000C28 D3                SETB     C
000C29 9167              ACALL    ?L?COM0032
000C2B 4013              JC       ?C0005?APP_CONFIG
   66:         {
   67:             s_System.Money = s_FactorySystem.Money;
000C2D 90001F            MOV      DPTR,#s_FactorySystem+011H
000C30 E4                CLR      A
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 26


000C31 93                MOVC     A,@A+DPTR
000C32 FF                MOV      R7,A
000C33 7401              MOV      A,#01H
000C35 93                MOVC     A,@A+DPTR
000C36 9000B2            MOV      DPTR,#s_System+011H
000C39 CF                XCH      A,R7
000C3A F0                MOVX     @DPTR,A
000C3B A3                INC      DPTR
000C3C EF                MOV      A,R7
000C3D F0                MOVX     @DPTR,A
   68:             state = TRUE;
000C3E D200              SETB     state
   69:         }
000C40         ?C0005?APP_CONFIG:
   70:         if(state)
000C40 300006            JNB      state,?C0002?APP_CONFIG
   71:         {
   72: 			app_configWrite(SYSTEM_SETTING_SECTOR);
000C43 E4                CLR      A
000C44 FF                MOV      R7,A
000C45 71AF              ACALL    _app_configWrite
   73:             b_FactorySystem = TRUE;
000C47 D209              SETB     b_FactorySystem
   74:         }
   75:     }
000C49         ?C0002?APP_CONFIG:
   76:     
   77:     if(app_configRead(MONEY_SECTOR) == FALSE)
000C49 7F01              MOV      R7,#01H
000C4B 121941            LCALL    _app_configRead
000C4E 4013              JC       ?C0007?APP_CONFIG
   78:     {
   79:         memset(&MoneySum, 0x00, sizeof(MoneySum));
000C50 7E00              MOV      R6,#00H
000C52 7F04              MOV      R7,#04H
000C54 7D00              MOV      R5,#00H
000C56 7B01              MOV      R3,#01H
000C58 7A00              MOV      R2,#HIGH MoneySum
000C5A 799D              MOV      R1,#LOW MoneySum
000C5C 120519            LCALL    ?C?MEMSET
   80: 		app_configWrite(MONEY_SECTOR);
000C5F 7F01              MOV      R7,#01H
000C61 71AF              ACALL    _app_configWrite
   81:     }
000C63         ?C0007?APP_CONFIG:
   82:     led_Switch(ON);
000C63 D201              SETB     ?led_Switch?BIT
000C65 61D1              AJMP     led_Switch
----- FUNCTION app_configInit (END) -------


----- FUNCTION ?L?COM0032 (BEGIN) -----
000C67 9000B3            MOV      DPTR,#s_System+012H
000C6A         ?L?COM0033:
000C6A E0                MOVX     A,@DPTR
000C6B 9420              SUBB     A,#020H
000C6D 9000B2            MOV      DPTR,#s_System+011H
000C70 E0                MOVX     A,@DPTR
000C71 944E              SUBB     A,#04EH
000C73 22                RET      
----- FUNCTION ?L?COM0032 (END) -------


----- FUNCTION ?L?COM004F (BEGIN) -----
000C74 9000A7            MOV      DPTR,#s_System+06H
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 27


000C77 E0                MOVX     A,@DPTR
000C78 FD                MOV      R5,A
----- FUNCTION _hwa_mifareWriteSector (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  255: BOOL hwa_mifareWriteSector(UINT8 *dat, UINT8 sector)
  256: {
000C79 900078            MOV      DPTR,#dat
000C7C B1FA              ACALL    ?L?COM0004
;---- Variable 'sector' assigned to Register 'R5' ----
  257: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  258: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
000C7E ED                MOV      A,R5
000C7F 121AF6            LCALL    ?L?COM003E
  259: 	UINT16 crc;
  260:     BOOL falg = FALSE;
000C82 C200              CLR      falg
  261: 	if (dat != NULL && sector > 0 && sector < 16)
000C84 900078            MOV      DPTR,#dat
000C87 91DA              ACALL    ?L?COM0002
000C89 4A                ORL      A,R2
000C8A 4B                ORL      A,R3
000C8B 6047              JZ       ?C0067?HWA_MIFARE
000C8D ED                MOV      A,R5
000C8E D3                SETB     C
000C8F 9400              SUBB     A,#00H
000C91 4041              JC       ?C0067?HWA_MIFARE
000C93 ED                MOV      A,R5
000C94 9410              SUBB     A,#010H
000C96 503C              JNC      ?C0067?HWA_MIFARE
  262: 	{
  263: 		crc = hwa_mifareCheckOut(dat, USE_DATA_BLOCK_LEN);
000C98 900078            MOV      DPTR,#dat
000C9B A3                INC      DPTR
000C9C A3                INC      DPTR
000C9D E0                MOVX     A,@DPTR
000C9E F9                MOV      R1,A
;---- Variable 'crc' assigned to Register 'R4/R5' ----
000C9F 121367            LCALL    ?L?COM002C
  264: 		dat[USE_DATA_BLOCK_LEN] = (UINT8)(crc >> 8);
000CA2 EC                MOV      A,R4
000CA3 FF                MOV      R7,A
000CA4 900078            MOV      DPTR,#dat
000CA7 91DA              ACALL    ?L?COM0002
000CA9 F9                MOV      R1,A
000CAA 900002            MOV      DPTR,#02H
000CAD EF                MOV      A,R7
000CAE 120174            LCALL    ?C?CSTOPTR
  265: 		dat[USE_DATA_BLOCK_LEN + 1] = (UINT8)(crc & 0xFF);
000CB1 ED                MOV      A,R5
000CB2 900003            MOV      DPTR,#03H
000CB5 120174            LCALL    ?C?CSTOPTR
  266: 		if (hwa_mifareWriteBlock(dat, block))
000CB8 90007B            MOV      DPTR,#block
000CBB E0                MOVX     A,@DPTR
000CBC FD                MOV      R5,A
000CBD B194              ACALL    _hwa_mifareWriteBlock
000CBF 5002              JNC      ?C0068?HWA_MIFARE
  267: 		{
  268: 			falg = TRUE;
000CC1 D200              SETB     falg
  269: 		}
000CC3         ?C0068?HWA_MIFARE:
  270: 		if (hwa_mifareWriteBlock(dat, blockBak))
000CC3 900078            MOV      DPTR,#dat
000CC6 91DA              ACALL    ?L?COM0002
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 28


000CC8 F9                MOV      R1,A
000CC9 90007C            MOV      DPTR,#blockBak
000CCC E0                MOVX     A,@DPTR
000CCD FD                MOV      R5,A
000CCE B194              ACALL    _hwa_mifareWriteBlock
000CD0 5002              JNC      ?C0067?HWA_MIFARE
  271: 		{
  272: 			falg = TRUE;
000CD2 D200              SETB     falg
  273: 		}
  274: 	}
000CD4         ?C0067?HWA_MIFARE:
  275:     return falg;
000CD4 A200              MOV      C,falg
  276: }
000CD6 22                RET      
----- FUNCTION _hwa_mifareWriteSector (END) -------


----- FUNCTION ?L?COM0001 (BEGIN) -----
000CD7 90007F            MOV      DPTR,#buff
000CDA         ?L?COM0002:
000CDA E0                MOVX     A,@DPTR
000CDB FB                MOV      R3,A
000CDC A3                INC      DPTR
000CDD E0                MOVX     A,@DPTR
000CDE FA                MOV      R2,A
000CDF A3                INC      DPTR
000CE0 E0                MOVX     A,@DPTR
000CE1 22                RET      
----- FUNCTION ?L?COM0001 (END) -------


----- FUNCTION _hwa_mifareReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  194: BOOL hwa_mifareReadSector(UINT8 *dat, UINT8 sector)
  195: {
000CE2 900070            MOV      DPTR,#dat
000CE5 B1FA              ACALL    ?L?COM0004
000CE7 A3                INC      DPTR
000CE8 ED                MOV      A,R5
000CE9 F0                MOVX     @DPTR,A
  196: 	UINT8 block = sector * 4 + NORMAL_DATA_BLOCK;
  197: 	UINT8 blockBak = sector * 4 + BACKUP_DATA_BLOCK;
000CEA 121AF6            LCALL    ?L?COM003E
  198: 
  199: 	if (dat != NULL && sector > 0 && sector < 16)
000CED 900070            MOV      DPTR,#dat
000CF0 91DA              ACALL    ?L?COM0002
000CF2 4A                ORL      A,R2
000CF3 4B                ORL      A,R3
000CF4 7002              JNZ      $ + 4H
000CF6 A192              AJMP     ?C0051?HWA_MIFARE
000CF8 A3                INC      DPTR
000CF9 E0                MOVX     A,@DPTR
000CFA FF                MOV      R7,A
000CFB D3                SETB     C
000CFC 9400              SUBB     A,#00H
000CFE 5002              JNC      $ + 4H
000D00 A192              AJMP     ?C0051?HWA_MIFARE
000D02 EF                MOV      A,R7
000D03 9410              SUBB     A,#010H
000D05 4002              JC       $ + 4H
000D07 A192              AJMP     ?C0051?HWA_MIFARE
  200: 	{
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 29


  201: 		if (hwa_mifareReadBlock((UINT8*)&s_NormalBuff, block) == FALSE)
000D09 F1BC              ACALL    ?L?COM0026
000D0B A3                INC      DPTR
000D0C E0                MOVX     A,@DPTR
000D0D FD                MOV      R5,A
000D0E 716D              ACALL    _hwa_mifareReadBlock
000D10 4001              JC       ?C0052?HWA_MIFARE
  202: 		{
  203: 			return FALSE;
000D12 22                RET      
  204: 		}
000D13         ?C0052?HWA_MIFARE:
  205: 
  206: 		if (hwa_mifareReadBlock((UINT8*)&s_BackupBuff, blockBak) == FALSE)
000D13 F1D1              ACALL    ?L?COM0027
000D15 900075            MOV      DPTR,#blockBak
000D18 E0                MOVX     A,@DPTR
000D19 FD                MOV      R5,A
000D1A 716D              ACALL    _hwa_mifareReadBlock
000D1C 4001              JC       ?C0054?HWA_MIFARE
  207: 		{
  208: 			return FALSE;
000D1E 22                RET      
  209: 		}
000D1F         ?C0054?HWA_MIFARE:
  210: 
  211: 		hwa_mifareCheckBlock();
000D1F 121327            LCALL    hwa_mifareCheckBlock
  212: 
  213: 		if (NormalErrorFlag && BackupErrorFlag)				//正常块和备份块都校验错误
000D22 30051A            JNB      NormalErrorFlag,?C0055?HWA_MIFARE
000D25 300417            JNB      BackupErrorFlag,?C0055?HWA_MIFARE
  214: 		{
  215:             if(s_System.RecoveryOldCard)
000D28 9000B1            MOV      DPTR,#s_System+010H
000D2B E0                MOVX     A,@DPTR
000D2C 900073            MOV      DPTR,#sector
000D2F 6007              JZ       ?C0056?HWA_MIFARE
  216:             {
  217:                 hwa_mifareRecoveryOldCard(sector);				//兼容旧卡
000D31 E0                MOVX     A,@DPTR
000D32 FF                MOV      R7,A
000D33 12195B            LCALL    _hwa_mifareRecoveryOldCard
  218:             }
000D36 8005              SJMP     ?C0057?HWA_MIFARE
000D38         ?C0056?HWA_MIFARE:
  219:             else
  220:             {
  221:                 hwa_mifareRecoveryNewCard(sector);				//兼容新卡
000D38 E0                MOVX     A,@DPTR
000D39 FF                MOV      R7,A
000D3A 1219C8            LCALL    _hwa_mifareRecoveryNewCard
  222:             }
000D3D         ?C0057?HWA_MIFARE:
  223: 			return FALSE;
000D3D C3                CLR      C
000D3E 22                RET      
  224: 		}
000D3F         ?C0055?HWA_MIFARE:
  225: 		else if (NormalErrorFlag)							//正常块校验错误
000D3F 30050C            JNB      NormalErrorFlag,?C0059?HWA_MIFARE
  226: 		{
  227: 			if (hwa_mifareWriteBlock((UINT8*)&s_BackupBuff, block) == FALSE)
000D42 F1D1              ACALL    ?L?COM0027
000D44 900074            MOV      DPTR,#block
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 30


000D47 E0                MOVX     A,@DPTR
000D48 FD                MOV      R5,A
000D49 B194              ACALL    _hwa_mifareWriteBlock
000D4B 4028              JC       ?C0058?HWA_MIFARE
  228: 			{
  229: 				return FALSE;
000D4D 22                RET      
  230: 			}
  231: 		}
000D4E         ?C0059?HWA_MIFARE:
  232: 		else if (BackupErrorFlag							//备份块校验错误
000D4E 200418            JB       BackupErrorFlag,?C0063?HWA_MIFARE
000D51 900042            MOV      DPTR,#s_BackupBuff+02H
000D54 E0                MOVX     A,@DPTR
000D55 FF                MOV      R7,A
000D56 900052            MOV      DPTR,#s_NormalBuff+02H
000D59 E0                MOVX     A,@DPTR
000D5A B5070C            CJNE     A,AR7,?C0063?HWA_MIFARE
000D5D 900043            MOV      DPTR,#s_BackupBuff+03H
000D60 E0                MOVX     A,@DPTR
000D61 FF                MOV      R7,A
000D62 900053            MOV      DPTR,#s_NormalBuff+03H
000D65 E0                MOVX     A,@DPTR
000D66 6F                XRL      A,R7
000D67 600C              JZ       ?C0058?HWA_MIFARE
000D69         ?C0063?HWA_MIFARE:
  233: 			|| s_NormalBuff.crc[0] != s_BackupBuff.crc[0]	//正常块和备份块校验正确但数据不一样，用正常块替换备份块
  234: 			|| s_NormalBuff.crc[1] != s_BackupBuff.crc[1]
  235:         )
  236: 		{
  237: 			if (hwa_mifareWriteBlock((UINT8*)&s_NormalBuff, blockBak) == FALSE)
000D69 F1BC              ACALL    ?L?COM0026
000D6B 900075            MOV      DPTR,#blockBak
000D6E E0                MOVX     A,@DPTR
000D6F FD                MOV      R5,A
000D70 B194              ACALL    _hwa_mifareWriteBlock
000D72 4001              JC       ?C0058?HWA_MIFARE
  238: 			{
  239: 				return FALSE;
000D74 22                RET      
  240: 			}
  241: 		}
000D75         ?C0058?HWA_MIFARE:
  242: 		if (BackupErrorFlag)
000D75 900070            MOV      DPTR,#dat
000D78 91DA              ACALL    ?L?COM0002
000D7A F8                MOV      R0,A
000D7B AC02              MOV      R4,AR2
000D7D AD03              MOV      R5,AR3
000D7F 7B01              MOV      R3,#01H
000D81 300406            JNB      BackupErrorFlag,?C0065?HWA_MIFARE
  243: 		{
  244: 			memcpy(dat, (UINT8*)&s_NormalBuff, DATA_BLOCK_SIZE);
000D84 7A00              MOV      R2,#HIGH s_NormalBuff
000D86 7950              MOV      R1,#LOW s_NormalBuff
  245: 		}
000D88 8004              SJMP     ?C0083?HWA_MIFARE
000D8A         ?C0065?HWA_MIFARE:
  246: 		else
  247: 		{
  248: 			memcpy(dat, (UINT8*)&s_BackupBuff, DATA_BLOCK_SIZE);
000D8A 7A00              MOV      R2,#HIGH s_BackupBuff
000D8C 7940              MOV      R1,#LOW s_BackupBuff
000D8E         
000D8E F1CA              ACALL    ?L?COM0048
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 31


  249: 		}
000D90         ?C0066?HWA_MIFARE:
  250: 		return TRUE;
000D90 D3                SETB     C
000D91 22                RET      
  251: 	}
000D92         ?C0051?HWA_MIFARE:
  252: 	return FALSE;
000D92 C3                CLR      C
  253: }
000D93 22                RET      
----- FUNCTION _hwa_mifareReadSector (END) -------


----- FUNCTION _hwa_mifareWriteBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   76: BOOL hwa_mifareWriteBlock(UINT8 *buff, UINT8 block)
   77: {
000D94 90007D            MOV      DPTR,#block
000D97 ED                MOV      A,R5
000D98 F0                MOVX     @DPTR,A
;---- Variable 'buff' assigned to Register 'R1/R2/R3' ----
   78: 	UINT8 u8_ReadErrCount;
   79: 	UINT8 u8_Result;
   80:     memcpy((UINT8*)&s_TempBuff, buff, 16);
000D99 7860              MOV      R0,#LOW s_TempBuff
000D9B 7C00              MOV      R4,#HIGH s_TempBuff
000D9D 7D01              MOV      R5,#01H
000D9F F1CA              ACALL    ?L?COM0048
   81:     hwa_mifareEncrypt((UINT8*)&s_TempBuff);             //利用卡ID加密
000DA1 7B01              MOV      R3,#01H
000DA3 7A00              MOV      R2,#HIGH s_TempBuff
000DA5 7960              MOV      R1,#LOW s_TempBuff
000DA7 B1D0              ACALL    _hwa_mifareEncrypt
   82: 	for (u8_ReadErrCount = 0; u8_ReadErrCount < 3; u8_ReadErrCount++)
000DA9 E4                CLR      A
000DAA 90007E            MOV      DPTR,#u8_ReadErrCount
000DAD F0                MOVX     @DPTR,A
000DAE         ?C0025?HWA_MIFARE:
   83: 	{
   84: 		u8_Result = Write_Block((UINT8*)&s_TempBuff, block);
000DAE 7B01              MOV      R3,#01H
000DB0 7A00              MOV      R2,#HIGH s_TempBuff
000DB2 7960              MOV      R1,#LOW s_TempBuff
000DB4 90007D            MOV      DPTR,#block
000DB7 E0                MOVX     A,@DPTR
000DB8 FD                MOV      R5,A
000DB9 121568            LCALL    _Write_Block
;---- Variable 'u8_Result' assigned to Register 'R7' ----
   85: 		if (u8_Result == FM1702_OK)
000DBC EF                MOV      A,R7
000DBD 7002              JNZ      ?C0028?HWA_MIFARE
   86: 		{
   87: 			return TRUE;
000DBF D3                SETB     C
000DC0 22                RET      
   88: 		}
000DC1         ?C0028?HWA_MIFARE:
   89: 		else if (u8_Result == FM1702_NOTAGERR)
000DC1 EF                MOV      A,R7
000DC2 B40102            CJNE     A,#01H,?C0027?HWA_MIFARE
   90: 		{
   91: 			return FALSE;
000DC5 C3                CLR      C
000DC6 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 32


   92: 		}
   93: 	}
000DC7         ?C0027?HWA_MIFARE:
000DC7 90007E            MOV      DPTR,#u8_ReadErrCount
000DCA F1EE              ACALL    ?L?COM0060
000DCC 40E0              JC       ?C0025?HWA_MIFARE
000DCE         ?C0026?HWA_MIFARE:
   94: 	return FALSE;
000DCE C3                CLR      C
   95: }
000DCF 22                RET      
----- FUNCTION _hwa_mifareWriteBlock (END) -------


----- FUNCTION _hwa_mifareEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   30: void hwa_mifareEncrypt(UINT8 *pData)        //利用卡ID加密
   31: {
000DD0 B1F7              ACALL    ?L?COM0003
   32: 	UINT8 i, j;
   33: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
000DD2 E4                CLR      A
000DD3 FE                MOV      R6,A
000DD4         ?C0004?HWA_MIFARE:
   34: 	{
   35: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
000DD4 7D04              MOV      R5,#04H
000DD6         ?C0007?HWA_MIFARE:
   36: 		{
   37: 			pData[i] ^= gCard_UID[i % 5];
000DD6 91D7              ACALL    ?L?COM0001
000DD8 121A6F            LCALL    ?L?COM0014
   38: 			pData[i] = _cror_(pData[i], 1);
000DDB 91D7              ACALL    ?L?COM0001
000DDD F9                MOV      R1,A
000DDE 8E82              MOV      DPL,R6
000DE0 12127A            LCALL    ?L?COM001F
000DE3 FF                MOV      R7,A
000DE4 7801              MOV      R0,#01H
000DE6 08                INC      R0
000DE7 8001              SJMP     ?C0072?HWA_MIFARE
000DE9         ?C0071?HWA_MIFARE:
000DE9 03                RR       A
000DEA         ?C0072?HWA_MIFARE:
000DEA D8FD              DJNZ     R0,?C0071?HWA_MIFARE
000DEC 121B44            LCALL    ?L?COM0054
   39: 		}
000DEF DDE5              DJNZ     R5,?C0007?HWA_MIFARE
   40: 	}
000DF1         ?C0006?HWA_MIFARE:
000DF1 0E                INC      R6
000DF2 EE                MOV      A,R6
000DF3 B404DE            CJNE     A,#04H,?C0004?HWA_MIFARE
   41: }
000DF6 22                RET      
----- FUNCTION _hwa_mifareEncrypt (END) -------


----- FUNCTION ?L?COM0003 (BEGIN) -----
000DF7 90007F            MOV      DPTR,#buff
000DFA         ?L?COM0004:
000DFA EB                MOV      A,R3
000DFB F0                MOVX     @DPTR,A
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 33


000DFC A3                INC      DPTR
000DFD EA                MOV      A,R2
000DFE F0                MOVX     @DPTR,A
000DFF A3                INC      DPTR
000E00 E9                MOV      A,R1
000E01 F0                MOVX     @DPTR,A
000E02 22                RET      
----- FUNCTION ?L?COM0003 (END) -------


----- FUNCTION _Authentication (BEGIN) -----
 FILE: 'Driver\mifare.c'
  472: uchar Authentication(uchar *UID, uchar SecNR, uchar mode)
  473: {
000E03 900073            MOV      DPTR,#UID
000E06 B1FA              ACALL    ?L?COM0004
;---- Variable 'SecNR' assigned to Register 'R4' ----
000E08 AC05              MOV      R4,AR5
  474: 	uchar i;
  475: 	uchar temp, temp1;
  476: 
  477: 	if(SecNR >= 16)
000E0A EC                MOV      A,R4
000E0B C3                CLR      C
000E0C 9410              SUBB     A,#010H
000E0E 4004              JC       ?C0094?MIFARE
  478: 		SecNR = SecNR % 16;
000E10 EC                MOV      A,R4
000E11 540F              ANL      A,#0FH
000E13 FC                MOV      R4,A
000E14         ?C0094?MIFARE:
  479: 	
  480: 	//选择数据校验种类和模式
  481: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
000E14 F1D8              ACALL    ?L?COM0057
  482: 	gBuff[0] = mode;
000E16 900077            MOV      DPTR,#mode
000E19 E0                MOVX     A,@DPTR
000E1A 9000B9            MOV      DPTR,#gBuff
000E1D F0                MOVX     @DPTR,A
  483: 	gBuff[1] = SecNR * 4 + 3;
000E1E EC                MOV      A,R4
000E1F 25E0              ADD      A,ACC
000E21 25E0              ADD      A,ACC
000E23 2403              ADD      A,#03H
000E25 A3                INC      DPTR
000E26 F0                MOVX     @DPTR,A
  484: 	for(i = 0; i < 4; i++)
;---- Variable 'i' assigned to Register 'R7' ----
000E27 E4                CLR      A
000E28 FF                MOV      R7,A
000E29         ?C0095?MIFARE:
  485: 	{
  486: 		gBuff[2 + i] = UID[i];
000E29 900073            MOV      DPTR,#UID
000E2C 91DA              ACALL    ?L?COM0002
000E2E 121277            LCALL    ?L?COM001D
000E31 121629            LCALL    ?L?COM002F
000E34 B404F2            CJNE     A,#04H,?C0095?MIFARE
000E37         ?C0096?MIFARE:
  487: 	}
  488: 
  489: 	temp = Command_Send(Authent1, gBuff,6 );
000E37 712D              ACALL    ?L?COM0011
000E39 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 34


000E3C 7406              MOV      A,#06H
000E3E F0                MOVX     @DPTR,A
000E3F 7F0C              MOV      R7,#0CH
000E41 120794            LCALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  490: 	if(temp==0)
000E44 EF                MOV      A,R7
000E45 7003              JNZ      ?C0098?MIFARE
  491: 	{
  492: 		return 0x99;
000E47 7F99              MOV      R7,#099H
000E49 22                RET      
  493: 	}
000E4A         ?C0098?MIFARE:
  494: 
  495: 	temp = SPIReadOne(ErrorFlag_Reg);   
000E4A F1C3              ACALL    ?L?COM002E
000E4C 30E103            JNB      ACC.1,?C0100?MIFARE
000E4F 7F05              MOV      R7,#05H
000E51 22                RET      
000E52         ?C0100?MIFARE:
  496: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  497: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
000E52 EF                MOV      A,R7
000E53 30E203            JNB      ACC.2,?C0101?MIFARE
000E56 7F14              MOV      R7,#014H
000E58 22                RET      
000E59         ?C0101?MIFARE:
  498: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
000E59 EF                MOV      A,R7
000E5A 30E303            JNB      ACC.3,?C0102?MIFARE
000E5D 7F02              MOV      R7,#02H
000E5F 22                RET      
000E60         ?C0102?MIFARE:
  499: 	temp = Command_Send(Authent2, gBuff,0 );	
000E60 712D              ACALL    ?L?COM0011
000E62 E4                CLR      A
000E63 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
000E66 F0                MOVX     @DPTR,A
000E67 7F14              MOV      R7,#014H
000E69 120794            LCALL    _Command_Send
  500: 	if(temp ==0)
000E6C EF                MOV      A,R7
000E6D 7003              JNZ      ?C0103?MIFARE
  501: 	{
  502: 		return 0x88;
000E6F 7F88              MOV      R7,#088H
000E71 22                RET      
  503: 	}
000E72         ?C0103?MIFARE:
  504: 
  505: 	temp = SPIReadOne(ErrorFlag_Reg);
000E72 F1C3              ACALL    ?L?COM002E
000E74 30E103            JNB      ACC.1,?C0104?MIFARE
000E77 7F05              MOV      R7,#05H
000E79 22                RET      
000E7A         ?C0104?MIFARE:
  506: //	Show(temp,0);
  507: 	if((temp & 0x02) == 0x02) return FM1702_PARITYERR;
  508: 	if((temp & 0x04) == 0x04) return FM1702_FRAMINGERR;
000E7A EF                MOV      A,R7
000E7B 30E203            JNB      ACC.2,?C0105?MIFARE
000E7E 7F14              MOV      R7,#014H
000E80 22                RET      
000E81         ?C0105?MIFARE:
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 35


  509: 	if((temp & 0x08) == 0x08) return FM1702_CRCERR;
000E81 EF                MOV      A,R7
000E82 30E303            JNB      ACC.3,?C0106?MIFARE
000E85 7F02              MOV      R7,#02H
000E87 22                RET      
000E88         ?C0106?MIFARE:
  510: 	temp1 = SPIReadOne(Control_Reg);
000E88 7F09              MOV      R7,#09H
000E8A 1206F4            LCALL    _SPIReadOne
;---- Variable 'temp1' assigned to Register 'R7' ----
  511: 	temp1 = temp1 & 0x08;	
000E8D EF                MOV      A,R7
000E8E 5408              ANL      A,#08H
  512: 	if(temp1 == 0x08)
000E90 7F04              MOV      R7,#04H
000E92 B40802            CJNE     A,#08H,?C0107?MIFARE
  513: 	{
  514: 		return FM1702_OK;
000E95 7F00              MOV      R7,#00H
  515: 	}
000E97         ?C0107?MIFARE:
  516: 
  517: 	return FM1702_AUTHERR;
  518: }
000E97 22                RET      
----- FUNCTION _Authentication (END) -------


----- FUNCTION _hwa_eepromWriteSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   97: BOOL hwa_eepromWriteSector(UINT8 *dat, UINT8 sector)
   98: {
000E98 900071            MOV      DPTR,#dat
000E9B B1FA              ACALL    ?L?COM0004
000E9D A3                INC      DPTR
000E9E ED                MOV      A,R5
000E9F F0                MOVX     @DPTR,A
   99:     UINT16 e2_addr, e2_bak_addr;
  100:     UINT16 e2_check_sum;
  101:     
  102:     UINT16 Size, SectorSize;
  103:     
  104:     if(sector >= c_u8_eepromSectorNum)
000EA0 121B55            LCALL    ?L?COM0056
000EA3 9F                SUBB     A,R7
000EA4 4001              JC       ?C0022?HWA_EEPROM
  105:     {
  106:     	return FALSE;
000EA6 22                RET      
  107:     }
000EA7         ?C0022?HWA_EEPROM:
  108: 	Size = c_s_eepromConfig[sector].UseSize;
000EA7 900074            MOV      DPTR,#sector
000EAA 121AC6            LCALL    ?L?COM002D
000EAD 7401              MOV      A,#01H
000EAF 93                MOVC     A,@A+DPTR
000EB0 FD                MOV      R5,A
000EB1 90007B            MOV      DPTR,#Size
000EB4 121A3F            LCALL    ?L?COM0009
000EB7 900075            MOV      DPTR,#e2_addr
000EBA 121B66            LCALL    ?L?COM0061
000EBD 121A66            LCALL    ?L?COM000A
000EC0 900077            MOV      DPTR,#e2_bak_addr
000EC3 F0                MOVX     @DPTR,A
000EC4 A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 36


000EC5 CE                XCH      A,R6
000EC6 F0                MOVX     @DPTR,A
  109:     SectorSize = Size+2;
  110: 
  111:     e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
  112:     e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
  113:     e2_check_sum = hwa_eepromCheck(dat, Size);
000EC7 900071            MOV      DPTR,#dat
000ECA 91DA              ACALL    ?L?COM0002
000ECC F9                MOV      R1,A
000ECD 121B4C            LCALL    ?L?COM0055
000ED0 1218D3            LCALL    _hwa_eepromCheck
000ED3 900079            MOV      DPTR,#e2_check_sum
000ED6 1217A6            LCALL    ?L?COM0016
000ED9 900074            MOV      DPTR,#sector
000EDC E0                MOVX     A,@DPTR
000EDD FD                MOV      R5,A
000EDE 121675            LCALL    _hwa_eepromReadSector
  114: 
  115:     hwa_eepromReadSector(e2_data, sector);                                  //  写入之前，如果有错误块，先恢复
  116: 
  117:     memcpy(e2_data, dat, Size);
000EE1 90007B            MOV      DPTR,#Size
000EE4 121B1D            LCALL    ?L?COM0049
000EE7 900071            MOV      DPTR,#dat
000EEA 91DA              ACALL    ?L?COM0002
000EEC F9                MOV      R1,A
000EED 1200F6            LCALL    ?C?COPY
  118: 
  119: 	if (c_s_eepromConfig[sector].Encrypt)
000EF0 900074            MOV      DPTR,#sector
000EF3 1218C1            LCALL    ?L?COM0013
000EF6 6008              JZ       ?C0024?HWA_EEPROM
  120: 	{
  121: 		hwa_eepromEncrypt(e2_data, Size);
000EF8 1217AB            LCALL    ?L?COM0017
000EFB 121B4C            LCALL    ?L?COM0055
000EFE F147              ACALL    _hwa_eepromEncrypt
  122: 	}
000F00         ?C0024?HWA_EEPROM:
  123:     e2_data[Size] = (UINT8)(e2_check_sum >> 8);
000F00 900079            MOV      DPTR,#e2_check_sum
000F03 E0                MOVX     A,@DPTR
000F04 FC                MOV      R4,A
000F05 A3                INC      DPTR
000F06 E0                MOVX     A,@DPTR
000F07 FD                MOV      R5,A
000F08 EC                MOV      A,R4
000F09 FF                MOV      R7,A
000F0A A3                INC      DPTR
000F0B E0                MOVX     A,@DPTR
000F0C FA                MOV      R2,A
000F0D A3                INC      DPTR
000F0E E0                MOVX     A,@DPTR
000F0F FB                MOV      R3,A
000F10 2400              ADD      A,#LOW e2_data
000F12 F582              MOV      DPL,A
000F14 7400              MOV      A,#HIGH e2_data
000F16 3A                ADDC     A,R2
000F17 F583              MOV      DPH,A
000F19 EF                MOV      A,R7
000F1A F0                MOVX     @DPTR,A
  124:     e2_data[Size + 1] = (UINT8)(e2_check_sum&0xFF);
000F1B 7401              MOV      A,#LOW e2_data+01H
000F1D 2B                ADD      A,R3
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 37


000F1E F582              MOV      DPL,A
000F20 7400              MOV      A,#HIGH e2_data+01H
000F22 3A                ADDC     A,R2
000F23 F583              MOV      DPH,A
000F25 ED                MOV      A,R5
000F26 F0                MOVX     @DPTR,A
  125: 	sys_eepromEraseSector(e2_addr);
000F27 900075            MOV      DPTR,#e2_addr
000F2A 12183F            LCALL    ?L?COM0031
  126:     sys_eepromWrite(e2_addr, e2_data, SectorSize);
000F2D 900075            MOV      DPTR,#e2_addr
000F30 1217D0            LCALL    ?L?COM000D
000F33 121852            LCALL    _sys_eepromWrite
  127: 	
  128: //    memcpy(e2_data_bak, e2_data, SectorSize);
  129: 	sys_eepromEraseSector(e2_bak_addr);
000F36 900077            MOV      DPTR,#e2_bak_addr
000F39 12183F            LCALL    ?L?COM0031
  130: 	sys_eepromWrite(e2_bak_addr, e2_data, SectorSize);
000F3C 900077            MOV      DPTR,#e2_bak_addr
000F3F 1217D0            LCALL    ?L?COM000D
000F42 121852            LCALL    _sys_eepromWrite
  131:     return TRUE;
000F45 D3                SETB     C
  132: }
000F46 22                RET      
----- FUNCTION _hwa_eepromWriteSector (END) -------


----- FUNCTION _hwa_eepromEncrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   37: void hwa_eepromEncrypt(UINT8 *dat, UINT16 size)        //加密
   38: {
000F47 B1F7              ACALL    ?L?COM0003
000F49 121639            LCALL    ?L?COM0042
   39: 	UINT16 i;
   40: 	UINT8 tmp;
   41: 	for (i = 0; i<size; i++)
;---- Variable 'i' assigned to Register 'R6/R7' ----
000F4C E4                CLR      A
000F4D FF                MOV      R7,A
000F4E FE                MOV      R6,A
000F4F         ?C0001?HWA_EEPROM_CFG:
000F4F D3                SETB     C
000F50 900083            MOV      DPTR,#size+01H
000F53 E0                MOVX     A,@DPTR
000F54 9F                SUBB     A,R7
000F55 900082            MOV      DPTR,#size
000F58 E0                MOVX     A,@DPTR
000F59 9E                SUBB     A,R6
000F5A 4018              JC       ?C0004?HWA_EEPROM_CFG
   42: 	{
   43: 		tmp = dat[i];
000F5C 91D7              ACALL    ?L?COM0001
;---- Variable 'tmp' assigned to Register 'R5' ----
000F5E 121B11            LCALL    ?L?COM0045
   44: 		tmp ^= SecretKey;
   45: 		tmp = (tmp >> 1) | (tmp << 7);
000F61 C4                SWAP     A
000F62 33                RLC      A
000F63 33                RLC      A
000F64 33                RLC      A
000F65 5480              ANL      A,#080H
000F67 FC                MOV      R4,A
000F68 ED                MOV      A,R5
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 38


000F69 C3                CLR      C
000F6A 13                RRC      A
000F6B 121B04            LCALL    ?L?COM0044
000F6E BF0001            CJNE     R7,#00H,?C0009?HWA_EEPROM_CFG
000F71 0E                INC      R6
000F72         ?C0009?HWA_EEPROM_CFG:
000F72 80DB              SJMP     ?C0001?HWA_EEPROM_CFG
   46: 		tmp ^= SecretKey;
   47: 		dat[i] = tmp;
   48: 	}
   49: }
000F74         ?C0004?HWA_EEPROM_CFG:
000F74 22                RET      
----- FUNCTION _hwa_eepromEncrypt (END) -------


----- FUNCTION _Read_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  532: uchar Read_Block(uchar *buff,uchar index)
  533: {
000F75 90007B            MOV      DPTR,#buff
000F78 B1FA              ACALL    ?L?COM0004
;---- Variable 'index' assigned to Register 'R4' ----
000F7A AC05              MOV      R4,AR5
  534:     uchar ucCmdLine[2],ucResult;
  535:     SPIWriteOne(ChannelRedundancy_Reg,0x0F);
000F7C F1D8              ACALL    ?L?COM0057
  536:     ucCmdLine[0] = RF_CMD_READ;
000F7E A3                INC      DPTR
000F7F 7430              MOV      A,#030H
000F81 F0                MOVX     @DPTR,A
  537:     ucCmdLine[1] = index;
000F82 A3                INC      DPTR
000F83 EC                MOV      A,R4
000F84 F0                MOVX     @DPTR,A
  538:     ucResult = Command_Send(Transceive,ucCmdLine,2);
000F85 7B01              MOV      R3,#01H
000F87 7A00              MOV      R2,#HIGH ucCmdLine
000F89 797E              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
000F8B 1214E8            LCALL    ?L?COM0024
000F8E 7003              JNZ      ?C0108?MIFARE
  539:     if(ucResult == FALSE)
  540:         return FM1702_NOTAGERR;   //无卡
000F90 7F01              MOV      R7,#01H
000F92 22                RET      
000F93         ?C0108?MIFARE:
  541:     ucResult = SPIReadOne(ErrorFlag_Reg);
000F93 F1C3              ACALL    ?L?COM002E
000F95 30E103            JNB      ACC.1,?C0110?MIFARE
000F98 7F05              MOV      R7,#05H
000F9A 22                RET      
000F9B         ?C0110?MIFARE:
  542: 	if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
  543: 	if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
000F9B EF                MOV      A,R7
000F9C 30E203            JNB      ACC.2,?C0111?MIFARE
000F9F 7F14              MOV      R7,#014H
000FA1 22                RET      
000FA2         ?C0111?MIFARE:
  544: 	if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
000FA2 EF                MOV      A,R7
000FA3 30E303            JNB      ACC.3,?C0112?MIFARE
000FA6 7F02              MOV      R7,#02H
000FA8 22                RET      
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 39


000FA9         ?C0112?MIFARE:
  545:     ucResult = Read_FIFO(buff);
000FA9 90007B            MOV      DPTR,#buff
000FAC 91DA              ACALL    ?L?COM0002
000FAE F9                MOV      R1,A
000FAF 1215E5            LCALL    _Read_FIFO
  546:     if(ucResult!=0x10)
000FB2 EF                MOV      A,R7
000FB3 6410              XRL      A,#010H
000FB5 7F00              MOV      R7,#00H
000FB7 6002              JZ       ?C0113?MIFARE
  547:         return FM1702_BYTECOUNTERR;
000FB9 7F0C              MOV      R7,#0CH
000FBB         ?C0113?MIFARE:
  548:     else
  549:         return FM1702_OK;
  550: }
000FBB 22                RET      
----- FUNCTION _Read_Block (END) -------


----- FUNCTION ?L?COM0026 (BEGIN) -----
000FBC 7B01              MOV      R3,#01H
000FBE 7A00              MOV      R2,#HIGH s_NormalBuff
000FC0 7950              MOV      R1,#LOW s_NormalBuff
000FC2 22                RET      
----- FUNCTION ?L?COM0026 (END) -------


----- FUNCTION ?L?COM002E (BEGIN) -----
000FC3 7F0A              MOV      R7,#0AH
000FC5 1206F4            LCALL    _SPIReadOne
000FC8 EF                MOV      A,R7
000FC9 22                RET      
----- FUNCTION ?L?COM002E (END) -------


----- FUNCTION ?L?COM0048 (BEGIN) -----
000FCA 7E00              MOV      R6,#00H
000FCC 7F10              MOV      R7,#010H
000FCE 0200F6            LJMP     ?C?COPY
----- FUNCTION ?L?COM0048 (END) -------


----- FUNCTION ?L?COM0027 (BEGIN) -----
000FD1 7B01              MOV      R3,#01H
000FD3 7A00              MOV      R2,#HIGH s_BackupBuff
000FD5 7940              MOV      R1,#LOW s_BackupBuff
000FD7 22                RET      
----- FUNCTION ?L?COM0027 (END) -------


----- FUNCTION ?L?COM0057 (BEGIN) -----
000FD8 7D0F              MOV      R5,#0FH
000FDA 7F22              MOV      R7,#022H
000FDC 0206BE            LJMP     _SPIWriteOne
----- FUNCTION ?L?COM0057 (END) -------


----- FUNCTION ?L?COM0064 (BEGIN) -----
000FDF AF03              MOV      R7,AR3
000FE1 AE02              MOV      R6,AR2
000FE3 0201A8            LJMP     ?C?UIDIV
----- FUNCTION ?L?COM0064 (END) -------

LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 40



----- FUNCTION ?L?COM005E (BEGIN) -----
000FE6 7403              MOV      A,#03H
000FE8 F0                MOVX     @DPTR,A
000FE9 A3                INC      DPTR
000FEA 74E7              MOV      A,#0E7H
000FEC F0                MOVX     @DPTR,A
000FED 22                RET      
----- FUNCTION ?L?COM005E (END) -------


----- FUNCTION ?L?COM0060 (BEGIN) -----
000FEE E0                MOVX     A,@DPTR
000FEF 04                INC      A
000FF0 F0                MOVX     @DPTR,A
000FF1 E0                MOVX     A,@DPTR
000FF2 C3                CLR      C
000FF3 9403              SUBB     A,#03H
000FF5 22                RET      
----- FUNCTION ?L?COM0060 (END) -------


----- FUNCTION ?L?COM004D (BEGIN) -----
000FF6 D2A1              SETB     RC500SCK
000FF8 EF                MOV      A,R7
000FF9 25E0              ADD      A,ACC
000FFB FF                MOV      R7,A
000FFC C2A1              CLR      RC500SCK
000FFE 0E                INC      R6
000FFF EE                MOV      A,R6
001000 22                RET      
----- FUNCTION ?L?COM004D (END) -------


----- FUNCTION sys_tim0Init (BEGIN) -----
 FILE: 'System\sys_tim.c'
  101: void sys_tim0Init(void)
  102: {
  103: 	TMOD &= 0xF0;
  104: 	TH0 = (UINT8)(T1MS>>8);
001001 5389F0            ANL      TMOD,#0F0H
  105: 	TL0 = (UINT8)T1MS;
001004 758CF8            MOV      TH0,#0F8H
  106: 	ET0 = 1;
001007 758ACD            MOV      TL0,#0CDH
  107: 	TR0 = 1;
00100A D2A9              SETB     ET0
  108: //	PT1 = 1;
00100C D28C              SETB     TR0
  109:     EA = 1;
00100E D2AF              SETB     EA
  110: }
001010 22                RET      
----- FUNCTION sys_tim0Init (END) -------


----- FUNCTION sys_taskInit (BEGIN) -----
 FILE: 'System\sys_task.c'
   27: void sys_taskInit(void)
   28: {
   29:     WDT_CONTR = 0x33;
   30:     len_Init();
001011 75C133            MOV      WDT_CONTR,#033H
   31:     sys_gpioInit();
001014 31FD              ACALL    len_Init
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 41


   32:     buzzer_Init();
001016 12000A            LCALL    sys_gpioInit
   33:     sys_uartInit();
001019 31D2              ACALL    buzzer_Init
   34:     sys_tim0Init();
00101B 31E9              ACALL    sys_uartInit
   35:     app_configInit();
00101D 1101              ACALL    sys_tim0Init
   36: 	app_Show();
00101F 120BDC            LCALL    app_configInit
   37:     app_brushInit();
001022 12081E            LCALL    app_Show
   38: }
001025 0207F8            LJMP     app_brushInit
----- FUNCTION sys_taskInit (END) -------


----- FUNCTION sys_tim0Isr (BEGIN) -----
 FILE: 'System\sys_task.c'
   40: void sys_tim0Isr(void) interrupt 1      //1ms interrupt task
001028 C0E0              PUSH     ACC
00102A C0F0              PUSH     B
00102C C083              PUSH     DPH
00102E C082              PUSH     DPL
001030 C0D0              PUSH     PSW
001032 75D000            MOV      PSW,#00H
001035 C000              PUSH     AR0
001037 C001              PUSH     AR1
001039 C002              PUSH     AR2
00103B C003              PUSH     AR3
00103D C004              PUSH     AR4
00103F C005              PUSH     AR5
001041 C006              PUSH     AR6
001043 C007              PUSH     AR7
   41: {
   42:     led_Handler1ms();
001045 11AD              ACALL    led_Handler1ms
   43: 	taskHandlerCnt10ms++;
001047 9000EE            MOV      DPTR,#taskHandlerCnt10ms
00104A E0                MOVX     A,@DPTR
00104B 04                INC      A
00104C F0                MOVX     @DPTR,A
   44:     if(taskHandlerCnt10ms>=10)
00104D E0                MOVX     A,@DPTR
00104E C3                CLR      C
00104F 940A              SUBB     A,#0AH
001051 400B              JC       ?C0003?SYS_TASK
   45:     {
   46:         taskHandlerCnt10ms = 0;
001053 E4                CLR      A
001054 F0                MOVX     @DPTR,A
   47:         sys_taskHandler10ms();
001055 120021            LCALL    sys_taskHandler10ms
   48:         taskHandlerCnt100ms++;
001058 9000EC            MOV      DPTR,#taskHandlerCnt100ms
00105B E0                MOVX     A,@DPTR
00105C 04                INC      A
00105D F0                MOVX     @DPTR,A
   49:     }
00105E         ?C0003?SYS_TASK:
   50:     if(taskHandlerCnt100ms>=10)
00105E 9000EC            MOV      DPTR,#taskHandlerCnt100ms
001061 E0                MOVX     A,@DPTR
001062 C3                CLR      C
001063 940A              SUBB     A,#0AH
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 42


001065 400A              JC       ?C0004?SYS_TASK
   51:     {
   52:         taskHandlerCnt100ms = 0;
001067 E4                CLR      A
001068 F0                MOVX     @DPTR,A
   53:         sys_taskHandler100ms();
001069 119C              ACALL    sys_taskHandler100ms
   54:         taskHandlerCnt1s++;
00106B 9000ED            MOV      DPTR,#taskHandlerCnt1s
00106E E0                MOVX     A,@DPTR
00106F 04                INC      A
001070 F0                MOVX     @DPTR,A
   55:     }
001071         ?C0004?SYS_TASK:
   56:     if(taskHandlerCnt1s>=10)
001071 9000ED            MOV      DPTR,#taskHandlerCnt1s
001074 E0                MOVX     A,@DPTR
001075 C3                CLR      C
001076 940A              SUBB     A,#0AH
001078 4007              JC       ?C0006?SYS_TASK
   57:     {
   58:         taskHandlerCnt1s = 0;
00107A E4                CLR      A
00107B F0                MOVX     @DPTR,A
   59:         sys_taskHandler1s();
00107C 120022            LCALL    sys_taskHandler1s
   60:         taskCycle1sFlag = TRUE;
00107F D206              SETB     taskCycle1sFlag
   61:     }
   62: }
001081         ?C0006?SYS_TASK:
001081 D007              POP      AR7
001083 D006              POP      AR6
001085 D005              POP      AR5
001087 D004              POP      AR4
001089 D003              POP      AR3
00108B D002              POP      AR2
00108D D001              POP      AR1
00108F D000              POP      AR0
001091 D0D0              POP      PSW
001093 D082              POP      DPL
001095 D083              POP      DPH
001097 D0F0              POP      B
001099 D0E0              POP      ACC
00109B 32                RETI     
----- FUNCTION sys_tim0Isr (END) -------


----- FUNCTION sys_taskHandler100ms (BEGIN) -----
 FILE: 'System\sys_task.c'
   68: void sys_taskHandler100ms(void)           //100ms interrupt task
;----                  JMP      buzzer_Handler100ms
   69: {
----- FUNCTION sys_taskHandler100ms (END) -------


----- FUNCTION buzzer_Handler100ms (BEGIN) -----
 FILE: 'Driver\buzzer.c'
   15: void buzzer_Handler100ms(void)
   16: {
   17:     if(Buzzer)
   18: 	{
00109C 30B503            JNB      Buzzer,?C0002?BUZZER
   19: 		Buzzer = 0;
   20: 	}
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 43


00109F C2B5              CLR      Buzzer
   21: 	else if(SoundNumberCount)
0010A1 22                RET      
0010A2         ?C0002?BUZZER:
   22: 	{
0010A2 9000EF            MOV      DPTR,#SoundNumberCount
0010A5 E0                MOVX     A,@DPTR
0010A6 6004              JZ       ?C0005?BUZZER
   23: 		Buzzer = 1;
   24: 		SoundNumberCount--;
0010A8 D2B5              SETB     Buzzer
   25: 	}
0010AA 14                DEC      A
0010AB F0                MOVX     @DPTR,A
   26: }
   27: 
0010AC         ?C0005?BUZZER:
0010AC 22                RET      
----- FUNCTION buzzer_Handler100ms (END) -------


----- FUNCTION led_Handler1ms (BEGIN) -----
 FILE: 'Driver\LED.c'
   34: void led_Handler1ms(void)
   35: {
   36:     if(ledsw)
   37:     {
0010AD 200A02            JB       ledsw,$ + 5H
0010B0 21B1              AJMP     ?C0033?LED
   38:     	if (gCurLed<5)
   39:     		gCurLed++;
0010B2 9000EA            MOV      DPTR,#gCurLed
0010B5 E0                MOVX     A,@DPTR
0010B6 C3                CLR      C
0010B7 9405              SUBB     A,#05H
0010B9 5005              JNC      ?C0003?LED
   40:     	else
0010BB E0                MOVX     A,@DPTR
0010BC 04                INC      A
0010BD F0                MOVX     @DPTR,A
0010BE 8005              SJMP     ?C0004?LED
0010C0         ?C0003?LED:
   41:     		gCurLed=0;
0010C0 E4                CLR      A
0010C1 9000EA            MOV      DPTR,#gCurLed
0010C4 F0                MOVX     @DPTR,A
0010C5         ?C0004?LED:
   42:     	LED_CS0 = 1;
0010C5 31DC              ACALL    ?L?COM0043
   43:     	LED_CS1 = 1;
   44:     	LED_CS2 = 1;
   45:     	LED_CS3 = 1;
   46:     	LED_CS4 = 1;
   47:     	LED_CS5 = 1;
   48:     	switch ( gLedBuf[gCurLed])		 //switch case 语句中 switch中的条件case都不满足就执行default
0010C7 9000EA            MOV      DPTR,#gCurLed
0010CA E0                MOVX     A,@DPTR
0010CB FF                MOV      R7,A
0010CC 24E4              ADD      A,#LOW gLedBuf
0010CE F582              MOV      DPL,A
0010D0 E4                CLR      A
0010D1 3400              ADDC     A,#HIGH gLedBuf
0010D3 F583              MOV      DPH,A
0010D5 E0                MOVX     A,@DPTR
0010D6 B41100            CJNE     A,#011H,?C0045?LED
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 44


0010D9         ?C0045?LED:
0010D9 4002              JC       $ + 4H
0010DB 2169              AJMP     ?C0023?LED
0010DD 9010E4            MOV      DPTR,#010E4H
0010E0 F8                MOV      R0,A
0010E1 28                ADD      A,R0
0010E2 28                ADD      A,R0
0010E3 73                JMP      @A+DPTR
0010E4         ?C0046?LED:
0010E4 021117            LJMP     ?C0006?LED
0010E7 02111C            LJMP     ?C0007?LED
0010EA 021121            LJMP     ?C0008?LED
0010ED 021126            LJMP     ?C0009?LED
0010F0 02112B            LJMP     ?C0010?LED
0010F3 021130            LJMP     ?C0011?LED
0010F6 021135            LJMP     ?C0012?LED
0010F9 02113A            LJMP     ?C0013?LED
0010FC 02113F            LJMP     ?C0014?LED
0010FF 021144            LJMP     ?C0015?LED
001102 021149            LJMP     ?C0016?LED
001105 02114E            LJMP     ?C0017?LED
001108 021153            LJMP     ?C0018?LED
00110B 021155            LJMP     ?C0019?LED
00110E 02115A            LJMP     ?C0020?LED
001111 02115F            LJMP     ?C0021?LED
001114 021164            LJMP     ?C0022?LED
   49:     	{
   50:     	    case 0:	P1 = 0xf5; break;//0
001117         ?C0006?LED:
001117 7590F5            MOV      P1,#0F5H
00111A 8050              SJMP     ?C0005?LED
   51:     		case 1:	P1 = 0x05; break;//1
00111C         ?C0007?LED:
00111C 759005            MOV      P1,#05H
00111F 804B              SJMP     ?C0005?LED
   52:     		case 2:	P1 = 0xB3; break;//2
001121         ?C0008?LED:
001121 7590B3            MOV      P1,#0B3H
001124 8046              SJMP     ?C0005?LED
   53:     		case 3:	P1 = 0x97; break;//3
001126         ?C0009?LED:
001126 759097            MOV      P1,#097H
001129 8041              SJMP     ?C0005?LED
   54:     		case 4:	P1 = 0x47; break;//4
00112B         ?C0010?LED:
00112B 759047            MOV      P1,#047H
00112E 803C              SJMP     ?C0005?LED
   55:     		case 5:	P1 = 0xD6; break;//5
001130         ?C0011?LED:
001130 7590D6            MOV      P1,#0D6H
001133 8037              SJMP     ?C0005?LED
   56:     		case 6:	P1 = 0xF6; break;//6
001135         ?C0012?LED:
001135 7590F6            MOV      P1,#0F6H
001138 8032              SJMP     ?C0005?LED
   57:     		case 7:	P1 = 0x85; break;//7
00113A         ?C0013?LED:
00113A 759085            MOV      P1,#085H
00113D 802D              SJMP     ?C0005?LED
   58:     		case 8:	P1 = 0xF7; break;//8
00113F         ?C0014?LED:
00113F 7590F7            MOV      P1,#0F7H
001142 8028              SJMP     ?C0005?LED
   59:     		case 9:	P1 = 0xD7; break;//9
001144         ?C0015?LED:
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 45


001144 7590D7            MOV      P1,#0D7H
001147 8023              SJMP     ?C0005?LED
   60:     		case 10:P1 = 0x75; break;//U
001149         ?C0016?LED:
001149 759075            MOV      P1,#075H
00114C 801E              SJMP     ?C0005?LED
   61:     		case 11:P1 = 0x9F; break;//3.
00114E         ?C0017?LED:
00114E 75909F            MOV      P1,#09FH
001151 8019              SJMP     ?C0005?LED
   62:     		case 12:P1 = 0x00; break;//空
001153         ?C0018?LED:
001153 8014              SJMP     ?C0049?LED
   63:     		case 13:P1 = 0xDE; break;//5.
001155         ?C0019?LED:
001155 7590DE            MOV      P1,#0DEH
001158 8012              SJMP     ?C0005?LED
   64:             case 14:P1 = 0xE3;break;//P
00115A         ?C0020?LED:
00115A 7590E3            MOV      P1,#0E3H
00115D 800D              SJMP     ?C0005?LED
   65:             case 15:P1 = 0x02;break;//-
00115F         ?C0021?LED:
00115F 759002            MOV      P1,#02H
001162 8008              SJMP     ?C0005?LED
   66:             case 16:P1 = 0xE7;break;//A
001164         ?C0022?LED:
001164 7590E7            MOV      P1,#0E7H
001167 8003              SJMP     ?C0005?LED
   67:     		default:P1 = 0x00; break;
001169         ?C0023?LED:
001169         
001169 E4                CLR      A
00116A F590              MOV      P1,A
   68:     	}
00116C         ?C0005?LED:
   69:         if(gShowDot & (1<<gCurLed))//show dot
00116C 7401              MOV      A,#01H
00116E 7E00              MOV      R6,#00H
001170 A807              MOV      R0,AR7
001172 08                INC      R0
001173 8005              SJMP     ?C0048?LED
001175         ?C0047?LED:
001175 C3                CLR      C
001176 33                RLC      A
001177 CE                XCH      A,R6
001178 33                RLC      A
001179 CE                XCH      A,R6
00117A         ?C0048?LED:
00117A D8F9              DJNZ     R0,?C0047?LED
00117C FF                MOV      R7,A
00117D 9000EB            MOV      DPTR,#gShowDot
001180 E0                MOVX     A,@DPTR
001181 FD                MOV      R5,A
001182 EF                MOV      A,R7
001183 5D                ANL      A,R5
001184 6003              JZ       ?C0024?LED
   70:         {
   71:      		P1 |= 0X08;
001186 439008            ORL      P1,#08H
   72:         }
001189         ?C0024?LED:
   73:     	switch (gCurLed)
001189 9000EA            MOV      DPTR,#gCurLed
00118C E0                MOVX     A,@DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 46


00118D 14                DEC      A
00118E 6013              JZ       ?C0027?LED
001190 14                DEC      A
001191 6013              JZ       ?C0028?LED
001193 14                DEC      A
001194 6013              JZ       ?C0029?LED
001196 14                DEC      A
001197 6013              JZ       ?C0030?LED
001199 14                DEC      A
00119A 6013              JZ       ?C0031?LED
00119C 2405              ADD      A,#05H
00119E 7011              JNZ      ?C0033?LED
   74:     	{
   75:     		case 0:
0011A0         ?C0026?LED:
   76:     			LED_CS0 = 0;
0011A0 C2B6              CLR      LED_CS0
   77:     			break;
0011A2 22                RET      
   78:     		case 1:
0011A3         ?C0027?LED:
   79:     			LED_CS1 = 0;
0011A3 C2CC              CLR      LED_CS1
   80:     			break;
0011A5 22                RET      
   81:     		case 2:
0011A6         ?C0028?LED:
   82:     			LED_CS2 = 0;
0011A6 C2CD              CLR      LED_CS2
   83:     			break;
0011A8 22                RET      
   84:     		case 3:
0011A9         ?C0029?LED:
   85:     			LED_CS3 = 0;
0011A9 C2A0              CLR      LED_CS3
   86:     			break;
0011AB 22                RET      
   87:     		case 4:
0011AC         ?C0030?LED:
   88:     			LED_CS4 = 0;
0011AC C2A7              CLR      LED_CS4
   89:     			break;
0011AE 22                RET      
   90:     		case 5:
0011AF         ?C0031?LED:
   91:     			LED_CS5 = 0;
0011AF C2A6              CLR      LED_CS5
   92:     			break;
   93:     		default:
   94:     			break;
   95:     	}
   96:     }
   97: }
0011B1         ?C0033?LED:
0011B1 22                RET      
----- FUNCTION led_Handler1ms (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: 'System\sys_task.c'
   77: void main(void)
   78: {
   79:     sys_taskInit();
   80:     buzzer_SoundNumber(1);
0011B2 1111              ACALL    sys_taskInit
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 47


   81:     while(1)
0011B4 7F01              MOV      R7,#01H
0011B6 120B34            LCALL    _buzzer_SoundNumber
0011B9         ?C0010?SYS_TASK:
   82:     {
   83:         WDT_CONTR = 0x33;          //reset watch dog      SyttemClk is 11.0592M Over Time 568.8ms
   84:         if(taskCycle1sFlag == TRUE)
0011B9 75C133            MOV      WDT_CONTR,#033H
   85:         {
0011BC 3006FA            JNB      taskCycle1sFlag,?C0010?SYS_TASK
   86:         	taskCycle1sFlag = FALSE;
   87:             app_confingHandler1s();
0011BF C206              CLR      taskCycle1sFlag
   88:             app_brushCycle1s();
0011C1 31C8              ACALL    app_confingHandler1s
   89:         }
0011C3 120943            LCALL    app_brushCycle1s
   90:     }
   91: }
0011C6 80F1              SJMP     ?C0010?SYS_TASK
----- FUNCTION main (END) -------


----- FUNCTION app_confingHandler1s (BEGIN) -----
 FILE: 'App\app_config.c'
  113: void app_confingHandler1s(void)
  114: {
  115:     led_Switch(OFF);
  116: //    hwa_eepromReadSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
0011C8 C201              CLR      ?led_Switch?BIT
0011CA 120BD1            LCALL    led_Switch
  117: //    sys_uartSendData((UINT8*)&USER_Card_ID, 5);
  118: //    USER_Card_ID[0][0]++;
  119: //    hwa_eepromWriteSector((UINT8*)&USER_Card_ID, USER_CAED_ID_SECTOR);
  120:     led_Switch(ON);
0011CD D201              SETB     ?led_Switch?BIT
0011CF 020BD1            LJMP     led_Switch
----- FUNCTION app_confingHandler1s (END) -------


----- FUNCTION buzzer_Init (BEGIN) -----
 FILE: 'Driver\buzzer.c'
    8: void buzzer_Init(void)
    9: {
   10:     P3M1 &= ~0x20;      //推挽输出
   11:     P3M0 |= 0x20;
0011D2 53B1DF            ANL      P3M1,#0DFH
   12:     P3 &= ~0x20;
0011D5 43B220            ORL      P3M0,#020H
   13: }
0011D8 53B0DF            ANL      P3,#0DFH
   14: 
0011DB 22                RET      
----- FUNCTION buzzer_Init (END) -------


----- FUNCTION ?L?COM0043 (BEGIN) -----
0011DC D2B6              SETB     LED_CS0
0011DE D2CC              SETB     LED_CS1
0011E0 D2CD              SETB     LED_CS2
0011E2 D2A0              SETB     LED_CS3
0011E4 D2A7              SETB     LED_CS4
0011E6 D2A6              SETB     LED_CS5
0011E8 22                RET      
----- FUNCTION ?L?COM0043 (END) -------
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 48




----- FUNCTION sys_uartInit (BEGIN) -----
 FILE: 'System\sys_uart.c'
   37: void sys_uartInit(void)
   38: {
   39: //    sys_uartSetChannel(2);
   40:     SCON = 0x50;                    //8位可变波特率
0011E9 759850            MOV      SCON,#050H
   41:     T2L = (65536 - (FOSC/4/BAUD));  //设置波特率重装值
0011EC 75D7C0            MOV      T2L,#0C0H
   42:     T2H = (65536 - (FOSC/4/BAUD))>>8;
0011EF 75D6FD            MOV      T2H,#0FDH
   43:     AUXR |= 0x14;                   //T2为1T模式, 并启动定时器2
0011F2 438E14            ORL      AUXR,#014H
   44:     AUXR |= 0x01;                   //选择定时器2为串口1的波特率发生器
0011F5 438E01            ORL      AUXR,#01H
   45:     ES = 1;                         //使能串口1中断
0011F8 D2AC              SETB     ES
   46:     EA = 1;
0011FA D2AF              SETB     EA
   47: }
0011FC 22                RET      
----- FUNCTION sys_uartInit (END) -------


----- FUNCTION len_Init (BEGIN) -----
 FILE: 'Driver\LED.c'
   21: void len_Init(void)
   22: {
   23:     P1M1 &= ~0xFF;      //推挽输出
   24:     P1M0 |= 0xFF;
0011FD 759100            MOV      P1M1,#00H
   25:     P2M1 &= ~0xC1;      //推挽输出
001200 7592FF            MOV      P1M0,#0FFH
   26:     P2M0 |= 0xC1;
001203 53953E            ANL      P2M1,#03EH
   27:     P5M1 &= ~0x30;      //推挽输出
001206 4396C1            ORL      P2M0,#0C1H
   28:     P5M0 |= 0x30;
001209 53C9CF            ANL      P5M1,#0CFH
   29:     P3M1 &= ~0x40;      //推挽输出
00120C 43CA30            ORL      P5M0,#030H
   30:     P3M0 |= 0x40;
00120F 53B1BF            ANL      P3M1,#0BFH
   31: }
001212 43B240            ORL      P3M0,#040H
   32: 
001215 22                RET      
----- FUNCTION len_Init (END) -------


----- FUNCTION sys_uartInterrupt (BEGIN) -----
 FILE: 'System\sys_uart.c'
   64: void sys_uartInterrupt() interrupt 4
001216 C0E0              PUSH     ACC
001218 C0F0              PUSH     B
00121A C083              PUSH     DPH
00121C C082              PUSH     DPL
00121E C0D0              PUSH     PSW
001220 75D000            MOV      PSW,#00H
001223 C000              PUSH     AR0
001225 C001              PUSH     AR1
001227 C002              PUSH     AR2
001229 C003              PUSH     AR3
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 49


00122B C004              PUSH     AR4
00122D C005              PUSH     AR5
00122F C006              PUSH     AR6
001231 C007              PUSH     AR7
   65: {
   66:     if(RI)
001233 309804            JNB      RI,?C0008?SYS_UART
   67:     {
   68:         RI = 0;
001236 C298              CLR      RI
   69:         sys_uartRxHandler();
001238 F1F3              ACALL    sys_uartRxHandler
   70:     }
00123A         ?C0008?SYS_UART:
   71:     if(TI)
00123A 30991F            JNB      TI,?C0011?SYS_UART
   72:     {
   73:         TI = 0;
00123D C299              CLR      TI
   74: #ifdef ENABLE_INTERRUPT_SEND
   75:         if(++TxCnt != TxLen)
00123F 9000D8            MOV      DPTR,#TxLen
001242 E0                MOVX     A,@DPTR
001243 FF                MOV      R7,A
001244 A3                INC      DPTR
001245 E0                MOVX     A,@DPTR
001246 04                INC      A
001247 F0                MOVX     @DPTR,A
001248 6F                XRL      A,R7
001249 6011              JZ       ?C0011?SYS_UART
   76:         {
   77:             SBUF = pTxBuff[TxCnt];
00124B 9000C9            MOV      DPTR,#pTxBuff
00124E 120CDA            LCALL    ?L?COM0002
001251 F9                MOV      R1,A
001252 9000D9            MOV      DPTR,#TxCnt
001255 E0                MOVX     A,@DPTR
001256 F582              MOV      DPL,A
001258 517A              ACALL    ?L?COM001F
00125A F599              MOV      SBUF,A
   78:         }
   79: #else
   80:         b_TxFlag = TRUE;
   81: #endif
   82:     }
   83: }
00125C         ?C0011?SYS_UART:
00125C D007              POP      AR7
00125E D006              POP      AR6
001260 D005              POP      AR5
001262 D004              POP      AR4
001264 D003              POP      AR3
001266 D002              POP      AR2
001268 D001              POP      AR1
00126A D000              POP      AR0
00126C D0D0              POP      PSW
00126E D082              POP      DPL
001270 D083              POP      DPH
001272 D0F0              POP      B
001274 D0E0              POP      ACC
001276 32                RETI     
----- FUNCTION sys_uartInterrupt (END) -------


----- FUNCTION ?L?COM001D (BEGIN) -----
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 50


001277 F9                MOV      R1,A
001278         ?L?COM001E:
001278 8F82              MOV      DPL,R7
00127A         ?L?COM001F:
00127A 758300            MOV      DPH,#00H
00127D 020135            LJMP     ?C?CLDOPTR
----- FUNCTION ?L?COM001D (END) -------


----- FUNCTION _Load_Key (BEGIN) -----
 FILE: 'Driver\mifare.c'
  406: uchar Load_Key(uchar *ramadr)
  407: {
001280 900073            MOV      DPTR,#ramadr
001283 120DFA            LCALL    ?L?COM0004
  408: 	uchar acktemp,temp[1],i;
  409: 	uchar ucBuff[12];
  410: 	for (i=0;i<6;i++)
;---- Variable 'i' assigned to Register 'R7' ----
001286 E4                CLR      A
001287 FF                MOV      R7,A
001288         ?C0089?MIFARE:
  411: 	{
  412: 		temp[0]=ramadr[i];
001288 900073            MOV      DPTR,#ramadr
00128B 120CDA            LCALL    ?L?COM0002
00128E 5177              ACALL    ?L?COM001D
001290 900077            MOV      DPTR,#temp
001293 F0                MOVX     @DPTR,A
001294 FD                MOV      R5,A
  413: 		ucBuff[2*i]=(((ramadr[i]&0xf0)>>4)|((~ramadr[i])&0xf0));
001295 54F0              ANL      A,#0F0H
001297 C4                SWAP     A
001298 540F              ANL      A,#0FH
00129A FE                MOV      R6,A
00129B 5178              ACALL    ?L?COM001E
00129D F4                CPL      A
00129E 51F2              ACALL    ?L?COM005D
0012A0 2478              ADD      A,#LOW ucBuff
0012A2 F582              MOV      DPL,A
0012A4 E4                CLR      A
0012A5 3400              ADDC     A,#HIGH ucBuff
0012A7 F583              MOV      DPH,A
0012A9 EE                MOV      A,R6
0012AA F0                MOVX     @DPTR,A
  414: 		ucBuff[2*i+1]=((temp[0]&0xf)|(~(temp[0]&0xf)<<4));
0012AB ED                MOV      A,R5
0012AC 540F              ANL      A,#0FH
0012AE FE                MOV      R6,A
0012AF F4                CPL      A
0012B0 FD                MOV      R5,A
0012B1 C4                SWAP     A
0012B2 51F2              ACALL    ?L?COM005D
0012B4 2479              ADD      A,#LOW ucBuff+01H
0012B6 F582              MOV      DPL,A
0012B8 E4                CLR      A
0012B9 3400              ADDC     A,#HIGH ucBuff+01H
0012BB D132              ACALL    ?L?COM0030
0012BD B406C8            CJNE     A,#06H,?C0089?MIFARE
0012C0         ?C0090?MIFARE:
  415: 	}
  416: 	acktemp=Command_Send(LOAD_KEY, ucBuff, 12);
0012C0 7B01              MOV      R3,#01H
0012C2 7A00              MOV      R2,#HIGH ucBuff
0012C4 7978              MOV      R1,#LOW ucBuff
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 51


0012C6 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
0012C9 740C              MOV      A,#0CH
0012CB F0                MOVX     @DPTR,A
0012CC 7F19              MOV      R7,#019H
0012CE 120794            LCALL    _Command_Send
0012D1 900076            MOV      DPTR,#acktemp
0012D4 EF                MOV      A,R7
0012D5 F0                MOVX     @DPTR,A
  417: 	temp[0] = SPIReadOne(SecondaryStatus_Reg);
0012D6 7F05              MOV      R7,#05H
0012D8 1206F4            LCALL    _SPIReadOne
0012DB A3                INC      DPTR
0012DC EF                MOV      A,R7
0012DD F0                MOVX     @DPTR,A
  418: 	if (temp[0]&0x40)
0012DE 30E607            JNB      ACC.6,?C0092?MIFARE
  419: 	{
  420: 		temp[0]=0x0;
0012E1 E4                CLR      A
0012E2 1206BA            LCALL    ?L?COM003D
  421: 		SPIWriteOne(Command_Reg,temp[0]);
  422: 		return(0);
0012E5 7F00              MOV      R7,#00H
0012E7 22                RET      
  423: 	}
0012E8         ?C0092?MIFARE:
  424: 	temp[0]=0x0;
0012E8 E4                CLR      A
0012E9 900077            MOV      DPTR,#temp
0012EC 1206BA            LCALL    ?L?COM003D
  425: 	SPIWriteOne(Command_Reg,temp[0]);
  426: 	return(1);
0012EF 7F01              MOV      R7,#01H
  427: }
0012F1 22                RET      
----- FUNCTION _Load_Key (END) -------


----- FUNCTION ?L?COM005D (BEGIN) -----
0012F2 54F0              ANL      A,#0F0H
0012F4 4E                ORL      A,R6
0012F5 FE                MOV      R6,A
0012F6 EF                MOV      A,R7
0012F7 25E0              ADD      A,ACC
0012F9 22                RET      
----- FUNCTION ?L?COM005D (END) -------


----- FUNCTION _hwa_mifareDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   44: void hwa_mifareDecrypt(UINT8 *pData)        //利用卡ID解密
   45: {
0012FA 900076            MOV      DPTR,#pData
0012FD 120DFA            LCALL    ?L?COM0004
   46: 	UINT8 i, j;
   47: 	for (i = 0; i<USE_DATA_BLOCK_LEN + 2; i++)
;---- Variable 'i' assigned to Register 'R6' ----
001300 E4                CLR      A
001301 FE                MOV      R6,A
001302         ?C0011?HWA_MIFARE:
   48: 	{
   49: 		for (j = 4; j>0; j--)
;---- Variable 'j' assigned to Register 'R5' ----
001302 7D04              MOV      R5,#04H
001304         ?C0014?HWA_MIFARE:
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 52


   50: 		{
   51: 			pData[i] = _crol_(pData[i], 1);
001304 900076            MOV      DPTR,#pData
001307 120CDA            LCALL    ?L?COM0002
00130A F9                MOV      R1,A
00130B 8E82              MOV      DPL,R6
00130D 517A              ACALL    ?L?COM001F
00130F FF                MOV      R7,A
001310 7801              MOV      R0,#01H
001312 08                INC      R0
001313 8001              SJMP     ?C0074?HWA_MIFARE
001315         ?C0073?HWA_MIFARE:
001315 23                RL       A
001316         ?C0074?HWA_MIFARE:
001316 D8FD              DJNZ     R0,?C0073?HWA_MIFARE
001318 121B44            LCALL    ?L?COM0054
   52: 			pData[i] ^= gCard_UID[i % 5];
00131B E9                MOV      A,R1
00131C 121A6F            LCALL    ?L?COM0014
   53: 		}
00131F DDE3              DJNZ     R5,?C0014?HWA_MIFARE
   54: 	}
001321         ?C0013?HWA_MIFARE:
001321 0E                INC      R6
001322 EE                MOV      A,R6
001323 B404DC            CJNE     A,#04H,?C0011?HWA_MIFARE
   55: }
001326 22                RET      
----- FUNCTION _hwa_mifareDecrypt (END) -------


----- FUNCTION hwa_mifareCheckBlock (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  120: void hwa_mifareCheckBlock(void)
  121: {
  122: 	UINT16 crc, crcBak;
  123: 	hwa_mifareDecrypt((UINT8*)&s_NormalBuff);        //利用卡ID解密
001327 120FBC            LCALL    ?L?COM0026
00132A 51FA              ACALL    _hwa_mifareDecrypt
  124: 	crc = hwa_mifareCheckOut((UINT8*)&s_NormalBuff, USE_DATA_BLOCK_LEN);
00132C 120FBC            LCALL    ?L?COM0026
;---- Variable 'crc' assigned to Register 'R4/R5' ----
00132F 7167              ACALL    ?L?COM002C
  125: 	if (crc == (s_NormalBuff.crc[0] << 8 | s_NormalBuff.crc[1]))
001331 900052            MOV      DPTR,#s_NormalBuff+02H
001334 E0                MOVX     A,@DPTR
001335 FE                MOV      R6,A
001336 A3                INC      DPTR
001337 E0                MOVX     A,@DPTR
001338 FB                MOV      R3,A
001339 EB                MOV      A,R3
00133A B50508            CJNE     A,AR5,?C0040?HWA_MIFARE
00133D EE                MOV      A,R6
00133E B50404            CJNE     A,AR4,?C0040?HWA_MIFARE
  126: 	{
  127: 		NormalErrorFlag = FALSE;
001341 C205              CLR      NormalErrorFlag
  128: 	}
001343 8002              SJMP     ?C0041?HWA_MIFARE
001345         ?C0040?HWA_MIFARE:
  129: 	else
  130: 	{
  131: 		NormalErrorFlag = TRUE;
001345 D205              SETB     NormalErrorFlag
  132: 	}
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 53


001347         ?C0041?HWA_MIFARE:
  133: 	hwa_mifareDecrypt((UINT8*)&s_BackupBuff);        //利用卡ID解密
001347 120FD1            LCALL    ?L?COM0027
00134A 51FA              ACALL    _hwa_mifareDecrypt
  134: 	crcBak = hwa_mifareCheckOut((UINT8*)&s_BackupBuff, USE_DATA_BLOCK_LEN);
00134C 120FD1            LCALL    ?L?COM0027
;---- Variable 'crcBak' assigned to Register 'R4/R5' ----
00134F 7167              ACALL    ?L?COM002C
  135: 	if (crcBak == (s_BackupBuff.crc[0] << 8 | s_BackupBuff.crc[1]))
001351 900042            MOV      DPTR,#s_BackupBuff+02H
001354 E0                MOVX     A,@DPTR
001355 FE                MOV      R6,A
001356 A3                INC      DPTR
001357 E0                MOVX     A,@DPTR
001358 FB                MOV      R3,A
001359 EB                MOV      A,R3
00135A B50507            CJNE     A,AR5,?C0042?HWA_MIFARE
00135D EE                MOV      A,R6
00135E B50403            CJNE     A,AR4,?C0042?HWA_MIFARE
  136: 	{
  137: 		BackupErrorFlag = FALSE;
001361 C204              CLR      BackupErrorFlag
  138: 	}
001363 22                RET      
001364         ?C0042?HWA_MIFARE:
  139: 	else
  140: 	{
  141: 		BackupErrorFlag = TRUE;
001364 D204              SETB     BackupErrorFlag
  142: 	}
  143: }
001366 22                RET      
----- FUNCTION hwa_mifareCheckBlock (END) -------


----- FUNCTION ?L?COM002C (BEGIN) -----
001367 7D02              MOV      R5,#02H
001369 7C00              MOV      R4,#00H
00136B 7172              ACALL    _hwa_mifareCheckOut
00136D AD07              MOV      R5,AR7
00136F AC06              MOV      R4,AR6
001371 22                RET      
----- FUNCTION ?L?COM002C (END) -------


----- FUNCTION _hwa_mifareCheckOut (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
   97: UINT16 hwa_mifareCheckOut(UINT8 *dat, UINT16 len)
   98: {
001372 90007D            MOV      DPTR,#dat
001375 120DFA            LCALL    ?L?COM0004
001378 D139              ACALL    ?L?COM0042
   99: 	UINT16 crc = 0xFFFF;
  100:     UINT8 i;
;---- Variable 'crc' assigned to Register 'R6/R7' ----
00137A 74FF              MOV      A,#0FFH
00137C FF                MOV      R7,A
00137D FE                MOV      R6,A
00137E         ?C0032?HWA_MIFARE:
  101:     while(len--)
00137E 900080            MOV      DPTR,#len
001381 1218B2            LCALL    ?L?COM0029
001384 6030              JZ       ?C0033?HWA_MIFARE
  102:     {
  103:         crc = crc ^*dat++;
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 54


001386 90007D            MOV      DPTR,#dat
001389 121914            LCALL    ?L?COM002A
00138C 121922            LCALL    ?L?COM005C
  104:         for ( i = 0; i < 8; i++)
00138F E4                CLR      A
001390 900082            MOV      DPTR,#i
001393 F0                MOVX     @DPTR,A
001394         ?C0034?HWA_MIFARE:
001394 900082            MOV      DPTR,#i
001397 E0                MOVX     A,@DPTR
001398 C3                CLR      C
001399 9408              SUBB     A,#08H
00139B 50E1              JNC      ?C0032?HWA_MIFARE
  105:         {
  106:             if( ( crc & 0x0001) > 0)
00139D 12192A            LCALL    ?L?COM0053
0013A0 EE                MOV      A,R6
0013A1 4005              JC       ?C0037?HWA_MIFARE
  107:             {
  108:                 crc = crc >> 1;
0013A3 121933            LCALL    ?L?COM003F
  109:                 crc = crc ^ 0xa001;
  110:             }
0013A6 8006              SJMP     ?C0036?HWA_MIFARE
0013A8         ?C0037?HWA_MIFARE:
  111:             else
  112:             {
  113:                 crc = crc >> 1;
0013A8 C3                CLR      C
0013A9 13                RRC      A
0013AA FE                MOV      R6,A
0013AB EF                MOV      A,R7
0013AC 13                RRC      A
0013AD FF                MOV      R7,A
  114:             }
  115:         }
0013AE         ?C0036?HWA_MIFARE:
0013AE 900082            MOV      DPTR,#i
0013B1 E0                MOVX     A,@DPTR
0013B2 04                INC      A
0013B3 F0                MOVX     @DPTR,A
0013B4 80DE              SJMP     ?C0034?HWA_MIFARE
  116:     }
0013B6         ?C0033?HWA_MIFARE:
  117:     return ( crc );
  118: }
0013B6 22                RET      
----- FUNCTION _hwa_mifareCheckOut (END) -------


----- FUNCTION app_brushCard (BEGIN) -----
 FILE: 'App\app_brush.c'
   58: UINT8 app_brushCard(void)
   59: {
   60: 	UINT8 Sector;
   61: 	UINT8 CardIndex;
   62:     UINT8 i;
   63: 	for (CardIndex = MEM_CARD; CardIndex <= PWD_CARD; CardIndex++)
0013B7 900071            MOV      DPTR,#CardIndex
0013BA 7401              MOV      A,#01H
0013BC F0                MOVX     @DPTR,A
0013BD         ?C0005?APP_BRUSH:
   64: 	{
   65: 		if (b_FactorySystem)
0013BD 300906            JNB      b_FactorySystem,?C0008?APP_BRUSH
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 55


   66: 		{
   67: 			CardIndex = PWD_CARD;
0013C0 900071            MOV      DPTR,#CardIndex
0013C3 7403              MOV      A,#03H
0013C5 F0                MOVX     @DPTR,A
   68: 		}
0013C6         ?C0008?APP_BRUSH:
   69: 		if (CardIndex == MEM_CARD)
0013C6 900071            MOV      DPTR,#CardIndex
0013C9 E0                MOVX     A,@DPTR
0013CA B40108            CJNE     A,#01H,?C0009?APP_BRUSH
   70: 		{
   71: 			Load_Key(&s_System.MGM_Card);
0013CD 7B01              MOV      R3,#01H
0013CF 7A00              MOV      R2,#HIGH s_System
0013D1 79A1              MOV      R1,#LOW s_System
   72: 		}
0013D3 801C              SJMP     ?C0064?APP_BRUSH
0013D5         ?C0009?APP_BRUSH:
   73: 		else if (CardIndex == USER_CARD)
0013D5 900071            MOV      DPTR,#CardIndex
0013D8 E0                MOVX     A,@DPTR
0013D9 B40208            CJNE     A,#02H,?C0011?APP_BRUSH
   74: 		{
   75: 			Load_Key(&s_System.USER_Card);
0013DC 7B01              MOV      R3,#01H
0013DE 7A00              MOV      R2,#HIGH s_System+0AH
0013E0 79AB              MOV      R1,#LOW s_System+0AH
0013E2         
   76: 		}
0013E2 800D              SJMP     ?C0064?APP_BRUSH
0013E4         ?C0011?APP_BRUSH:
   77: 		else if (CardIndex == PWD_CARD)
0013E4 900071            MOV      DPTR,#CardIndex
0013E7 E0                MOVX     A,@DPTR
0013E8 B40308            CJNE     A,#03H,?C0010?APP_BRUSH
   78: 		{
   79: 			Load_Key(PWD_Card);
0013EB 7BFF              MOV      R3,#0FFH
0013ED 7A00              MOV      R2,#HIGH PWD_Card
0013EF 7903              MOV      R1,#LOW PWD_Card
0013F1         
0013F1 5180              ACALL    _Load_Key
   80: 		}
0013F3         ?C0010?APP_BRUSH:
   81: 		MIF_Halt();
0013F3 915D              ACALL    MIF_Halt
   82: 		if (Request(RF_CMD_REQUEST_STD) != FM1702_OK)
0013F5 7F26              MOV      R7,#026H
0013F7 918A              ACALL    _Request
0013F9 EF                MOV      A,R7
0013FA 7050              JNZ      ?C0007?APP_BRUSH
   83: 		{
   84: 			continue;
   85: 		}
0013FC         ?C0014?APP_BRUSH:
   86:         for(i=0; i<2; i++)
0013FC E4                CLR      A
0013FD 900072            MOV      DPTR,#i
001400 F0                MOVX     @DPTR,A
001401         ?C0015?APP_BRUSH:
   87:         {
   88:             if (AntiColl() == FM1702_OK && SelectCard() == FM1702_OK)
001401 120725            LCALL    AntiColl
001404 EF                MOV      A,R7
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 56


001405 7039              JNZ      ?C0017?APP_BRUSH
001407 91F5              ACALL    SelectCard
001409 EF                MOV      A,R7
00140A 7034              JNZ      ?C0017?APP_BRUSH
   89:             {
   90:                 if (CardIndex == USER_CARD)     //用户卡验证钱所在扇区
00140C 900071            MOV      DPTR,#CardIndex
00140F E0                MOVX     A,@DPTR
001410 B4020A            CJNE     A,#02H,?C0019?APP_BRUSH
   91:                 {
   92:                     Sector = s_System.Sector;
001413 9000A7            MOV      DPTR,#s_System+06H
001416 E0                MOVX     A,@DPTR
001417 900070            MOV      DPTR,#Sector
00141A F0                MOVX     @DPTR,A
   93:                 }
00141B 8006              SJMP     ?C0020?APP_BRUSH
00141D         ?C0019?APP_BRUSH:
   94:                 else                            //管理和密码卡验证1扇区
   95:                 {
   96:                     Sector = 1;
00141D 900070            MOV      DPTR,#Sector
001420 7401              MOV      A,#01H
001422 F0                MOVX     @DPTR,A
   97:                 }
001423         ?C0020?APP_BRUSH:
   98:                 if (Authentication(gCard_UID, Sector, 0x60) == FM1702_OK)
001423 7B01              MOV      R3,#01H
001425 7A00              MOV      R2,#HIGH gCard_UID
001427 79B4              MOV      R1,#LOW gCard_UID
001429 900070            MOV      DPTR,#Sector
00142C E0                MOVX     A,@DPTR
00142D FD                MOV      R5,A
00142E 900077            MOV      DPTR,#?_Authentication?BYTE+04H
001431 7460              MOV      A,#060H
001433 F0                MOVX     @DPTR,A
001434 120E03            LCALL    _Authentication
001437 EF                MOV      A,R7
001438 7006              JNZ      ?C0017?APP_BRUSH
   99:                 {
  100:                     return CardIndex;
00143A 900071            MOV      DPTR,#CardIndex
00143D E0                MOVX     A,@DPTR
00143E FF                MOV      R7,A
00143F 22                RET      
  101:                 }
  102:             }
  103:         }
001440         ?C0017?APP_BRUSH:
001440 900072            MOV      DPTR,#i
001443 E0                MOVX     A,@DPTR
001444 04                INC      A
001445 F0                MOVX     @DPTR,A
001446 E0                MOVX     A,@DPTR
001447 C3                CLR      C
001448 9402              SUBB     A,#02H
00144A 40B5              JC       ?C0015?APP_BRUSH
  104: 	}
00144C         ?C0007?APP_BRUSH:
00144C 900071            MOV      DPTR,#CardIndex
00144F E0                MOVX     A,@DPTR
001450 04                INC      A
001451 F0                MOVX     @DPTR,A
001452 E0                MOVX     A,@DPTR
001453 D3                SETB     C
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 57


001454 9403              SUBB     A,#03H
001456 5002              JNC      $ + 4H
001458 61BD              AJMP     ?C0005?APP_BRUSH
00145A         ?C0006?APP_BRUSH:
  105: 	return NONE_CARD;
00145A 7F00              MOV      R7,#00H
  106: }
00145C 22                RET      
----- FUNCTION app_brushCard (END) -------


----- FUNCTION MIF_Halt (BEGIN) -----
 FILE: 'Driver\mifare.c'
  610: uchar MIF_Halt(void)
  611: {
  612: 	uchar	temp;
  613: 	//选择TX1、TX2的发射天线阻抗
  614: 	SPIWriteOne(CwConductance_Reg,0x3f);
00145D B156              ACALL    ?L?COM0020
00145F 7450              MOV      A,#050H
001461 F0                MOVX     @DPTR,A
  615: 	//选择数据校验种类和模式
  616: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
  617: 	*gBuff = RF_CMD_HALT;
  618: 	*(gBuff + 1) = 0x00;
001462 E4                CLR      A
001463 120B2B            LCALL    ?L?COM000F
001466 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
001469 7402              MOV      A,#02H
00146B F0                MOVX     @DPTR,A
00146C 7F1A              MOV      R7,#01AH
00146E 120794            LCALL    _Command_Send
;---- Variable 'temp' assigned to Register 'R7' ----
  619: 	temp = Command_Send(Transmit, gBuff, 2);//发送FIFO缓存地址
  620: 	if(temp == TRUE)
001471 EF                MOV      A,R7
001472 B40103            CJNE     A,#01H,?C0133?MIFARE
  621: 		return FM1702_OK;
001475 7F00              MOV      R7,#00H
001477 22                RET      
001478         ?C0133?MIFARE:
  622: 	else
  623: 	{
  624: 		temp = SPIReadOne(ErrorFlag_Reg);
001478 120FC3            LCALL    ?L?COM002E
00147B 30E103            JNB      ACC.1,?C0136?MIFARE
  625: 		if((temp & 0x02) == 0x02)
  626: 		{
  627: 			return(FM1702_PARITYERR);
00147E 7F05              MOV      R7,#05H
001480 22                RET      
  628: 		}
001481         ?C0136?MIFARE:
  629: 
  630: 		if((temp & 0x04) == 0x04)
001481 EF                MOV      A,R7
001482 7F01              MOV      R7,#01H
001484 30E202            JNB      ACC.2,?C0137?MIFARE
  631: 		{
  632: 			return(FM1702_FRAMINGERR);
001487 7F14              MOV      R7,#014H
  633: 		}
001489         ?C0137?MIFARE:
  634: 		return(FM1702_NOTAGERR);
  635: 	}
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 58


  636: }
001489 22                RET      
----- FUNCTION MIF_Halt (END) -------


----- FUNCTION _Request (BEGIN) -----
 FILE: 'Driver\mifare.c'
  152: uchar Request(uchar mode)
  153: {
;---- Variable 'mode' assigned to Register 'R4' ----
00148A AC07              MOV      R4,AR7
  154: 	
  155: 	uchar temp;
  156: 	
  157: 	//选择TX1、TX2的发射天线阻抗
  158: 	SPIWriteOne(CwConductance_Reg,0x3f);
00148C D119              ACALL    ?L?COM0059
  159: 	//选择数据校验种类和模式
  160: 	SPIWriteOne(ChannelRedundancy_Reg,0x03);
00148E 7D03              MOV      R5,#03H
001490 7F22              MOV      R7,#022H
001492 1206BE            LCALL    _SPIWriteOne
  161: 	//调整面向bit的格式
  162: 	SPIWriteOne(BitFraming_Reg,0x07);
001495 7D07              MOV      R5,#07H
001497 7F0F              MOV      R7,#0FH
001499 B161              ACALL    ?L?COM0022
00149B EC                MOV      A,R4
00149C F0                MOVX     @DPTR,A
  163: 	gBuff[0] = mode;		//Request模式选择 
  164: 	temp = SPIReadOne(Control_Reg);
00149D 7F09              MOV      R7,#09H
00149F 1206F4            LCALL    _SPIReadOne
;---- Variable 'temp' assigned to Register 'R7' ----
  165: 	temp = temp & (0xf7);	
0014A2 EF                MOV      A,R7
0014A3 54F7              ANL      A,#0F7H
  166: 	SPIWriteOne(Control_Reg,temp);			//Control reset value is 00
0014A5 FD                MOV      R5,A
0014A6 7F09              MOV      R7,#09H
0014A8 1206BE            LCALL    _SPIWriteOne
  167: 	temp = Command_Send(Transceive, gBuff,1 );   //发送接收命令 
0014AB 120B2D            LCALL    ?L?COM0011
0014AE 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
0014B1 7401              MOV      A,#01H
0014B3 91ED              ACALL    ?L?COM0025
0014B5 7003              JNZ      ?C0030?MIFARE
  168: 	if(temp==0 )
  169: 	{
  170: 		return FM1702_NOTAGERR;
0014B7 7F01              MOV      R7,#01H
0014B9 22                RET      
  171: 	}
0014BA         ?C0030?MIFARE:
  172: 
  173: 	temp=Read_FIFO(gBuff);		//从FIFO中读取应答信息到gBuff中 
0014BA 120B2D            LCALL    ?L?COM0011
0014BD B1E5              ACALL    _Read_FIFO
  174: 	// 判断应答信号是否正确 
  175: 	// 2  	Mifare Pro 卡
  176: 	//4 		Mifare One 卡
  177: 	if((gBuff[0] == 0x04) & (gBuff[1] == 0x0) &(temp == 2))
0014BF 9000BA            MOV      DPTR,#gBuff+01H
0014C2 E0                MOVX     A,@DPTR
0014C3 7E00              MOV      R6,#00H
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 59


0014C5 7002              JNZ      ?C0033?MIFARE
0014C7 7E01              MOV      R6,#01H
0014C9         ?C0033?MIFARE:
0014C9         ?C0034?MIFARE:
0014C9 9000B9            MOV      DPTR,#gBuff
0014CC E0                MOVX     A,@DPTR
0014CD 7D00              MOV      R5,#00H
0014CF B40402            CJNE     A,#04H,?C0035?MIFARE
0014D2 7D01              MOV      R5,#01H
0014D4         ?C0035?MIFARE:
0014D4         ?C0036?MIFARE:
0014D4 ED                MOV      A,R5
0014D5 5E                ANL      A,R6
0014D6 FE                MOV      R6,A
0014D7 EF                MOV      A,R7
0014D8 7F00              MOV      R7,#00H
0014DA B40202            CJNE     A,#02H,?C0037?MIFARE
0014DD 7F01              MOV      R7,#01H
0014DF         ?C0037?MIFARE:
0014DF         ?C0038?MIFARE:
0014DF EF                MOV      A,R7
0014E0 5E                ANL      A,R6
0014E1 7F15              MOV      R7,#015H
0014E3 6002              JZ       ?C0032?MIFARE
  178: 	{
  179: 			return FM1702_OK;
0014E5 7F00              MOV      R7,#00H
  180: 	}
0014E7         ?C0032?MIFARE:
  181: 	return FM1702_REQERR;
  182: }
0014E7 22                RET      
----- FUNCTION _Request (END) -------


----- FUNCTION ?L?COM0024 (BEGIN) -----
0014E8 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
0014EB 7402              MOV      A,#02H
0014ED         ?L?COM0025:
0014ED F0                MOVX     @DPTR,A
0014EE 7F1E              MOV      R7,#01EH
0014F0 120794            LCALL    _Command_Send
0014F3 EF                MOV      A,R7
0014F4 22                RET      
----- FUNCTION ?L?COM0024 (END) -------


----- FUNCTION SelectCard (BEGIN) -----
 FILE: 'Driver\mifare.c'
  335: uchar SelectCard(void)
  336: {
  337: 	
  338: 	uchar	temp, i;
  339: 	
  340: 	//选择TX1、TX2的发射天线阻抗
  341: 	SPIWriteOne(CwConductance_Reg,0x3f);
0014F5 D119              ACALL    ?L?COM0059
  342: 	//选择数据校验种类和模式
  343: 	SPIWriteOne(ChannelRedundancy_Reg,0x0F);
0014F7 7D0F              MOV      R5,#0FH
0014F9 B15F              ACALL    ?L?COM0021
0014FB 7493              MOV      A,#093H
0014FD F0                MOVX     @DPTR,A
  344: 
  345: 	gBuff[0] = RF_CMD_SELECT;
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 60


  346: 	gBuff[1] = 0x70;
0014FE A3                INC      DPTR
0014FF 7470              MOV      A,#070H
001501 F0                MOVX     @DPTR,A
  347: 	for(i = 0; i < 5; i++)
;---- Variable 'i' assigned to Register 'R7' ----
001502 E4                CLR      A
001503 FF                MOV      R7,A
001504         ?C0077?MIFARE:
  348: 	{
  349: 		gBuff[i + 2] = gCard_UID[i];
001504 74B4              MOV      A,#LOW gCard_UID
001506 2F                ADD      A,R7
001507 121B5E            LCALL    ?L?COM005A
00150A E0                MOVX     A,@DPTR
00150B D129              ACALL    ?L?COM002F
00150D B405F4            CJNE     A,#05H,?C0077?MIFARE
001510         ?C0078?MIFARE:
  350: 	}
  351: 	temp = Command_Send(Transceive, gBuff,7 );
001510 120B2D            LCALL    ?L?COM0011
001513 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
001516 7407              MOV      A,#07H
;---- Variable 'temp' assigned to Register 'R7' ----
001518 91ED              ACALL    ?L?COM0025
00151A 7003              JNZ      ?C0080?MIFARE
  352: 	if(temp==0 )
  353: 	{
  354: 		return(FM1702_NOTAGERR);
00151C 7F01              MOV      R7,#01H
00151E 22                RET      
  355: 	}
00151F         ?C0080?MIFARE:
  356: 	else
  357: 	{
  358: 		temp = SPIReadOne(ErrorFlag_Reg);
00151F 120FC3            LCALL    ?L?COM002E
001522 30E103            JNB      ACC.1,?C0083?MIFARE
001525 7F05              MOV      R7,#05H
001527 22                RET      
001528         ?C0083?MIFARE:
  359: 		if((temp & 0x02) == 0x02) return(FM1702_PARITYERR);
  360: 		if((temp & 0x04) == 0x04) return(FM1702_FRAMINGERR);
001528 EF                MOV      A,R7
001529 30E203            JNB      ACC.2,?C0084?MIFARE
00152C 7F14              MOV      R7,#014H
00152E 22                RET      
00152F         ?C0084?MIFARE:
  361: 		if((temp & 0x08) == 0x08) return(FM1702_CRCERR);
00152F EF                MOV      A,R7
001530 30E303            JNB      ACC.3,?C0085?MIFARE
001533 7F02              MOV      R7,#02H
001535 22                RET      
001536         ?C0085?MIFARE:
  362: 		temp = SPIReadOne(FIFOLength_Reg);
001536 7F04              MOV      R7,#04H
001538 1206F4            LCALL    _SPIReadOne
  363: 		if(temp != 1) return(FM1702_BYTECOUNTERR);
00153B EF                MOV      A,R7
00153C 6401              XRL      A,#01H
00153E 6003              JZ       ?C0086?MIFARE
001540 7F0C              MOV      R7,#0CH
001542 22                RET      
001543         ?C0086?MIFARE:
  364: //		SPIRead(FIFO_Reg,gBuff,temp);	//从FIFO中读取应答信息
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 61


  365: 		gBuff[0] = SPIReadOne(FIFO_Reg);
001543 7F02              MOV      R7,#02H
001545 1206F4            LCALL    _SPIReadOne
001548 9000B9            MOV      DPTR,#gBuff
00154B EF                MOV      A,R7
00154C F0                MOVX     @DPTR,A
  366: 		if(gBuff[0]==0x08) 	  	// 判断应答信号是否正确 
00154D BF0803            CJNE     R7,#08H,?C0087?MIFARE
  367: 			return(FM1702_OK);
001550 7F00              MOV      R7,#00H
001552 22                RET      
001553         ?C0087?MIFARE:
  368: 		else
  369: 			return(FM1702_SELERR);
001553 7F16              MOV      R7,#016H
  370: 	}
  371: }
001555 22                RET      
----- FUNCTION SelectCard (END) -------


----- FUNCTION ?L?COM0020 (BEGIN) -----
001556 7D3F              MOV      R5,#03FH
001558 7F12              MOV      R7,#012H
00155A 1206BE            LCALL    _SPIWriteOne
00155D 7D03              MOV      R5,#03H
00155F         ?L?COM0021:
00155F 7F22              MOV      R7,#022H
001561         ?L?COM0022:
001561 1206BE            LCALL    _SPIWriteOne
001564 9000B9            MOV      DPTR,#gBuff
001567 22                RET      
----- FUNCTION ?L?COM0020 (END) -------


----- FUNCTION _Write_Block (BEGIN) -----
 FILE: 'Driver\mifare.c'
  566: uchar Write_Block(uchar *buff,uchar index)
  567: {
001568 120DF7            LCALL    ?L?COM0003
;---- Variable 'index' assigned to Register 'R4' ----
00156B AC05              MOV      R4,AR5
  568:     uchar ucCmdLine[2],ucResult,ucData[16];
  569:     SPIWriteOne(ChannelRedundancy_Reg,0x07);   /* Note: this line is for 1702, different from RC500*/
00156D 7D07              MOV      R5,#07H
00156F 7F22              MOV      R7,#022H
001571 1206BE            LCALL    _SPIWriteOne
  570:     ucCmdLine[0] = RF_CMD_WRITE;
001574 A3                INC      DPTR
001575 74A0              MOV      A,#0A0H
001577 F0                MOVX     @DPTR,A
  571:     ucCmdLine[1] = index;
001578 A3                INC      DPTR
001579 EC                MOV      A,R4
00157A F0                MOVX     @DPTR,A
  572:     ucResult = Command_Send(Transceive,ucCmdLine,2);
00157B 7B01              MOV      R3,#01H
00157D 7A00              MOV      R2,#HIGH ucCmdLine
00157F 7982              MOV      R1,#LOW ucCmdLine
;---- Variable 'ucResult' assigned to Register 'R7' ----
001581 91E8              ACALL    ?L?COM0024
001583 7003              JNZ      ?C0115?MIFARE
  573:     if(ucResult == FALSE)
  574:         return FM1702_NOTAGERR;
001585 7F01              MOV      R7,#01H
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 62


001587 22                RET      
001588         ?C0115?MIFARE:
  575:     ucResult = Read_FIFO(ucData);
001588 7B01              MOV      R3,#01H
00158A 7A00              MOV      R2,#HIGH ucData
00158C 7984              MOV      R1,#LOW ucData
00158E B1E5              ACALL    _Read_FIFO
  576:     if(ucResult == 0)
001590 EF                MOV      A,R7
001591 7003              JNZ      ?C0117?MIFARE
  577:         return FM1702_BYTECOUNTERR;
001593 7F0C              MOV      R7,#0CH
001595 22                RET      
001596         ?C0117?MIFARE:
  578:     switch(ucData[0])
001596 900084            MOV      DPTR,#ucData
001599 E0                MOVX     A,@DPTR
00159A 14                DEC      A
00159B 6015              JZ       ?C0122?MIFARE
00159D 24FD              ADD      A,#0FDH
00159F 600E              JZ       ?C0120?MIFARE
0015A1 14                DEC      A
0015A2 6011              JZ       ?C0123?MIFARE
0015A4 24FB              ADD      A,#0FBH
0015A6 6013              JZ       ?C0118?MIFARE
0015A8 240A              ADD      A,#0AH
0015AA 700C              JNZ      ?C0124?MIFARE
  579:     {
  580: 	    case 0x00:	return(FM1702_NOTAUTHERR);	
0015AC         ?C0119?MIFARE:
0015AC 7F0A              MOV      R7,#0AH
0015AE 22                RET      
  581: 	    case 0x04:	return(FM1702_EMPTY);
0015AF         ?C0120?MIFARE:
0015AF 7F03              MOV      R7,#03H
0015B1 22                RET      
  582: 	    case 0x0a:	break;                   //正常
  583: 	    case 0x01:	return(FM1702_CRCERR);
0015B2         ?C0122?MIFARE:
0015B2 7F02              MOV      R7,#02H
0015B4 22                RET      
  584: 	    case 0x05:	return(FM1702_PARITYERR); 
0015B5         ?C0123?MIFARE:
0015B5 7F05              MOV      R7,#05H
0015B7 22                RET      
  585: 	    default:	return(FM1702_WRITEERR);
0015B8         ?C0124?MIFARE:
0015B8 7F0F              MOV      R7,#0FH
0015BA 22                RET      
  586:     }
0015BB         ?C0118?MIFARE:
  587:     ucResult = Command_Send(Transceive,buff,16);
0015BB 120CD7            LCALL    ?L?COM0001
0015BE F9                MOV      R1,A
0015BF 900098            MOV      DPTR,#?_Command_Send?BYTE+04H
0015C2 7410              MOV      A,#010H
0015C4 91ED              ACALL    ?L?COM0025
0015C6 B40103            CJNE     A,#01H,?C0125?MIFARE
  588:     if(ucResult == TRUE)
  589:         return FM1702_OK;
0015C9 7F00              MOV      R7,#00H
0015CB 22                RET      
0015CC         ?C0125?MIFARE:
  590:     else
  591:     {
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 63


  592:         ucResult = SPIReadOne(ErrorFlag_Reg);
0015CC 120FC3            LCALL    ?L?COM002E
0015CF 30E103            JNB      ACC.1,?C0127?MIFARE
0015D2 7F05              MOV      R7,#05H
0015D4 22                RET      
0015D5         ?C0127?MIFARE:
  593: 	    if((ucResult & 0x02) == 0x02) return FM1702_PARITYERR;
  594: 	    else if((ucResult & 0x04) == 0x04) return FM1702_FRAMINGERR;
0015D5 EF                MOV      A,R7
0015D6 30E203            JNB      ACC.2,?C0129?MIFARE
0015D9 7F14              MOV      R7,#014H
0015DB 22                RET      
0015DC         ?C0129?MIFARE:
  595: 	    else if((ucResult & 0x08) == 0x08) return FM1702_CRCERR;
0015DC EF                MOV      A,R7
0015DD 7F0F              MOV      R7,#0FH
0015DF 30E302            JNB      ACC.3,?C0131?MIFARE
0015E2 7F02              MOV      R7,#02H
0015E4         ?C0131?MIFARE:
  596:         else return FM1702_WRITEERR;
  597:     }
  598: }
0015E4 22                RET      
----- FUNCTION _Write_Block (END) -------


----- FUNCTION _Read_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  228: uchar Read_FIFO(uchar *buff)
  229: {
0015E5 900094            MOV      DPTR,#buff
0015E8 120DFA            LCALL    ?L?COM0004
  230: 	uchar	ucResult,i;
  231: 	ucResult = SPIReadOne(FIFOLength_Reg);
;---- Variable 'ucResult' assigned to Register 'R5' ----
0015EB D120              ACALL    ?L?COM0046
0015ED 6005              JZ       ?C0050?MIFARE
0015EF D3                SETB     C
0015F0 9410              SUBB     A,#010H
0015F2 4003              JC       ?C0049?MIFARE
0015F4         ?C0050?MIFARE:
  232: 	if(ucResult == 0 || ucResult>16)
  233: 		return 0;
0015F4 7F00              MOV      R7,#00H
0015F6 22                RET      
0015F7         ?C0049?MIFARE:
  234: 	for(i=0;i<ucResult;i++)
;---- Variable 'i' assigned to Register 'R4' ----
0015F7 E4                CLR      A
0015F8 FC                MOV      R4,A
0015F9         ?C0052?MIFARE:
0015F9 EC                MOV      A,R4
0015FA C3                CLR      C
0015FB 9D                SUBB     A,R5
0015FC 5018              JNC      ?C0053?MIFARE
  235: 	{
  236: 		buff[i] = SPIReadOne(FIFO_Reg);
0015FE 7F02              MOV      R7,#02H
001600 1206F4            LCALL    _SPIReadOne
001603 900094            MOV      DPTR,#buff
001606 120CDA            LCALL    ?L?COM0002
001609 F9                MOV      R1,A
00160A 8C82              MOV      DPL,R4
00160C 758300            MOV      DPH,#00H
00160F EF                MOV      A,R7
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 64


001610 120174            LCALL    ?C?CSTOPTR
  237: 	}
001613 0C                INC      R4
001614 80E3              SJMP     ?C0052?MIFARE
001616         ?C0053?MIFARE:
  238: 
  239: 	return ucResult;
001616 AF05              MOV      R7,AR5
  240: }
001618 22                RET      
----- FUNCTION _Read_FIFO (END) -------


----- FUNCTION ?L?COM0059 (BEGIN) -----
001619 7D3F              MOV      R5,#03FH
00161B 7F12              MOV      R7,#012H
00161D 0206BE            LJMP     _SPIWriteOne
----- FUNCTION ?L?COM0059 (END) -------


----- FUNCTION ?L?COM0046 (BEGIN) -----
001620 7F04              MOV      R7,#04H
001622         ?L?COM0047:
001622 1206F4            LCALL    _SPIReadOne
001625 AD07              MOV      R5,AR7
001627 ED                MOV      A,R5
001628 22                RET      
----- FUNCTION ?L?COM0046 (END) -------


----- FUNCTION ?L?COM002F (BEGIN) -----
001629 FE                MOV      R6,A
00162A 74BB              MOV      A,#LOW gBuff+02H
00162C 2F                ADD      A,R7
00162D F582              MOV      DPL,A
00162F E4                CLR      A
001630 3400              ADDC     A,#HIGH gBuff+02H
001632         ?L?COM0030:
001632 F583              MOV      DPH,A
001634 EE                MOV      A,R6
001635 F0                MOVX     @DPTR,A
001636 0F                INC      R7
001637 EF                MOV      A,R7
001638 22                RET      
----- FUNCTION ?L?COM002F (END) -------


----- FUNCTION ?L?COM0042 (BEGIN) -----
001639 A3                INC      DPTR
00163A EC                MOV      A,R4
00163B F0                MOVX     @DPTR,A
00163C A3                INC      DPTR
00163D ED                MOV      A,R5
00163E F0                MOVX     @DPTR,A
00163F 22                RET      
----- FUNCTION ?L?COM0042 (END) -------


----- FUNCTION _hwa_eepromDecrypt (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom_cfg.c'
   51: void hwa_eepromDecrypt(UINT8 *dat, UINT16 size)        //解密
   52: {
001640 90008F            MOV      DPTR,#dat
001643 120DFA            LCALL    ?L?COM0004
001646 D139              ACALL    ?L?COM0042
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 65


   53: 	UINT16 i;
   54: 	UINT8 tmp;
   55: 	for (i = 0; i<size; i++)
;---- Variable 'i' assigned to Register 'R6/R7' ----
001648 E4                CLR      A
001649 FF                MOV      R7,A
00164A FE                MOV      R6,A
00164B         ?C0005?HWA_EEPROM_CFG:
00164B D3                SETB     C
00164C 900093            MOV      DPTR,#size+01H
00164F E0                MOVX     A,@DPTR
001650 9F                SUBB     A,R7
001651 900092            MOV      DPTR,#size
001654 E0                MOVX     A,@DPTR
001655 9E                SUBB     A,R6
001656 401C              JC       ?C0008?HWA_EEPROM_CFG
   56: 	{
   57: 		tmp = dat[i];
001658 90008F            MOV      DPTR,#dat
00165B 120CDA            LCALL    ?L?COM0002
;---- Variable 'tmp' assigned to Register 'R5' ----
00165E 121B11            LCALL    ?L?COM0045
   58: 		tmp ^= SecretKey;
   59: 		tmp = (tmp << 1) | (tmp >> 7);
001661 25E0              ADD      A,ACC
001663 FC                MOV      R4,A
001664 ED                MOV      A,R5
001665 C4                SWAP     A
001666 13                RRC      A
001667 13                RRC      A
001668 13                RRC      A
001669 5401              ANL      A,#01H
00166B 121B04            LCALL    ?L?COM0044
00166E BF0001            CJNE     R7,#00H,?C0010?HWA_EEPROM_CFG
001671 0E                INC      R6
001672         ?C0010?HWA_EEPROM_CFG:
001672 80D7              SJMP     ?C0005?HWA_EEPROM_CFG
   60: 		tmp ^= SecretKey;
   61: 		dat[i] = tmp;
   62: 	}
   63: }
001674         ?C0008?HWA_EEPROM_CFG:
001674 22                RET      
----- FUNCTION _hwa_eepromDecrypt (END) -------


----- FUNCTION _hwa_eepromReadSector (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
   33: BOOL hwa_eepromReadSector(UINT8 *dat, UINT8 sector)
   34: {
001675 120DF7            LCALL    ?L?COM0003
001678 A3                INC      DPTR
001679 ED                MOV      A,R5
00167A F0                MOVX     @DPTR,A
   35:     BOOL e2_error = FALSE, e2_bak_error = FALSE;
   36:     UINT16 e2_addr, e2_bak_addr;
00167B C202              CLR      e2_error
00167D C203              CLR      e2_bak_error
   37:     UINT16 e2_check_sum, e2_bak_check_sum;
   38:     UINT16 Size, SectorSize;
   39: 
   40:     if(sector >= c_u8_eepromSectorNum)
00167F 121B55            LCALL    ?L?COM0056
001682 9F                SUBB     A,R7
001683 4001              JC       ?C0010?HWA_EEPROM
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 66


   41:     {
   42:     	return FALSE;
001685 22                RET      
   43:     }
001686         ?C0010?HWA_EEPROM:
   44: 	Size = c_s_eepromConfig[sector].UseSize;
001686 900082            MOV      DPTR,#sector
001689 121AC6            LCALL    ?L?COM002D
00168C 7401              MOV      A,#01H
00168E 93                MOVC     A,@A+DPTR
00168F FD                MOV      R5,A
001690 90008B            MOV      DPTR,#Size
001693 121A3F            LCALL    ?L?COM0009
001696 900083            MOV      DPTR,#e2_addr
001699 121B66            LCALL    ?L?COM0061
00169C 121A66            LCALL    ?L?COM000A
00169F 900085            MOV      DPTR,#e2_bak_addr
0016A2 F0                MOVX     @DPTR,A
0016A3 A3                INC      DPTR
0016A4 CE                XCH      A,R6
0016A5 F0                MOVX     @DPTR,A
   45:     SectorSize = Size+2;
   46:     
   47:     e2_addr = c_u16_eepromSectorAddr + c_u16_eepromSectorSize * sector;
   48:     e2_bak_addr = c_u16_eepromSectorBakAddr + c_u16_eepromSectorSize * sector;
   49: 
   50:     sys_eepromRead(e2_addr, e2_data, SectorSize);
0016A6 121B29            LCALL    ?L?COM004E
0016A9 F1AB              ACALL    ?L?COM0017
0016AB 90008D            MOV      DPTR,#SectorSize
0016AE F1DE              ACALL    ?L?COM000E
0016B0 1218BC            LCALL    ?L?COM0012
0016B3 6006              JZ       ?C0012?HWA_EEPROM
   51: 	if (c_s_eepromConfig[sector].Encrypt)
   52: 	{
   53: 		hwa_eepromDecrypt(e2_data, Size);
0016B5 F1AB              ACALL    ?L?COM0017
0016B7 F1B8              ACALL    ?L?COM0019
0016B9 D140              ACALL    _hwa_eepromDecrypt
   54: 	}
0016BB         ?C0012?HWA_EEPROM:
   55:     e2_check_sum = e2_data[Size] << 8 | e2_data[Size + 1];
0016BB F1B8              ACALL    ?L?COM0019
0016BD 2400              ADD      A,#LOW e2_data
0016BF F582              MOV      DPL,A
0016C1 7400              MOV      A,#HIGH e2_data
0016C3 3C                ADDC     A,R4
0016C4 F583              MOV      DPH,A
0016C6 E0                MOVX     A,@DPTR
0016C7 FE                MOV      R6,A
0016C8 7401              MOV      A,#LOW e2_data+01H
0016CA 2D                ADD      A,R5
0016CB F582              MOV      DPL,A
0016CD 7400              MOV      A,#HIGH e2_data+01H
0016CF F1EB              ACALL    ?L?COM0062
0016D1 900087            MOV      DPTR,#e2_check_sum
0016D4 EE                MOV      A,R6
0016D5 F0                MOVX     @DPTR,A
0016D6 A3                INC      DPTR
0016D7 EF                MOV      A,R7
0016D8 F0                MOVX     @DPTR,A
   56: 
   57: 	sys_eepromRead(e2_bak_addr, e2_data_bak, SectorSize);
0016D9 F1C1              ACALL    ?L?COM0036
0016DB 90008D            MOV      DPTR,#SectorSize
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 67


0016DE F1DE              ACALL    ?L?COM000E
0016E0 1218BC            LCALL    ?L?COM0012
0016E3 6004              JZ       ?C0013?HWA_EEPROM
   58: 	if (c_s_eepromConfig[sector].Encrypt)
   59: 	{
   60: 		hwa_eepromDecrypt(e2_data_bak, Size);
0016E5 F1B2              ACALL    ?L?COM0018
0016E7 D140              ACALL    _hwa_eepromDecrypt
   61: 	}
0016E9         ?C0013?HWA_EEPROM:
   62:     e2_bak_check_sum = e2_data_bak[Size] << 8 | e2_data_bak[Size + 1];
0016E9 F1B8              ACALL    ?L?COM0019
0016EB 2420              ADD      A,#LOW e2_data_bak
0016ED F582              MOV      DPL,A
0016EF 7400              MOV      A,#HIGH e2_data_bak
0016F1 3C                ADDC     A,R4
0016F2 F583              MOV      DPH,A
0016F4 E0                MOVX     A,@DPTR
0016F5 FE                MOV      R6,A
0016F6 7421              MOV      A,#LOW e2_data_bak+01H
0016F8 2D                ADD      A,R5
0016F9 F582              MOV      DPL,A
0016FB 7400              MOV      A,#HIGH e2_data_bak+01H
0016FD F1EB              ACALL    ?L?COM0062
0016FF 900089            MOV      DPTR,#e2_bak_check_sum
001702 F1A6              ACALL    ?L?COM0016
001704 A3                INC      DPTR
001705 A3                INC      DPTR
001706 E0                MOVX     A,@DPTR
001707 FD                MOV      R5,A
001708 1218D3            LCALL    _hwa_eepromCheck
00170B 900087            MOV      DPTR,#e2_check_sum
00170E E0                MOVX     A,@DPTR
00170F 6E                XRL      A,R6
001710 7003              JNZ      ?C0025?HWA_EEPROM
001712 A3                INC      DPTR
001713 E0                MOVX     A,@DPTR
001714 6F                XRL      A,R7
001715         ?C0025?HWA_EEPROM:
001715 6002              JZ       ?C0014?HWA_EEPROM
   63: 
   64:     if(e2_check_sum != hwa_eepromCheck(e2_data, Size))
   65:     {
   66:         e2_error = TRUE;
001717 D202              SETB     e2_error
   67:     }
001719         ?C0014?HWA_EEPROM:
   68:     if(e2_bak_check_sum != hwa_eepromCheck(e2_data_bak, Size))
001719 F1B2              ACALL    ?L?COM0018
00171B 1218D3            LCALL    _hwa_eepromCheck
00171E 900089            MOV      DPTR,#e2_bak_check_sum
001721 E0                MOVX     A,@DPTR
001722 6E                XRL      A,R6
001723 7003              JNZ      ?C0026?HWA_EEPROM
001725 A3                INC      DPTR
001726 E0                MOVX     A,@DPTR
001727 6F                XRL      A,R7
001728         ?C0026?HWA_EEPROM:
001728 6002              JZ       ?C0015?HWA_EEPROM
   69:     {
   70:         e2_bak_error = TRUE;
00172A D203              SETB     e2_bak_error
   71:     }
00172C         ?C0015?HWA_EEPROM:
   72: 
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 68


   73:     if(e2_error && e2_bak_error)    //~1~备份块和正常块都校验错误，返回错误
00172C 300205            JNB      e2_error,?C0016?HWA_EEPROM
00172F 300302            JNB      e2_bak_error,?C0016?HWA_EEPROM
   74:     {
   75:         return FALSE;
001732 C3                CLR      C
001733 22                RET      
   76:     }
001734         ?C0016?HWA_EEPROM:
   77:     else if(e2_error)                                 //~2~备份块校验错误，恢复正常块
001734 300218            JNB      e2_error,?C0018?HWA_EEPROM
   78:     {
   79:         memcpy(e2_data, e2_data_bak, SectorSize);
001737 90008D            MOV      DPTR,#SectorSize
00173A 121B1D            LCALL    ?L?COM0049
00173D F1C9              ACALL    ?L?COM0037
00173F 1200F6            LCALL    ?C?COPY
   80: 		sys_eepromEraseSector(e2_addr);
001742 900083            MOV      DPTR,#e2_addr
001745 12183F            LCALL    ?L?COM0031
   81:         sys_eepromWrite(e2_addr, e2_data, SectorSize);
001748 121B29            LCALL    ?L?COM004E
00174B F1AB              ACALL    ?L?COM0017
   82:     }
00174D 8038              SJMP     ?C0028?HWA_EEPROM
00174F         ?C0018?HWA_EEPROM:
   83:     else if(e2_bak_error ||                          //~3~正常块校验错误，恢复备份块
00174F 20031A            JB       e2_bak_error,?C0021?HWA_EEPROM
001752 20023A            JB       e2_error,?C0017?HWA_EEPROM
001755 200337            JB       e2_bak_error,?C0017?HWA_EEPROM
001758 900089            MOV      DPTR,#e2_bak_check_sum
00175B E0                MOVX     A,@DPTR
00175C FE                MOV      R6,A
00175D A3                INC      DPTR
00175E E0                MOVX     A,@DPTR
00175F FF                MOV      R7,A
001760 900087            MOV      DPTR,#e2_check_sum
001763 E0                MOVX     A,@DPTR
001764 6E                XRL      A,R6
001765 7003              JNZ      ?C0027?HWA_EEPROM
001767 A3                INC      DPTR
001768 E0                MOVX     A,@DPTR
001769 6F                XRL      A,R7
00176A         ?C0027?HWA_EEPROM:
00176A 6023              JZ       ?C0017?HWA_EEPROM
00176C         ?C0021?HWA_EEPROM:
   84:             (e2_error == FALSE                                //~4~正常块、备份块都检验正确，但数据不同，则以
   85:              && e2_bak_error == FALSE                         //   最新写入的正常块覆盖备份块
   86:              && e2_check_sum != e2_bak_check_sum)
   87:     )
   88:     {
   89:         memcpy(e2_data_bak, e2_data, SectorSize);
00176C 90008D            MOV      DPTR,#SectorSize
00176F E0                MOVX     A,@DPTR
001770 FE                MOV      R6,A
001771 A3                INC      DPTR
001772 E0                MOVX     A,@DPTR
001773 FF                MOV      R7,A
001774 7820              MOV      R0,#LOW e2_data_bak
001776 7C00              MOV      R4,#HIGH e2_data_bak
001778 7D01              MOV      R5,#01H
00177A F1AB              ACALL    ?L?COM0017
00177C 1200F6            LCALL    ?C?COPY
   90: 		sys_eepromEraseSector(e2_bak_addr);
00177F 900085            MOV      DPTR,#e2_bak_addr
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 69


001782 12183F            LCALL    ?L?COM0031
   91:         sys_eepromWrite(e2_bak_addr, e2_data_bak, SectorSize);
001785 F1C1              ACALL    ?L?COM0036
001787         
001787 90008D            MOV      DPTR,#SectorSize
00178A F1DE              ACALL    ?L?COM000E
00178C 121852            LCALL    _sys_eepromWrite
   92:     }
00178F         ?C0017?HWA_EEPROM:
   93:     memcpy(dat, e2_data, Size);
00178F 90008B            MOV      DPTR,#Size
001792 E0                MOVX     A,@DPTR
001793 FE                MOV      R6,A
001794 A3                INC      DPTR
001795 E0                MOVX     A,@DPTR
001796 FF                MOV      R7,A
001797 120CD7            LCALL    ?L?COM0001
00179A F8                MOV      R0,A
00179B AC02              MOV      R4,AR2
00179D AD03              MOV      R5,AR3
00179F F1AB              ACALL    ?L?COM0017
0017A1 1200F6            LCALL    ?C?COPY
   94:     return TRUE;
0017A4 D3                SETB     C
   95: }
0017A5 22                RET      
----- FUNCTION _hwa_eepromReadSector (END) -------


----- FUNCTION ?L?COM0016 (BEGIN) -----
0017A6 EE                MOV      A,R6
0017A7 F0                MOVX     @DPTR,A
0017A8 A3                INC      DPTR
0017A9 EF                MOV      A,R7
0017AA F0                MOVX     @DPTR,A
0017AB         ?L?COM0017:
0017AB 7B01              MOV      R3,#01H
0017AD 7A00              MOV      R2,#HIGH e2_data
0017AF 7900              MOV      R1,#LOW e2_data
0017B1 22                RET      
----- FUNCTION ?L?COM0016 (END) -------


----- FUNCTION ?L?COM0018 (BEGIN) -----
0017B2 7B01              MOV      R3,#01H
0017B4 7A00              MOV      R2,#HIGH e2_data_bak
0017B6 7920              MOV      R1,#LOW e2_data_bak
0017B8         ?L?COM0019:
0017B8 90008B            MOV      DPTR,#Size
0017BB E0                MOVX     A,@DPTR
0017BC FC                MOV      R4,A
0017BD A3                INC      DPTR
0017BE E0                MOVX     A,@DPTR
0017BF FD                MOV      R5,A
0017C0 22                RET      
----- FUNCTION ?L?COM0018 (END) -------


----- FUNCTION ?L?COM0036 (BEGIN) -----
0017C1 900085            MOV      DPTR,#e2_bak_addr
0017C4 E0                MOVX     A,@DPTR
0017C5 FE                MOV      R6,A
0017C6 A3                INC      DPTR
0017C7 E0                MOVX     A,@DPTR
0017C8 FF                MOV      R7,A
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 70


0017C9         ?L?COM0037:
0017C9 7B01              MOV      R3,#01H
0017CB 7A00              MOV      R2,#HIGH e2_data_bak
0017CD 7920              MOV      R1,#LOW e2_data_bak
0017CF 22                RET      
----- FUNCTION ?L?COM0036 (END) -------


----- FUNCTION ?L?COM000D (BEGIN) -----
0017D0 E0                MOVX     A,@DPTR
0017D1 FE                MOV      R6,A
0017D2 A3                INC      DPTR
0017D3 E0                MOVX     A,@DPTR
0017D4 FF                MOV      R7,A
0017D5 7B01              MOV      R3,#01H
0017D7 7A00              MOV      R2,#HIGH e2_data
0017D9 7900              MOV      R1,#LOW e2_data
0017DB 90007D            MOV      DPTR,#SectorSize
0017DE         ?L?COM000E:
0017DE E0                MOVX     A,@DPTR
0017DF FD                MOV      R5,A
0017E0 A3                INC      DPTR
0017E1 E0                MOVX     A,@DPTR
0017E2 900094            MOV      DPTR,#?_sys_eepromWrite?BYTE+05H
0017E5 CD                XCH      A,R5
0017E6 F0                MOVX     @DPTR,A
0017E7 A3                INC      DPTR
0017E8 ED                MOV      A,R5
0017E9 F0                MOVX     @DPTR,A
0017EA 22                RET      
----- FUNCTION ?L?COM000D (END) -------


----- FUNCTION ?L?COM0062 (BEGIN) -----
0017EB 3C                ADDC     A,R4
0017EC F583              MOV      DPH,A
0017EE E0                MOVX     A,@DPTR
0017EF FD                MOV      R5,A
0017F0 ED                MOV      A,R5
0017F1 FF                MOV      R7,A
0017F2 22                RET      
----- FUNCTION ?L?COM0062 (END) -------


----- FUNCTION sys_uartRxHandler (BEGIN) -----
 FILE: 'System\sys_uart.c'
  123: void sys_uartRxHandler(void)
  124: {
  125:     if(SBUF == 0x7F)        //0x7F auto download     boud 9600 0x7F at boud 2400 is 0xF8
  126:     {
0017F3 E599              MOV      A,SBUF
0017F5 B47F11            CJNE     A,#07FH,?C0017?SYS_UART
  127:         RxNum++;
  128:         if(RxNum >= 80)
0017F8 9000DA            MOV      DPTR,#RxNum
0017FB E0                MOVX     A,@DPTR
0017FC 04                INC      A
0017FD F0                MOVX     @DPTR,A
  129:         {
0017FE E0                MOVX     A,@DPTR
0017FF C3                CLR      C
001800 9450              SUBB     A,#050H
001802 400A              JC       ?C0019?SYS_UART
  130:             IAP_CONTR = 0x60;
  131:         }
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 71


001804 75C760            MOV      IAP_CONTR,#060H
  132:     }
  133:     else
001807 8005              SJMP     ?C0019?SYS_UART
001809         ?C0017?SYS_UART:
  134:     {
  135:         RxNum = 0;
001809 E4                CLR      A
00180A 9000DA            MOV      DPTR,#RxNum
00180D F0                MOVX     @DPTR,A
  136:     }
00180E         ?C0019?SYS_UART:
  137:     RxBuff[u8_RxIndex] = SBUF;
00180E 9000D7            MOV      DPTR,#u8_RxIndex
001811 E0                MOVX     A,@DPTR
001812 FF                MOV      R7,A
001813 24CD              ADD      A,#LOW RxBuff
001815 F582              MOV      DPL,A
001817 E4                CLR      A
001818 3400              ADDC     A,#HIGH RxBuff
00181A F583              MOV      DPH,A
00181C E599              MOV      A,SBUF
00181E F0                MOVX     @DPTR,A
  138:     u8_BoudOverTime = BOUD_OVER_TIME;
00181F 9000CC            MOV      DPTR,#u8_BoudOverTime
001822 7405              MOV      A,#05H
001824 F0                MOVX     @DPTR,A
  139:     if(u8_RxIndex <= MSG_LEN)
001825 EF                MOV      A,R7
001826 D3                SETB     C
001827 9408              SUBB     A,#08H
001829 5006              JNC      ?C0021?SYS_UART
  140:     {
  141:         u8_RxIndex++;
00182B 9000D7            MOV      DPTR,#u8_RxIndex
00182E E0                MOVX     A,@DPTR
00182F 04                INC      A
001830 F0                MOVX     @DPTR,A
  142:     }
  143: }
001831         ?C0021?SYS_UART:
001831 22                RET      
----- FUNCTION sys_uartRxHandler (END) -------


----- FUNCTION IapIdle (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   24: void IapIdle(void)
   25: {
   26:     IAP_CONTR = 0;                  //关闭IAP功能
   27:     IAP_CMD = 0;                    //清除命令寄存器
001832 E4                CLR      A
001833 F5C7              MOV      IAP_CONTR,A
   28:     IAP_TRIG = 0;                   //清除触发寄存器
001835 F5C5              MOV      IAP_CMD,A
   29:     IAP_ADDRH = 0x80;               //将地址设置到非IAP区域
001837 F5C6              MOV      IAP_TRIG,A
   30:     IAP_ADDRL = 0;
001839 75C380            MOV      IAP_ADDRH,#080H
   31: }
00183C F5C4              MOV      IAP_ADDRL,A
   32: 
00183E 22                RET      
----- FUNCTION IapIdle (END) -------

LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 72



----- FUNCTION ?L?COM0031 (BEGIN) -----
00183F E0                MOVX     A,@DPTR
001840 FE                MOV      R6,A
001841 A3                INC      DPTR
001842 E0                MOVX     A,@DPTR
001843 FF                MOV      R7,A
----- FUNCTION _sys_eepromEraseSector (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   72: void sys_eepromEraseSector(UINT16 addr)
   73: {
;---- Variable 'addr' assigned to Register 'R6/R7' ----
   74:     IAP_CONTR = ENABLE_IAP;         //使能IAP
   75:     IAP_CMD = CMD_ERASE;            //设置IAP命令
001844 75C780            MOV      IAP_CONTR,#080H
   76:     IAP_ADDRL = addr;               //设置IAP低地址
001847 75C503            MOV      IAP_CMD,#03H
   77:     IAP_ADDRH = addr >> 8;          //设置IAP高地址
00184A 8FC4              MOV      IAP_ADDRL,R7
   78:     IAP_TRIG = 0x5a;                //写触发命令(0x5a)
00184C EE                MOV      A,R6
00184D 1177              ACALL    ?L?COM004B
   79:     IAP_TRIG = 0xa5;                //写触发命令(0xa5)
   80:     _nop_();                        //等待ISP/IAP/EEPROM操作完成
00184F 00                NOP      
   81:     IapIdle();
001850 80E0              SJMP     IapIdle
----- FUNCTION _sys_eepromEraseSector (END) -------


----- FUNCTION _sys_eepromWrite (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
  100: void sys_eepromWrite(UINT16 addr, UINT8 *Data, UINT16 num)
  101: {
;---- Variable 'Data' assigned to Register 'R1/R2/R3' ----
;---- Variable 'addr' assigned to Register 'R4/R5' ----
001852 11A7              ACALL    ?L?COM0065
  102:     IAP_CONTR = ENABLE_IAP;
  103:     IAP_CMD = CMD_PROGRAM;
001854 75C502            MOV      IAP_CMD,#02H
001857         ?C0006?SYS_EEPROM:
  104:     while(num--)
001857 11AF              ACALL    ?L?COM0028
001859 601A              JZ       ?C0007?SYS_EEPROM
  105:     {
  106:         IAP_ADDRL = addr;
00185B 8DC4              MOV      IAP_ADDRL,R5
  107:         IAP_ADDRH = addr >> 8;
00185D EC                MOV      A,R4
00185E F5C3              MOV      IAP_ADDRH,A
  108:         IAP_DATA = *Data;
001860 12011C            LCALL    ?C?CLDPTR
001863 F5C2              MOV      IAP_DATA,A
  109:         IAP_TRIG = 0x5a;
001865 1179              ACALL    ?L?COM004C
  110:         IAP_TRIG = 0xa5;
  111:         addr++;
001867 0D                INC      R5
001868 BD0001            CJNE     R5,#00H,?C0010?SYS_EEPROM
00186B 0C                INC      R4
00186C         ?C0010?SYS_EEPROM:
  112:         Data++;
00186C 7401              MOV      A,#01H
00186E 29                ADD      A,R1
00186F F9                MOV      R1,A
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 73


001870 E4                CLR      A
001871 3A                ADDC     A,R2
001872 FA                MOV      R2,A
  113:     }
001873 80E2              SJMP     ?C0006?SYS_EEPROM
001875         ?C0007?SYS_EEPROM:
  114:     IapIdle();
001875 80BB              SJMP     IapIdle
----- FUNCTION _sys_eepromWrite (END) -------


----- FUNCTION ?L?COM004B (BEGIN) -----
001877 F5C3              MOV      IAP_ADDRH,A
001879         ?L?COM004C:
001879 75C65A            MOV      IAP_TRIG,#05AH
00187C 75C6A5            MOV      IAP_TRIG,#0A5H
00187F 22                RET      
----- FUNCTION ?L?COM004B (END) -------


----- FUNCTION _sys_eepromRead (BEGIN) -----
 FILE: 'System\sys_eeprom.c'
   84: void sys_eepromRead(UINT16 addr, UINT8 *Data, UINT16 num)
   85: {
001880 900091            MOV      DPTR,#Data
001883 120DFA            LCALL    ?L?COM0004
;---- Variable 'addr' assigned to Register 'R4/R5' ----
001886 11A7              ACALL    ?L?COM0065
   86:     IAP_CONTR = ENABLE_IAP;
   87:     IAP_CMD = CMD_READ;
001888 75C501            MOV      IAP_CMD,#01H
00188B         ?C0003?SYS_EEPROM:
   88:     while(num--)
00188B 11AF              ACALL    ?L?COM0028
00188D 6016              JZ       ?C0004?SYS_EEPROM
   89:     {
   90:         IAP_ADDRL = addr;
00188F 8DC4              MOV      IAP_ADDRL,R5
   91:         IAP_ADDRH = addr >> 8;
001891 EC                MOV      A,R4
001892 1177              ACALL    ?L?COM004B
   92:         IAP_TRIG = 0x5a;
   93:         IAP_TRIG = 0xa5;
   94:         addr++;
001894 0D                INC      R5
001895 BD0001            CJNE     R5,#00H,?C0009?SYS_EEPROM
001898 0C                INC      R4
001899         ?C0009?SYS_EEPROM:
   95:         *Data++ = IAP_DATA;
001899 900091            MOV      DPTR,#Data
00189C 3114              ACALL    ?L?COM002A
00189E E5C2              MOV      A,IAP_DATA
0018A0 120162            LCALL    ?C?CSTPTR
   96:     }
0018A3 80E6              SJMP     ?C0003?SYS_EEPROM
0018A5         ?C0004?SYS_EEPROM:
   97:     IapIdle();
0018A5 808B              SJMP     IapIdle
----- FUNCTION _sys_eepromRead (END) -------


----- FUNCTION ?L?COM0065 (BEGIN) -----
0018A7 AD07              MOV      R5,AR7
0018A9 AC06              MOV      R4,AR6
0018AB 75C780            MOV      IAP_CONTR,#080H
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 74


0018AE 22                RET      
----- FUNCTION ?L?COM0065 (END) -------


----- FUNCTION ?L?COM0028 (BEGIN) -----
0018AF 900094            MOV      DPTR,#num
0018B2         ?L?COM0029:
0018B2 74FF              MOV      A,#0FFH
0018B4 F5F0              MOV      B,A
0018B6 1201FD            LCALL    ?C?ILDIX
0018B9 45F0              ORL      A,B
0018BB 22                RET      
----- FUNCTION ?L?COM0028 (END) -------


----- FUNCTION ?L?COM0012 (BEGIN) -----
0018BC 1180              ACALL    _sys_eepromRead
0018BE 900082            MOV      DPTR,#sector
0018C1         ?L?COM0013:
0018C1 E0                MOVX     A,@DPTR
0018C2 75F003            MOV      B,#03H
0018C5 A4                MUL      AB
0018C6 244F              ADD      A,#LOW c_s_eepromConfig+02H
0018C8 F582              MOV      DPL,A
0018CA E5F0              MOV      A,B
0018CC 3406              ADDC     A,#HIGH c_s_eepromConfig+02H
0018CE F583              MOV      DPH,A
0018D0 E4                CLR      A
0018D1 93                MOVC     A,@A+DPTR
0018D2 22                RET      
----- FUNCTION ?L?COM0012 (END) -------


----- FUNCTION _hwa_eepromCheck (BEGIN) -----
 FILE: 'Hwa\hwa_eeprom.c'
    6: static UINT16 hwa_eepromCheck( UINT8 *dat, UINT16 len)
    7: {
0018D3 90008F            MOV      DPTR,#dat
0018D6 120DFA            LCALL    ?L?COM0004
0018D9 121639            LCALL    ?L?COM0042
    8:     UINT16 crc = 0xFFFF;
    9:     UINT8 i;
;---- Variable 'crc' assigned to Register 'R6/R7' ----
0018DC 74FF              MOV      A,#0FFH
0018DE FF                MOV      R7,A
0018DF FE                MOV      R6,A
0018E0         ?C0001?HWA_EEPROM:
   10:     while(len--)
0018E0 900092            MOV      DPTR,#len
0018E3 11B2              ACALL    ?L?COM0029
0018E5 602C              JZ       ?C0002?HWA_EEPROM
   11:     {
   12:         crc = crc ^*dat++;
0018E7 90008F            MOV      DPTR,#dat
0018EA 3114              ACALL    ?L?COM002A
0018EC 3122              ACALL    ?L?COM005C
   13:         for ( i = 0; i < 8; i++)
0018EE E4                CLR      A
0018EF 900094            MOV      DPTR,#i
0018F2 F0                MOVX     @DPTR,A
0018F3         ?C0003?HWA_EEPROM:
0018F3 900094            MOV      DPTR,#i
0018F6 E0                MOVX     A,@DPTR
0018F7 C3                CLR      C
0018F8 9408              SUBB     A,#08H
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 75


0018FA 50E4              JNC      ?C0001?HWA_EEPROM
   14:         {
   15:             if( ( crc & 0x0001) > 0)
0018FC 312A              ACALL    ?L?COM0053
0018FE EE                MOV      A,R6
0018FF 4004              JC       ?C0006?HWA_EEPROM
   16:             {
   17:                 crc = crc >> 1;
001901 3133              ACALL    ?L?COM003F
   18:                 crc = crc ^ 0xa001;
   19:             }
001903 8006              SJMP     ?C0005?HWA_EEPROM
001905         ?C0006?HWA_EEPROM:
   20:             else
   21:             {
   22:                 crc = crc >> 1;
001905 C3                CLR      C
001906 13                RRC      A
001907 FE                MOV      R6,A
001908 EF                MOV      A,R7
001909 13                RRC      A
00190A FF                MOV      R7,A
   23:             }
   24:         }
00190B         ?C0005?HWA_EEPROM:
00190B 900094            MOV      DPTR,#i
00190E E0                MOVX     A,@DPTR
00190F 04                INC      A
001910 F0                MOVX     @DPTR,A
001911 80E0              SJMP     ?C0003?HWA_EEPROM
   25:     }
001913         ?C0002?HWA_EEPROM:
   26:     return ( crc );
   27: }
001913 22                RET      
----- FUNCTION _hwa_eepromCheck (END) -------


----- FUNCTION ?L?COM002A (BEGIN) -----
001914 E0                MOVX     A,@DPTR
001915 FB                MOV      R3,A
001916 A3                INC      DPTR
001917 E4                CLR      A
001918 75F001            MOV      B,#01H
00191B 1201FD            LCALL    ?C?ILDIX
00191E A9F0              MOV      R1,B
001920 FA                MOV      R2,A
001921 22                RET      
----- FUNCTION ?L?COM002A (END) -------


----- FUNCTION ?L?COM005C (BEGIN) -----
001922 12011C            LCALL    ?C?CLDPTR
001925 FD                MOV      R5,A
001926 ED                MOV      A,R5
001927 6F                XRL      A,R7
001928 FF                MOV      R7,A
001929 22                RET      
----- FUNCTION ?L?COM005C (END) -------


----- FUNCTION ?L?COM0053 (BEGIN) -----
00192A EF                MOV      A,R7
00192B 5401              ANL      A,#01H
00192D 9400              SUBB     A,#00H
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 76


00192F E4                CLR      A
001930 9400              SUBB     A,#00H
001932 22                RET      
----- FUNCTION ?L?COM0053 (END) -------


----- FUNCTION ?L?COM003F (BEGIN) -----
001933 13                RRC      A
001934 FE                MOV      R6,A
001935 EF                MOV      A,R7
001936 13                RRC      A
001937 FF                MOV      R7,A
001938 EE                MOV      A,R6
001939 64A0              XRL      A,#0A0H
00193B FE                MOV      R6,A
00193C EF                MOV      A,R7
00193D 6401              XRL      A,#01H
00193F FF                MOV      R7,A
001940 22                RET      
----- FUNCTION ?L?COM003F (END) -------


----- FUNCTION _app_configRead (BEGIN) -----
 FILE: 'App\app_config.c'
   85: BOOL app_configRead(UINT8 Sector)
   86: {
;---- Variable 'Sector' assigned to Register 'R7' ----
   87:     BOOL state;
   88:     if(Sector == SYSTEM_SETTING_SECTOR)
001941 EF                MOV      A,R7
001942 7B01              MOV      R3,#01H
001944 7007              JNZ      ?C0009?APP_CONFIG
   89:     {
   90:         state = hwa_eepromReadSector((UINT8*)&s_System, SYSTEM_SETTING_SECTOR);
001946 7A00              MOV      R2,#HIGH s_System
001948 79A1              MOV      R1,#LOW s_System
00194A FD                MOV      R5,A
   91:     }
00194B 8006              SJMP     ?C0016?APP_CONFIG
00194D         ?C0009?APP_CONFIG:
   92:     else
   93:     {
   94:         state = hwa_eepromReadSector((UINT8*)&MoneySum, MONEY_SECTOR);
00194D 7A00              MOV      R2,#HIGH MoneySum
00194F 799D              MOV      R1,#LOW MoneySum
001951 7D01              MOV      R5,#01H
001953         
001953 121675            LCALL    _hwa_eepromReadSector
001956 9201              MOV      state,C
   95:     }
001958         ?C0010?APP_CONFIG:
   96:     return state;
001958 A201              MOV      C,state
   97: }
00195A 22                RET      
----- FUNCTION _app_configRead (END) -------


----- FUNCTION _hwa_mifareRecoveryOldCard (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  145: static void hwa_mifareRecoveryOldCard(UINT8 sector)
  146: {
00195B 900076            MOV      DPTR,#sector
00195E EF                MOV      A,R7
00195F F0                MOVX     @DPTR,A
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 77


  147: 	UINT8 money;
  148:     hwa_mifareEncrypt((UINT8*)&s_NormalBuff);             //旧卡由于未加密，校验时进行了解密操作，故此时利用卡ID
>> 用
001960 120FBC            LCALL    ?L?COM0026
001963 510A              ACALL    ?L?COM005B
001965 900077            MOV      DPTR,#money
001968 F0                MOVX     @DPTR,A
  149: 	money = *(UINT8*)&s_NormalBuff;
  150: 	if (money != 0xFF && money <= 200
001969 F4                CPL      A
00196A 6020              JZ       ?C0045?HWA_MIFARE
00196C E0                MOVX     A,@DPTR
00196D FF                MOV      R7,A
00196E D3                SETB     C
00196F 94C8              SUBB     A,#0C8H
001971 5019              JNC      ?C0045?HWA_MIFARE
001973 900052            MOV      DPTR,#s_NormalBuff+02H
001976 E0                MOVX     A,@DPTR
001977 7013              JNZ      ?C0045?HWA_MIFARE
001979 A3                INC      DPTR
00197A E0                MOVX     A,@DPTR
00197B 700F              JNZ      ?C0045?HWA_MIFARE
  151: 		&& s_NormalBuff.crc[0] == 0
  152: 		&& s_NormalBuff.crc[1] == 0
  153: 		)
  154: 	{
  155: 		s_NormalBuff.money = (UINT16)money * 100;
00197D 31B9              ACALL    ?L?COM005F
00197F 900050            MOV      DPTR,#s_NormalBuff
001982 EE                MOV      A,R6
001983 F0                MOVX     @DPTR,A
001984 A3                INC      DPTR
001985 EF                MOV      A,R7
001986 F0                MOVX     @DPTR,A
  156: 		hwa_mifareWriteSector((UINT8*)&s_NormalBuff, sector);
001987 120FBC            LCALL    ?L?COM0026
00198A 802A              SJMP     ?C0081?HWA_MIFARE
  157: 		return;
  158: 	}
00198C         ?C0045?HWA_MIFARE:
  159:     hwa_mifareEncrypt((UINT8*)&s_BackupBuff);             //旧卡由于未加密，校验时进行了解密操作，故此时利用卡ID
>> 用
00198C 120FD1            LCALL    ?L?COM0027
00198F 5102              ACALL    ?L?COM0058
001991 900077            MOV      DPTR,#money
001994 F0                MOVX     @DPTR,A
  160: 	money = *(UINT8*)&s_BackupBuff;
  161: 	if (money != 0xFF && money <= 200
001995 F4                CPL      A
001996 6020              JZ       ?C0046?HWA_MIFARE
001998 E0                MOVX     A,@DPTR
001999 FF                MOV      R7,A
00199A D3                SETB     C
00199B 94C8              SUBB     A,#0C8H
00199D 5019              JNC      ?C0046?HWA_MIFARE
00199F 900042            MOV      DPTR,#s_BackupBuff+02H
0019A2 E0                MOVX     A,@DPTR
0019A3 7013              JNZ      ?C0046?HWA_MIFARE
0019A5 A3                INC      DPTR
0019A6 E0                MOVX     A,@DPTR
0019A7 700F              JNZ      ?C0046?HWA_MIFARE
  162: 		&& s_BackupBuff.crc[0] == 0
  163: 		&& s_BackupBuff.crc[1] == 0
  164: 		)
  165: 	{
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 78


  166: 		s_BackupBuff.money = (UINT16)money * 100;
0019A9 31B9              ACALL    ?L?COM005F
0019AB 900040            MOV      DPTR,#s_BackupBuff
0019AE EE                MOV      A,R6
0019AF F0                MOVX     @DPTR,A
0019B0 A3                INC      DPTR
0019B1 EF                MOV      A,R7
0019B2 F0                MOVX     @DPTR,A
  167: 		hwa_mifareWriteSector((UINT8*)&s_BackupBuff, sector);
0019B3 120FD1            LCALL    ?L?COM0027
0019B6         
0019B6 31C0              ACALL    ?L?COM0052
  168: 		return;
  169: 	}
  170: }
0019B8         ?C0046?HWA_MIFARE:
0019B8 22                RET      
----- FUNCTION _hwa_mifareRecoveryOldCard (END) -------


----- FUNCTION ?L?COM005F (BEGIN) -----
0019B9 FE                MOV      R6,A
0019BA FC                MOV      R4,A
0019BB 7D64              MOV      R5,#064H
0019BD 020196            LJMP     ?C?IMUL
----- FUNCTION ?L?COM005F (END) -------


----- FUNCTION ?L?COM0052 (BEGIN) -----
0019C0 900076            MOV      DPTR,#sector
0019C3 E0                MOVX     A,@DPTR
0019C4 FD                MOV      R5,A
0019C5 020C79            LJMP     _hwa_mifareWriteSector
----- FUNCTION ?L?COM0052 (END) -------


----- FUNCTION _hwa_mifareRecoveryNewCard (BEGIN) -----
 FILE: 'Hwa\hwa_mifare.c'
  172: static void hwa_mifareRecoveryNewCard(UINT8 sector)
  173: {
0019C8 900076            MOV      DPTR,#sector
0019CB EF                MOV      A,R7
0019CC F0                MOVX     @DPTR,A
  174:     hwa_mifareEncrypt((UINT8*)&s_NormalBuff);             //旧卡由于未加密，校验时进行了解密操作，故此时利用卡ID
>> 用
  175: 	if (s_NormalBuff.money == 0
0019CD 120FBC            LCALL    ?L?COM0026
0019D0 510A              ACALL    ?L?COM005B
0019D2 7002              JNZ      ?C0077?HWA_MIFARE
0019D4 A3                INC      DPTR
0019D5 E0                MOVX     A,@DPTR
0019D6         ?C0077?HWA_MIFARE:
0019D6 700F              JNZ      ?C0048?HWA_MIFARE
0019D8 900052            MOV      DPTR,#s_NormalBuff+02H
0019DB E0                MOVX     A,@DPTR
0019DC 7009              JNZ      ?C0048?HWA_MIFARE
0019DE A3                INC      DPTR
0019DF E0                MOVX     A,@DPTR
0019E0 7005              JNZ      ?C0048?HWA_MIFARE
  176: 		&& s_NormalBuff.crc[0] == 0
  177: 		&& s_NormalBuff.crc[1] == 0
  178: 		)
  179: 	{
  180: 		hwa_mifareWriteSector((UINT8*)&s_NormalBuff, sector);
0019E2 120FBC            LCALL    ?L?COM0026
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 79


0019E5 8018              SJMP     ?C0082?HWA_MIFARE
  181: 		return;
  182: 	}
0019E7         ?C0048?HWA_MIFARE:
  183:     hwa_mifareEncrypt((UINT8*)&s_BackupBuff);             //旧卡由于未加密，校验时进行了解密操作，故此时利用卡ID
>> 用
0019E7 120FD1            LCALL    ?L?COM0027
0019EA 5102              ACALL    ?L?COM0058
0019EC 7002              JNZ      ?C0078?HWA_MIFARE
0019EE A3                INC      DPTR
0019EF E0                MOVX     A,@DPTR
0019F0         ?C0078?HWA_MIFARE:
0019F0 700F              JNZ      ?C0049?HWA_MIFARE
0019F2 900042            MOV      DPTR,#s_BackupBuff+02H
0019F5 E0                MOVX     A,@DPTR
0019F6 7009              JNZ      ?C0049?HWA_MIFARE
0019F8 A3                INC      DPTR
0019F9 E0                MOVX     A,@DPTR
0019FA 7005              JNZ      ?C0049?HWA_MIFARE
  184: 	if (s_BackupBuff.money == 0
  185: 		&& s_BackupBuff.crc[0] == 0
  186: 		&& s_BackupBuff.crc[1] == 0
  187: 		)
  188: 	{
  189: 		hwa_mifareWriteSector((UINT8*)&s_BackupBuff, sector);
0019FC 120FD1            LCALL    ?L?COM0027
0019FF         
0019FF 31C0              ACALL    ?L?COM0052
  190: 		return;
  191: 	}
  192: }
001A01         ?C0049?HWA_MIFARE:
001A01 22                RET      
----- FUNCTION _hwa_mifareRecoveryNewCard (END) -------


----- FUNCTION ?L?COM0058 (BEGIN) -----
001A02 120DD0            LCALL    _hwa_mifareEncrypt
001A05 900040            MOV      DPTR,#s_BackupBuff
001A08 E0                MOVX     A,@DPTR
001A09 22                RET      
----- FUNCTION ?L?COM0058 (END) -------


----- FUNCTION ?L?COM005B (BEGIN) -----
001A0A 120DD0            LCALL    _hwa_mifareEncrypt
001A0D 900050            MOV      DPTR,#s_NormalBuff
001A10 E0                MOVX     A,@DPTR
001A11 22                RET      
----- FUNCTION ?L?COM005B (END) -------


----- FUNCTION _Write_FIFO (BEGIN) -----
 FILE: 'Driver\mifare.c'
  212: void Write_FIFO(uchar *buff,uchar count)
  213: {
001A12 900099            MOV      DPTR,#buff
001A15 120DFA            LCALL    ?L?COM0004
001A18 A3                INC      DPTR
001A19 ED                MOV      A,R5
001A1A F0                MOVX     @DPTR,A
  214: 	uchar i;
  215: 	if(count == 0)
001A1B 6021              JZ       ?C0045?MIFARE
001A1D         ?C0044?MIFARE:
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 80


  216:         return;
  217: 	for(i=0;i<count;i++)
;---- Variable 'i' assigned to Register 'R4' ----
001A1D E4                CLR      A
001A1E FC                MOV      R4,A
001A1F         ?C0046?MIFARE:
001A1F 90009C            MOV      DPTR,#count
001A22 E0                MOVX     A,@DPTR
001A23 FF                MOV      R7,A
001A24 EC                MOV      A,R4
001A25 C3                CLR      C
001A26 9F                SUBB     A,R7
001A27 5015              JNC      ?C0045?MIFARE
  218: 		SPIWriteOne(FIFO_Reg,buff[i]);
001A29 900099            MOV      DPTR,#buff
001A2C 120CDA            LCALL    ?L?COM0002
001A2F F9                MOV      R1,A
001A30 8C82              MOV      DPL,R4
001A32 12127A            LCALL    ?L?COM001F
001A35 FD                MOV      R5,A
001A36 7F02              MOV      R7,#02H
001A38 1206BE            LCALL    _SPIWriteOne
001A3B 0C                INC      R4
001A3C 80E1              SJMP     ?C0046?MIFARE
  219: //		SPIWrite(FIFO_Reg,buff,count);
  220: }
001A3E         ?C0045?MIFARE:
001A3E 22                RET      
----- FUNCTION _Write_FIFO (END) -------


----- FUNCTION ?L?COM0009 (BEGIN) -----
001A3F EC                MOV      A,R4
001A40 F0                MOVX     @DPTR,A
001A41 A3                INC      DPTR
001A42 ED                MOV      A,R5
001A43 F0                MOVX     @DPTR,A
001A44 2402              ADD      A,#02H
001A46 FE                MOV      R6,A
001A47 E4                CLR      A
001A48 3C                ADDC     A,R4
001A49 A3                INC      DPTR
001A4A F0                MOVX     @DPTR,A
001A4B A3                INC      DPTR
001A4C CE                XCH      A,R6
001A4D F0                MOVX     @DPTR,A
001A4E EB                MOV      A,R3
001A4F FF                MOV      R7,A
001A50 7E00              MOV      R6,#00H
001A52 900653            MOV      DPTR,#c_u16_eepromSectorSize
001A55 E4                CLR      A
001A56 93                MOVC     A,@A+DPTR
001A57 FC                MOV      R4,A
001A58 7401              MOV      A,#01H
001A5A 93                MOVC     A,@A+DPTR
001A5B FD                MOV      R5,A
001A5C 120196            LCALL    ?C?IMUL
001A5F AA06              MOV      R2,AR6
001A61 AB07              MOV      R3,AR7
001A63 900655            MOV      DPTR,#c_u16_eepromSectorAddr
001A66         ?L?COM000A:
001A66 7401              MOV      A,#01H
001A68 93                MOVC     A,@A+DPTR
001A69 2B                ADD      A,R3
001A6A FE                MOV      R6,A
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 81


001A6B E4                CLR      A
001A6C 93                MOVC     A,@A+DPTR
001A6D 3A                ADDC     A,R2
001A6E 22                RET      
----- FUNCTION ?L?COM0009 (END) -------


----- FUNCTION ?L?COM0014 (BEGIN) -----
001A6F 2E                ADD      A,R6
001A70 F9                MOV      R1,A
001A71 E4                CLR      A
001A72 3A                ADDC     A,R2
001A73 FA                MOV      R2,A
001A74 12011C            LCALL    ?C?CLDPTR
001A77 FF                MOV      R7,A
001A78 EE                MOV      A,R6
001A79 75F005            MOV      B,#05H
001A7C 84                DIV      AB
001A7D 74B4              MOV      A,#LOW gCard_UID
001A7F 25F0              ADD      A,B
001A81 F582              MOV      DPL,A
001A83 E4                CLR      A
001A84 3400              ADDC     A,#HIGH gCard_UID
001A86 F583              MOV      DPH,A
001A88 E0                MOVX     A,@DPTR
001A89 6F                XRL      A,R7
001A8A 020162            LJMP     ?C?CSTPTR
----- FUNCTION ?L?COM0014 (END) -------


----- FUNCTION ?L?COM0015 (BEGIN) -----
001A8D AB08              MOV      R3,pMoney
001A8F AA09              MOV      R2,pMoney+01H
001A91 A90A              MOV      R1,pMoney+02H
001A93 120213            LCALL    ?C?ILDPTR
001A96 FF                MOV      R7,A
001A97 9000B3            MOV      DPTR,#s_System+012H
001A9A E0                MOVX     A,@DPTR
001A9B 2F                ADD      A,R7
001A9C FF                MOV      R7,A
001A9D 9000B2            MOV      DPTR,#s_System+011H
001AA0 E0                MOVX     A,@DPTR
001AA1 35F0              ADDC     A,B
001AA3 FE                MOV      R6,A
001AA4 D3                SETB     C
001AA5 EF                MOV      A,R7
001AA6 9420              SUBB     A,#020H
001AA8 EE                MOV      A,R6
001AA9 944E              SUBB     A,#04EH
001AAB 22                RET      
----- FUNCTION ?L?COM0015 (END) -------


----- FUNCTION ?L?COM0023 (BEGIN) -----
001AAC 9000E4            MOV      DPTR,#gLedBuf
001AAF 740C              MOV      A,#0CH
001AB1 F0                MOVX     @DPTR,A
001AB2 A3                INC      DPTR
001AB3 740F              MOV      A,#0FH
001AB5 F0                MOVX     @DPTR,A
001AB6 A3                INC      DPTR
001AB7 F0                MOVX     @DPTR,A
001AB8 A3                INC      DPTR
001AB9 F0                MOVX     @DPTR,A
001ABA A3                INC      DPTR
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 82


001ABB F0                MOVX     @DPTR,A
001ABC A3                INC      DPTR
001ABD 740C              MOV      A,#0CH
001ABF F0                MOVX     @DPTR,A
001AC0 E4                CLR      A
001AC1 9000EB            MOV      DPTR,#gShowDot
001AC4 F0                MOVX     @DPTR,A
001AC5 22                RET      
----- FUNCTION ?L?COM0023 (END) -------


----- FUNCTION ?L?COM002D (BEGIN) -----
001AC6 E0                MOVX     A,@DPTR
001AC7 FB                MOV      R3,A
001AC8 75F003            MOV      B,#03H
001ACB A4                MUL      AB
001ACC 244D              ADD      A,#LOW c_s_eepromConfig
001ACE F582              MOV      DPL,A
001AD0 E5F0              MOV      A,B
001AD2 3406              ADDC     A,#HIGH c_s_eepromConfig
001AD4 F583              MOV      DPH,A
001AD6 E4                CLR      A
001AD7 93                MOVC     A,@A+DPTR
001AD8 FC                MOV      R4,A
001AD9 22                RET      
----- FUNCTION ?L?COM002D (END) -------


----- FUNCTION ?L?COM0038 (BEGIN) -----
001ADA 74B9              MOV      A,#LOW gBuff
001ADC 2C                ADD      A,R4
001ADD F582              MOV      DPL,A
001ADF E4                CLR      A
001AE0 3400              ADDC     A,#HIGH gBuff
001AE2 F583              MOV      DPH,A
001AE4 22                RET      
----- FUNCTION ?L?COM0038 (END) -------


----- FUNCTION ?L?COM0039 (BEGIN) -----
001AE5 78DC              MOV      R0,#LOW LastCardId
001AE7 7C00              MOV      R4,#HIGH LastCardId
001AE9 7D01              MOV      R5,#01H
001AEB 7B01              MOV      R3,#01H
001AED 7A00              MOV      R2,#HIGH gCard_UID
001AEF 79B4              MOV      R1,#LOW gCard_UID
001AF1 7E00              MOV      R6,#00H
001AF3 7F05              MOV      R7,#05H
001AF5 22                RET      
----- FUNCTION ?L?COM0039 (END) -------


----- FUNCTION ?L?COM003E (BEGIN) -----
001AF6 25E0              ADD      A,ACC
001AF8 25E0              ADD      A,ACC
001AFA FE                MOV      R6,A
001AFB 04                INC      A
001AFC A3                INC      DPTR
001AFD F0                MOVX     @DPTR,A
001AFE EE                MOV      A,R6
001AFF 2402              ADD      A,#02H
001B01 A3                INC      DPTR
001B02 F0                MOVX     @DPTR,A
001B03 22                RET      
----- FUNCTION ?L?COM003E (END) -------
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 83




----- FUNCTION ?L?COM0044 (BEGIN) -----
001B04 4C                ORL      A,R4
001B05 64A5              XRL      A,#0A5H
001B07 FD                MOV      R5,A
001B08 8F82              MOV      DPL,R7
001B0A 8E83              MOV      DPH,R6
001B0C 120174            LCALL    ?C?CSTOPTR
001B0F 0F                INC      R7
001B10 22                RET      
----- FUNCTION ?L?COM0044 (END) -------


----- FUNCTION ?L?COM0045 (BEGIN) -----
001B11 F9                MOV      R1,A
001B12 8F82              MOV      DPL,R7
001B14 8E83              MOV      DPH,R6
001B16 120135            LCALL    ?C?CLDOPTR
001B19 64A5              XRL      A,#0A5H
001B1B FD                MOV      R5,A
001B1C 22                RET      
----- FUNCTION ?L?COM0045 (END) -------


----- FUNCTION ?L?COM0049 (BEGIN) -----
001B1D E0                MOVX     A,@DPTR
001B1E FE                MOV      R6,A
001B1F A3                INC      DPTR
001B20 E0                MOVX     A,@DPTR
001B21 FF                MOV      R7,A
001B22 7800              MOV      R0,#LOW e2_data
001B24 7C00              MOV      R4,#HIGH e2_data
001B26 7D01              MOV      R5,#01H
001B28 22                RET      
----- FUNCTION ?L?COM0049 (END) -------


----- FUNCTION ?L?COM004E (BEGIN) -----
001B29 900083            MOV      DPTR,#e2_addr
001B2C E0                MOVX     A,@DPTR
001B2D FE                MOV      R6,A
001B2E A3                INC      DPTR
001B2F E0                MOVX     A,@DPTR
001B30 FF                MOV      R7,A
001B31 22                RET      
----- FUNCTION ?L?COM004E (END) -------


----- FUNCTION ?L?COM0050 (BEGIN) -----
001B32 900070            MOV      DPTR,#L_num
001B35 EE                MOV      A,R6
001B36 F0                MOVX     @DPTR,A
001B37 A3                INC      DPTR
001B38 EF                MOV      A,R7
001B39 F0                MOVX     @DPTR,A
001B3A 22                RET      
----- FUNCTION ?L?COM0050 (END) -------


----- FUNCTION ?L?COM0051 (BEGIN) -----
001B3B 75F00A            MOV      B,#0AH
001B3E 84                DIV      AB
001B3F A3                INC      DPTR
001B40 E5F0              MOV      A,B
LX51 LINKER/LOCATER V4.66.1.0                                                         01/21/2016  20:26:57  PAGE 84


001B42 F0                MOVX     @DPTR,A
001B43 22                RET      
----- FUNCTION ?L?COM0051 (END) -------


----- FUNCTION ?L?COM0054 (BEGIN) -----
001B44 8E82              MOV      DPL,R6
001B46 758300            MOV      DPH,#00H
001B49 020174            LJMP     ?C?CSTOPTR
----- FUNCTION ?L?COM0054 (END) -------


----- FUNCTION ?L?COM0055 (BEGIN) -----
001B4C 90007B            MOV      DPTR,#Size
001B4F E0                MOVX     A,@DPTR
001B50 FC                MOV      R4,A
001B51 A3                INC      DPTR
001B52 E0                MOVX     A,@DPTR
001B53 FD                MOV      R5,A
001B54 22                RET      
----- FUNCTION ?L?COM0055 (END) -------


----- FUNCTION ?L?COM0056 (BEGIN) -----
001B55 90064C            MOV      DPTR,#c_u8_eepromSectorNum
001B58 E4                CLR      A
001B59 93                MOVC     A,@A+DPTR
001B5A FF                MOV      R7,A
001B5B ED                MOV      A,R5
001B5C C3                CLR      C
001B5D 22                RET      
----- FUNCTION ?L?COM0056 (END) -------


----- FUNCTION ?L?COM005A (BEGIN) -----
001B5E F582              MOV      DPL,A
001B60 E4                CLR      A
001B61 3400              ADDC     A,#HIGH gCard_UID
001B63 F583              MOV      DPH,A
001B65 22                RET      
----- FUNCTION ?L?COM005A (END) -------


----- FUNCTION ?L?COM0061 (BEGIN) -----
001B66 F0                MOVX     @DPTR,A
001B67 A3                INC      DPTR
001B68 CE                XCH      A,R6
001B69 F0                MOVX     @DPTR,A
001B6A 900657            MOV      DPTR,#c_u16_eepromSectorBakAddr
001B6D 22                RET      
----- FUNCTION ?L?COM0061 (END) -------


----- FUNCTION ?L?COM0063 (BEGIN) -----
001B6E E0                MOVX     A,@DPTR
001B6F F9                MOV      R1,A
001B70 A3                INC      DPTR
001B71 E0                MOVX     A,@DPTR
001B72 FA                MOV      R2,A
001B73 A3                INC      DPTR
001B74 E0                MOVX     A,@DPTR
001B75 22                RET      
----- FUNCTION ?L?COM0063 (END) -------


